   1               		.file	"ServerLLDN.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__RAMPZ__ = 0x3b
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.text
   9               	.Ltext0:
  10               		.cfi_sections	.debug_frame
  11               	.global	n
  12               		.section	.bss.n,"aw",@nobits
  15               	n:
  16 0000 00        		.zero	1
  17               		.comm	tTS,4,1
  18               		.comm	macLLDNnumTimeSlots,2,1
  19               		.comm	macLLDNnumUplinkTS,2,1
  20               		.comm	macLLDNRetransmitTS,2,1
  21               		.text
  23               	sysclk_get_main_hz:
  24               	.LFB67:
  25               		.file 1 "../../../platform/common/services/clock/mega/sysclk.h"
   1:../../../platform/common/services/clock/mega/sysclk.h **** /**
   2:../../../platform/common/services/clock/mega/sysclk.h ****  * \file
   3:../../../platform/common/services/clock/mega/sysclk.h ****  *
   4:../../../platform/common/services/clock/mega/sysclk.h ****  * \brief Chip-specific system clock management functions
   5:../../../platform/common/services/clock/mega/sysclk.h ****  *
   6:../../../platform/common/services/clock/mega/sysclk.h ****  * Copyright (c) 2012 Atmel Corporation. All rights reserved.
   7:../../../platform/common/services/clock/mega/sysclk.h ****  *
   8:../../../platform/common/services/clock/mega/sysclk.h ****  * \asf_license_start
   9:../../../platform/common/services/clock/mega/sysclk.h ****  *
  10:../../../platform/common/services/clock/mega/sysclk.h ****  * \page License
  11:../../../platform/common/services/clock/mega/sysclk.h ****  *
  12:../../../platform/common/services/clock/mega/sysclk.h ****  * Redistribution and use in source and binary forms, with or without
  13:../../../platform/common/services/clock/mega/sysclk.h ****  * modification, are permitted provided that the following conditions are met:
  14:../../../platform/common/services/clock/mega/sysclk.h ****  *
  15:../../../platform/common/services/clock/mega/sysclk.h ****  * 1. Redistributions of source code must retain the above copyright notice,
  16:../../../platform/common/services/clock/mega/sysclk.h ****  *    this list of conditions and the following disclaimer.
  17:../../../platform/common/services/clock/mega/sysclk.h ****  *
  18:../../../platform/common/services/clock/mega/sysclk.h ****  * 2. Redistributions in binary form must reproduce the above copyright notice,
  19:../../../platform/common/services/clock/mega/sysclk.h ****  *    this list of conditions and the following disclaimer in the documentation
  20:../../../platform/common/services/clock/mega/sysclk.h ****  *    and/or other materials provided with the distribution.
  21:../../../platform/common/services/clock/mega/sysclk.h ****  *
  22:../../../platform/common/services/clock/mega/sysclk.h ****  * 3. The name of Atmel may not be used to endorse or promote products derived
  23:../../../platform/common/services/clock/mega/sysclk.h ****  *    from this software without specific prior written permission.
  24:../../../platform/common/services/clock/mega/sysclk.h ****  *
  25:../../../platform/common/services/clock/mega/sysclk.h ****  * 4. This software may only be redistributed and used in connection with an
  26:../../../platform/common/services/clock/mega/sysclk.h ****  *    Atmel microcontroller product.
  27:../../../platform/common/services/clock/mega/sysclk.h ****  *
  28:../../../platform/common/services/clock/mega/sysclk.h ****  * THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR IMPLIED
  29:../../../platform/common/services/clock/mega/sysclk.h ****  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
  30:../../../platform/common/services/clock/mega/sysclk.h ****  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
  31:../../../platform/common/services/clock/mega/sysclk.h ****  * EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR
  32:../../../platform/common/services/clock/mega/sysclk.h ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  33:../../../platform/common/services/clock/mega/sysclk.h ****  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
  34:../../../platform/common/services/clock/mega/sysclk.h ****  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  35:../../../platform/common/services/clock/mega/sysclk.h ****  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
  36:../../../platform/common/services/clock/mega/sysclk.h ****  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  37:../../../platform/common/services/clock/mega/sysclk.h ****  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  38:../../../platform/common/services/clock/mega/sysclk.h ****  * POSSIBILITY OF SUCH DAMAGE.
  39:../../../platform/common/services/clock/mega/sysclk.h ****  *
  40:../../../platform/common/services/clock/mega/sysclk.h ****  * \asf_license_stop
  41:../../../platform/common/services/clock/mega/sysclk.h ****  *
  42:../../../platform/common/services/clock/mega/sysclk.h ****  */
  43:../../../platform/common/services/clock/mega/sysclk.h **** #ifndef MEGA_SYSCLK_H_INCLUDED
  44:../../../platform/common/services/clock/mega/sysclk.h **** #define MEGA_SYSCLK_H_INCLUDED
  45:../../../platform/common/services/clock/mega/sysclk.h **** 
  46:../../../platform/common/services/clock/mega/sysclk.h **** #include <board.h>
  47:../../../platform/common/services/clock/mega/sysclk.h **** #include <compiler.h>
  48:../../../platform/common/services/clock/mega/sysclk.h **** #include <parts.h>
  49:../../../platform/common/services/clock/mega/sysclk.h **** 
  50:../../../platform/common/services/clock/mega/sysclk.h **** /* Include clock configuration for the project. */
  51:../../../platform/common/services/clock/mega/sysclk.h **** #include <conf_clock.h>
  52:../../../platform/common/services/clock/mega/sysclk.h **** 
  53:../../../platform/common/services/clock/mega/sysclk.h **** #ifdef __cplusplus
  54:../../../platform/common/services/clock/mega/sysclk.h **** extern "C" {
  55:../../../platform/common/services/clock/mega/sysclk.h **** #endif
  56:../../../platform/common/services/clock/mega/sysclk.h **** #define ASM __asm__
  57:../../../platform/common/services/clock/mega/sysclk.h **** 
  58:../../../platform/common/services/clock/mega/sysclk.h **** /* CONFIG_SYSCLK_PSDIV  to use default if not defined*/
  59:../../../platform/common/services/clock/mega/sysclk.h **** #ifndef CONFIG_SYSCLK_PSDIV
  60:../../../platform/common/services/clock/mega/sysclk.h **** # define CONFIG_SYSCLK_PSDIV    SYSCLK_PSDIV_8
  61:../../../platform/common/services/clock/mega/sysclk.h **** #endif
  62:../../../platform/common/services/clock/mega/sysclk.h **** 
  63:../../../platform/common/services/clock/mega/sysclk.h **** /* ! \name Prescaler Setting (relative to CLKsys) */
  64:../../../platform/common/services/clock/mega/sysclk.h **** /* @{ */
  65:../../../platform/common/services/clock/mega/sysclk.h **** #define SYSCLK_PSDIV_1      0   /* !< Do not prescale */
  66:../../../platform/common/services/clock/mega/sysclk.h **** #define SYSCLK_PSDIV_2      1   /* !< Prescale CLKper4 by 2 */
  67:../../../platform/common/services/clock/mega/sysclk.h **** #define SYSCLK_PSDIV_4      2   /* !< Prescale CLKper4 by 4 */
  68:../../../platform/common/services/clock/mega/sysclk.h **** #define SYSCLK_PSDIV_8      3   /* !< Prescale CLKper4 by 8 */
  69:../../../platform/common/services/clock/mega/sysclk.h **** #define SYSCLK_PSDIV_16     4   /* !< Prescale CLKper4 by 16 */
  70:../../../platform/common/services/clock/mega/sysclk.h **** #define SYSCLK_PSDIV_32     5   /* !< Prescale CLKper4 by 32 */
  71:../../../platform/common/services/clock/mega/sysclk.h **** #define SYSCLK_PSDIV_64     6   /* !< Prescale CLKper4 by 64 */
  72:../../../platform/common/services/clock/mega/sysclk.h **** #define SYSCLK_PSDIV_128    7   /* !< Prescale CLKper4 by 128 */
  73:../../../platform/common/services/clock/mega/sysclk.h **** #define SYSCLK_PSDIV_256    8   /* !< Prescale CLKper4 by 256 */
  74:../../../platform/common/services/clock/mega/sysclk.h **** 
  75:../../../platform/common/services/clock/mega/sysclk.h **** /* @} */
  76:../../../platform/common/services/clock/mega/sysclk.h **** 
  77:../../../platform/common/services/clock/mega/sysclk.h **** #if MEGA_RF || MEGA_XX0_1 || MEGA_XX4 || MEGA_XX4_A
  78:../../../platform/common/services/clock/mega/sysclk.h **** 
  79:../../../platform/common/services/clock/mega/sysclk.h **** #define NUMBER_OF_POWER_REG       2
  80:../../../platform/common/services/clock/mega/sysclk.h **** /*Starting Address for power reduction*/
  81:../../../platform/common/services/clock/mega/sysclk.h **** #define POWER_REG_ADD             PRR0
  82:../../../platform/common/services/clock/mega/sysclk.h **** 
  83:../../../platform/common/services/clock/mega/sysclk.h **** /* ! \name Power Reduction  Clock Port Numbers */
  84:../../../platform/common/services/clock/mega/sysclk.h **** enum power_red_id {
  85:../../../platform/common/services/clock/mega/sysclk.h **** 	POWER_RED_REG0,     /* !< Devices on PRR0 */
  86:../../../platform/common/services/clock/mega/sysclk.h **** #if !MEGA_XX4 || !MEGA_XX4_A || MEGA_XX0_1
  87:../../../platform/common/services/clock/mega/sysclk.h **** 	POWER_RED_REG1,     /* !< Devices on PRR1 */
  88:../../../platform/common/services/clock/mega/sysclk.h **** #endif
  89:../../../platform/common/services/clock/mega/sysclk.h **** };
  90:../../../platform/common/services/clock/mega/sysclk.h **** #endif
  91:../../../platform/common/services/clock/mega/sysclk.h **** 
  92:../../../platform/common/services/clock/mega/sysclk.h **** /****************************************************
  93:../../../platform/common/services/clock/mega/sysclk.h ****  * Given a dummy type but not used for these groups
  94:../../../platform/common/services/clock/mega/sysclk.h ****  * to support for otherthen megaRF device.
  95:../../../platform/common/services/clock/mega/sysclk.h ****  **************************************************/
  96:../../../platform/common/services/clock/mega/sysclk.h **** #if MEGA_XX8 || MEGA_XX8_A || MEGA_UNSPECIFIED
  97:../../../platform/common/services/clock/mega/sysclk.h **** #define NUMBER_OF_POWER_REG       1
  98:../../../platform/common/services/clock/mega/sysclk.h **** /*Starting Address for power reduction*/
  99:../../../platform/common/services/clock/mega/sysclk.h **** #define POWER_REG_ADD             PRR
 100:../../../platform/common/services/clock/mega/sysclk.h **** 
 101:../../../platform/common/services/clock/mega/sysclk.h **** /* ! \name Power Reduction  Clock Port Numbers */
 102:../../../platform/common/services/clock/mega/sysclk.h **** enum power_red_id {
 103:../../../platform/common/services/clock/mega/sysclk.h **** 	POWER_RED_REG0,     /* !< Devices on PRR */
 104:../../../platform/common/services/clock/mega/sysclk.h **** };
 105:../../../platform/common/services/clock/mega/sysclk.h **** #endif
 106:../../../platform/common/services/clock/mega/sysclk.h **** 
 107:../../../platform/common/services/clock/mega/sysclk.h **** /* Bit mask for the power reduction register based on */
 108:../../../platform/common/services/clock/mega/sysclk.h **** /*   MCU ARCH.                                        */
 109:../../../platform/common/services/clock/mega/sysclk.h **** #if MEGA_RF
 110:../../../platform/common/services/clock/mega/sysclk.h **** /*Bit mask for PRR2 */
 111:../../../platform/common/services/clock/mega/sysclk.h **** 
 112:../../../platform/common/services/clock/mega/sysclk.h **** #define PRRAM0_bm                       1 << PRRAM0
 113:../../../platform/common/services/clock/mega/sysclk.h **** #define PRRAM1_bm                       1 << PRRAM1
 114:../../../platform/common/services/clock/mega/sysclk.h **** #define PRRAM2_bm                       1 << PRRAM2
 115:../../../platform/common/services/clock/mega/sysclk.h **** #define PRRAM3_bm                       1 << PRRAM3
 116:../../../platform/common/services/clock/mega/sysclk.h **** #endif
 117:../../../platform/common/services/clock/mega/sysclk.h **** 
 118:../../../platform/common/services/clock/mega/sysclk.h **** /*Bit mask for the power reduction 0 or PRR*/
 119:../../../platform/common/services/clock/mega/sysclk.h **** #if !MEGA_XX_UN0 && !MEGA_XX_UN0
 120:../../../platform/common/services/clock/mega/sysclk.h **** #define PRADC_bm                        1 << PRADC
 121:../../../platform/common/services/clock/mega/sysclk.h **** #define PRUSART0_bm                     1 << PRUSART0
 122:../../../platform/common/services/clock/mega/sysclk.h **** #define PRSPI_bm                        1 << PRSPI
 123:../../../platform/common/services/clock/mega/sysclk.h **** #define PRTIM1_bm                       1 << PRTIM1
 124:../../../platform/common/services/clock/mega/sysclk.h **** #endif
 125:../../../platform/common/services/clock/mega/sysclk.h **** 
 126:../../../platform/common/services/clock/mega/sysclk.h **** #if MEGA_RF
 127:../../../platform/common/services/clock/mega/sysclk.h **** #define PRPGA_bm                        1 << PRPGA
 128:../../../platform/common/services/clock/mega/sysclk.h **** #endif
 129:../../../platform/common/services/clock/mega/sysclk.h **** 
 130:../../../platform/common/services/clock/mega/sysclk.h **** #if !MEGA_UNSPECIFIED
 131:../../../platform/common/services/clock/mega/sysclk.h **** #define PRTIM0_bm                       1 << PRTIM0
 132:../../../platform/common/services/clock/mega/sysclk.h **** #define PRTIM2_bm                       1 << PRTIM2
 133:../../../platform/common/services/clock/mega/sysclk.h **** #define PRTWI_bm                        1 << PRTWI
 134:../../../platform/common/services/clock/mega/sysclk.h **** #endif
 135:../../../platform/common/services/clock/mega/sysclk.h **** 
 136:../../../platform/common/services/clock/mega/sysclk.h **** #if MEGA_XX_UN2
 137:../../../platform/common/services/clock/mega/sysclk.h **** #define PRLCD_bm                        1 << PRLCD
 138:../../../platform/common/services/clock/mega/sysclk.h **** #endif
 139:../../../platform/common/services/clock/mega/sysclk.h **** 
 140:../../../platform/common/services/clock/mega/sysclk.h **** /*Bit mask for  PRR1  */
 141:../../../platform/common/services/clock/mega/sysclk.h **** #ifdef PRR1
 142:../../../platform/common/services/clock/mega/sysclk.h **** #if (MEGA_XX4 || MEGA_XX4_A)
 143:../../../platform/common/services/clock/mega/sysclk.h **** #define PRTIM3_bm                       1 << PRTIM3
 144:../../../platform/common/services/clock/mega/sysclk.h **** #endif
 145:../../../platform/common/services/clock/mega/sysclk.h **** #endif
 146:../../../platform/common/services/clock/mega/sysclk.h **** 
 147:../../../platform/common/services/clock/mega/sysclk.h **** #if MEGA_RF || MEGA_XX4 || MEGA_XX4_A
 148:../../../platform/common/services/clock/mega/sysclk.h **** #define PRUSART1_bm                     1 << PRUSART1
 149:../../../platform/common/services/clock/mega/sysclk.h **** #define PRUSART2_bm                     1 << PRUSART2
 150:../../../platform/common/services/clock/mega/sysclk.h **** #define PRUSART3_bm                     1 << PRUSART3
 151:../../../platform/common/services/clock/mega/sysclk.h **** #define PRTIM3_bm                       1 << PRTIM3
 152:../../../platform/common/services/clock/mega/sysclk.h **** #define PRTIM4_bm                       1 << PRTIM4
 153:../../../platform/common/services/clock/mega/sysclk.h **** #define PRTIM5_bm                       1 << PRTIM5
 154:../../../platform/common/services/clock/mega/sysclk.h **** #endif
 155:../../../platform/common/services/clock/mega/sysclk.h **** 
 156:../../../platform/common/services/clock/mega/sysclk.h **** #if MEGA_RF
 157:../../../platform/common/services/clock/mega/sysclk.h **** #define PRTRX24_bm                      1 << PRTRX24
 158:../../../platform/common/services/clock/mega/sysclk.h **** #endif
 159:../../../platform/common/services/clock/mega/sysclk.h **** 
 160:../../../platform/common/services/clock/mega/sysclk.h **** /**
 161:../../../platform/common/services/clock/mega/sysclk.h ****  * \name Querying the system clock and its derived clocks
 162:../../../platform/common/services/clock/mega/sysclk.h ****  */
 163:../../../platform/common/services/clock/mega/sysclk.h **** /* @{ */
 164:../../../platform/common/services/clock/mega/sysclk.h **** 
 165:../../../platform/common/services/clock/mega/sysclk.h **** /**
 166:../../../platform/common/services/clock/mega/sysclk.h ****  * \brief Return the current rate in Hz of the main system clock
 167:../../../platform/common/services/clock/mega/sysclk.h ****  * To know the clock value at what frequency the main clock is running
 168:../../../platform/common/services/clock/mega/sysclk.h ****  * \return Frequency of the main system clock, in Hz.
 169:../../../platform/common/services/clock/mega/sysclk.h ****  * \todo : please initialize the SYSCLK_SOURCE in conf_clock.h file for
 170:../../../platform/common/services/clock/mega/sysclk.h ****  * configured source clock using fuses.
 171:../../../platform/common/services/clock/mega/sysclk.h ****  * \eg. #define SYSCLK_SOURCE SYSCLK_SRC_RC16MHZ to use internal RC
 172:../../../platform/common/services/clock/mega/sysclk.h ****  * oscillator for clock source.
 173:../../../platform/common/services/clock/mega/sysclk.h ****  */
 174:../../../platform/common/services/clock/mega/sysclk.h **** static inline uint32_t sysclk_get_main_hz(void)
 175:../../../platform/common/services/clock/mega/sysclk.h **** {
  26               		.loc 1 175 0
  27               		.cfi_startproc
  28 0000 CF93      		push r28
  29               	.LCFI0:
  30               		.cfi_def_cfa_offset 3
  31               		.cfi_offset 28, -2
  32 0002 DF93      		push r29
  33               	.LCFI1:
  34               		.cfi_def_cfa_offset 4
  35               		.cfi_offset 29, -3
  36 0004 CDB7      		in r28,__SP_L__
  37 0006 DEB7      		in r29,__SP_H__
  38               	.LCFI2:
  39               		.cfi_def_cfa_register 28
  40               	/* prologue: function */
  41               	/* frame size = 0 */
  42               	/* stack size = 2 */
  43               	.L__stack_usage = 2
 176:../../../platform/common/services/clock/mega/sysclk.h **** 	switch (SYSCLK_SOURCE) {
 177:../../../platform/common/services/clock/mega/sysclk.h **** 	case SYSCLK_SRC_RC16MHZ:
 178:../../../platform/common/services/clock/mega/sysclk.h **** 		return 16000000UL;
 179:../../../platform/common/services/clock/mega/sysclk.h **** 
 180:../../../platform/common/services/clock/mega/sysclk.h **** 	case SYSCLK_SRC_RC128KHZ:
 181:../../../platform/common/services/clock/mega/sysclk.h **** 		return 128000UL;
 182:../../../platform/common/services/clock/mega/sysclk.h **** 
 183:../../../platform/common/services/clock/mega/sysclk.h **** #if MEGA_RF
 184:../../../platform/common/services/clock/mega/sysclk.h **** 	case SYSCLK_SRC_TRS16MHZ:
 185:../../../platform/common/services/clock/mega/sysclk.h **** 		return 16000000UL;
  44               		.loc 1 185 0
  45 0008 80E0      		ldi r24,0
  46 000a 94E2      		ldi r25,lo8(36)
  47 000c A4EF      		ldi r26,lo8(-12)
  48 000e B0E0      		ldi r27,0
 186:../../../platform/common/services/clock/mega/sysclk.h **** #endif
 187:../../../platform/common/services/clock/mega/sysclk.h **** #ifdef BOARD_EXTERNAL_CLK
 188:../../../platform/common/services/clock/mega/sysclk.h **** 	case SYSCLK_SRC_EXTERNAL:
 189:../../../platform/common/services/clock/mega/sysclk.h **** 		return BOARD_EXTERNAL_CLK;
 190:../../../platform/common/services/clock/mega/sysclk.h **** #endif
 191:../../../platform/common/services/clock/mega/sysclk.h **** 	default:
 192:../../../platform/common/services/clock/mega/sysclk.h **** 
 193:../../../platform/common/services/clock/mega/sysclk.h **** 		return 1000000UL;
 194:../../../platform/common/services/clock/mega/sysclk.h **** 	}
 195:../../../platform/common/services/clock/mega/sysclk.h **** }
  49               		.loc 1 195 0
  50 0010 BC01      		movw r22,r24
  51 0012 CD01      		movw r24,r26
  52               	/* epilogue start */
  53 0014 DF91      		pop r29
  54 0016 CF91      		pop r28
  55 0018 0895      		ret
  56               		.cfi_endproc
  57               	.LFE67:
  60               	sysclk_get_source_clock_hz:
  61               	.LFB68:
 196:../../../platform/common/services/clock/mega/sysclk.h **** 
 197:../../../platform/common/services/clock/mega/sysclk.h **** /**
 198:../../../platform/common/services/clock/mega/sysclk.h ****  * \brief Return the current rate in Hz of source clock in Hz.
 199:../../../platform/common/services/clock/mega/sysclk.h ****  *
 200:../../../platform/common/services/clock/mega/sysclk.h ****  * This clock always runs at the same rate as the CPU clock unless the divider
 201:../../../platform/common/services/clock/mega/sysclk.h ****  * is set.
 202:../../../platform/common/services/clock/mega/sysclk.h ****  *
 203:../../../platform/common/services/clock/mega/sysclk.h ****  * \return Frequency of the system clock, in Hz.
 204:../../../platform/common/services/clock/mega/sysclk.h ****  */
 205:../../../platform/common/services/clock/mega/sysclk.h **** static inline uint32_t sysclk_get_source_clock_hz(void)
 206:../../../platform/common/services/clock/mega/sysclk.h **** {
  62               		.loc 1 206 0
  63               		.cfi_startproc
  64 001a CF93      		push r28
  65               	.LCFI3:
  66               		.cfi_def_cfa_offset 3
  67               		.cfi_offset 28, -2
  68 001c DF93      		push r29
  69               	.LCFI4:
  70               		.cfi_def_cfa_offset 4
  71               		.cfi_offset 29, -3
  72 001e CDB7      		in r28,__SP_L__
  73 0020 DEB7      		in r29,__SP_H__
  74               	.LCFI5:
  75               		.cfi_def_cfa_register 28
  76               	/* prologue: function */
  77               	/* frame size = 0 */
  78               	/* stack size = 2 */
  79               	.L__stack_usage = 2
 207:../../../platform/common/services/clock/mega/sysclk.h **** 	switch (CONFIG_SYSCLK_PSDIV) {
 208:../../../platform/common/services/clock/mega/sysclk.h **** 	case SYSCLK_PSDIV_1: /* Fall through */
 209:../../../platform/common/services/clock/mega/sysclk.h **** 		if (SYSCLK_SOURCE == SYSCLK_SRC_RC16MHZ ||
 210:../../../platform/common/services/clock/mega/sysclk.h **** 				SYSCLK_SOURCE == SYSCLK_SRC_RC128KHZ) {
 211:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 2;
 212:../../../platform/common/services/clock/mega/sysclk.h **** 		} else {
 213:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz();
  80               		.loc 1 213 0
  81 0022 0E94 0000 		call sysclk_get_main_hz
  82 0026 DC01      		movw r26,r24
  83 0028 CB01      		movw r24,r22
 214:../../../platform/common/services/clock/mega/sysclk.h **** 		}
 215:../../../platform/common/services/clock/mega/sysclk.h **** 
 216:../../../platform/common/services/clock/mega/sysclk.h **** 	case SYSCLK_PSDIV_2:
 217:../../../platform/common/services/clock/mega/sysclk.h **** 		if (SYSCLK_SOURCE == SYSCLK_SRC_RC16MHZ ||
 218:../../../platform/common/services/clock/mega/sysclk.h **** 				SYSCLK_SOURCE == SYSCLK_SRC_RC128KHZ) {
 219:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 4;
 220:../../../platform/common/services/clock/mega/sysclk.h **** 		} else {
 221:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 2;
 222:../../../platform/common/services/clock/mega/sysclk.h **** 		}
 223:../../../platform/common/services/clock/mega/sysclk.h **** 
 224:../../../platform/common/services/clock/mega/sysclk.h **** 	case SYSCLK_PSDIV_4:
 225:../../../platform/common/services/clock/mega/sysclk.h **** 		if (SYSCLK_SOURCE == SYSCLK_SRC_RC16MHZ ||
 226:../../../platform/common/services/clock/mega/sysclk.h **** 				SYSCLK_SOURCE == SYSCLK_SRC_RC128KHZ) {
 227:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 8;
 228:../../../platform/common/services/clock/mega/sysclk.h **** 		} else {
 229:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 4;
 230:../../../platform/common/services/clock/mega/sysclk.h **** 		}
 231:../../../platform/common/services/clock/mega/sysclk.h **** 
 232:../../../platform/common/services/clock/mega/sysclk.h **** 	case SYSCLK_PSDIV_8:
 233:../../../platform/common/services/clock/mega/sysclk.h **** 		if (SYSCLK_SOURCE == SYSCLK_SRC_RC16MHZ ||
 234:../../../platform/common/services/clock/mega/sysclk.h **** 				SYSCLK_SOURCE == SYSCLK_SRC_RC128KHZ) {
 235:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 16;
 236:../../../platform/common/services/clock/mega/sysclk.h **** 		} else {
 237:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 8;
 238:../../../platform/common/services/clock/mega/sysclk.h **** 		}
 239:../../../platform/common/services/clock/mega/sysclk.h **** 
 240:../../../platform/common/services/clock/mega/sysclk.h **** 	case SYSCLK_PSDIV_16:
 241:../../../platform/common/services/clock/mega/sysclk.h **** 		if (SYSCLK_SOURCE == SYSCLK_SRC_RC16MHZ ||
 242:../../../platform/common/services/clock/mega/sysclk.h **** 				SYSCLK_SOURCE == SYSCLK_SRC_RC128KHZ) {
 243:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 32;
 244:../../../platform/common/services/clock/mega/sysclk.h **** 		} else {
 245:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 16;
 246:../../../platform/common/services/clock/mega/sysclk.h **** 		}
 247:../../../platform/common/services/clock/mega/sysclk.h **** 
 248:../../../platform/common/services/clock/mega/sysclk.h **** 	case SYSCLK_PSDIV_32:
 249:../../../platform/common/services/clock/mega/sysclk.h **** 		if (SYSCLK_SOURCE == SYSCLK_SRC_RC16MHZ ||
 250:../../../platform/common/services/clock/mega/sysclk.h **** 				SYSCLK_SOURCE == SYSCLK_SRC_RC128KHZ) {
 251:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 64;
 252:../../../platform/common/services/clock/mega/sysclk.h **** 		} else {
 253:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 32;
 254:../../../platform/common/services/clock/mega/sysclk.h **** 		}
 255:../../../platform/common/services/clock/mega/sysclk.h **** 
 256:../../../platform/common/services/clock/mega/sysclk.h **** 	case SYSCLK_PSDIV_64:
 257:../../../platform/common/services/clock/mega/sysclk.h **** 		if (SYSCLK_SOURCE == SYSCLK_SRC_RC16MHZ ||
 258:../../../platform/common/services/clock/mega/sysclk.h **** 				SYSCLK_SOURCE == SYSCLK_SRC_RC128KHZ) {
 259:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 128;
 260:../../../platform/common/services/clock/mega/sysclk.h **** 		} else {
 261:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 64;
 262:../../../platform/common/services/clock/mega/sysclk.h **** 		}
 263:../../../platform/common/services/clock/mega/sysclk.h **** 
 264:../../../platform/common/services/clock/mega/sysclk.h **** 	case SYSCLK_PSDIV_128:
 265:../../../platform/common/services/clock/mega/sysclk.h **** 		if (SYSCLK_SOURCE == SYSCLK_SRC_RC16MHZ ||
 266:../../../platform/common/services/clock/mega/sysclk.h **** 				SYSCLK_SOURCE == SYSCLK_SRC_RC128KHZ) {
 267:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 256;
 268:../../../platform/common/services/clock/mega/sysclk.h **** 		} else {
 269:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 128;
 270:../../../platform/common/services/clock/mega/sysclk.h **** 		}
 271:../../../platform/common/services/clock/mega/sysclk.h **** 
 272:../../../platform/common/services/clock/mega/sysclk.h **** 	case SYSCLK_PSDIV_256:
 273:../../../platform/common/services/clock/mega/sysclk.h **** 		if (SYSCLK_SOURCE == SYSCLK_SRC_RC16MHZ ||
 274:../../../platform/common/services/clock/mega/sysclk.h **** 				SYSCLK_SOURCE == SYSCLK_SRC_RC128KHZ) {
 275:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 512;
 276:../../../platform/common/services/clock/mega/sysclk.h **** 		} else {
 277:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 256;
 278:../../../platform/common/services/clock/mega/sysclk.h **** 		}
 279:../../../platform/common/services/clock/mega/sysclk.h **** 
 280:../../../platform/common/services/clock/mega/sysclk.h **** 	default:
 281:../../../platform/common/services/clock/mega/sysclk.h **** 		/*Invalide case*/
 282:../../../platform/common/services/clock/mega/sysclk.h **** 		return 0;
 283:../../../platform/common/services/clock/mega/sysclk.h **** 	}
 284:../../../platform/common/services/clock/mega/sysclk.h **** }
  84               		.loc 1 284 0
  85 002a BC01      		movw r22,r24
  86 002c CD01      		movw r24,r26
  87               	/* epilogue start */
  88 002e DF91      		pop r29
  89 0030 CF91      		pop r28
  90 0032 0895      		ret
  91               		.cfi_endproc
  92               	.LFE68:
  94               		.section	.progmem.data.baudctrl_1mhz,"a",@progbits
  97               	baudctrl_1mhz:
  98 0000 3300      		.word	51
  99 0002 1900      		.word	25
 100 0004 0C00      		.word	12
 101 0006 0600      		.word	6
 102 0008 0300      		.word	3
 103 000a 0200      		.word	2
 104 000c 0100      		.word	1
 105 000e FF00      		.word	255
 106               		.section	.progmem.data.baudctrl_8mhz,"a",@progbits
 109               	baudctrl_8mhz:
 110 0000 A001      		.word	416
 111 0002 CF00      		.word	207
 112 0004 6700      		.word	103
 113 0006 3300      		.word	51
 114 0008 1900      		.word	25
 115 000a 0C00      		.word	12
 116 000c 0700      		.word	7
 117 000e 0800      		.word	8
 118               		.section	.progmem.data.baudctrl_16mhz,"a",@progbits
 121               	baudctrl_16mhz:
 122 0000 4003      		.word	832
 123 0002 A001      		.word	416
 124 0004 CF00      		.word	207
 125 0006 6700      		.word	103
 126 0008 3300      		.word	51
 127 000a 1900      		.word	25
 128 000c 1000      		.word	16
 129 000e 1000      		.word	16
 130               		.text
 132               	usart_double_baud_enable:
 133               	.LFB101:
 134               		.file 2 "../../../platform/mega_rf/drivers/usart/usart_megarf.h"
   1:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
   2:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \file
   3:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
   4:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief USART driver for AVR MEGARF.
   5:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
   6:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * This file contains basic functions for the AVR MEGA USART, with support for
   7:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * all modes, settings and clock speeds.
   8:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
   9:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * Copyright (c) 2013-2015 Atmel Corporation. All rights reserved.
  10:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
  11:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \asf_license_start
  12:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
  13:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \page License
  14:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
  15:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * Redistribution and use in source and binary forms, with or without
  16:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * modification, are permitted provided that the following conditions are met:
  17:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
  18:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * 1. Redistributions of source code must retain the above copyright notice,
  19:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *    this list of conditions and the following disclaimer.
  20:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
  21:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * 2. Redistributions in binary form must reproduce the above copyright notice,
  22:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *    this list of conditions and the following disclaimer in the documentation
  23:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *    and/or other materials provided with the distribution.
  24:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
  25:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * 3. The name of Atmel may not be used to endorse or promote products derived
  26:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *    from this software without specific prior written permission.
  27:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
  28:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * 4. This software may only be redistributed and used in connection with an
  29:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *    Atmel microcontroller product.
  30:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
  31:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR IMPLIED
  32:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
  33:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
  34:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR
  35:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  36:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
  37:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  38:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
  39:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  40:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  41:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * POSSIBILITY OF SUCH DAMAGE.
  42:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
  43:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \asf_license_stop
  44:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
  45:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
  46:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #ifndef _USART_MEGARF_H_
  47:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define _USART_MEGARF_H_
  48:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
  49:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #ifdef __cplusplus
  50:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** extern "C" {
  51:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #endif
  52:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
  53:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #include "compiler.h"
  54:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #include "status_codes.h"
  55:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
  56:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
  57:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \defgroup megarf_usart_group USART module (USART)
  58:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
  59:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * See \ref megarf_usart_quickstart.
  60:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
  61:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * This is a driver for configuring, enabling, disabling and use of the on-chip
  62:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * USART.
  63:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
  64:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \section dependencies Dependencies
  65:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
  66:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * The USART module depends on the following modules:
  67:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *  - \ref sysclk_group for peripheral clock control.
  68:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *  - \ref port_driver_group for peripheral io port control.
  69:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
  70:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * @{
  71:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
  72:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
  73:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* ! Offset in lookup table for baudrate 1200 */
  74:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_BAUD_1200      0x00
  75:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* ! Offset in lookup table for baudrate 2400 */
  76:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_BAUD_2400      0x01
  77:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* ! Offset in lookup table for baudrate 4800 */
  78:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_BAUD_4800      0x02
  79:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* ! Offset in lookup table for baudrate 9600 */
  80:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_BAUD_9600      0x03
  81:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* ! Offset in lookup table for baudrate 19200 */
  82:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_BAUD_19200     0x04
  83:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* ! Offset in lookup table for baudrate 38400 */
  84:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_BAUD_38400     0x05
  85:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* ! Offset in lookup table for baudrate 57600 */
  86:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_BAUD_57600     0x06
  87:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* ! Offset in lookup table for baudrate 115200 */
  88:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_BAUD_115200    0x07
  89:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* ! Baudrate not in lookup table */
  90:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_BAUD_UNDEFINED 0xFF
  91:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
  92:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** typedef volatile uint8_t register8_t;
  93:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** typedef volatile uint16_t register16_t;
  94:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* Universal Synchronous/Asynchronous Receiver/Transmitter */
  95:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** typedef struct USART_struct {
  96:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	register8_t UCSRnA;  /* Control Register A */
  97:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	register8_t UCSRnB;  /* Control Register B */
  98:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	register8_t UCSRnC;  /* Control Register C */
  99:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	register8_t reserved;
 100:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	register16_t UBRR;  /* Baud Rate Register Value */
 101:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	register8_t UDR;  /* I/O Data Register */
 102:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** } USART_t;
 103:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 104:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USARTA0    (*(USART_t *)0xC0)   /* Universal Asynchronous
 105:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	                                 * Receiver-Transmitter A0 */
 106:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USARTA1    (*(USART_t *)0XC8)   /* Universal Asynchronous
 107:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	                                 * Receiver-Transmitter A1 */
 108:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 109:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* USART.UCSRxA  bit masks and bit positions */
 110:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_RXC_bm  0x80 /* RX complete bit mask.*/
 111:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_RXC_bp  7 /* RX complete bit position.*/
 112:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 113:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_TXC_bm  0x40 /* TX complete bit mask.*/
 114:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_TXC_bp  6 /* TX complete bit position.*/
 115:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 116:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_DRE_bm  0x20 /* DATA Register Empty Bit mask.*/
 117:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_DRE_bp  5 /*  DATA Register Empty bit position.*/
 118:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 119:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_FE_bm   0x10 /* Frame Error bit mask.*/
 120:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_FE_bp   4 /*Frame error bit position.*/
 121:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 122:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_DOR_bm  0x08 /* Data Over Run bit mask.*/
 123:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_DOR_bp  3 /* Data Over Run bit position.*/
 124:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 125:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_UPE_bm  0x04 /* Parity error bit mask.*/
 126:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_UPE_bp  2 /* Parity error bit position.*/
 127:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 128:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_U2X_bm  0x02 /* Double TX speed bit mask.*/
 129:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_U2X_bp  1 /* Double TX speed bit position.*/
 130:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 131:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_MPCM_bm  0x01 /* Multi Processor bit mask.*/
 132:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_MPMC_bp  0 /* Multi processor bit position.*/
 133:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 134:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* USART.UCSRxB  bit masks and bit positions */
 135:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_RXCIE_bm  0x80 /* RX complete interrupt Enable bit mask.*/
 136:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_RXCIE_bp  7 /* RX complete interrupt Enable bit position.*/
 137:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 138:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_TXCIE_bm  0x40 /* TX complete interrupt Enable bit mask.*/
 139:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_TXCIE_bp  6 /* TX complete interrupt Enable bit position.*/
 140:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 141:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_DRIE_bm  0x20 /* Data register empty interrupt Enable bit mask.*/
 142:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_DRIE_bp  5 /* Data register empty interrupt Enable bit position.*/
 143:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 144:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_RXEN_bm  0x10  /* Receiver Enable bit mask. */
 145:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_RXEN_bp  4  /* Receiver Enable bit position. */
 146:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 147:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_TXEN_bm  0x08  /* Transmitter Enable bit mask. */
 148:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_TXEN_bp  3  /* Transmitter Enable bit position. */
 149:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 150:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_CHSIZE2_bm  0x04  /* Character Size bit mask. */
 151:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_CHSIZE2_bp  2 /* Character Size bit position. */
 152:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 153:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_RXB8_bm  0x02  /* Transmit bit 8 bit mask. */
 154:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_RXB8_bp  1  /* Transmit bit 8 bit position. */
 155:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 156:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_TXB8_bm  0x01  /* Transmit bit 8 bit mask. */
 157:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_TXB8_bp  0  /* Transmit bit 8 bit position. */
 158:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 159:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* USART.UCSRxC  bit masks and bit positions */
 160:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_UMSEL01_gm  0xC0 /* USART Mode Select 01 grp mask.*/
 161:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_UMSEL01_gp  6 /* USART Mode Select 01 grp position.*/
 162:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 163:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_UMSEL01_bm  0x80 /* USART Mode Select 01 bit mask.*/
 164:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_UMSEL01_bp  7 /* USART Mode Select 01 bit position.*/
 165:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 166:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_UMSEL00_bm  0x40 /* USART Mode Select 00 bit mask.*/
 167:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_UMSEL00_bp  6 /* USART Mode Select 00 bit position.*/
 168:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 169:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_PMODE_gm  0x30 /* USART Parity Mode Select grp mask.*/
 170:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_PMODE_gp  4 /* USART Parity Mode Select grp position.*/
 171:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 172:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_PMODE01_bm  0x20 /* USART Parity Mode Select 01 bit mask.*/
 173:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_PMODE01_bp  5 /* USART Parity Mode Select 01 bit position.*/
 174:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 175:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_PMODE00_bm  0x10 /* USART Parity Mode Select 00 bit mask.*/
 176:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_PMODE00_bp  4 /* USART Parity Mode Select 00 bit position.*/
 177:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 178:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_STOPB_bm  0x08 /* USART stop bit mask.*/
 179:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_STOPB_bp  3 /* USART stop bit Position.*/
 180:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 181:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_CHSIZE01C_gm  0x06  /* Character Size 10 bit 1 mask. */
 182:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_CHSIZE01C_gp  1 /* Character Size 10 bit position. */
 183:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 184:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_CHSIZE01_bm  0x04  /* Character Size 10 bit 1 mask. */
 185:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_CHSIZE01_bp  2 /* Character Size 10 bit position. */
 186:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 187:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_CHSIZE00_bm  0x02  /* Character Size 00 bit 1 mask. */
 188:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_CHSIZE00_bp  1 /* Character Size bit 00 position. */
 189:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 190:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_UCPOL_bm  0x01  /* Sync mode Pol bit 1 mask. */
 191:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_UCPOL_bp  0 /*Sync mode Pol bit 0 position */
 192:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 193:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_UCPHA_bm 0x02 /* Clock Phase bit mask. */
 194:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_UCPHA_bp 1 /* Clock Phase bit position. */
 195:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 196:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_DORD_bm 0x04 /* Data order bit mask. */
 197:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_DORD_bp 2 /* Data order bit position. */
 198:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 199:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* Character Size */
 200:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** typedef enum USART_CHSIZE_enum {
 201:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	USART_CHSIZE_5BIT_gc = (0x00),  /* Character size: 5 bit */
 202:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	USART_CHSIZE_6BIT_gc = (0x01),  /* Character size: 6 bit */
 203:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	USART_CHSIZE_7BIT_gc = (0x02),  /* Character size: 7 bit */
 204:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	USART_CHSIZE_8BIT_gc = (0x03),  /* Character size: 8 bit */
 205:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	USART_CHSIZE_9BIT_gc = (0x07),  /* Character size: 9 bit */
 206:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** } USART_CHSIZE_t;
 207:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 208:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* Communication Mode */
 209:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** typedef enum USART_CMODE_enum {
 210:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	USART_CMODE_ASYNCHRONOUS_gc = (0x00 << USART_UMSEL01_gp),  /*
 211:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	                                                            *
 212:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	                                                            *
 213:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	                                                            *Asynchronous
 214:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	                                                            * Mode */
 215:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	USART_CMODE_SYNCHRONOUS_gc = (0x01 << USART_UMSEL01_gp),  /* Synchronous
 216:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	                                                           * Mode */
 217:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	USART_CMODE_IRDA_gc = (0x02 << USART_UMSEL01_gp),  /* IrDA Mode */
 218:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	USART_CMODE_MSPI_gc = (0x03 << USART_UMSEL01_gp),  /* Master SPI Mode */
 219:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** } USART_CMODE_t;
 220:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 221:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* Parity Mode */
 222:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** typedef enum USART_PMODE_enum {
 223:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	USART_PMODE_DISABLED_gc = (0x00 << USART_PMODE_gp),  /* No Parity */
 224:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	USART_PMODE_EVEN_gc = (0x02 << USART_PMODE_gp),  /* Even Parity */
 225:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	USART_PMODE_ODD_gc = (0x03 << USART_PMODE_gp),  /* Odd Parity */
 226:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** } USART_PMODE_t;
 227:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 228:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* ! Lookup table containing baudctrl values for CPU frequency 1 Mhz */
 229:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static PROGMEM_DECLARE(uint16_t, baudctrl_1mhz[]) = {
 230:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0033, /* Baud: 1200 */
 231:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0019, /* Baud: 2400 */
 232:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x000C, /* Baud: 4800 */
 233:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0006, /* Baud: 9600 */
 234:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0003, /* Baud: 19200 */
 235:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0002, /* Baud: 38400 */
 236:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0001, /* Baud: 57600 */
 237:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	USART_BAUD_UNDEFINED, /* Baud: 115200 */
 238:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** };
 239:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 240:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* ! Lookup table containing baudctrl values for CPU frequency 8 Mhz */
 241:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static PROGMEM_DECLARE(uint16_t, baudctrl_8mhz[]) = {
 242:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x01A0, /* Baud: 1200 */
 243:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x00CF, /* Baud: 2400 */
 244:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0067, /* Baud: 4800 */
 245:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0033, /* Baud: 9600 */
 246:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0019, /* Baud: 19200 */
 247:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x000C, /* Baud: 38400 */
 248:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0007, /* Baud: 57600 */
 249:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0008, /* Baud: 115200 */
 250:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** };
 251:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 252:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* ! Lookup table containing baudctrl values for CPU frequency 16 Mhz */
 253:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static PROGMEM_DECLARE(uint16_t, baudctrl_16mhz[]) = {
 254:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0340, /* Baud: 1200 */
 255:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x01A0, /* Baud: 2400 */
 256:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x00CF, /* Baud: 4800 */
 257:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0067, /* Baud: 9600 */
 258:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0033, /* Baud: 19200 */
 259:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0019, /* Baud: 38400 */
 260:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0010, /* Baud: 57600 */
 261:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0010, /* Baud: 115200 */
 262:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** };
 263:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 264:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 265:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* ! Input parameters when initializing RS232 and similar modes. */
 266:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** typedef struct usart_rs232_options {
 267:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	/* ! Set baud rate of the USART (unused in slave modes). */
 268:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	uint32_t baudrate;
 269:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 270:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	/* ! Number of bits to transmit as a character (5 to 9). */
 271:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	USART_CHSIZE_t charlength;
 272:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 273:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	/* ! Parity type: USART_PMODE_DISABLED_gc, USART_PMODE_EVEN_gc, */
 274:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	/* ! USART_PMODE_ODD_gc. */
 275:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	USART_PMODE_t paritytype;
 276:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 277:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	/* ! Number of stop bits between two characters: */
 278:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	/* ! true: 2 stop bits */
 279:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	/* ! false: 1 stop bit */
 280:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	bool stopbits;
 281:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** } usart_rs232_options_t;
 282:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 283:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* ! Input parameters when initializing SPI master mode. */
 284:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** typedef struct usart_spi_options {
 285:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	/* ! Set baud rate of the USART in SPI mode. */
 286:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	uint32_t baudrate;
 287:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 288:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	/* ! SPI transmission mode. */
 289:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	uint8_t spimode;
 290:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 291:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	uint8_t data_order;
 292:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** } usart_spi_options_t;
 293:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 294:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 295:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 296:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Enable USART receiver.
 297:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 298:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart Pointer to the USART module
 299:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 300:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline void usart_rx_enable(USART_t *usart)
 301:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 302:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	(usart)->UCSRnB |= USART_RXEN_bm;
 303:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 304:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 305:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 306:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Disable USART receiver.
 307:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 308:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart Pointer to the USART module.
 309:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 310:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline void usart_rx_disable(USART_t *usart)
 311:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 312:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	(usart)->UCSRnB &= ~USART_RXEN_bm;
 313:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 314:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 315:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 316:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief  Configure the USART frame format.
 317:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 318:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *  Sets the frame format, Frame Size, parity mode and number of stop bits.
 319:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 320:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *  \param usart Pointer to the USART module
 321:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *  \param charSize The character size. Use USART_CHSIZE_t type.
 322:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *  \param parityMode The parity Mode. Use USART_PMODE_t type.
 323:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *  \param twoStopBits Enable two stop bit mode. Use bool type.
 324:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 325:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline void usart_format_set(USART_t *usart, USART_CHSIZE_t charSize,
 326:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 		USART_PMODE_t parityMode, bool twoStopBits)
 327:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 328:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	(usart)->UCSRnC
 329:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 		= ((usart)->UCSRnC &
 330:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 			(~USART_CHSIZE01C_gm)) | ((charSize & 0x03)
 331:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 			<< USART_CHSIZE01C_gp);
 332:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	(usart)->UCSRnB
 333:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 		= ((usart)->UCSRnB &
 334:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 			(~USART_CHSIZE2_bm)) | ((charSize & 0x04)
 335:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 			<< USART_CHSIZE2_bp);
 336:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 337:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	(usart)->UCSRnC = ((usart)->UCSRnC & (~USART_PMODE_gm)) | parityMode;
 338:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 339:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	(usart)->UCSRnC = ((usart)->UCSRnC & (~USART_STOPB_bm)) | (twoStopBits
 340:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 			<< USART_STOPB_bp);
 341:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 342:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 343:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 344:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Enable USART transmitter.
 345:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 346:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart Pointer to the USART module.
 347:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 348:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline void usart_tx_enable(USART_t *usart)
 349:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 350:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	(usart)->UCSRnB |= USART_TXEN_bm;
 351:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 352:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 353:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 354:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Disable USART transmitter.
 355:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 356:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart Pointer to the USART module.
 357:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 358:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline void usart_tx_disable(USART_t *usart)
 359:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 360:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	(usart)->UCSRnB &= ~USART_TXEN_bm;
 361:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 362:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 363:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 364:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Enable USART transmit complete interrupt.
 365:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 366:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart Pointer to the USART module.
 367:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 368:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline void usart_tx_complete_interrupt_enable(USART_t *usart)
 369:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 370:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	(usart)->UCSRnB |= USART_TXC_bm;
 371:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 372:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 373:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 374:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Enable USART receive complete interrupt.
 375:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 376:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart Pointer to the USART module.
 377:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 378:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline void usart_rx_complete_interrupt_enable(USART_t *usart)
 379:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 380:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	(usart)->UCSRnB |= USART_RXC_bm;
 381:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 382:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 383:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 384:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Enable USART data register empty interrupt.
 385:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 386:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart Pointer to the USART module.
 387:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 388:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline void usart_data_empty_interrupt_enable(USART_t *usart)
 389:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 390:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	(usart)->UCSRnB |= USART_DRIE_bm;
 391:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 392:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 393:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 394:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Disable USART transmit complete interrupt.
 395:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 396:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart Pointer to the USART module.
 397:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 398:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline void usart_tx_complete_interrupt_disable(USART_t *usart)
 399:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 400:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	(usart)->UCSRnB &= ~USART_TXC_bm;
 401:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 402:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 403:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 404:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Disable USART receive complete interrupt.
 405:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 406:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart Pointer to the USART module.
 407:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 408:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline void usart_rx_complete_interrupt_disable(USART_t *usart)
 409:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 410:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	(usart)->UCSRnB &= ~USART_RXC_bm;
 411:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 412:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 413:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 414:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Disable USART data register empty interrupt.
 415:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 416:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart Pointer to the USART module.
 417:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 418:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline void usart_data_empty_interrupt_disable(USART_t *usart)
 419:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 420:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	(usart)->UCSRnB &= ~USART_DRIE_bm;
 421:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 422:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 423:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 424:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Set the mode the USART run in.
 425:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 426:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * Set the mode the USART run in. The default mode is asynchronous mode.
 427:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 428:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart Pointer to the USART module register section.
 429:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usartmode Selects the USART mode. Use USART_CMODE_t type.
 430:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 431:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * USART modes:
 432:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * - 0x0        : Asynchronous mode.
 433:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * - 0x1        : Synchronous mode.
 434:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * - 0x2        : IrDA mode.
 435:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * - 0x3        : Master SPI mode.
 436:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 437:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline void usart_set_mode(USART_t *usart, USART_CMODE_t usartmode)
 438:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 439:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	(usart)->UCSRnC = ((usart)->UCSRnC & (~USART_UMSEL01_gm)) | usartmode;
 440:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 441:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 442:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 443:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Check if data register empty flag is set.
 444:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 445:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart The USART module.
 446:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 447:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline bool usart_data_register_is_empty(USART_t *usart)
 448:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 449:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	return (usart)->UCSRnA & USART_DRE_bm;
 450:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 451:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 452:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 453:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Checks if the RX complete interrupt flag is set.
 454:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 455:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * Checks if the RX complete interrupt flag is set.
 456:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 457:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart The USART module.
 458:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 459:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline bool usart_rx_is_complete(USART_t *usart)
 460:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 461:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	return (usart)->UCSRnA & USART_RXC_bm;
 462:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 463:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 464:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 465:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Checks if the TX complete interrupt flag is set.
 466:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 467:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * Checks if the TX complete interrupt flag is set.
 468:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 469:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart The USART module.
 470:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 471:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline bool usart_tx_is_complete(USART_t *usart)
 472:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 473:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	return (usart)->UCSRnA & USART_TXC_bm;
 474:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 475:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 476:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 477:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Clear TX complete interrupt flag.
 478:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * TX flag is clear after complete transmission, automatically.
 479:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart The USART module.
 480:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 481:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline void usart_clear_tx_complete(USART_t *usart)
 482:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 483:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****          usart->UCSRnA |=  USART_TXC_bm;
 484:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 485:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 486:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 487:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Write a data to the USART data register.
 488:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 489:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart The USART module.
 490:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param txdata The data to be transmitted.
 491:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 492:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline void usart_put(USART_t *usart, uint8_t txdata)
 493:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 494:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	(usart)->UDR = txdata;
 495:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 496:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 497:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 498:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief  Read a data to the USART data register.
 499:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 500:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart The USART module.
 501:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 502:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \return The received data
 503:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 504:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline uint8_t usart_get(USART_t *usart)
 505:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 506:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	return (usart)->UDR;
 507:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 508:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 509:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 510:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Double the USART transmission speed.
 511:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 512:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart The USART module.
 513:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 514:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline void usart_double_baud_enable(USART_t *usart)
 515:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 135               		.loc 2 515 0
 136               		.cfi_startproc
 137 0034 CF93      		push r28
 138               	.LCFI6:
 139               		.cfi_def_cfa_offset 3
 140               		.cfi_offset 28, -2
 141 0036 DF93      		push r29
 142               	.LCFI7:
 143               		.cfi_def_cfa_offset 4
 144               		.cfi_offset 29, -3
 145 0038 00D0      		rcall .
 146               	.LCFI8:
 147               		.cfi_def_cfa_offset 6
 148 003a CDB7      		in r28,__SP_L__
 149 003c DEB7      		in r29,__SP_H__
 150               	.LCFI9:
 151               		.cfi_def_cfa_register 28
 152               	/* prologue: function */
 153               	/* frame size = 2 */
 154               	/* stack size = 4 */
 155               	.L__stack_usage = 4
 156 003e 9A83      		std Y+2,r25
 157 0040 8983      		std Y+1,r24
 516:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	usart->UCSRnA |=  USART_U2X_bm;
 158               		.loc 2 516 0
 159 0042 8981      		ldd r24,Y+1
 160 0044 9A81      		ldd r25,Y+2
 161 0046 FC01      		movw r30,r24
 162 0048 8081      		ld r24,Z
 163 004a 282F      		mov r18,r24
 164 004c 2260      		ori r18,lo8(2)
 165 004e 8981      		ldd r24,Y+1
 166 0050 9A81      		ldd r25,Y+2
 167 0052 FC01      		movw r30,r24
 168 0054 2083      		st Z,r18
 517:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 169               		.loc 2 517 0
 170 0056 0000      		nop
 171               	/* epilogue start */
 172 0058 0F90      		pop __tmp_reg__
 173 005a 0F90      		pop __tmp_reg__
 174 005c DF91      		pop r29
 175 005e CF91      		pop r28
 176 0060 0895      		ret
 177               		.cfi_endproc
 178               	.LFE101:
 181               	usart_serial_init:
 182               	.LFB104:
 183               		.file 3 "../../../platform/common/services/serial/megarf_usart/usart_serial.h"
   1:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** /**
   2:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * \file
   3:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
   4:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * \brief This file defines a useful set of functions for the Serial interface on 
   5:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * AVR MEGARF devices.
   6:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
   7:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * Copyright (c) 2013 Atmel Corporation. All rights reserved.
   8:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
   9:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * \asf_license_start
  10:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
  11:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * \page License
  12:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
  13:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * Redistribution and use in source and binary forms, with or without
  14:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * modification, are permitted provided that the following conditions are met:
  15:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
  16:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * 1. Redistributions of source code must retain the above copyright notice,
  17:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *    this list of conditions and the following disclaimer.
  18:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
  19:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * 2. Redistributions in binary form must reproduce the above copyright notice,
  20:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *    this list of conditions and the following disclaimer in the documentation
  21:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *    and/or other materials provided with the distribution.
  22:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
  23:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * 3. The name of Atmel may not be used to endorse or promote products derived
  24:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *    from this software without specific prior written permission.
  25:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
  26:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * 4. This software may only be redistributed and used in connection with an
  27:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *    Atmel microcontroller product.
  28:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
  29:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR IMPLIED
  30:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
  31:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
  32:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR
  33:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  34:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
  35:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  36:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
  37:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  38:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  39:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * POSSIBILITY OF SUCH DAMAGE.
  40:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
  41:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * \asf_license_stop
  42:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
  43:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  */
  44:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** #ifndef _USART_SERIAL_H_
  45:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** #define _USART_SERIAL_H_
  46:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 
  47:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** #ifdef __cplusplus
  48:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** extern "C" {
  49:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** #endif
  50:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 
  51:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** #include "compiler.h"
  52:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** #include "sysclk.h"
  53:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** #include "status_codes.h"
  54:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** #include "usart_megarf.h"
  55:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 
  56:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** /*! \name Serial Management Configuration
  57:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  */
  58:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** /* ! @{ */
  59:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** #include "conf_usart_serial.h"
  60:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** /* ! @} */
  61:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 
  62:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** typedef usart_rs232_options_t usart_serial_options_t;
  63:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 
  64:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** typedef USART_t *usart_if;
  65:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 
  66:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** /*! \brief Initializes the Usart in master mode.
  67:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
  68:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * \param usart       Base address of the USART instance.
  69:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * \param options     Options needed to set up RS232 communication (see \ref
  70:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * usart_serial_options_t).
  71:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
  72:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * \retval true if the initialization was successful
  73:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * \retval false if initialization failed (error in baud rate calculation)
  74:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  */
  75:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** static inline bool usart_serial_init(usart_if usart, const
  76:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 		usart_serial_options_t *options)
  77:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** {
 184               		.loc 3 77 0
 185               		.cfi_startproc
 186 0062 CF93      		push r28
 187               	.LCFI10:
 188               		.cfi_def_cfa_offset 3
 189               		.cfi_offset 28, -2
 190 0064 DF93      		push r29
 191               	.LCFI11:
 192               		.cfi_def_cfa_offset 4
 193               		.cfi_offset 29, -3
 194 0066 CDB7      		in r28,__SP_L__
 195 0068 DEB7      		in r29,__SP_H__
 196               	.LCFI12:
 197               		.cfi_def_cfa_register 28
 198 006a 2B97      		sbiw r28,11
 199               	.LCFI13:
 200               		.cfi_def_cfa_offset 15
 201 006c 0FB6      		in __tmp_reg__,__SREG__
 202 006e F894      		cli
 203 0070 DEBF      		out __SP_H__,r29
 204 0072 0FBE      		out __SREG__,__tmp_reg__
 205 0074 CDBF      		out __SP_L__,r28
 206               	/* prologue: function */
 207               	/* frame size = 11 */
 208               	/* stack size = 13 */
 209               	.L__stack_usage = 13
 210 0076 9987      		std Y+9,r25
 211 0078 8887      		std Y+8,r24
 212 007a 7B87      		std Y+11,r23
 213 007c 6A87      		std Y+10,r22
  78:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 	/* USART options. */
  79:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 	usart_rs232_options_t usart_rs232_options;
  80:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 	usart_rs232_options.charlength   = options->charlength;
 214               		.loc 3 80 0
 215 007e 8A85      		ldd r24,Y+10
 216 0080 9B85      		ldd r25,Y+11
 217 0082 FC01      		movw r30,r24
 218 0084 8481      		ldd r24,Z+4
 219 0086 8D83      		std Y+5,r24
  81:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 	usart_rs232_options.paritytype   = options->paritytype;
 220               		.loc 3 81 0
 221 0088 8A85      		ldd r24,Y+10
 222 008a 9B85      		ldd r25,Y+11
 223 008c FC01      		movw r30,r24
 224 008e 8581      		ldd r24,Z+5
 225 0090 8E83      		std Y+6,r24
  82:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 	usart_rs232_options.stopbits     = options->stopbits;
 226               		.loc 3 82 0
 227 0092 8A85      		ldd r24,Y+10
 228 0094 9B85      		ldd r25,Y+11
 229 0096 FC01      		movw r30,r24
 230 0098 8681      		ldd r24,Z+6
 231 009a 8F83      		std Y+7,r24
  83:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 	usart_rs232_options.baudrate     = options->baudrate;
 232               		.loc 3 83 0
 233 009c 8A85      		ldd r24,Y+10
 234 009e 9B85      		ldd r25,Y+11
 235 00a0 FC01      		movw r30,r24
 236 00a2 8081      		ld r24,Z
 237 00a4 9181      		ldd r25,Z+1
 238 00a6 A281      		ldd r26,Z+2
 239 00a8 B381      		ldd r27,Z+3
 240 00aa 8983      		std Y+1,r24
 241 00ac 9A83      		std Y+2,r25
 242 00ae AB83      		std Y+3,r26
 243 00b0 BC83      		std Y+4,r27
  84:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 
  85:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 	if (usart_init_rs232(usart, &usart_rs232_options)) {
 244               		.loc 3 85 0
 245 00b2 8885      		ldd r24,Y+8
 246 00b4 9985      		ldd r25,Y+9
 247 00b6 9E01      		movw r18,r28
 248 00b8 2F5F      		subi r18,-1
 249 00ba 3F4F      		sbci r19,-1
 250 00bc B901      		movw r22,r18
 251 00be 0E94 0000 		call usart_init_rs232
 252 00c2 8823      		tst r24
 253 00c4 01F0      		breq .L7
  86:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 		return true;
 254               		.loc 3 86 0
 255 00c6 81E0      		ldi r24,lo8(1)
 256 00c8 00C0      		rjmp .L9
 257               	.L7:
  87:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 	} else {
  88:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 		return false;
 258               		.loc 3 88 0
 259 00ca 80E0      		ldi r24,0
 260               	.L9:
 261               	/* epilogue start */
  89:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 	}
  90:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** }
 262               		.loc 3 90 0 discriminator 1
 263 00cc 2B96      		adiw r28,11
 264 00ce 0FB6      		in __tmp_reg__,__SREG__
 265 00d0 F894      		cli
 266 00d2 DEBF      		out __SP_H__,r29
 267 00d4 0FBE      		out __SREG__,__tmp_reg__
 268 00d6 CDBF      		out __SP_L__,r28
 269 00d8 DF91      		pop r29
 270 00da CF91      		pop r28
 271 00dc 0895      		ret
 272               		.cfi_endproc
 273               	.LFE104:
 276               	usart_serial_putchar:
 277               	.LFB105:
  91:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 
  92:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** /*! \brief Sends a character with the USART.
  93:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
  94:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * \param usart   Base address of the USART instance.
  95:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * \param c       Character to write.
  96:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
  97:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * \return Status code
  98:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  */
  99:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** static inline status_code_t usart_serial_putchar(usart_if usart, uint8_t c)
 100:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** {
 278               		.loc 3 100 0
 279               		.cfi_startproc
 280 00de CF93      		push r28
 281               	.LCFI14:
 282               		.cfi_def_cfa_offset 3
 283               		.cfi_offset 28, -2
 284 00e0 DF93      		push r29
 285               	.LCFI15:
 286               		.cfi_def_cfa_offset 4
 287               		.cfi_offset 29, -3
 288 00e2 00D0      		rcall .
 289 00e4 1F92      		push __zero_reg__
 290               	.LCFI16:
 291               		.cfi_def_cfa_offset 7
 292 00e6 CDB7      		in r28,__SP_L__
 293 00e8 DEB7      		in r29,__SP_H__
 294               	.LCFI17:
 295               		.cfi_def_cfa_register 28
 296               	/* prologue: function */
 297               	/* frame size = 3 */
 298               	/* stack size = 5 */
 299               	.L__stack_usage = 5
 300 00ea 9A83      		std Y+2,r25
 301 00ec 8983      		std Y+1,r24
 302 00ee 6B83      		std Y+3,r22
 101:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 	return usart_putchar(usart, c);
 303               		.loc 3 101 0
 304 00f0 8981      		ldd r24,Y+1
 305 00f2 9A81      		ldd r25,Y+2
 306 00f4 6B81      		ldd r22,Y+3
 307 00f6 0E94 0000 		call usart_putchar
 308               	/* epilogue start */
 102:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** }
 309               		.loc 3 102 0
 310 00fa 0F90      		pop __tmp_reg__
 311 00fc 0F90      		pop __tmp_reg__
 312 00fe 0F90      		pop __tmp_reg__
 313 0100 DF91      		pop r29
 314 0102 CF91      		pop r28
 315 0104 0895      		ret
 316               		.cfi_endproc
 317               	.LFE105:
 320               	usart_serial_getchar:
 321               	.LFB106:
 103:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 
 104:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** /*! \brief Waits until a character is received, and returns it.
 105:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
 106:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * \param usart   Base address of the USART instance.
 107:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * \param data   Data to read
 108:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
 109:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  */
 110:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** static inline void usart_serial_getchar(usart_if usart, uint8_t *data)
 111:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** {
 322               		.loc 3 111 0
 323               		.cfi_startproc
 324 0106 CF93      		push r28
 325               	.LCFI18:
 326               		.cfi_def_cfa_offset 3
 327               		.cfi_offset 28, -2
 328 0108 DF93      		push r29
 329               	.LCFI19:
 330               		.cfi_def_cfa_offset 4
 331               		.cfi_offset 29, -3
 332 010a 00D0      		rcall .
 333 010c 00D0      		rcall .
 334               	.LCFI20:
 335               		.cfi_def_cfa_offset 8
 336 010e CDB7      		in r28,__SP_L__
 337 0110 DEB7      		in r29,__SP_H__
 338               	.LCFI21:
 339               		.cfi_def_cfa_register 28
 340               	/* prologue: function */
 341               	/* frame size = 4 */
 342               	/* stack size = 6 */
 343               	.L__stack_usage = 6
 344 0112 9A83      		std Y+2,r25
 345 0114 8983      		std Y+1,r24
 346 0116 7C83      		std Y+4,r23
 347 0118 6B83      		std Y+3,r22
 112:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 	*data = usart_getchar(usart);
 348               		.loc 3 112 0
 349 011a 8981      		ldd r24,Y+1
 350 011c 9A81      		ldd r25,Y+2
 351 011e 0E94 0000 		call usart_getchar
 352 0122 282F      		mov r18,r24
 353 0124 8B81      		ldd r24,Y+3
 354 0126 9C81      		ldd r25,Y+4
 355 0128 FC01      		movw r30,r24
 356 012a 2083      		st Z,r18
 113:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** }
 357               		.loc 3 113 0
 358 012c 0000      		nop
 359               	/* epilogue start */
 360 012e 0F90      		pop __tmp_reg__
 361 0130 0F90      		pop __tmp_reg__
 362 0132 0F90      		pop __tmp_reg__
 363 0134 0F90      		pop __tmp_reg__
 364 0136 DF91      		pop r29
 365 0138 CF91      		pop r28
 366 013a 0895      		ret
 367               		.cfi_endproc
 368               	.LFE106:
 371               	stdio_serial_init:
 372               	.LFB107:
 373               		.file 4 "../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h"
   1:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** /**
   2:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
   3:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * \file
   4:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
   5:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * \brief Common Standard I/O Serial Management.
   6:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
   7:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * This file defines a useful set of functions for the Stdio Serial interface on AVR
   8:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * and SAM devices.
   9:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
  10:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * Copyright (c) 2009-2013 Atmel Corporation. All rights reserved.
  11:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
  12:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * \asf_license_start
  13:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
  14:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * \page License
  15:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
  16:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * Redistribution and use in source and binary forms, with or without
  17:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * modification, are permitted provided that the following conditions are met:
  18:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
  19:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * 1. Redistributions of source code must retain the above copyright notice,
  20:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *    this list of conditions and the following disclaimer.
  21:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
  22:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * 2. Redistributions in binary form must reproduce the above copyright notice,
  23:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *    this list of conditions and the following disclaimer in the documentation
  24:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *    and/or other materials provided with the distribution.
  25:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
  26:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * 3. The name of Atmel may not be used to endorse or promote products derived
  27:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *    from this software without specific prior written permission.
  28:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
  29:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * 4. This software may only be redistributed and used in connection with an
  30:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *    Atmel microcontroller product.
  31:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
  32:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR IMPLIED
  33:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
  34:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
  35:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR
  36:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  37:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
  38:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  39:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
  40:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  41:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  42:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * POSSIBILITY OF SUCH DAMAGE.
  43:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
  44:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * \asf_license_stop
  45:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
  46:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  ******************************************************************************/
  47:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 
  48:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 
  49:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** #ifndef _STDIO_SERIAL_H_
  50:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** #define _STDIO_SERIAL_H_
  51:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 
  52:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** /**
  53:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * \defgroup group_common_utils_stdio_stdio_serial Standard serial I/O (stdio)
  54:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * \ingroup group_common_utils_stdio
  55:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
  56:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * Common standard serial I/O management driver that
  57:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * implements a stdio serial interface on AVR and SAM devices.
  58:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
  59:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * \{
  60:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  */
  61:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 
  62:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** #include <stdio.h>
  63:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** #include "compiler.h"
  64:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** #ifndef SAMD20
  65:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** # include "sysclk.h"
  66:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** #endif
  67:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** #include "serial.h"
  68:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 
  69:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** #if (XMEGA || MEGA_RF) && defined(__GNUC__)
  70:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	extern int _write (char c, int *f);
  71:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	extern int _read (int *f);
  72:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** #endif
  73:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 
  74:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 
  75:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** //! Pointer to the base of the USART module instance to use for stdio.
  76:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** extern volatile void *volatile stdio_base;
  77:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** //! Pointer to the external low level write function.
  78:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** extern int (*ptr_put)(void volatile*, char);
  79:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 
  80:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** //! Pointer to the external low level read function.
  81:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** extern void (*ptr_get)(void volatile*, char*);
  82:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 
  83:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** /*! \brief Initializes the stdio in Serial Mode.
  84:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
  85:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * \param usart       Base address of the USART instance.
  86:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * \param opt         Options needed to set up RS232 communication (see \ref usart_options_t).
  87:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
  88:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  */
  89:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** static inline void stdio_serial_init(volatile void *usart, const usart_serial_options_t *opt)
  90:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** {
 374               		.loc 4 90 0
 375               		.cfi_startproc
 376 013c CF93      		push r28
 377               	.LCFI22:
 378               		.cfi_def_cfa_offset 3
 379               		.cfi_offset 28, -2
 380 013e DF93      		push r29
 381               	.LCFI23:
 382               		.cfi_def_cfa_offset 4
 383               		.cfi_offset 29, -3
 384 0140 00D0      		rcall .
 385 0142 00D0      		rcall .
 386               	.LCFI24:
 387               		.cfi_def_cfa_offset 8
 388 0144 CDB7      		in r28,__SP_L__
 389 0146 DEB7      		in r29,__SP_H__
 390               	.LCFI25:
 391               		.cfi_def_cfa_register 28
 392               	/* prologue: function */
 393               	/* frame size = 4 */
 394               	/* stack size = 6 */
 395               	.L__stack_usage = 6
 396 0148 9A83      		std Y+2,r25
 397 014a 8983      		std Y+1,r24
 398 014c 7C83      		std Y+4,r23
 399 014e 6B83      		std Y+3,r22
  91:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	stdio_base = (void *)usart;
 400               		.loc 4 91 0
 401 0150 8981      		ldd r24,Y+1
 402 0152 9A81      		ldd r25,Y+2
 403 0154 9093 0000 		sts stdio_base+1,r25
 404 0158 8093 0000 		sts stdio_base,r24
  92:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	ptr_put = (int (*)(void volatile*,char))&usart_serial_putchar;
 405               		.loc 4 92 0
 406 015c 80E0      		ldi r24,lo8(gs(usart_serial_putchar))
 407 015e 90E0      		ldi r25,hi8(gs(usart_serial_putchar))
 408 0160 9093 0000 		sts ptr_put+1,r25
 409 0164 8093 0000 		sts ptr_put,r24
  93:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	ptr_get = (void (*)(void volatile*,char*))&usart_serial_getchar;
 410               		.loc 4 93 0
 411 0168 80E0      		ldi r24,lo8(gs(usart_serial_getchar))
 412 016a 90E0      		ldi r25,hi8(gs(usart_serial_getchar))
 413 016c 9093 0000 		sts ptr_get+1,r25
 414 0170 8093 0000 		sts ptr_get,r24
  94:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** # if (XMEGA || MEGA_RF)
  95:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	usart_serial_init((USART_t *)usart,opt);
 415               		.loc 4 95 0
 416 0174 2B81      		ldd r18,Y+3
 417 0176 3C81      		ldd r19,Y+4
 418 0178 8981      		ldd r24,Y+1
 419 017a 9A81      		ldd r25,Y+2
 420 017c B901      		movw r22,r18
 421 017e 0E94 0000 		call usart_serial_init
  96:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** # elif UC3
  97:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	usart_serial_init(usart,(usart_serial_options_t *)opt);
  98:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** # elif SAM
  99:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	usart_serial_init((Usart *)usart,(usart_serial_options_t *)opt);
 100:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** # else
 101:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** #  error Unsupported chip type
 102:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** # endif
 103:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 
 104:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** # if defined(__GNUC__)
 105:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** #  if (XMEGA || MEGA_RF)
 106:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	// For AVR GCC libc print redirection uses fdevopen.
 107:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	fdevopen((int (*)(char, FILE*))(_write),(int (*)(FILE*))(_read));
 422               		.loc 4 107 0
 423 0182 60E0      		ldi r22,lo8(gs(_read))
 424 0184 70E0      		ldi r23,hi8(gs(_read))
 425 0186 80E0      		ldi r24,lo8(gs(_write))
 426 0188 90E0      		ldi r25,hi8(gs(_write))
 427 018a 0E94 0000 		call fdevopen
 108:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** #  endif
 109:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** #  if UC3 || SAM
 110:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	// For AVR32 and SAM GCC
 111:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	// Specify that stdout and stdin should not be buffered.
 112:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	setbuf(stdout, NULL);
 113:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	setbuf(stdin, NULL);
 114:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	// Note: Already the case in IAR's Normal DLIB default configuration
 115:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	// and AVR GCC library:
 116:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	// - printf() emits one character at a time.
 117:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	// - getchar() requests only 1 byte to exit.
 118:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** #  endif
 119:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** # endif
 120:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** }
 428               		.loc 4 120 0
 429 018e 0000      		nop
 430               	/* epilogue start */
 431 0190 0F90      		pop __tmp_reg__
 432 0192 0F90      		pop __tmp_reg__
 433 0194 0F90      		pop __tmp_reg__
 434 0196 0F90      		pop __tmp_reg__
 435 0198 DF91      		pop r29
 436 019a CF91      		pop r28
 437 019c 0895      		ret
 438               		.cfi_endproc
 439               	.LFE107:
 442               	macsc_enable_manual_bts:
 443               	.LFB121:
 444               		.file 5 "../../../platform/mega_rf/drivers/macsc/macsc_megarf.h"
   1:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
   2:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \file
   3:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
   4:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief AVR MEGARF MAC Symbol Counter Driver Definitions
   5:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
   6:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * Copyright (c) 2013 Atmel Corporation. All rights reserved.
   7:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
   8:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \asf_license_start
   9:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  10:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \page License
  11:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  12:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * Redistribution and use in source and binary forms, with or without
  13:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * modification, are permitted provided that the following conditions are met:
  14:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  15:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * 1. Redistributions of source code must retain the above copyright notice,
  16:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *    this list of conditions and the following disclaimer.
  17:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  18:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * 2. Redistributions in binary form must reproduce the above copyright notice,
  19:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *    this list of conditions and the following disclaimer in the documentation
  20:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *    and/or other materials provided with the distribution.
  21:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  22:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * 3. The name of Atmel may not be used to endorse or promote products derived
  23:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *    from this software without specific prior written permission.
  24:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  25:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * 4. This software may only be redistributed and used in connection with an
  26:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *    Atmel microcontroller product.
  27:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  28:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR IMPLIED
  29:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
  30:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
  31:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR
  32:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  33:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
  34:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  35:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
  36:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  37:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  38:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * POSSIBILITY OF SUCH DAMAGE.
  39:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  40:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \asf_license_stop
  41:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  42:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
  43:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** #ifndef MACSC_MEGARF_H
  44:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** #define MACSC_MEGARF_H
  45:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
  46:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** #include <compiler.h>
  47:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** #include <parts.h>
  48:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** #include "status_codes.h"
  49:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
  50:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** #ifdef __cplusplus
  51:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** extern "C" {
  52:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** #endif
  53:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
  54:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
  55:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \defgroup macsc_group MAC Symbol Counter Driver(MACSC)
  56:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  57:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * See \ref megarf_macsc_quickstart
  58:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  59:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * This is a driver for the AVR MEGARF MAC Symbol Counter Driver(MACSC).
  60:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * It provides functions for enabling, disabling and configuring the module.
  61:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  62:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \section dependencies Dependencies
  63:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * This driver depends on the following modules:
  64:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * - \ref interrupt_group for ISR definition and disabling interrupts during
  65:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * critical code sections.
  66:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * @{
  67:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
  68:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
  69:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
  70:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Interrupt event callback function type
  71:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  72:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * The interrupt handler can be configured to do a function callback,
  73:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * the callback function must match the macsc_callback_t type.
  74:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  75:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
  76:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** typedef void (*macsc_callback_t)(void);
  77:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
  78:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /* ! MAC symbol counter compare Channel index */
  79:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** enum macsc_cc_channel {
  80:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	/* ! Channel 1 */
  81:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	MACSC_CC1 = 1,
  82:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	/* ! Channel 2 */
  83:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	MACSC_CC2 = 2,
  84:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	/* ! Channel 3 */
  85:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	MACSC_CC3 = 3,
  86:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** };
  87:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
  88:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief MAC SC clock source select
  89:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  90:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * uses the SCCKSEL bit in SSCR register to select macsc clk src
  91:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  92:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * If the bit is one,the RTC clock from TOSC1 is selected, otherwise the symbol
  93:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * counter operates with the clock from XTAL1.
  94:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * During transceiver sleep modes the clock falls back to the RTC clock source,
  95:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * regardless of the selected clock. After wakeup, it switches back to the
  96:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * previosly
  97:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * selected clock source.
  98:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
  99:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 100:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** enum macsc_xtal {
 101:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	/* ! 16MHz as macsc clock */
 102:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	MACSC_16MHz = 0,
 103:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	MACSC_32KHz = 1,
 104:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** };
 105:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 106:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 107:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * @brief Reads the 32-bit timer register in the required order of bytes
 108:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 109:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * @param hh hh octet of 32-bit register
 110:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * @param hl hl octet of 32-bit register
 111:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * @param lh lh octet of 32-bit register
 112:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * @param ll ll octet of 32-bit register
 113:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 114:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * @returns uint32_t Value of timer register
 115:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 116:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** static inline uint32_t macsc_read32(volatile uint8_t *hh,
 117:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		volatile uint8_t *hl,
 118:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		volatile uint8_t *lh,
 119:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		volatile uint8_t *ll)
 120:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** {
 121:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	union {
 122:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		uint8_t a[4];
 123:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		uint32_t rv;
 124:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	}
 125:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	x;
 126:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 127:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	x.a[0] = *ll;
 128:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	x.a[1] = *lh;
 129:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	x.a[2] = *hl;
 130:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	x.a[3] = *hh;
 131:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 132:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	return x.rv;
 133:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** }
 134:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 135:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /* ! compare modes */
 136:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** #define MACSC_ABSOLUTE_CMP 0
 137:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** #define MACSC_RELATIVE_CMP 1
 138:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 139:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /** String concatenation by preprocessor used to create proper register names.
 140:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  **/
 141:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** #define CONCAT(a, b) a ## b
 142:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 143:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /** Creates proper subregister names and reads the corresponding values. */
 144:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** #define MACSC_READ32(reg)                  macsc_read32(&CONCAT(reg, HH), \
 145:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		&CONCAT(reg, HL), \
 146:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		&CONCAT(reg, LH), \
 147:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		&CONCAT(reg, LL))
 148:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 149:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** #define MACSC_WRITE32(reg, val)	\
 150:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	do { \
 151:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		union { uint8_t a[4]; uint32_t v; } \
 152:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		x; \
 153:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		x.v = val; \
 154:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		CONCAT(reg, HH) = x.a[3]; \
 155:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		CONCAT(reg, HL) = x.a[2]; \
 156:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		CONCAT(reg, LH) = x.a[1]; \
 157:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		CONCAT(reg, LL) = x.a[0]; \
 158:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	} \
 159:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	while (0)
 160:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 161:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 162:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Enable MAC SC
 163:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 164:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * Enables the SC
 165:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 166:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param clk_src selection of clk source,avalable options in macsc_xtal,fixed
 167:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *  prescalar
 168:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param sleep_enable enable RTC as clock source during sleep
 169:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param auto_ts enable automatic timestamping
 170:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 171:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 172:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** void macsc_enable(void);
 173:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 174:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 175:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Check if MACSC is enabled
 176:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 177:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * check if the MACSC is enabled.
 178:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 179:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param none
 180:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 181:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 182:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** bool is_macsc_enable(void);
 183:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 184:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 185:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Disable MAC SC
 186:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 187:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * Disables the MAC SC
 188:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 189:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param none
 190:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 191:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 192:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** void macsc_disable(void);
 193:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 194:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 195:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Check if back-off slot counter is enabled
 196:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 197:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * check if the back-off slot counter is enabled.
 198:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 199:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param none
 200:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 201:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 202:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** bool is_macsc_backoff_enable(void);
 203:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 204:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 205:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Enables compare interrupts of the MACSC
 206:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 207:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param channel Compare channel
 208:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 209:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** void macsc_enable_cmp_int(enum macsc_cc_channel channel);
 210:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 211:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 212:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Disables compare interrupts of the MACSC
 213:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 214:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param channel Compare channel
 215:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */void macsc_disable_cmp_int(enum macsc_cc_channel channel);
 216:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 217:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 218:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Usage of Absolute compare mode of the MACSC
 219:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 220:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param abs_rel  0 for absoulte cmp;1 for relative cmp
 221:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param cmp compare value for SCOCRx register
 222:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param channel Compare channel
 223:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 224:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** void macsc_use_cmp(bool abs_rel, uint32_t cmp,enum macsc_cc_channel channel);
 225:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 226:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 227:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \ingroup macsc_group
 228:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \defgroup macsc_interrupt_group MAC Symbol Counter (MACSC) interrupt
 229:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * management
 230:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * This group provides functions to configure MACSC module interrupts
 231:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 232:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * @{
 233:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 234:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 235:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 236:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Set MACSC overflow interrupt callback function
 237:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 238:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * This function allows the caller to set and change the interrupt callback
 239:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * function. Without setting a callback function the interrupt handler in the
 240:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * driver will only clear the interrupt flags.
 241:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 242:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param callback Reference to a callback function
 243:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 244:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** void macsc_set_ovf_int_cb(macsc_callback_t callback);
 245:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 246:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 247:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Set MACSC Compare Channel 1 interrupt callback function
 248:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 249:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * This function allows the caller to set and change the interrupt callback
 250:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * function. Without setting a callback function the interrupt handler in the
 251:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * driver will only clear the interrupt flags.
 252:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 253:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param callback Reference to a callback function
 254:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 255:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** void macsc_set_cmp1_int_cb(macsc_callback_t callback);
 256:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 257:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 258:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Set MACSC Compare Channel 2 interrupt callback function
 259:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 260:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * This function allows the caller to set and change the interrupt callback
 261:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * function. Without setting a callback function the interrupt handler in the
 262:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * driver will only clear the interrupt flags.
 263:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 264:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param callback Reference to a callback function
 265:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 266:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** void macsc_set_cmp2_int_cb(macsc_callback_t callback);
 267:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 268:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 269:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Set MACSC Compare Channel 3 interrupt callback function
 270:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 271:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * This function allows the caller to set and change the interrupt callback
 272:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * function. Without setting a callback function the interrupt handler in the
 273:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * driver will only clear the interrupt flags.
 274:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 275:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param callback Reference to a callback function
 276:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 277:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** void macsc_set_cmp3_int_cb(macsc_callback_t callback);
 278:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 279:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 280:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Set MACSC backoff slot counter interrupt callback function
 281:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 282:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * This function allows the caller to set and change the interrupt callback
 283:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * function. Without setting a callback function the interrupt handler in the
 284:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * driver will only clear the interrupt flags.
 285:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 286:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param callback Reference to a callback function
 287:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 288:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** void macsc_set_backoff_slot_cntr_int_cb(macsc_callback_t callback);
 289:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** //@}
 290:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 291:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 292:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Enable 32.768KHz clk using timer 2 async register
 293:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 294:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param none
 295:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 296:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 297:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** static inline void macsc_sleep_clk_enable(void)
 298:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** {
 299:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	ASSR |= (1 << AS2);
 300:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** }
 301:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 302:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 303:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Disable 32.768KHz clk using timer 2 async register
 304:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 305:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param none
 306:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 307:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** static inline void macsc_sleep_clk_disable(void)
 308:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** {
 309:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	ASSR &= ~(1 << AS2);
 310:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** }
 311:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 312:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /* @} */
 313:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 314:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 315:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Configure MAC Symbol Counter Clock Source
 316:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 317:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param macsc macsc clk src
 318:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 319:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** static inline void macsc_write_clock_source(enum macsc_xtal source)
 320:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** {
 321:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	if (source == MACSC_16MHz) {
 322:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		SCCR0 |= (source << SCCKSEL);
 323:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	} else if (source == MACSC_32KHz) {
 324:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		SCCR0 &= ~(1 << SCCKSEL);
 325:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	}
 326:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** }
 327:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 328:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 329:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Read MAC SC Clock Source
 330:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 331:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param none
 332:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \return macsc_xtal enum Clock source selection
 333:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 334:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** static inline enum macsc_xtal macsc_read_clock_source(void)
 335:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** {
 336:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	return (enum macsc_xtal)(SCCR0 & (1 << SCCKSEL));
 337:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** }
 338:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 339:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 340:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Write the Counter value of the MAC Symbol counter
 341:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 342:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param cnt_value Counter value
 343:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 344:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** static inline void macsc_write_count(uint32_t cnt_value)
 345:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** {
 346:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	MACSC_WRITE32(SCCNT, cnt_value);
 347:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** }
 348:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 349:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 350:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Reads the Counter value of the MAC Symbol counter
 351:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 352:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \note Output the Counter value
 353:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 354:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** static inline uint32_t macsc_read_count(void)
 355:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** {
 356:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	return (MACSC_READ32(SCCNT));
 357:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** }
 358:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 359:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 360:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief enable back-off slot counter
 361:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 362:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param none
 363:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \note  Enables interrupt as well	.
 364:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \note This counter works only if transceiver clock is running.So check Trx
 365:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * state in app before using this function in IEEE802.15.4 applications.
 366:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 367:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** static inline bool macsc_backoff_slot_cnt_enable(void)
 368:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** {
 369:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	if (!(PRR1 & (1 << PRTRX24))) {
 370:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		SCCR1 = (1 << SCENBO);
 371:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		SCIRQS |= (1 << IRQSBO);
 372:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		SCIRQM |= (1 << IRQMBO);
 373:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		return true;
 374:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	}
 375:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	else return false;
 376:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** }
 377:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 378:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 379:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Disable back-off slot counter
 380:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 381:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param none
 382:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \note    Disables interrupt as well	.
 383:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \note This counter works only if transceiver clock is running.So check Trx
 384:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * state in app before using this function in IEEE802.15.4 applications.
 385:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 386:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** static inline void macsc_backoff_slot_cnt_disable(void)
 387:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** {
 388:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	SCCR1 &= ~(1 << SCENBO);
 389:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	SCIRQM &= ~(1 << IRQMBO);
 390:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** }
 391:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 392:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 393:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Tests if the Backoff slot cntr interrupt flag is set
 394:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 395:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \return  backoff slot cntr interrupt has occurred or not : IRQSBO
 396:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 397:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** static inline bool macsc_is_slot_cntr_interrupt_flag_set(void)
 398:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** {
 399:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	return (SCIRQS & (1 << IRQSBO));
 400:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** }
 401:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 402:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 403:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Clears the Backoff Slot cntr interrupt flag
 404:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 405:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \note  IRQSBO is cleared
 406:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 407:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** static inline void macsc_clear_slot_cntr_interrupt_flag(void)
 408:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** {
 409:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	SCIRQS |= (1 << IRQSBO);
 410:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** }
 411:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 412:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 413:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Reads the SFD Timestamp register
 414:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 415:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \return Timestamp of last received frame :SCTSR(read-only register)
 416:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 417:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** static inline uint32_t macsc_read_ts(void)
 418:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** {
 419:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	return (MACSC_READ32(SCTSR));
 420:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** }
 421:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 422:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 423:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Reads the Beacon Timestamp register
 424:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 425:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \return Timestamp of last received beacon frame :SCBTSR
 426:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 427:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** static inline uint32_t macsc_read_bts(void)
 428:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** {
 429:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	return (MACSC_READ32(SCBTSR));
 430:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** }
 431:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 432:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 433:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Write the Beacon Timestamp register of the MAC Symbol counter
 434:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * The manual beacon timestamping can be used in conjunction with the
 435:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * relative compare mode of the three compare units to generate compare match
 436:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * interrupts without having a beacon frame received
 437:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 438:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * If set to 1, the current symbol counter value is stored into the beacon
 439:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * timestamp register.
 440:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * The bit is cleared afterwards.
 441:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 442:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 443:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** static inline void macsc_enable_manual_bts(void)
 444:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** {
 445               		.loc 5 444 0
 446               		.cfi_startproc
 447 019e CF93      		push r28
 448               	.LCFI26:
 449               		.cfi_def_cfa_offset 3
 450               		.cfi_offset 28, -2
 451 01a0 DF93      		push r29
 452               	.LCFI27:
 453               		.cfi_def_cfa_offset 4
 454               		.cfi_offset 29, -3
 455 01a2 CDB7      		in r28,__SP_L__
 456 01a4 DEB7      		in r29,__SP_H__
 457               	.LCFI28:
 458               		.cfi_def_cfa_register 28
 459               	/* prologue: function */
 460               	/* frame size = 0 */
 461               	/* stack size = 2 */
 462               	.L__stack_usage = 2
 445:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	SCCR0 |= (1 << SCMBTS);
 463               		.loc 5 445 0
 464 01a6 8CED      		ldi r24,lo8(-36)
 465 01a8 90E0      		ldi r25,0
 466 01aa 2CED      		ldi r18,lo8(-36)
 467 01ac 30E0      		ldi r19,0
 468 01ae F901      		movw r30,r18
 469 01b0 2081      		ld r18,Z
 470 01b2 2064      		ori r18,lo8(64)
 471 01b4 FC01      		movw r30,r24
 472 01b6 2083      		st Z,r18
 446:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	SCCR0 &= ~(1 << SCTSE);
 473               		.loc 5 446 0
 474 01b8 8CED      		ldi r24,lo8(-36)
 475 01ba 90E0      		ldi r25,0
 476 01bc 2CED      		ldi r18,lo8(-36)
 477 01be 30E0      		ldi r19,0
 478 01c0 F901      		movw r30,r18
 479 01c2 2081      		ld r18,Z
 480 01c4 277F      		andi r18,lo8(-9)
 481 01c6 FC01      		movw r30,r24
 482 01c8 2083      		st Z,r18
 447:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** }
 483               		.loc 5 447 0
 484 01ca 0000      		nop
 485               	/* epilogue start */
 486 01cc DF91      		pop r29
 487 01ce CF91      		pop r28
 488 01d0 0895      		ret
 489               		.cfi_endproc
 490               	.LFE121:
 492               	.global	appState
 493               		.section	.bss.appState,"aw",@nobits
 496               	appState:
 497 0000 00        		.zero	1
 498               		.section	.bss.msgReq,"aw",@nobits
 501               	msgReq:
 502 0000 0000 0000 		.zero	20
 502      0000 0000 
 502      0000 0000 
 502      0000 0000 
 502      0000 0000 
 503               		.section	.bss.PanId,"aw",@nobits
 506               	PanId:
 507 0000 00        		.zero	1
 508               		.section	.rodata
 509               	.LC1:
 510 0000 0A4D 5347 		.string	"\nMSG REQ SENT %d"
 510      2052 4551 
 510      2053 454E 
 510      5420 2564 
 510      00
 511               		.text
 512               	.global	appSendData
 514               	appSendData:
 515               	.LFB130:
 516               		.file 6 "ServerLLDN.c"
   1:ServerLLDN.c  **** /*
   2:ServerLLDN.c  **** 	* ServerLLDN.c
   3:ServerLLDN.c  **** 	*
   4:ServerLLDN.c  **** 	* Created: 10/18/2019 5:15:37 PM
   5:ServerLLDN.c  **** 	*  Author: guilherme
   6:ServerLLDN.c  **** 	*/ 
   7:ServerLLDN.c  **** 
   8:ServerLLDN.c  **** #include <stdlib.h>
   9:ServerLLDN.c  **** #include <stdio.h>
  10:ServerLLDN.c  **** #include <string.h>
  11:ServerLLDN.c  **** #include <inttypes.h>
  12:ServerLLDN.c  **** #include "config.h"
  13:ServerLLDN.c  **** #include "sys.h"
  14:ServerLLDN.c  **** #include "phy.h"
  15:ServerLLDN.c  **** #include "sys.h"
  16:ServerLLDN.c  **** #include "nwk.h"
  17:ServerLLDN.c  **** #include "sysclk.h"
  18:ServerLLDN.c  **** #include "sysTimer.h"
  19:ServerLLDN.c  **** #include "sleep_mgr.h"
  20:ServerLLDN.c  **** #include "sleepmgr.h"
  21:ServerLLDN.c  **** #include "led.h"
  22:ServerLLDN.c  **** #include "ioport.h"
  23:ServerLLDN.c  **** #include "conf_sleepmgr.h"
  24:ServerLLDN.c  **** #include "board.h"
  25:ServerLLDN.c  **** #include "platform.h"
  26:ServerLLDN.c  **** 
  27:ServerLLDN.c  **** #include "lldn.h"
  28:ServerLLDN.c  **** 
  29:ServerLLDN.c  **** #if 1
  30:ServerLLDN.c  **** #if (SIO2HOST_CHANNEL == SIO_USB)
  31:ServerLLDN.c  **** /* Only ARM */
  32:ServerLLDN.c  **** #include "hw_timer_lldn.h"
  33:ServerLLDN.c  **** #include "stdio_usb.h"
  34:ServerLLDN.c  **** #define MASTER_MACSC	0
  35:ServerLLDN.c  **** #else
  36:ServerLLDN.c  **** /* Only megarf series */
  37:ServerLLDN.c  **** #include "conf_sio2host.h"
  38:ServerLLDN.c  **** #define MASTER_MACSC	1
  39:ServerLLDN.c  **** #endif
  40:ServerLLDN.c  **** #else
  41:ServerLLDN.c  **** /* Only megarf series */
  42:ServerLLDN.c  **** #define MASTER_MACSC		1
  43:ServerLLDN.c  **** #endif
  44:ServerLLDN.c  **** 
  45:ServerLLDN.c  **** #define HUMAM_READABLE			1
  46:ServerLLDN.c  **** 
  47:ServerLLDN.c  **** #if (MASTER_MACSC == 1)
  48:ServerLLDN.c  **** #include "macsc_megarf.h"
  49:ServerLLDN.c  **** #define TIMESLOT_TIMER 0
  50:ServerLLDN.c  **** #else
  51:ServerLLDN.c  **** static SYS_Timer_t				tmrBeaconInterval;			// Beacon
  52:ServerLLDN.c  **** static SYS_Timer_t				tmrComputeData;				// Compute data
  53:ServerLLDN.c  **** #endif
  54:ServerLLDN.c  **** 
  55:ServerLLDN.c  **** #define PRINT 1
  56:ServerLLDN.c  **** 
  57:ServerLLDN.c  **** 	
  58:ServerLLDN.c  **** // equation for tTS gives time in seconds, the division by SYMBOL_TIME changes to symbols for count
  59:ServerLLDN.c  **** AppState_t	appState = APP_STATE_INITIAL;
  60:ServerLLDN.c  **** static NWK_DataReq_t msgReq;
  61:ServerLLDN.c  **** static uint8_t PanId;
  62:ServerLLDN.c  **** 
  63:ServerLLDN.c  ****  void appSendData(void)
  64:ServerLLDN.c  **** {
 517               		.loc 6 64 0
 518               		.cfi_startproc
 519 01d2 CF93      		push r28
 520               	.LCFI29:
 521               		.cfi_def_cfa_offset 3
 522               		.cfi_offset 28, -2
 523 01d4 DF93      		push r29
 524               	.LCFI30:
 525               		.cfi_def_cfa_offset 4
 526               		.cfi_offset 29, -3
 527 01d6 CDB7      		in r28,__SP_L__
 528 01d8 DEB7      		in r29,__SP_H__
 529               	.LCFI31:
 530               		.cfi_def_cfa_register 28
 531               	/* prologue: function */
 532               	/* frame size = 0 */
 533               	/* stack size = 2 */
 534               	.L__stack_usage = 2
  65:ServerLLDN.c  **** 	if(msgReq.options != 0)
 535               		.loc 6 65 0
 536 01da 8091 0000 		lds r24,msgReq+9
 537 01de 9091 0000 		lds r25,msgReq+9+1
 538 01e2 892B      		or r24,r25
 539 01e4 01F0      		breq .L17
  66:ServerLLDN.c  **** 	{
  67:ServerLLDN.c  **** 		printf("\nMSG REQ SENT %d",msgReq.options);
 540               		.loc 6 67 0
 541 01e6 8091 0000 		lds r24,msgReq+9
 542 01ea 9091 0000 		lds r25,msgReq+9+1
 543 01ee 292F      		mov r18,r25
 544 01f0 2F93      		push r18
 545 01f2 8F93      		push r24
 546 01f4 80E0      		ldi r24,lo8(.LC1)
 547 01f6 90E0      		ldi r25,hi8(.LC1)
 548 01f8 892F      		mov r24,r25
 549 01fa 8F93      		push r24
 550 01fc 80E0      		ldi r24,lo8(.LC1)
 551 01fe 90E0      		ldi r25,hi8(.LC1)
 552 0200 8F93      		push r24
 553 0202 0E94 0000 		call printf
 554 0206 0F90      		pop __tmp_reg__
 555 0208 0F90      		pop __tmp_reg__
 556 020a 0F90      		pop __tmp_reg__
 557 020c 0F90      		pop __tmp_reg__
  68:ServerLLDN.c  **** 		NWK_DataReq(&msgReq);
 558               		.loc 6 68 0
 559 020e 80E0      		ldi r24,lo8(msgReq)
 560 0210 90E0      		ldi r25,hi8(msgReq)
 561 0212 0E94 0000 		call NWK_DataReq
 562               	.L17:
  69:ServerLLDN.c  **** 	#if !APP_COORDINATOR
  70:ServerLLDN.c  **** 	#endif
  71:ServerLLDN.c  **** 	}
  72:ServerLLDN.c  **** }
 563               		.loc 6 72 0
 564 0216 0000      		nop
 565               	/* epilogue start */
 566 0218 DF91      		pop r29
 567 021a CF91      		pop r28
 568 021c 0895      		ret
 569               		.cfi_endproc
 570               	.LFE130:
 572               	.global	payloadSize
 573               		.section	.data.payloadSize,"aw",@progbits
 576               	payloadSize:
 577 0000 16        		.byte	22
 578               	.global	assTimeSlot
 579               		.section	.data.assTimeSlot,"aw",@progbits
 582               	assTimeSlot:
 583 0000 FF        		.byte	-1
 584               		.comm	rec_beacon,8,1
 585               		.comm	ackframe,2,1
 586               		.section	.data.msgDiscResponse,"aw",@progbits
 589               	msgDiscResponse:
 590 0000 0D        		.byte	13
 591 0001 07        		.byte	7
 592 0002 96        		.byte	150
 593               		.section	.data.msgConfigStatus,"aw",@progbits
 596               	msgConfigStatus:
 597 0000 0E        		.byte	14
 598 0001 07        		.byte	7
 599 0002 FF        		.byte	-1
 600 0003 07        		.byte	7
 601 0004 96        		.byte	150
 602               	.global	data_payload
 603               		.section	.data.data_payload,"aw",@progbits
 606               	data_payload:
 607 0000 07        		.byte	7
 608               		.section	.bss.ack_received,"aw",@nobits
 611               	ack_received:
 612 0000 00        		.zero	1
 613               	.global	MacLLDNMgmtTS
 614               		.section	.bss.MacLLDNMgmtTS,"aw",@nobits
 617               	MacLLDNMgmtTS:
 618 0000 00        		.zero	1
 619               	.global	associated
 620               		.section	.bss.associated,"aw",@nobits
 623               	associated:
 624 0000 00        		.zero	1
 625               		.comm	ts_time,2,1
 626               	.global	STATE
 627               		.section	.data.STATE,"aw",@progbits
 630               	STATE:
 631 0000 0A        		.byte	10
 632               		.section	.rodata
 633               	.LC2:
 634 0011 0A72 7473 		.string	"\nrts tmr"
 634      2074 6D72 
 634      00
 635               		.text
 637               	send_message_timeHandler:
 638               	.LFB131:
  73:ServerLLDN.c  **** 
  74:ServerLLDN.c  **** #if APP_COORDINATOR
  75:ServerLLDN.c  **** 
  76:ServerLLDN.c  **** 	#define NODOS_ASSOCIADOS_ESPERADOS 12
  77:ServerLLDN.c  **** 	
  78:ServerLLDN.c  **** 	AppPanState_t appPanState = APP_PAN_STATE_RESET; // Initial state of PAN node
  79:ServerLLDN.c  **** 	
  80:ServerLLDN.c  **** 	/* Configuration Request Frames */
  81:ServerLLDN.c  **** 	/* Da pra mudar o envio do confrequest pra ja usar essa array com as informas dos nodos */	
  82:ServerLLDN.c  **** 	nodes_info_t nodes_info_arr[50]; // Array for Configure Request messages, one position per node, 2
  83:ServerLLDN.c  **** 	NWK_ConfigRequest_t config_request_frame = { .id = LL_CONFIGURATION_REQUEST,
  84:ServerLLDN.c  **** 												 .s_macAddr = APP_ADDR,
  85:ServerLLDN.c  **** 												 .tx_channel = APP_CHANNEL,
  86:ServerLLDN.c  **** 												 .conf.macLLDNmgmtTS = MacLLDNMgmtTS };
  87:ServerLLDN.c  **** 	nodes_info_list_t *conf_req_list = NULL;
  88:ServerLLDN.c  **** 
  89:ServerLLDN.c  **** 	/* Acknowledge Frame and Array */
  90:ServerLLDN.c  **** 	NWK_ACKFormat_t ACKFrame;	// ACK Frame Payload used in Discovery State
  91:ServerLLDN.c  **** 	int ACKFrame_size = 0;
  92:ServerLLDN.c  **** 
  93:ServerLLDN.c  **** 	float beaconInterval = 0; // no precisa ser global
  94:ServerLLDN.c  **** 	float beaconInterval_association = 0;
  95:ServerLLDN.c  **** 	
  96:ServerLLDN.c  **** 	/* This timer implements a delay between messages, 
  97:ServerLLDN.c  **** 	 * if not used the nodes are not able to receive the message
  98:ServerLLDN.c  **** 	 */
  99:ServerLLDN.c  **** 	static SYS_Timer_t tmrDelay;	
 100:ServerLLDN.c  **** 	
 101:ServerLLDN.c  **** 	/*  Control variables for testing */	
 102:ServerLLDN.c  **** 	int assTimeSlot = 0;
 103:ServerLLDN.c  **** 	uint8_t timeslot_counter = 0;
 104:ServerLLDN.c  **** 
 105:ServerLLDN.c  **** 	int counter_associados = 0;		// Associated nodes counter
 106:ServerLLDN.c  **** 	uint8_t cycles_counter = macLLDNdiscoveryModeTimeout;
 107:ServerLLDN.c  **** 
 108:ServerLLDN.c  **** 	bool association_request = false;
 109:ServerLLDN.c  **** 
 110:ServerLLDN.c  **** 	/* data related variables */
 111:ServerLLDN.c  **** 	msg_info_t msg_info_array[50]; // size of array limited by hardware
 112:ServerLLDN.c  **** 	unsigned int size_msg_info = 0;
 113:ServerLLDN.c  **** 	bool data_received = false;	
 114:ServerLLDN.c  **** 	float succes_rate = 0;
 115:ServerLLDN.c  **** 	
 116:ServerLLDN.c  **** 	uint8_t retransmit_ts_array[32];
 117:ServerLLDN.c  **** 	int retransmit_ts_array_counter = 0;
 118:ServerLLDN.c  **** 	
 119:ServerLLDN.c  **** 	int counter_delay_msg = 0;
 120:ServerLLDN.c  **** 	
 121:ServerLLDN.c  **** 	static void tmrDelayHandler(SYS_Timer_t *timer)
 122:ServerLLDN.c  **** 	{
 123:ServerLLDN.c  **** 		printf("\ndelay handler");
 124:ServerLLDN.c  **** 		appState = APP_STATE_SEND;
 125:ServerLLDN.c  **** 	}
 126:ServerLLDN.c  **** 	
 127:ServerLLDN.c  **** 	static void lldn_server_beacon(void)
 128:ServerLLDN.c  **** 	{
 129:ServerLLDN.c  **** 		macsc_enable_manual_bts();
 130:ServerLLDN.c  **** 		appState = APP_STATE_SEND;
 131:ServerLLDN.c  **** 	}
 132:ServerLLDN.c  **** 	
 133:ServerLLDN.c  **** 	
 134:ServerLLDN.c  **** 	static void time_slot_handler(void)
 135:ServerLLDN.c  **** 	{
 136:ServerLLDN.c  **** 		/*
 137:ServerLLDN.c  **** 		if (timeslot_counter == 1)
 138:ServerLLDN.c  **** 		{
 139:ServerLLDN.c  **** 			macsc_disable_cmp_int(MACSC_CC1);
 140:ServerLLDN.c  **** 			macsc_use_cmp(MACSC_RELATIVE_CMP, tTS / (SYMBOL_TIME), MACSC_CC1);
 141:ServerLLDN.c  **** 			macsc_enable_cmp_int(MACSC_CC1);
 142:ServerLLDN.c  **** 		} 
 143:ServerLLDN.c  **** 		*/
 144:ServerLLDN.c  **** 		// macsc_enable_manual_bts();
 145:ServerLLDN.c  **** 		appState = APP_STATE_ATT_PAN_STATE;
 146:ServerLLDN.c  **** 		appPanState = APP_PAN_STATE_CHECK_TS;
 147:ServerLLDN.c  **** 	}
 148:ServerLLDN.c  **** 	
 149:ServerLLDN.c  **** 	static void downlink_delay_handler(void)
 150:ServerLLDN.c  **** 	{
 151:ServerLLDN.c  **** 		if(msgReq.options == NWK_OPT_MAC_COMMAND)
 152:ServerLLDN.c  **** 		{
 153:ServerLLDN.c  **** 			counter_delay_msg++;
 154:ServerLLDN.c  **** 			appState = APP_STATE_SEND;
 155:ServerLLDN.c  **** 		}
 156:ServerLLDN.c  **** 	}
 157:ServerLLDN.c  **** 
 158:ServerLLDN.c  **** 	static void end_of_association_delay_handler(void)
 159:ServerLLDN.c  **** 	{
 160:ServerLLDN.c  **** 		appState = APP_STATE_ATT_PAN_STATE;
 161:ServerLLDN.c  **** 		appPanState = APP_PAN_STATE_ONLINE_INITIAL;
 162:ServerLLDN.c  **** 	}
 163:ServerLLDN.c  **** 	
 164:ServerLLDN.c  **** 	#if TIMESLOT_TIMER
 165:ServerLLDN.c  **** 	static void teste_handler(void)
 166:ServerLLDN.c  **** 	{
 167:ServerLLDN.c  **** 		if(msgReq.options)
 168:ServerLLDN.c  **** 			printf("\n***TIMESLOT****");
 169:ServerLLDN.c  **** 		macsc_disable_cmp_int(MACSC_CC3);
 170:ServerLLDN.c  **** 	}
 171:ServerLLDN.c  **** 	#endif
 172:ServerLLDN.c  **** 	
 173:ServerLLDN.c  **** 	static bool addToAckArray(uint8_t addres)
 174:ServerLLDN.c  **** 	{	
 175:ServerLLDN.c  **** 		int pos =(int) addres / 8;
 176:ServerLLDN.c  **** 		int bit_shift = 8 - (addres % 8);
 177:ServerLLDN.c  **** 		
 178:ServerLLDN.c  **** // 		if(ACKFrame.ackFlags[pos] & 1 << bit_shift)
 179:ServerLLDN.c  **** // 		{
 180:ServerLLDN.c  **** // 			printf("\nAddr rep %d", addres);
 181:ServerLLDN.c  **** // 			return false;
 182:ServerLLDN.c  **** // 		}
 183:ServerLLDN.c  **** 		ACKFrame.ackFlags[pos] |= 1 << bit_shift;
 184:ServerLLDN.c  **** 		if (pos + 1 > ACKFrame_size)
 185:ServerLLDN.c  **** 			ACKFrame_size = pos + 1;
 186:ServerLLDN.c  **** 		
 187:ServerLLDN.c  **** 		return true;
 188:ServerLLDN.c  **** 	}
 189:ServerLLDN.c  **** 
 190:ServerLLDN.c  **** 	static void addConfRequestArray(NWK_ConfigStatus_t *node)
 191:ServerLLDN.c  **** 	{
 192:ServerLLDN.c  **** 
 193:ServerLLDN.c  **** 		uint8_t i;
 194:ServerLLDN.c  **** 		for (i= 0;i < 256 && nodes_info_arr[i].mac_addr != 0; i++);
 195:ServerLLDN.c  **** 		
 196:ServerLLDN.c  **** 		assTimeSlot++;
 197:ServerLLDN.c  **** 	
 198:ServerLLDN.c  **** 		if(node->ts_dir.tsDuration > config_request_frame.conf.tsDuration)
 199:ServerLLDN.c  **** 			config_request_frame.conf.tsDuration =  node->ts_dir.tsDuration;
 200:ServerLLDN.c  **** 		
 201:ServerLLDN.c  **** 		nodes_info_arr[i].req_timeslot_duration = node->ts_dir.tsDuration;
 202:ServerLLDN.c  **** 		nodes_info_arr[i].mac_addr = node->macAddr;
 203:ServerLLDN.c  **** 		nodes_info_arr[i].assigned_time_slot = (uint8_t)i;
 204:ServerLLDN.c  **** 		
 205:ServerLLDN.c  **** 		if(conf_req_list != NULL)
 206:ServerLLDN.c  **** 		{
 207:ServerLLDN.c  **** 			nodes_info_list_t *tmp = (nodes_info_list_t*)malloc(sizeof(nodes_info_list_t));
 208:ServerLLDN.c  **** 			tmp->node = &nodes_info_arr[i];
 209:ServerLLDN.c  **** 			tmp->next = conf_req_list;
 210:ServerLLDN.c  **** 			conf_req_list = tmp;
 211:ServerLLDN.c  **** 		}
 212:ServerLLDN.c  **** 		else
 213:ServerLLDN.c  **** 		{
 214:ServerLLDN.c  **** 			conf_req_list = (nodes_info_list_t*)malloc(sizeof(nodes_info_list_t));
 215:ServerLLDN.c  **** 			conf_req_list->node = &nodes_info_arr[i];
 216:ServerLLDN.c  **** 			conf_req_list->next = NULL;
 217:ServerLLDN.c  **** 		}
 218:ServerLLDN.c  **** 	}
 219:ServerLLDN.c  **** 
 220:ServerLLDN.c  **** 	static void CopyToConfigRequest()
 221:ServerLLDN.c  **** 	{
 222:ServerLLDN.c  **** 		config_request_frame.assTimeSlot = conf_req_list->node->assigned_time_slot;
 223:ServerLLDN.c  **** 		config_request_frame.macAddr = conf_req_list->node->mac_addr;
 224:ServerLLDN.c  **** 		nodes_info_list_t *tmp = conf_req_list;
 225:ServerLLDN.c  **** 		conf_req_list = conf_req_list->next;
 226:ServerLLDN.c  **** 		tmp->node = NULL;
 227:ServerLLDN.c  **** 		tmp->next = NULL;
 228:ServerLLDN.c  **** 		free(tmp);
 229:ServerLLDN.c  **** 	}
 230:ServerLLDN.c  **** 
 231:ServerLLDN.c  **** 
 232:ServerLLDN.c  **** 	static bool appCommandInd(NWK_DataInd_t *ind)
 233:ServerLLDN.c  **** 	{
 234:ServerLLDN.c  **** 		if(ind->data[0] == LL_DISCOVER_RESPONSE)
 235:ServerLLDN.c  **** 		{
 236:ServerLLDN.c  **** 			NWK_DiscoverResponse_t *msg = (NWK_DiscoverResponse_t*)ind->data;
 237:ServerLLDN.c  **** 			addToAckArray(msg->macAddr);	
 238:ServerLLDN.c  **** 					
 239:ServerLLDN.c  **** 			#if PRINT
 240:ServerLLDN.c  **** 			printf("\nDISC %hhx", msg->macAddr);	
 241:ServerLLDN.c  **** 			#endif
 242:ServerLLDN.c  **** 		}
 243:ServerLLDN.c  **** 		else if(ind->data[0] == LL_CONFIGURATION_STATUS)
 244:ServerLLDN.c  **** 		{
 245:ServerLLDN.c  **** 			NWK_ConfigStatus_t *msg = (NWK_ConfigStatus_t*)ind->data;
 246:ServerLLDN.c  **** 			addConfRequestArray(msg);
 247:ServerLLDN.c  **** 			#if PRINT
 248:ServerLLDN.c  **** 			printf("\nCONF %d", msg->macAddr);	
 249:ServerLLDN.c  **** 			#endif
 250:ServerLLDN.c  **** 		}
 251:ServerLLDN.c  **** 		else return false;			
 252:ServerLLDN.c  **** 		return true;
 253:ServerLLDN.c  **** 	}
 254:ServerLLDN.c  **** 	
 255:ServerLLDN.c  **** 	bool check_ack_pan(int addr)
 256:ServerLLDN.c  **** 	{
 257:ServerLLDN.c  **** 		int pos =  addr / 8;
 258:ServerLLDN.c  **** 		int bit_shift = 8 - addr % 8;
 259:ServerLLDN.c  **** 		
 260:ServerLLDN.c  **** 		if( ACKFrame.ackFlags[pos] & 1 << bit_shift)
 261:ServerLLDN.c  **** 		{
 262:ServerLLDN.c  **** 			return true;
 263:ServerLLDN.c  **** 		}
 264:ServerLLDN.c  **** 		else
 265:ServerLLDN.c  **** 			return false;
 266:ServerLLDN.c  **** 	}
 267:ServerLLDN.c  **** 	
 268:ServerLLDN.c  **** 	static bool appDataInd(NWK_DataInd_t *ind)
 269:ServerLLDN.c  **** 	{
 270:ServerLLDN.c  **** 		if(!data_received && timeslot_counter > 1)
 271:ServerLLDN.c  **** 		{
 272:ServerLLDN.c  **** 			int curr_ts = timeslot_counter - 2*MacLLDNMgmtTS;
 273:ServerLLDN.c  **** 			if(curr_ts > macLLDNRetransmitTS)
 274:ServerLLDN.c  **** 			{
 275:ServerLLDN.c  **** 				
 276:ServerLLDN.c  **** 
 277:ServerLLDN.c  **** 				int retransmition_slot = 0;
 278:ServerLLDN.c  **** 				int i;
 279:ServerLLDN.c  **** 				curr_ts = curr_ts - macLLDNRetransmitTS - 2;
 280:ServerLLDN.c  **** 	
 281:ServerLLDN.c  **** 				if(retransmit_ts_array[curr_ts] > 0)
 282:ServerLLDN.c  **** 				{
 283:ServerLLDN.c  **** 					curr_ts = retransmit_ts_array[curr_ts];
 284:ServerLLDN.c  **** 					
 285:ServerLLDN.c  **** 				}
 286:ServerLLDN.c  **** 	
 287:ServerLLDN.c  **** 				printf("\ncurr %d ack %hhx", curr_ts, ACKFrame.ackFlags[0]);
 288:ServerLLDN.c  **** 
 289:ServerLLDN.c  **** 			
 290:ServerLLDN.c  **** 			}
 291:ServerLLDN.c  **** 			data_received = true;
 292:ServerLLDN.c  **** 		
 293:ServerLLDN.c  **** 			nodes_info_arr[curr_ts].rssi = ind->rssi;
 294:ServerLLDN.c  **** 			nodes_info_arr[curr_ts].average_rssi = (nodes_info_arr[curr_ts].rssi + nodes_info_arr[curr_ts].a
 295:ServerLLDN.c  **** 																/(nodes_info_arr[curr_ts].msg_rec + 1);
 296:ServerLLDN.c  **** 			nodes_info_arr[curr_ts].msg_rec++;
 297:ServerLLDN.c  **** 
 298:ServerLLDN.c  **** 			// printf("\n addrs %hhx, msg_rec %d, curr_ts %d", nodes_info_arr[curr_ts].mac_addr, nodes_info_
 299:ServerLLDN.c  **** 
 300:ServerLLDN.c  **** 			addToAckArray(curr_ts+1);
 301:ServerLLDN.c  **** 		
 302:ServerLLDN.c  **** 			printf("\n %d payload: ", curr_ts);
 303:ServerLLDN.c  **** 		
 304:ServerLLDN.c  **** 			msg_info_array[curr_ts].size = ind->size;		
 305:ServerLLDN.c  **** 			for (int i = 0; i < ind->size; i++)
 306:ServerLLDN.c  **** 				{
 307:ServerLLDN.c  **** 				msg_info_array[curr_ts].data_payload[i] = ind->data[i];
 308:ServerLLDN.c  **** 				printf("%hhx", msg_info_array[curr_ts].data_payload[i]);
 309:ServerLLDN.c  **** 				}
 310:ServerLLDN.c  **** 		}
 311:ServerLLDN.c  **** 	}
 312:ServerLLDN.c  **** 	
 313:ServerLLDN.c  **** 	static void appPanPrepareACK(void)
 314:ServerLLDN.c  **** 	{
 315:ServerLLDN.c  **** 		msgReq.dstAddr		= 0;
 316:ServerLLDN.c  **** 		msgReq.dstEndpoint	= APP_BEACON_ENDPOINT;
 317:ServerLLDN.c  **** 		msgReq.srcEndpoint	= APP_BEACON_ENDPOINT;
 318:ServerLLDN.c  **** 		msgReq.options		= NWK_OPT_LLDN_ACK;
 319:ServerLLDN.c  **** 		msgReq.data	= (uint8_t *)&ACKFrame;
 320:ServerLLDN.c  **** 		msgReq.size	= sizeof(uint8_t)*(ACKFrame_size + 1);
 321:ServerLLDN.c  **** 
 322:ServerLLDN.c  **** 	}
 323:ServerLLDN.c  **** 
 324:ServerLLDN.c  **** 	static void appPanReset(void)
 325:ServerLLDN.c  **** 	{
 326:ServerLLDN.c  **** 		// prepare beacon reset message
 327:ServerLLDN.c  **** 		msgReq.dstAddr		= 0;
 328:ServerLLDN.c  **** 		msgReq.dstEndpoint	= APP_BEACON_ENDPOINT;
 329:ServerLLDN.c  **** 		msgReq.srcEndpoint	= APP_BEACON_ENDPOINT;
 330:ServerLLDN.c  **** 		msgReq.options		= NWK_OPT_LLDN_BEACON | NWK_OPT_RESET_STATE;
 331:ServerLLDN.c  **** 		msgReq.data			= NULL;
 332:ServerLLDN.c  **** 		msgReq.size			= 0;
 333:ServerLLDN.c  **** 
 334:ServerLLDN.c  **** 		for(int i = 0; i < 32; i++)
 335:ServerLLDN.c  **** 			ACKFrame.ackFlags[i] = 0;
 336:ServerLLDN.c  **** 			
 337:ServerLLDN.c  **** 		for (int i = 0; i < 50; i++)
 338:ServerLLDN.c  **** 		{
 339:ServerLLDN.c  **** 			nodes_info_arr[i].mac_addr = 0;
 340:ServerLLDN.c  **** 			nodes_info_arr[i].msg_rec = 0;
 341:ServerLLDN.c  **** 
 342:ServerLLDN.c  **** 			
 343:ServerLLDN.c  **** 			msg_info_array[i].mac_addr = 0;
 344:ServerLLDN.c  **** 			msg_info_array[i].coop_addr = 0;
 345:ServerLLDN.c  **** 			for (int j = 0; j < 50; j++)
 346:ServerLLDN.c  **** 				nodes_info_arr[i].neighbors[j] = 0;
 347:ServerLLDN.c  **** 		}
 348:ServerLLDN.c  **** 		// assTimeSlot = MacLLDNMgmtTS * 2;	
 349:ServerLLDN.c  **** 		ACKFrame_size = 0;
 350:ServerLLDN.c  **** 		counter_associados = 0;
 351:ServerLLDN.c  **** 		macLLDNnumUplinkTS = 0;
 352:ServerLLDN.c  **** 		n = 0;
 353:ServerLLDN.c  **** 	}
 354:ServerLLDN.c  **** 
 355:ServerLLDN.c  **** 	static void appPanDiscInit(void)
 356:ServerLLDN.c  **** 	{	
 357:ServerLLDN.c  **** 		/* clearray of previous discovery state */
 358:ServerLLDN.c  **** 		for(int i = 0; i < 32; i++)
 359:ServerLLDN.c  **** 			ACKFrame.ackFlags[i] = 0;
 360:ServerLLDN.c  **** 		ACKFrame_size = 0;
 361:ServerLLDN.c  **** 		/* Prepare Beacon Message as first beacon in discovery state */		
 362:ServerLLDN.c  **** 		msgReq.dstAddr				= 0;
 363:ServerLLDN.c  **** 		msgReq.dstEndpoint			= APP_BEACON_ENDPOINT;
 364:ServerLLDN.c  **** 		msgReq.srcEndpoint			= APP_BEACON_ENDPOINT;
 365:ServerLLDN.c  **** 		msgReq.options				= NWK_OPT_LLDN_BEACON | NWK_OPT_DISCOVERY_STATE;
 366:ServerLLDN.c  **** 		msgReq.data					= NULL;
 367:ServerLLDN.c  **** 		msgReq.size					= 0;
 368:ServerLLDN.c  **** 		
 369:ServerLLDN.c  **** 		
 370:ServerLLDN.c  **** 		/* Only start timers if it is the first association process */
 371:ServerLLDN.c  **** 		if(cycles_counter == 0) 
 372:ServerLLDN.c  **** 		{
 373:ServerLLDN.c  **** 			
 374:ServerLLDN.c  **** 		/* Calculates Beacon Intervals according to 802.15.4e - 2012 p. 70 */
 375:ServerLLDN.c  **** 		n = 127; 
 376:ServerLLDN.c  **** 		tTS =  ((p_var*sp + (m+n)*sm + macMinLIFSPeriod)/v_var);
 377:ServerLLDN.c  **** 		#if (MASTER_MACSC == 1)
 378:ServerLLDN.c  **** 		
 379:ServerLLDN.c  **** 			beaconInterval_association = 2 * numBaseTimeSlotperMgmt_association * (tTS) / (SYMBOL_TIME);
 380:ServerLLDN.c  **** 			/*
 381:ServerLLDN.c  **** 			* Configure interrupts callback functions
 382:ServerLLDN.c  **** 			* overflow interrupt, compare 1,2,3 interrupts
 383:ServerLLDN.c  **** 			*/
 384:ServerLLDN.c  **** 			macsc_set_cmp1_int_cb(lldn_server_beacon);
 385:ServerLLDN.c  **** 			/*
 386:ServerLLDN.c  **** 			* Configure MACSC to generate compare interrupts from channels 1,2,3
 387:ServerLLDN.c  **** 			* Set compare mode to absolute, set compare value.
 388:ServerLLDN.c  **** 			*/
 389:ServerLLDN.c  **** 			macsc_enable_manual_bts();
 390:ServerLLDN.c  **** 			macsc_enable_cmp_int(MACSC_CC1);
 391:ServerLLDN.c  **** 
 392:ServerLLDN.c  **** 			macsc_use_cmp(MACSC_RELATIVE_CMP, beaconInterval_association , MACSC_CC1);
 393:ServerLLDN.c  **** 			
 394:ServerLLDN.c  **** 			/* Timer used in testing */
 395:ServerLLDN.c  **** 			#if TIMESLOT_TIMER
 396:ServerLLDN.c  **** 			macsc_set_cmp2_int_cb(teste_handler);	
 397:ServerLLDN.c  **** 			macsc_enable_cmp_int(MACSC_CC2);
 398:ServerLLDN.c  **** 			macsc_use_cmp(MACSC_RELATIVE_CMP, beaconInterval_association / 2, MACSC_CC2);
 399:ServerLLDN.c  **** 			#endif
 400:ServerLLDN.c  **** 			
 401:ServerLLDN.c  **** 		#endif
 402:ServerLLDN.c  **** 		}
 403:ServerLLDN.c  **** 	}
 404:ServerLLDN.c  **** 
 405:ServerLLDN.c  **** 	static void appPanOnlineInit()
 406:ServerLLDN.c  **** 	{
 407:ServerLLDN.c  **** 			timeslot_counter = 0;
 408:ServerLLDN.c  **** 			
 409:ServerLLDN.c  **** 			macLLDNnumUplinkTS = (assTimeSlot) * 2 + 1;
 410:ServerLLDN.c  **** 			macLLDNRetransmitTS = assTimeSlot;
 411:ServerLLDN.c  **** 			macLLDNnumTimeSlots = macLLDNnumUplinkTS + 2 *MacLLDNMgmtTS;			
 412:ServerLLDN.c  **** 			
 413:ServerLLDN.c  **** 			// printf("\nmacLLDNnumUplinkTS : %d\nmacLLDNRetransmitTS : %d\nmacLLDNnumTimeSlots : %d",macLLD
 414:ServerLLDN.c  **** 			
 415:ServerLLDN.c  **** 			
 416:ServerLLDN.c  **** 			tTS =  ((p_var*sp + (m+ config_request_frame.conf.tsDuration )*sm + macMinLIFSPeriod)/v_var);
 417:ServerLLDN.c  **** 			
 418:ServerLLDN.c  **** 			n = config_request_frame.conf.tsDuration;
 419:ServerLLDN.c  **** 			
 420:ServerLLDN.c  **** 			msgReq.dstAddr		= 0;
 421:ServerLLDN.c  **** 			msgReq.dstEndpoint	= APP_BEACON_ENDPOINT;
 422:ServerLLDN.c  **** 			msgReq.srcEndpoint	= APP_BEACON_ENDPOINT;
 423:ServerLLDN.c  **** 			msgReq.options		= NWK_OPT_LLDN_BEACON | NWK_OPT_ONLINE_STATE;
 424:ServerLLDN.c  **** 			
 425:ServerLLDN.c  **** 			if(macLLDNRetransmitTS > 0)
 426:ServerLLDN.c  **** 			{
 427:ServerLLDN.c  **** 				// precisa repensar isto
 428:ServerLLDN.c  **** 				msgReq.data		= &ACKFrame.ackFlags[macLLDNRetransmitTS + 1];
 429:ServerLLDN.c  **** 				msgReq.size		= macLLDNRetransmitTS;
 430:ServerLLDN.c  **** 			}
 431:ServerLLDN.c  **** 			else
 432:ServerLLDN.c  **** 			{
 433:ServerLLDN.c  **** 				msgReq.data					= NULL;
 434:ServerLLDN.c  **** 				msgReq.size					= 0;	
 435:ServerLLDN.c  **** 			}
 436:ServerLLDN.c  **** 			
 437:ServerLLDN.c  **** 			// (number of time slots x mgmt time solts) x base timelosts
 438:ServerLLDN.c  **** 			beaconInterval = (assTimeSlot * 2 + 1 + 2*MacLLDNMgmtTS) * tTS / (SYMBOL_TIME);
 439:ServerLLDN.c  **** 			
 440:ServerLLDN.c  **** 			// Configure Timers
 441:ServerLLDN.c  **** 			macsc_set_cmp1_int_cb(time_slot_handler);
 442:ServerLLDN.c  **** 			
 443:ServerLLDN.c  **** 			macsc_enable_manual_bts();
 444:ServerLLDN.c  **** 			
 445:ServerLLDN.c  **** 			macsc_enable_cmp_int(MACSC_CC1);
 446:ServerLLDN.c  **** 			macsc_use_cmp(MACSC_RELATIVE_CMP, numBaseTimeSlotperMgmt_online * tTS / (SYMBOL_TIME), MACSC_CC1
 447:ServerLLDN.c  **** 			
 448:ServerLLDN.c  **** 			NWK_OpenEndpoint(APP_DATA_ENDPOINT, appDataInd);
 449:ServerLLDN.c  **** 	}
 450:ServerLLDN.c  **** 
 451:ServerLLDN.c  **** #else 
 452:ServerLLDN.c  **** 	uint8_t payloadSize = 22;
 453:ServerLLDN.c  **** 	uint8_t assTimeSlot = 0xFF;
 454:ServerLLDN.c  **** 	uint8_t n = 0;
 455:ServerLLDN.c  **** 	
 456:ServerLLDN.c  **** 	NwkFrameBeaconHeaderLLDN_t rec_beacon;
 457:ServerLLDN.c  **** 	NWK_ACKFormat_t *ackframe;
 458:ServerLLDN.c  **** 	static NWK_DiscoverResponse_t msgDiscResponse = { .id = LL_DISCOVER_RESPONSE,
 459:ServerLLDN.c  **** 													 .macAddr = APP_ADDR,
 460:ServerLLDN.c  **** 													 .ts_dir.tsDuration = 22,
 461:ServerLLDN.c  **** 													 .ts_dir.dirIndicator = 0b1 };
 462:ServerLLDN.c  **** 	static NWK_ConfigStatus_t msgConfigStatus = { .id = LL_CONFIGURATION_STATUS,
 463:ServerLLDN.c  **** 												 .macAddr = APP_ADDR,
 464:ServerLLDN.c  **** 												 .s_macAddr = APP_ADDR,
 465:ServerLLDN.c  **** 												 .ts_dir.tsDuration = 22,
 466:ServerLLDN.c  **** 												 .ts_dir.dirIndicator = 1,
 467:ServerLLDN.c  **** 												 .assTimeSlot = 0xff };
 468:ServerLLDN.c  **** 	uint8_t data_payload = APP_ADDR;
 469:ServerLLDN.c  **** 	static bool ack_received;
 470:ServerLLDN.c  **** 	bool MacLLDNMgmtTS = 0; 
 471:ServerLLDN.c  **** 	bool associated = 0;
 472:ServerLLDN.c  **** 	int ts_time;
 473:ServerLLDN.c  **** 	uint8_t STATE = 10;
 474:ServerLLDN.c  **** 	
 475:ServerLLDN.c  **** 	static void send_message_timeHandler(void)
 476:ServerLLDN.c  **** 	{
 639               		.loc 6 476 0
 640               		.cfi_startproc
 641 021e CF93      		push r28
 642               	.LCFI32:
 643               		.cfi_def_cfa_offset 3
 644               		.cfi_offset 28, -2
 645 0220 DF93      		push r29
 646               	.LCFI33:
 647               		.cfi_def_cfa_offset 4
 648               		.cfi_offset 29, -3
 649 0222 CDB7      		in r28,__SP_L__
 650 0224 DEB7      		in r29,__SP_H__
 651               	.LCFI34:
 652               		.cfi_def_cfa_register 28
 653               	/* prologue: function */
 654               	/* frame size = 0 */
 655               	/* stack size = 2 */
 656               	.L__stack_usage = 2
 477:ServerLLDN.c  **** 		printf("\nrts tmr");
 657               		.loc 6 477 0
 658 0226 80E0      		ldi r24,lo8(.LC2)
 659 0228 90E0      		ldi r25,hi8(.LC2)
 660 022a 892F      		mov r24,r25
 661 022c 8F93      		push r24
 662 022e 80E0      		ldi r24,lo8(.LC2)
 663 0230 90E0      		ldi r25,hi8(.LC2)
 664 0232 8F93      		push r24
 665 0234 0E94 0000 		call printf
 666 0238 0F90      		pop __tmp_reg__
 667 023a 0F90      		pop __tmp_reg__
 478:ServerLLDN.c  **** 		appSendData();
 668               		.loc 6 478 0
 669 023c 0E94 0000 		call appSendData
 479:ServerLLDN.c  **** 		#if MASTER_MACSC == 0
 480:ServerLLDN.c  **** 			timer_stop();
 481:ServerLLDN.c  **** 		#else 
 482:ServerLLDN.c  **** 		macsc_disable_cmp_int(MACSC_CC1);
 670               		.loc 6 482 0
 671 0240 81E0      		ldi r24,lo8(1)
 672 0242 0E94 0000 		call macsc_disable_cmp_int
 483:ServerLLDN.c  **** 		macsc_set_cmp1_int_cb(NULL);
 673               		.loc 6 483 0
 674 0246 80E0      		ldi r24,0
 675 0248 90E0      		ldi r25,0
 676 024a 0E94 0000 		call macsc_set_cmp1_int_cb
 484:ServerLLDN.c  **** 		#endif
 485:ServerLLDN.c  **** 	
 486:ServerLLDN.c  **** 	}
 677               		.loc 6 486 0
 678 024e 0000      		nop
 679               	/* epilogue start */
 680 0250 DF91      		pop r29
 681 0252 CF91      		pop r28
 682 0254 0895      		ret
 683               		.cfi_endproc
 684               	.LFE131:
 687               	start_timer:
 688               	.LFB132:
 487:ServerLLDN.c  **** 
 488:ServerLLDN.c  **** 	static void start_timer(uint8_t delay)
 489:ServerLLDN.c  **** 	{
 689               		.loc 6 489 0
 690               		.cfi_startproc
 691 0256 CF93      		push r28
 692               	.LCFI35:
 693               		.cfi_def_cfa_offset 3
 694               		.cfi_offset 28, -2
 695 0258 DF93      		push r29
 696               	.LCFI36:
 697               		.cfi_def_cfa_offset 4
 698               		.cfi_offset 29, -3
 699 025a 1F92      		push __zero_reg__
 700               	.LCFI37:
 701               		.cfi_def_cfa_offset 5
 702 025c CDB7      		in r28,__SP_L__
 703 025e DEB7      		in r29,__SP_H__
 704               	.LCFI38:
 705               		.cfi_def_cfa_register 28
 706               	/* prologue: function */
 707               	/* frame size = 1 */
 708               	/* stack size = 3 */
 709               	.L__stack_usage = 3
 710 0260 8983      		std Y+1,r24
 490:ServerLLDN.c  **** 		#if MASTER_MACSC
 491:ServerLLDN.c  **** 		macsc_enable_manual_bts();
 711               		.loc 6 491 0
 712 0262 0E94 0000 		call macsc_enable_manual_bts
 492:ServerLLDN.c  **** 		macsc_set_cmp1_int_cb(send_message_timeHandler);
 713               		.loc 6 492 0
 714 0266 80E0      		ldi r24,lo8(gs(send_message_timeHandler))
 715 0268 90E0      		ldi r25,hi8(gs(send_message_timeHandler))
 716 026a 0E94 0000 		call macsc_set_cmp1_int_cb
 493:ServerLLDN.c  **** 		macsc_enable_cmp_int(MACSC_CC1);
 717               		.loc 6 493 0
 718 026e 81E0      		ldi r24,lo8(1)
 719 0270 0E94 0000 		call macsc_enable_cmp_int
 494:ServerLLDN.c  **** 		macsc_use_cmp(MACSC_RELATIVE_CMP, delay - (uint8_t)125, MACSC_CC1);
 720               		.loc 6 494 0
 721 0274 8981      		ldd r24,Y+1
 722 0276 882F      		mov r24,r24
 723 0278 90E0      		ldi r25,0
 724 027a 8D57      		subi r24,125
 725 027c 9109      		sbc r25,__zero_reg__
 726 027e 092E      		mov __tmp_reg__,r25
 727 0280 000C      		lsl r0
 728 0282 AA0B      		sbc r26,r26
 729 0284 BB0B      		sbc r27,r27
 730 0286 21E0      		ldi r18,lo8(1)
 731 0288 AC01      		movw r20,r24
 732 028a BD01      		movw r22,r26
 733 028c 81E0      		ldi r24,lo8(1)
 734 028e 0E94 0000 		call macsc_use_cmp
 495:ServerLLDN.c  **** 		#else
 496:ServerLLDN.c  **** 		timer_init();
 497:ServerLLDN.c  **** 		timer_delay(delay/2);
 498:ServerLLDN.c  **** 		hw_timer_setup_handler(send_message_timeHandler);
 499:ServerLLDN.c  **** 		timer_start();
 500:ServerLLDN.c  **** 		#endif
 501:ServerLLDN.c  **** 	}
 735               		.loc 6 501 0
 736 0292 0000      		nop
 737               	/* epilogue start */
 738 0294 0F90      		pop __tmp_reg__
 739 0296 DF91      		pop r29
 740 0298 CF91      		pop r28
 741 029a 0895      		ret
 742               		.cfi_endproc
 743               	.LFE132:
 745               	.global	__floatsisf
 746               	.global	__addsf3
 747               	.global	__divsf3
 748               	.global	__fixsfsi
 749               		.section	.rodata
 750               	.LC3:
 751 001a 0A6E 756D 		.string	"\nnumBaseMgmtTimeslots %hhx %hhx "
 751      4261 7365 
 751      4D67 6D74 
 751      5469 6D65 
 751      736C 6F74 
 752               	.LC4:
 753 003b 0A20 5265 		.string	"\n Reset beacon"
 753      7365 7420 
 753      6265 6163 
 753      6F6E 00
 754               		.text
 756               	appBeaconInd:
 757               	.LFB133:
 502:ServerLLDN.c  **** 	
 503:ServerLLDN.c  **** 	static bool appBeaconInd(NWK_DataInd_t *ind)
 504:ServerLLDN.c  **** 	{
 758               		.loc 6 504 0
 759               		.cfi_startproc
 760 029c CF93      		push r28
 761               	.LCFI39:
 762               		.cfi_def_cfa_offset 3
 763               		.cfi_offset 28, -2
 764 029e DF93      		push r29
 765               	.LCFI40:
 766               		.cfi_def_cfa_offset 4
 767               		.cfi_offset 29, -3
 768 02a0 CDB7      		in r28,__SP_L__
 769 02a2 DEB7      		in r29,__SP_H__
 770               	.LCFI41:
 771               		.cfi_def_cfa_register 28
 772 02a4 2797      		sbiw r28,7
 773               	.LCFI42:
 774               		.cfi_def_cfa_offset 11
 775 02a6 0FB6      		in __tmp_reg__,__SREG__
 776 02a8 F894      		cli
 777 02aa DEBF      		out __SP_H__,r29
 778 02ac 0FBE      		out __SREG__,__tmp_reg__
 779 02ae CDBF      		out __SP_L__,r28
 780               	/* prologue: function */
 781               	/* frame size = 7 */
 782               	/* stack size = 9 */
 783               	.L__stack_usage = 9
 784 02b0 9F83      		std Y+7,r25
 785 02b2 8E83      		std Y+6,r24
 505:ServerLLDN.c  **** 		NwkFrameBeaconHeaderLLDN_t *tmp_beacon = (NwkFrameBeaconHeaderLLDN_t*)ind->data;
 786               		.loc 6 505 0
 787 02b4 8E81      		ldd r24,Y+6
 788 02b6 9F81      		ldd r25,Y+7
 789 02b8 FC01      		movw r30,r24
 790 02ba 8085      		ldd r24,Z+8
 791 02bc 9185      		ldd r25,Z+9
 792 02be 9A83      		std Y+2,r25
 793 02c0 8983      		std Y+1,r24
 506:ServerLLDN.c  **** 		rec_beacon = *tmp_beacon;
 794               		.loc 6 506 0
 795 02c2 8981      		ldd r24,Y+1
 796 02c4 9A81      		ldd r25,Y+2
 797 02c6 28E0      		ldi r18,lo8(8)
 798 02c8 FC01      		movw r30,r24
 799 02ca A0E0      		ldi r26,lo8(rec_beacon)
 800 02cc B0E0      		ldi r27,hi8(rec_beacon)
 801               		0:
 802 02ce 0190      		ld r0,Z+
 803 02d0 0D92      		st X+,r0
 804 02d2 2A95      		dec r18
 805 02d4 01F4      		brne 0b
 507:ServerLLDN.c  **** 		tmp_beacon->Flags.numBaseMgmtTimeslots = tmp_beacon->Flags.numBaseMgmtTimeslots;
 806               		.loc 6 507 0
 807 02d6 8981      		ldd r24,Y+1
 808 02d8 9A81      		ldd r25,Y+2
 809 02da FC01      		movw r30,r24
 810 02dc 8381      		ldd r24,Z+3
 811 02de 282F      		mov r18,r24
 812 02e0 2295      		swap r18
 813 02e2 2695      		lsr r18
 814 02e4 2770      		andi r18,lo8(7)
 815 02e6 8981      		ldd r24,Y+1
 816 02e8 9A81      		ldd r25,Y+2
 817 02ea 2295      		swap r18
 818 02ec 220F      		lsl r18
 819 02ee 207E      		andi r18,lo8(-32)
 820 02f0 FC01      		movw r30,r24
 821 02f2 3381      		ldd r19,Z+3
 822 02f4 3F71      		andi r19,lo8(31)
 823 02f6 232B      		or r18,r19
 824 02f8 FC01      		movw r30,r24
 825 02fa 2383      		std Z+3,r18
 508:ServerLLDN.c  **** 		STATE = tmp_beacon->Flags.txState;
 826               		.loc 6 508 0
 827 02fc 8981      		ldd r24,Y+1
 828 02fe 9A81      		ldd r25,Y+2
 829 0300 FC01      		movw r30,r24
 830 0302 8381      		ldd r24,Z+3
 831 0304 8770      		andi r24,lo8(7)
 832 0306 8093 0000 		sts STATE,r24
 509:ServerLLDN.c  **** 		PanId = tmp_beacon->PanId;
 833               		.loc 6 509 0
 834 030a 8981      		ldd r24,Y+1
 835 030c 9A81      		ldd r25,Y+2
 836 030e FC01      		movw r30,r24
 837 0310 8481      		ldd r24,Z+4
 838 0312 8093 0000 		sts PanId,r24
 510:ServerLLDN.c  **** 		//  bom implementar rotinas pra se o nodo estiver associado a um coordeandor e se no estiver
 511:ServerLLDN.c  **** 		if( ((tmp_beacon->Flags.txState == DISC_MODE && !ack_received && tmp_beacon->confSeqNumber == 0x0
 839               		.loc 6 511 0
 840 0316 8981      		ldd r24,Y+1
 841 0318 9A81      		ldd r25,Y+2
 842 031a FC01      		movw r30,r24
 843 031c 8381      		ldd r24,Z+3
 844 031e 8770      		andi r24,lo8(7)
 845 0320 8430      		cpi r24,lo8(4)
 846 0322 01F4      		brne .L21
 847               		.loc 6 511 0 is_stmt 0 discriminator 1
 848 0324 9091 0000 		lds r25,ack_received
 849 0328 81E0      		ldi r24,lo8(1)
 850 032a 8927      		eor r24,r25
 851 032c 8823      		tst r24
 852 032e 01F0      		breq .L21
 853               		.loc 6 511 0 discriminator 3
 854 0330 8981      		ldd r24,Y+1
 855 0332 9A81      		ldd r25,Y+2
 856 0334 FC01      		movw r30,r24
 857 0336 8581      		ldd r24,Z+5
 858 0338 8823      		tst r24
 859 033a 01F0      		breq .L22
 860               	.L21:
 512:ServerLLDN.c  **** 			(tmp_beacon->Flags.txState == CONFIG_MODE && ack_received)) && associated == 0)
 861               		.loc 6 512 0 is_stmt 1 discriminator 5
 862 033c 8981      		ldd r24,Y+1
 863 033e 9A81      		ldd r25,Y+2
 864 0340 FC01      		movw r30,r24
 865 0342 8381      		ldd r24,Z+3
 866 0344 8770      		andi r24,lo8(7)
 511:ServerLLDN.c  **** 			(tmp_beacon->Flags.txState == CONFIG_MODE && ack_received)) && associated == 0)
 867               		.loc 6 511 0 discriminator 5
 868 0346 8630      		cpi r24,lo8(6)
 869 0348 01F0      		breq .+2
 870 034a 00C0      		rjmp .L23
 871               		.loc 6 512 0
 872 034c 8091 0000 		lds r24,ack_received
 873 0350 8823      		tst r24
 874 0352 01F4      		brne .+2
 875 0354 00C0      		rjmp .L23
 876               	.L22:
 877               		.loc 6 512 0 is_stmt 0 discriminator 1
 878 0356 9091 0000 		lds r25,associated
 879 035a 81E0      		ldi r24,lo8(1)
 880 035c 8927      		eor r24,r25
 881 035e 8823      		tst r24
 882 0360 01F4      		brne .+2
 883 0362 00C0      		rjmp .L23
 884               	.LBB2:
 513:ServerLLDN.c  **** 		{
 514:ServerLLDN.c  **** 	
 515:ServerLLDN.c  **** 			ts_time =  ((p_var*sp + (m+ tmp_beacon->TimeSlotSize  )*sm + macMinLIFSPeriod)/v_var)  / (SYMBOL
 885               		.loc 6 515 0 is_stmt 1
 886 0364 8981      		ldd r24,Y+1
 887 0366 9A81      		ldd r25,Y+2
 888 0368 FC01      		movw r30,r24
 889 036a 8681      		ldd r24,Z+6
 890 036c 882F      		mov r24,r24
 891 036e 90E0      		ldi r25,0
 892 0370 0396      		adiw r24,3
 893 0372 880F      		lsl r24
 894 0374 991F      		rol r25
 895 0376 092E      		mov __tmp_reg__,r25
 896 0378 000C      		lsl r0
 897 037a AA0B      		sbc r26,r26
 898 037c BB0B      		sbc r27,r27
 899 037e BC01      		movw r22,r24
 900 0380 CD01      		movw r24,r26
 901 0382 0E94 0000 		call __floatsisf
 902 0386 DC01      		movw r26,r24
 903 0388 CB01      		movw r24,r22
 904 038a 20E0      		ldi r18,0
 905 038c 30E0      		ldi r19,0
 906 038e 40E4      		ldi r20,lo8(64)
 907 0390 51E4      		ldi r21,lo8(65)
 908 0392 BC01      		movw r22,r24
 909 0394 CD01      		movw r24,r26
 910 0396 0E94 0000 		call __addsf3
 911 039a DC01      		movw r26,r24
 912 039c CB01      		movw r24,r22
 913 039e 20E0      		ldi r18,0
 914 03a0 30E0      		ldi r19,0
 915 03a2 40E2      		ldi r20,lo8(32)
 916 03a4 52E4      		ldi r21,lo8(66)
 917 03a6 BC01      		movw r22,r24
 918 03a8 CD01      		movw r24,r26
 919 03aa 0E94 0000 		call __addsf3
 920 03ae DC01      		movw r26,r24
 921 03b0 CB01      		movw r24,r22
 922 03b2 20E0      		ldi r18,0
 923 03b4 34E2      		ldi r19,lo8(36)
 924 03b6 44E7      		ldi r20,lo8(116)
 925 03b8 57E4      		ldi r21,lo8(71)
 926 03ba BC01      		movw r22,r24
 927 03bc CD01      		movw r24,r26
 928 03be 0E94 0000 		call __divsf3
 929 03c2 DC01      		movw r26,r24
 930 03c4 CB01      		movw r24,r22
 931 03c6 2DEB      		ldi r18,lo8(-67)
 932 03c8 37E3      		ldi r19,lo8(55)
 933 03ca 46E8      		ldi r20,lo8(-122)
 934 03cc 57E3      		ldi r21,lo8(55)
 935 03ce BC01      		movw r22,r24
 936 03d0 CD01      		movw r24,r26
 937 03d2 0E94 0000 		call __divsf3
 938 03d6 DC01      		movw r26,r24
 939 03d8 CB01      		movw r24,r22
 940 03da BC01      		movw r22,r24
 941 03dc CD01      		movw r24,r26
 942 03de 0E94 0000 		call __fixsfsi
 943 03e2 DC01      		movw r26,r24
 944 03e4 CB01      		movw r24,r22
 945 03e6 9093 0000 		sts ts_time+1,r25
 946 03ea 8093 0000 		sts ts_time,r24
 516:ServerLLDN.c  **** 			int msg_wait_time = tmp_beacon->Flags.numBaseMgmtTimeslots * tmp_beacon->TimeSlotSize * 2; 
 947               		.loc 6 516 0
 948 03ee 8981      		ldd r24,Y+1
 949 03f0 9A81      		ldd r25,Y+2
 950 03f2 FC01      		movw r30,r24
 951 03f4 8381      		ldd r24,Z+3
 952 03f6 8295      		swap r24
 953 03f8 8695      		lsr r24
 954 03fa 8770      		andi r24,lo8(7)
 955 03fc 482F      		mov r20,r24
 956 03fe 50E0      		ldi r21,0
 957 0400 8981      		ldd r24,Y+1
 958 0402 9A81      		ldd r25,Y+2
 959 0404 FC01      		movw r30,r24
 960 0406 8681      		ldd r24,Z+6
 961 0408 282F      		mov r18,r24
 962 040a 30E0      		ldi r19,0
 963 040c 429F      		mul r20,r18
 964 040e C001      		movw r24,r0
 965 0410 439F      		mul r20,r19
 966 0412 900D      		add r25,r0
 967 0414 529F      		mul r21,r18
 968 0416 900D      		add r25,r0
 969 0418 1124      		clr r1
 970 041a 880F      		lsl r24
 971 041c 991F      		rol r25
 972 041e 9C83      		std Y+4,r25
 973 0420 8B83      		std Y+3,r24
 517:ServerLLDN.c  **** 			
 518:ServerLLDN.c  **** 			start_timer(msg_wait_time);
 974               		.loc 6 518 0
 975 0422 8B81      		ldd r24,Y+3
 976 0424 0E94 0000 		call start_timer
 519:ServerLLDN.c  **** 			
 520:ServerLLDN.c  **** 			appState = (tmp_beacon->Flags.txState == DISC_MODE) ? APP_STATE_PREP_DISC_REPONSE : APP_STATE_PR
 977               		.loc 6 520 0
 978 0428 8981      		ldd r24,Y+1
 979 042a 9A81      		ldd r25,Y+2
 980 042c FC01      		movw r30,r24
 981 042e 8381      		ldd r24,Z+3
 982 0430 8770      		andi r24,lo8(7)
 983 0432 8430      		cpi r24,lo8(4)
 984 0434 01F4      		brne .L24
 985               		.loc 6 520 0 is_stmt 0 discriminator 1
 986 0436 84E0      		ldi r24,lo8(4)
 987 0438 00C0      		rjmp .L25
 988               	.L24:
 989               		.loc 6 520 0 discriminator 2
 990 043a 85E0      		ldi r24,lo8(5)
 991               	.L25:
 992               		.loc 6 520 0 discriminator 4
 993 043c 8093 0000 		sts appState,r24
 994               	.LBE2:
 513:ServerLLDN.c  **** 	
 995               		.loc 6 513 0 is_stmt 1 discriminator 4
 996 0440 00C0      		rjmp .L26
 997               	.L23:
 521:ServerLLDN.c  **** 		}
 522:ServerLLDN.c  **** 		else if (tmp_beacon->Flags.txState == ONLINE_MODE && assTimeSlot != 0xFF && associated == 1)
 998               		.loc 6 522 0
 999 0442 8981      		ldd r24,Y+1
 1000 0444 9A81      		ldd r25,Y+2
 1001 0446 FC01      		movw r30,r24
 1002 0448 8381      		ldd r24,Z+3
 1003 044a 8770      		andi r24,lo8(7)
 1004 044c 8823      		tst r24
 1005 044e 01F0      		breq .+2
 1006 0450 00C0      		rjmp .L27
 1007               		.loc 6 522 0 is_stmt 0 discriminator 1
 1008 0452 8091 0000 		lds r24,assTimeSlot
 1009 0456 8F3F      		cpi r24,lo8(-1)
 1010 0458 01F4      		brne .+2
 1011 045a 00C0      		rjmp .L27
 1012               		.loc 6 522 0 discriminator 2
 1013 045c 8091 0000 		lds r24,associated
 1014 0460 8823      		tst r24
 1015 0462 01F4      		brne .+2
 1016 0464 00C0      		rjmp .L27
 1017               	.LBB3:
 523:ServerLLDN.c  **** 		{
 524:ServerLLDN.c  **** 			ts_time = ((p_var*sp + (m+ n)*sm + macMinLIFSPeriod)/v_var)  / (SYMBOL_TIME);
 1018               		.loc 6 524 0 is_stmt 1
 1019 0466 8091 0000 		lds r24,n
 1020 046a 882F      		mov r24,r24
 1021 046c 90E0      		ldi r25,0
 1022 046e 0396      		adiw r24,3
 1023 0470 880F      		lsl r24
 1024 0472 991F      		rol r25
 1025 0474 092E      		mov __tmp_reg__,r25
 1026 0476 000C      		lsl r0
 1027 0478 AA0B      		sbc r26,r26
 1028 047a BB0B      		sbc r27,r27
 1029 047c BC01      		movw r22,r24
 1030 047e CD01      		movw r24,r26
 1031 0480 0E94 0000 		call __floatsisf
 1032 0484 DC01      		movw r26,r24
 1033 0486 CB01      		movw r24,r22
 1034 0488 20E0      		ldi r18,0
 1035 048a 30E0      		ldi r19,0
 1036 048c 40E4      		ldi r20,lo8(64)
 1037 048e 51E4      		ldi r21,lo8(65)
 1038 0490 BC01      		movw r22,r24
 1039 0492 CD01      		movw r24,r26
 1040 0494 0E94 0000 		call __addsf3
 1041 0498 DC01      		movw r26,r24
 1042 049a CB01      		movw r24,r22
 1043 049c 20E0      		ldi r18,0
 1044 049e 30E0      		ldi r19,0
 1045 04a0 40E2      		ldi r20,lo8(32)
 1046 04a2 52E4      		ldi r21,lo8(66)
 1047 04a4 BC01      		movw r22,r24
 1048 04a6 CD01      		movw r24,r26
 1049 04a8 0E94 0000 		call __addsf3
 1050 04ac DC01      		movw r26,r24
 1051 04ae CB01      		movw r24,r22
 1052 04b0 20E0      		ldi r18,0
 1053 04b2 34E2      		ldi r19,lo8(36)
 1054 04b4 44E7      		ldi r20,lo8(116)
 1055 04b6 57E4      		ldi r21,lo8(71)
 1056 04b8 BC01      		movw r22,r24
 1057 04ba CD01      		movw r24,r26
 1058 04bc 0E94 0000 		call __divsf3
 1059 04c0 DC01      		movw r26,r24
 1060 04c2 CB01      		movw r24,r22
 1061 04c4 2DEB      		ldi r18,lo8(-67)
 1062 04c6 37E3      		ldi r19,lo8(55)
 1063 04c8 46E8      		ldi r20,lo8(-122)
 1064 04ca 57E3      		ldi r21,lo8(55)
 1065 04cc BC01      		movw r22,r24
 1066 04ce CD01      		movw r24,r26
 1067 04d0 0E94 0000 		call __divsf3
 1068 04d4 DC01      		movw r26,r24
 1069 04d6 CB01      		movw r24,r22
 1070 04d8 BC01      		movw r22,r24
 1071 04da CD01      		movw r24,r26
 1072 04dc 0E94 0000 		call __fixsfsi
 1073 04e0 DC01      		movw r26,r24
 1074 04e2 CB01      		movw r24,r22
 1075 04e4 9093 0000 		sts ts_time+1,r25
 1076 04e8 8093 0000 		sts ts_time,r24
 525:ServerLLDN.c  **** 			uint8_t msg_wait_time = (2*tmp_beacon->Flags.numBaseMgmtTimeslots + assTimeSlot) * ts_time;
 1077               		.loc 6 525 0
 1078 04ec 8981      		ldd r24,Y+1
 1079 04ee 9A81      		ldd r25,Y+2
 1080 04f0 FC01      		movw r30,r24
 1081 04f2 8381      		ldd r24,Z+3
 1082 04f4 8295      		swap r24
 1083 04f6 8695      		lsr r24
 1084 04f8 8770      		andi r24,lo8(7)
 1085 04fa 882F      		mov r24,r24
 1086 04fc 90E0      		ldi r25,0
 1087 04fe 9C01      		movw r18,r24
 1088 0500 220F      		lsl r18
 1089 0502 331F      		rol r19
 1090 0504 8091 0000 		lds r24,assTimeSlot
 1091 0508 882F      		mov r24,r24
 1092 050a 90E0      		ldi r25,0
 1093 050c 820F      		add r24,r18
 1094 050e 931F      		adc r25,r19
 1095 0510 282F      		mov r18,r24
 1096 0512 8091 0000 		lds r24,ts_time
 1097 0516 9091 0000 		lds r25,ts_time+1
 1098 051a 289F      		mul r18,r24
 1099 051c 802D      		mov r24,r0
 1100 051e 1124      		clr r1
 1101 0520 8D83      		std Y+5,r24
 526:ServerLLDN.c  **** 			printf("\nnumBaseMgmtTimeslots %hhx %hhx ", tmp_beacon->Flags.numBaseMgmtTimeslots, tmp_beacon->
 1102               		.loc 6 526 0
 1103 0522 8981      		ldd r24,Y+1
 1104 0524 9A81      		ldd r25,Y+2
 1105 0526 FC01      		movw r30,r24
 1106 0528 8781      		ldd r24,Z+7
 1107 052a 282F      		mov r18,r24
 1108 052c 30E0      		ldi r19,0
 1109 052e 8981      		ldd r24,Y+1
 1110 0530 9A81      		ldd r25,Y+2
 1111 0532 FC01      		movw r30,r24
 1112 0534 8381      		ldd r24,Z+3
 1113 0536 8295      		swap r24
 1114 0538 8695      		lsr r24
 1115 053a 8770      		andi r24,lo8(7)
 1116 053c 882F      		mov r24,r24
 1117 053e 90E0      		ldi r25,0
 1118 0540 432F      		mov r20,r19
 1119 0542 4F93      		push r20
 1120 0544 2F93      		push r18
 1121 0546 292F      		mov r18,r25
 1122 0548 2F93      		push r18
 1123 054a 8F93      		push r24
 1124 054c 80E0      		ldi r24,lo8(.LC3)
 1125 054e 90E0      		ldi r25,hi8(.LC3)
 1126 0550 892F      		mov r24,r25
 1127 0552 8F93      		push r24
 1128 0554 80E0      		ldi r24,lo8(.LC3)
 1129 0556 90E0      		ldi r25,hi8(.LC3)
 1130 0558 8F93      		push r24
 1131 055a 0E94 0000 		call printf
 1132 055e 0F90      		pop __tmp_reg__
 1133 0560 0F90      		pop __tmp_reg__
 1134 0562 0F90      		pop __tmp_reg__
 1135 0564 0F90      		pop __tmp_reg__
 1136 0566 0F90      		pop __tmp_reg__
 1137 0568 0F90      		pop __tmp_reg__
 527:ServerLLDN.c  **** 			start_timer(msg_wait_time + 80);
 1138               		.loc 6 527 0
 1139 056a 8D81      		ldd r24,Y+5
 1140 056c 805B      		subi r24,lo8(-(80))
 1141 056e 0E94 0000 		call start_timer
 528:ServerLLDN.c  **** 			ack_received = false;
 1142               		.loc 6 528 0
 1143 0572 1092 0000 		sts ack_received,__zero_reg__
 529:ServerLLDN.c  **** 			appState = APP_STATE_PREP_DATA_FRAME;
 1144               		.loc 6 529 0
 1145 0576 86E0      		ldi r24,lo8(6)
 1146 0578 8093 0000 		sts appState,r24
 1147               	.LBE3:
 523:ServerLLDN.c  **** 			ts_time = ((p_var*sp + (m+ n)*sm + macMinLIFSPeriod)/v_var)  / (SYMBOL_TIME);
 1148               		.loc 6 523 0
 1149 057c 00C0      		rjmp .L26
 1150               	.L27:
 530:ServerLLDN.c  **** 		}
 531:ServerLLDN.c  **** 		else if (tmp_beacon->Flags.txState == RESET_MODE)
 1151               		.loc 6 531 0
 1152 057e 8981      		ldd r24,Y+1
 1153 0580 9A81      		ldd r25,Y+2
 1154 0582 FC01      		movw r30,r24
 1155 0584 8381      		ldd r24,Z+3
 1156 0586 8770      		andi r24,lo8(7)
 1157 0588 8730      		cpi r24,lo8(7)
 1158 058a 01F4      		brne .L26
 532:ServerLLDN.c  **** 		{
 533:ServerLLDN.c  **** 			printf("\n Reset beacon");
 1159               		.loc 6 533 0
 1160 058c 80E0      		ldi r24,lo8(.LC4)
 1161 058e 90E0      		ldi r25,hi8(.LC4)
 1162 0590 892F      		mov r24,r25
 1163 0592 8F93      		push r24
 1164 0594 80E0      		ldi r24,lo8(.LC4)
 1165 0596 90E0      		ldi r25,hi8(.LC4)
 1166 0598 8F93      		push r24
 1167 059a 0E94 0000 		call printf
 1168 059e 0F90      		pop __tmp_reg__
 1169 05a0 0F90      		pop __tmp_reg__
 534:ServerLLDN.c  **** 			ack_received = 0;
 1170               		.loc 6 534 0
 1171 05a2 1092 0000 		sts ack_received,__zero_reg__
 535:ServerLLDN.c  **** 			associated = 0;
 1172               		.loc 6 535 0
 1173 05a6 1092 0000 		sts associated,__zero_reg__
 1174               	.L26:
 536:ServerLLDN.c  **** 		}
 537:ServerLLDN.c  **** 		return true;
 1175               		.loc 6 537 0
 1176 05aa 81E0      		ldi r24,lo8(1)
 1177               	/* epilogue start */
 538:ServerLLDN.c  **** 	}
 1178               		.loc 6 538 0
 1179 05ac 2796      		adiw r28,7
 1180 05ae 0FB6      		in __tmp_reg__,__SREG__
 1181 05b0 F894      		cli
 1182 05b2 DEBF      		out __SP_H__,r29
 1183 05b4 0FBE      		out __SREG__,__tmp_reg__
 1184 05b6 CDBF      		out __SP_L__,r28
 1185 05b8 DF91      		pop r29
 1186 05ba CF91      		pop r28
 1187 05bc 0895      		ret
 1188               		.cfi_endproc
 1189               	.LFE133:
 1191               		.section	.rodata
 1192               	.LC5:
 1193 004a 0A20 2568 		.string	"\n %hhx "
 1193      6878 2000 
 1194               	.LC6:
 1195 0052 4143 4B20 		.string	"ACK TRUE"
 1195      5452 5545 
 1195      00
 1196               		.text
 1197               	.global	check_ack
 1199               	check_ack:
 1200               	.LFB134:
 539:ServerLLDN.c  **** 	
 540:ServerLLDN.c  **** 	bool check_ack(int addr)
 541:ServerLLDN.c  **** 	{
 1201               		.loc 6 541 0
 1202               		.cfi_startproc
 1203 05be CF93      		push r28
 1204               	.LCFI43:
 1205               		.cfi_def_cfa_offset 3
 1206               		.cfi_offset 28, -2
 1207 05c0 DF93      		push r29
 1208               	.LCFI44:
 1209               		.cfi_def_cfa_offset 4
 1210               		.cfi_offset 29, -3
 1211 05c2 00D0      		rcall .
 1212 05c4 00D0      		rcall .
 1213 05c6 00D0      		rcall .
 1214               	.LCFI45:
 1215               		.cfi_def_cfa_offset 10
 1216 05c8 CDB7      		in r28,__SP_L__
 1217 05ca DEB7      		in r29,__SP_H__
 1218               	.LCFI46:
 1219               		.cfi_def_cfa_register 28
 1220               	/* prologue: function */
 1221               	/* frame size = 6 */
 1222               	/* stack size = 8 */
 1223               	.L__stack_usage = 8
 1224 05cc 9E83      		std Y+6,r25
 1225 05ce 8D83      		std Y+5,r24
 542:ServerLLDN.c  **** 		int pos =  addr / 8;
 1226               		.loc 6 542 0
 1227 05d0 8D81      		ldd r24,Y+5
 1228 05d2 9E81      		ldd r25,Y+6
 1229 05d4 9923      		tst r25
 1230 05d6 04F4      		brge .L30
 1231 05d8 0796      		adiw r24,7
 1232               	.L30:
 1233 05da 9595      		asr r25
 1234 05dc 8795      		ror r24
 1235 05de 9595      		asr r25
 1236 05e0 8795      		ror r24
 1237 05e2 9595      		asr r25
 1238 05e4 8795      		ror r24
 1239 05e6 9A83      		std Y+2,r25
 1240 05e8 8983      		std Y+1,r24
 543:ServerLLDN.c  **** 		int bit_shift = 8 - addr % 8;
 1241               		.loc 6 543 0
 1242 05ea 8D81      		ldd r24,Y+5
 1243 05ec 9E81      		ldd r25,Y+6
 1244 05ee 8770      		andi r24,7
 1245 05f0 9078      		andi r25,128
 1246 05f2 9923      		tst r25
 1247 05f4 04F4      		brge .L31
 1248 05f6 0197      		sbiw r24,1
 1249 05f8 886F      		ori r24,248
 1250 05fa 9F6F      		ori r25,255
 1251 05fc 0196      		adiw r24,1
 1252               	.L31:
 1253 05fe 9C01      		movw r18,r24
 1254 0600 88E0      		ldi r24,lo8(8)
 1255 0602 90E0      		ldi r25,0
 1256 0604 821B      		sub r24,r18
 1257 0606 930B      		sbc r25,r19
 1258 0608 9C83      		std Y+4,r25
 1259 060a 8B83      		std Y+3,r24
 544:ServerLLDN.c  **** 		printf("\n %hhx ", ackframe->ackFlags[pos]);
 1260               		.loc 6 544 0
 1261 060c 2091 0000 		lds r18,ackframe
 1262 0610 3091 0000 		lds r19,ackframe+1
 1263 0614 8981      		ldd r24,Y+1
 1264 0616 9A81      		ldd r25,Y+2
 1265 0618 820F      		add r24,r18
 1266 061a 931F      		adc r25,r19
 1267 061c 0196      		adiw r24,1
 1268 061e FC01      		movw r30,r24
 1269 0620 8081      		ld r24,Z
 1270 0622 882F      		mov r24,r24
 1271 0624 90E0      		ldi r25,0
 1272 0626 292F      		mov r18,r25
 1273 0628 2F93      		push r18
 1274 062a 8F93      		push r24
 1275 062c 80E0      		ldi r24,lo8(.LC5)
 1276 062e 90E0      		ldi r25,hi8(.LC5)
 1277 0630 892F      		mov r24,r25
 1278 0632 8F93      		push r24
 1279 0634 80E0      		ldi r24,lo8(.LC5)
 1280 0636 90E0      		ldi r25,hi8(.LC5)
 1281 0638 8F93      		push r24
 1282 063a 0E94 0000 		call printf
 1283 063e 0F90      		pop __tmp_reg__
 1284 0640 0F90      		pop __tmp_reg__
 1285 0642 0F90      		pop __tmp_reg__
 1286 0644 0F90      		pop __tmp_reg__
 545:ServerLLDN.c  **** 		if( ackframe->ackFlags[pos] & 1 << bit_shift)
 1287               		.loc 6 545 0
 1288 0646 2091 0000 		lds r18,ackframe
 1289 064a 3091 0000 		lds r19,ackframe+1
 1290 064e 8981      		ldd r24,Y+1
 1291 0650 9A81      		ldd r25,Y+2
 1292 0652 820F      		add r24,r18
 1293 0654 931F      		adc r25,r19
 1294 0656 0196      		adiw r24,1
 1295 0658 FC01      		movw r30,r24
 1296 065a 8081      		ld r24,Z
 1297 065c 882F      		mov r24,r24
 1298 065e 90E0      		ldi r25,0
 1299 0660 0B80      		ldd r0,Y+3
 1300 0662 00C0      		rjmp 2f
 1301               		1:
 1302 0664 9595      		asr r25
 1303 0666 8795      		ror r24
 1304               		2:
 1305 0668 0A94      		dec r0
 1306 066a 02F4      		brpl 1b
 1307 066c 8170      		andi r24,1
 1308 066e 9927      		clr r25
 1309 0670 892B      		or r24,r25
 1310 0672 01F0      		breq .L32
 546:ServerLLDN.c  **** 		{
 547:ServerLLDN.c  **** 			printf("ACK TRUE");
 1311               		.loc 6 547 0
 1312 0674 80E0      		ldi r24,lo8(.LC6)
 1313 0676 90E0      		ldi r25,hi8(.LC6)
 1314 0678 892F      		mov r24,r25
 1315 067a 8F93      		push r24
 1316 067c 80E0      		ldi r24,lo8(.LC6)
 1317 067e 90E0      		ldi r25,hi8(.LC6)
 1318 0680 8F93      		push r24
 1319 0682 0E94 0000 		call printf
 1320 0686 0F90      		pop __tmp_reg__
 1321 0688 0F90      		pop __tmp_reg__
 548:ServerLLDN.c  **** 			return true;
 1322               		.loc 6 548 0
 1323 068a 81E0      		ldi r24,lo8(1)
 1324 068c 00C0      		rjmp .L33
 1325               	.L32:
 549:ServerLLDN.c  **** 		}
 550:ServerLLDN.c  **** 		else
 551:ServerLLDN.c  **** 			return false;
 1326               		.loc 6 551 0
 1327 068e 80E0      		ldi r24,0
 1328               	.L33:
 1329               	/* epilogue start */
 552:ServerLLDN.c  **** 	}
 1330               		.loc 6 552 0
 1331 0690 2696      		adiw r28,6
 1332 0692 0FB6      		in __tmp_reg__,__SREG__
 1333 0694 F894      		cli
 1334 0696 DEBF      		out __SP_H__,r29
 1335 0698 0FBE      		out __SREG__,__tmp_reg__
 1336 069a CDBF      		out __SP_L__,r28
 1337 069c DF91      		pop r29
 1338 069e CF91      		pop r28
 1339 06a0 0895      		ret
 1340               		.cfi_endproc
 1341               	.LFE134:
 1343               		.section	.rodata
 1344               	.LC7:
 1345 005b 0A72 6574 		.string	"\nretransmition_slot %d , %hhx"
 1345      7261 6E73 
 1345      6D69 7469 
 1345      6F6E 5F73 
 1345      6C6F 7420 
 1346               		.text
 1348               	appAckInd:
 1349               	.LFB135:
 553:ServerLLDN.c  **** 	
 554:ServerLLDN.c  **** 	static bool appAckInd(NWK_DataInd_t *ind)
 555:ServerLLDN.c  **** 	{
 1350               		.loc 6 555 0
 1351               		.cfi_startproc
 1352 06a2 CF93      		push r28
 1353               	.LCFI47:
 1354               		.cfi_def_cfa_offset 3
 1355               		.cfi_offset 28, -2
 1356 06a4 DF93      		push r29
 1357               	.LCFI48:
 1358               		.cfi_def_cfa_offset 4
 1359               		.cfi_offset 29, -3
 1360 06a6 00D0      		rcall .
 1361 06a8 00D0      		rcall .
 1362 06aa 00D0      		rcall .
 1363               	.LCFI49:
 1364               		.cfi_def_cfa_offset 10
 1365 06ac CDB7      		in r28,__SP_L__
 1366 06ae DEB7      		in r29,__SP_H__
 1367               	.LCFI50:
 1368               		.cfi_def_cfa_register 28
 1369               	/* prologue: function */
 1370               	/* frame size = 6 */
 1371               	/* stack size = 8 */
 1372               	.L__stack_usage = 8
 1373 06b0 9E83      		std Y+6,r25
 1374 06b2 8D83      		std Y+5,r24
 556:ServerLLDN.c  **** 		#if !MASTER_MACSC
 557:ServerLLDN.c  **** 		ind->data = ind->data - (uint8_t) 1;
 558:ServerLLDN.c  **** 		#endif
 559:ServerLLDN.c  **** 		ackframe = (NWK_ACKFormat_t*)ind->data;
 1375               		.loc 6 559 0
 1376 06b4 8D81      		ldd r24,Y+5
 1377 06b6 9E81      		ldd r25,Y+6
 1378 06b8 FC01      		movw r30,r24
 1379 06ba 8085      		ldd r24,Z+8
 1380 06bc 9185      		ldd r25,Z+9
 1381 06be 9093 0000 		sts ackframe+1,r25
 1382 06c2 8093 0000 		sts ackframe,r24
 560:ServerLLDN.c  **** 
 561:ServerLLDN.c  **** 		if(PanId == ackframe->sourceId)
 1383               		.loc 6 561 0
 1384 06c6 8091 0000 		lds r24,ackframe
 1385 06ca 9091 0000 		lds r25,ackframe+1
 1386 06ce FC01      		movw r30,r24
 1387 06d0 9081      		ld r25,Z
 1388 06d2 8091 0000 		lds r24,PanId
 1389 06d6 9817      		cp r25,r24
 1390 06d8 01F0      		breq .+2
 1391 06da 00C0      		rjmp .L35
 562:ServerLLDN.c  **** 		{
 563:ServerLLDN.c  **** 			if(STATE == ONLINE_MODE)
 1392               		.loc 6 563 0
 1393 06dc 8091 0000 		lds r24,STATE
 1394 06e0 8823      		tst r24
 1395 06e2 01F0      		breq .+2
 1396 06e4 00C0      		rjmp .L36
 564:ServerLLDN.c  **** 			{
 565:ServerLLDN.c  **** 				ack_received = check_ack(assTimeSlot + 1);	
 1397               		.loc 6 565 0
 1398 06e6 8091 0000 		lds r24,assTimeSlot
 1399 06ea 882F      		mov r24,r24
 1400 06ec 90E0      		ldi r25,0
 1401 06ee 0196      		adiw r24,1
 1402 06f0 0E94 0000 		call check_ack
 1403 06f4 8093 0000 		sts ack_received,r24
 566:ServerLLDN.c  **** 				if(!ack_received)
 1404               		.loc 6 566 0
 1405 06f8 9091 0000 		lds r25,ack_received
 1406 06fc 81E0      		ldi r24,lo8(1)
 1407 06fe 8927      		eor r24,r25
 1408 0700 8823      		tst r24
 1409 0702 01F4      		brne .+2
 1410 0704 00C0      		rjmp .L35
 1411               	.LBB4:
 567:ServerLLDN.c  **** 				{
 568:ServerLLDN.c  **** 				
 569:ServerLLDN.c  **** 					int retransmition_slot = 0;
 1412               		.loc 6 569 0
 1413 0706 1A82      		std Y+2,__zero_reg__
 1414 0708 1982      		std Y+1,__zero_reg__
 1415               	.LBB5:
 570:ServerLLDN.c  **** 					
 571:ServerLLDN.c  **** 					
 572:ServerLLDN.c  **** 					for(int i = 0; i < assTimeSlot - 1 && i < (rec_beacon.NumberOfBaseTimeslotsinSuperframe - 3)/2
 1416               		.loc 6 572 0
 1417 070a 1C82      		std Y+4,__zero_reg__
 1418 070c 1B82      		std Y+3,__zero_reg__
 1419 070e 00C0      		rjmp .L38
 1420               	.L42:
 573:ServerLLDN.c  **** 						if( !check_ack(i) )
 1421               		.loc 6 573 0
 1422 0710 8B81      		ldd r24,Y+3
 1423 0712 9C81      		ldd r25,Y+4
 1424 0714 0E94 0000 		call check_ack
 1425 0718 982F      		mov r25,r24
 1426 071a 81E0      		ldi r24,lo8(1)
 1427 071c 8927      		eor r24,r25
 1428 071e 8823      		tst r24
 1429 0720 01F0      		breq .L39
 574:ServerLLDN.c  **** 							retransmition_slot++;
 1430               		.loc 6 574 0
 1431 0722 8981      		ldd r24,Y+1
 1432 0724 9A81      		ldd r25,Y+2
 1433 0726 0196      		adiw r24,1
 1434 0728 9A83      		std Y+2,r25
 1435 072a 8983      		std Y+1,r24
 1436               	.L39:
 572:ServerLLDN.c  **** 						if( !check_ack(i) )
 1437               		.loc 6 572 0 discriminator 2
 1438 072c 8B81      		ldd r24,Y+3
 1439 072e 9C81      		ldd r25,Y+4
 1440 0730 0196      		adiw r24,1
 1441 0732 9C83      		std Y+4,r25
 1442 0734 8B83      		std Y+3,r24
 1443               	.L38:
 572:ServerLLDN.c  **** 						if( !check_ack(i) )
 1444               		.loc 6 572 0 is_stmt 0 discriminator 1
 1445 0736 8091 0000 		lds r24,assTimeSlot
 1446 073a 882F      		mov r24,r24
 1447 073c 90E0      		ldi r25,0
 1448 073e 9C01      		movw r18,r24
 1449 0740 2150      		subi r18,1
 1450 0742 3109      		sbc r19,__zero_reg__
 1451 0744 8B81      		ldd r24,Y+3
 1452 0746 9C81      		ldd r25,Y+4
 1453 0748 8217      		cp r24,r18
 1454 074a 9307      		cpc r25,r19
 1455 074c 04F4      		brge .L40
 572:ServerLLDN.c  **** 						if( !check_ack(i) )
 1456               		.loc 6 572 0 discriminator 3
 1457 074e 8091 0000 		lds r24,rec_beacon+7
 1458 0752 882F      		mov r24,r24
 1459 0754 90E0      		ldi r25,0
 1460 0756 0397      		sbiw r24,3
 1461 0758 9923      		tst r25
 1462 075a 04F4      		brge .L41
 1463 075c 0196      		adiw r24,1
 1464               	.L41:
 1465 075e 9595      		asr r25
 1466 0760 8795      		ror r24
 1467 0762 9C01      		movw r18,r24
 1468 0764 8B81      		ldd r24,Y+3
 1469 0766 9C81      		ldd r25,Y+4
 1470 0768 8217      		cp r24,r18
 1471 076a 9307      		cpc r25,r19
 1472 076c 04F0      		brlt .L42
 1473               	.L40:
 1474               	.LBE5:
 575:ServerLLDN.c  **** 					
 576:ServerLLDN.c  **** 					printf("\nretransmition_slot %d , %hhx", retransmition_slot, rec_beacon.NumberOfBaseTimeslotsi
 1475               		.loc 6 576 0 is_stmt 1
 1476 076e 8091 0000 		lds r24,rec_beacon+7
 1477 0772 882F      		mov r24,r24
 1478 0774 90E0      		ldi r25,0
 1479 0776 292F      		mov r18,r25
 1480 0778 2F93      		push r18
 1481 077a 8F93      		push r24
 1482 077c 8A81      		ldd r24,Y+2
 1483 077e 8F93      		push r24
 1484 0780 8981      		ldd r24,Y+1
 1485 0782 8F93      		push r24
 1486 0784 80E0      		ldi r24,lo8(.LC7)
 1487 0786 90E0      		ldi r25,hi8(.LC7)
 1488 0788 892F      		mov r24,r25
 1489 078a 8F93      		push r24
 1490 078c 80E0      		ldi r24,lo8(.LC7)
 1491 078e 90E0      		ldi r25,hi8(.LC7)
 1492 0790 8F93      		push r24
 1493 0792 0E94 0000 		call printf
 1494 0796 0F90      		pop __tmp_reg__
 1495 0798 0F90      		pop __tmp_reg__
 1496 079a 0F90      		pop __tmp_reg__
 1497 079c 0F90      		pop __tmp_reg__
 1498 079e 0F90      		pop __tmp_reg__
 1499 07a0 0F90      		pop __tmp_reg__
 577:ServerLLDN.c  **** 					
 578:ServerLLDN.c  **** 					if( retransmition_slot > (rec_beacon.NumberOfBaseTimeslotsinSuperframe - 3)/2 - 1)
 1500               		.loc 6 578 0
 1501 07a2 8091 0000 		lds r24,rec_beacon+7
 1502 07a6 882F      		mov r24,r24
 1503 07a8 90E0      		ldi r25,0
 1504 07aa 0397      		sbiw r24,3
 1505 07ac 9923      		tst r25
 1506 07ae 04F4      		brge .L43
 1507 07b0 0196      		adiw r24,1
 1508               	.L43:
 1509 07b2 9595      		asr r25
 1510 07b4 8795      		ror r24
 1511 07b6 9C01      		movw r18,r24
 1512 07b8 2150      		subi r18,1
 1513 07ba 3109      		sbc r19,__zero_reg__
 1514 07bc 8981      		ldd r24,Y+1
 1515 07be 9A81      		ldd r25,Y+2
 1516 07c0 2817      		cp r18,r24
 1517 07c2 3907      		cpc r19,r25
 1518 07c4 04F4      		brge .L44
 579:ServerLLDN.c  **** 						return false;
 1519               		.loc 6 579 0
 1520 07c6 80E0      		ldi r24,0
 1521 07c8 00C0      		rjmp .L45
 1522               	.L44:
 580:ServerLLDN.c  **** 					
 581:ServerLLDN.c  **** 					if(retransmition_slot == 0)
 1523               		.loc 6 581 0
 1524 07ca 8981      		ldd r24,Y+1
 1525 07cc 9A81      		ldd r25,Y+2
 1526 07ce 892B      		or r24,r25
 1527 07d0 01F4      		brne .L46
 582:ServerLLDN.c  **** 					{
 583:ServerLLDN.c  **** 						appSendData();
 1528               		.loc 6 583 0
 1529 07d2 0E94 0000 		call appSendData
 1530 07d6 00C0      		rjmp .L35
 1531               	.L46:
 584:ServerLLDN.c  **** 					}
 585:ServerLLDN.c  **** 					else
 586:ServerLLDN.c  **** 					{
 587:ServerLLDN.c  **** 						#if MASTER_MACSC
 588:ServerLLDN.c  **** 						macsc_enable_manual_bts();
 1532               		.loc 6 588 0
 1533 07d8 0E94 0000 		call macsc_enable_manual_bts
 589:ServerLLDN.c  **** 						macsc_set_cmp1_int_cb(send_message_timeHandler);
 1534               		.loc 6 589 0
 1535 07dc 80E0      		ldi r24,lo8(gs(send_message_timeHandler))
 1536 07de 90E0      		ldi r25,hi8(gs(send_message_timeHandler))
 1537 07e0 0E94 0000 		call macsc_set_cmp1_int_cb
 590:ServerLLDN.c  **** 						macsc_enable_cmp_int(MACSC_CC1);
 1538               		.loc 6 590 0
 1539 07e4 81E0      		ldi r24,lo8(1)
 1540 07e6 0E94 0000 		call macsc_enable_cmp_int
 591:ServerLLDN.c  **** 						macsc_use_cmp(MACSC_RELATIVE_CMP, ts_time * retransmition_slot, MACSC_CC1);
 1541               		.loc 6 591 0
 1542 07ea 4091 0000 		lds r20,ts_time
 1543 07ee 5091 0000 		lds r21,ts_time+1
 1544 07f2 2981      		ldd r18,Y+1
 1545 07f4 3A81      		ldd r19,Y+2
 1546 07f6 429F      		mul r20,r18
 1547 07f8 C001      		movw r24,r0
 1548 07fa 439F      		mul r20,r19
 1549 07fc 900D      		add r25,r0
 1550 07fe 529F      		mul r21,r18
 1551 0800 900D      		add r25,r0
 1552 0802 1124      		clr r1
 1553 0804 092E      		mov __tmp_reg__,r25
 1554 0806 000C      		lsl r0
 1555 0808 AA0B      		sbc r26,r26
 1556 080a BB0B      		sbc r27,r27
 1557 080c 21E0      		ldi r18,lo8(1)
 1558 080e AC01      		movw r20,r24
 1559 0810 BD01      		movw r22,r26
 1560 0812 81E0      		ldi r24,lo8(1)
 1561 0814 0E94 0000 		call macsc_use_cmp
 1562 0818 00C0      		rjmp .L35
 1563               	.L36:
 1564               	.LBE4:
 592:ServerLLDN.c  **** 						#endif
 593:ServerLLDN.c  **** 					}					
 594:ServerLLDN.c  **** 				
 595:ServerLLDN.c  **** 				}
 596:ServerLLDN.c  **** 								
 597:ServerLLDN.c  **** 			}
 598:ServerLLDN.c  **** 			else
 599:ServerLLDN.c  **** 				ack_received = check_ack(APP_ADDR);								
 1565               		.loc 6 599 0
 1566 081a 87E0      		ldi r24,lo8(7)
 1567 081c 90E0      		ldi r25,0
 1568 081e 0E94 0000 		call check_ack
 1569 0822 8093 0000 		sts ack_received,r24
 1570               	.L35:
 600:ServerLLDN.c  **** 		}
 601:ServerLLDN.c  **** 		return true;
 1571               		.loc 6 601 0
 1572 0826 81E0      		ldi r24,lo8(1)
 1573               	.L45:
 1574               	/* epilogue start */
 602:ServerLLDN.c  **** 	}
 1575               		.loc 6 602 0
 1576 0828 2696      		adiw r28,6
 1577 082a 0FB6      		in __tmp_reg__,__SREG__
 1578 082c F894      		cli
 1579 082e DEBF      		out __SP_H__,r29
 1580 0830 0FBE      		out __SREG__,__tmp_reg__
 1581 0832 CDBF      		out __SP_L__,r28
 1582 0834 DF91      		pop r29
 1583 0836 CF91      		pop r28
 1584 0838 0895      		ret
 1585               		.cfi_endproc
 1586               	.LFE135:
 1588               		.section	.rodata
 1589               	.LC8:
 1590 0079 0A41 7373 		.string	"\nAssociado!"
 1590      6F63 6961 
 1590      646F 2100 
 1591               		.text
 1593               	appCommandInd:
 1594               	.LFB136:
 603:ServerLLDN.c  **** 	
 604:ServerLLDN.c  **** 	static bool appCommandInd(NWK_DataInd_t *ind)
 605:ServerLLDN.c  **** 	{
 1595               		.loc 6 605 0
 1596               		.cfi_startproc
 1597 083a CF93      		push r28
 1598               	.LCFI51:
 1599               		.cfi_def_cfa_offset 3
 1600               		.cfi_offset 28, -2
 1601 083c DF93      		push r29
 1602               	.LCFI52:
 1603               		.cfi_def_cfa_offset 4
 1604               		.cfi_offset 29, -3
 1605 083e 00D0      		rcall .
 1606 0840 00D0      		rcall .
 1607               	.LCFI53:
 1608               		.cfi_def_cfa_offset 8
 1609 0842 CDB7      		in r28,__SP_L__
 1610 0844 DEB7      		in r29,__SP_H__
 1611               	.LCFI54:
 1612               		.cfi_def_cfa_register 28
 1613               	/* prologue: function */
 1614               	/* frame size = 4 */
 1615               	/* stack size = 6 */
 1616               	.L__stack_usage = 6
 1617 0846 9C83      		std Y+4,r25
 1618 0848 8B83      		std Y+3,r24
 606:ServerLLDN.c  **** 		#if !MASTER_MACSC
 607:ServerLLDN.c  **** 		ind->data = ind->data - (uint8_t) 1;
 608:ServerLLDN.c  **** 		#endif
 609:ServerLLDN.c  **** 		
 610:ServerLLDN.c  **** 		if(ind->data[0] == LL_CONFIGURATION_REQUEST)
 1619               		.loc 6 610 0
 1620 084a 8B81      		ldd r24,Y+3
 1621 084c 9C81      		ldd r25,Y+4
 1622 084e FC01      		movw r30,r24
 1623 0850 8085      		ldd r24,Z+8
 1624 0852 9185      		ldd r25,Z+9
 1625 0854 FC01      		movw r30,r24
 1626 0856 8081      		ld r24,Z
 1627 0858 8F30      		cpi r24,lo8(15)
 1628 085a 01F4      		brne .L48
 1629               	.LBB6:
 611:ServerLLDN.c  **** 		{
 612:ServerLLDN.c  **** 			NWK_ConfigRequest_t *msg = (NWK_ConfigRequest_t*)ind->data;
 1630               		.loc 6 612 0
 1631 085c 8B81      		ldd r24,Y+3
 1632 085e 9C81      		ldd r25,Y+4
 1633 0860 FC01      		movw r30,r24
 1634 0862 8085      		ldd r24,Z+8
 1635 0864 9185      		ldd r25,Z+9
 1636 0866 9A83      		std Y+2,r25
 1637 0868 8983      		std Y+1,r24
 613:ServerLLDN.c  **** 			if(msg->macAddr == APP_ADDR)
 1638               		.loc 6 613 0
 1639 086a 8981      		ldd r24,Y+1
 1640 086c 9A81      		ldd r25,Y+2
 1641 086e FC01      		movw r30,r24
 1642 0870 8481      		ldd r24,Z+4
 1643 0872 8730      		cpi r24,lo8(7)
 1644 0874 01F4      		brne .L48
 614:ServerLLDN.c  **** 			{
 615:ServerLLDN.c  **** 				PHY_SetChannel(msg->tx_channel);
 1645               		.loc 6 615 0
 1646 0876 8981      		ldd r24,Y+1
 1647 0878 9A81      		ldd r25,Y+2
 1648 087a FC01      		movw r30,r24
 1649 087c 8281      		ldd r24,Z+2
 1650 087e 0E94 0000 		call PHY_SetChannel
 616:ServerLLDN.c  **** 				NWK_SetPanId(msg->s_macAddr);
 1651               		.loc 6 616 0
 1652 0882 8981      		ldd r24,Y+1
 1653 0884 9A81      		ldd r25,Y+2
 1654 0886 FC01      		movw r30,r24
 1655 0888 8181      		ldd r24,Z+1
 1656 088a 882F      		mov r24,r24
 1657 088c 90E0      		ldi r25,0
 1658 088e 0E94 0000 		call NWK_SetPanId
 617:ServerLLDN.c  **** 				PanId = msg->s_macAddr;
 1659               		.loc 6 617 0
 1660 0892 8981      		ldd r24,Y+1
 1661 0894 9A81      		ldd r25,Y+2
 1662 0896 FC01      		movw r30,r24
 1663 0898 8181      		ldd r24,Z+1
 1664 089a 8093 0000 		sts PanId,r24
 618:ServerLLDN.c  **** 				assTimeSlot = msg->assTimeSlot;
 1665               		.loc 6 618 0
 1666 089e 8981      		ldd r24,Y+1
 1667 08a0 9A81      		ldd r25,Y+2
 1668 08a2 FC01      		movw r30,r24
 1669 08a4 8381      		ldd r24,Z+3
 1670 08a6 8093 0000 		sts assTimeSlot,r24
 619:ServerLLDN.c  **** 				n = msg->conf.tsDuration;
 1671               		.loc 6 619 0
 1672 08aa 8981      		ldd r24,Y+1
 1673 08ac 9A81      		ldd r25,Y+2
 1674 08ae FC01      		movw r30,r24
 1675 08b0 8581      		ldd r24,Z+5
 1676 08b2 8F77      		andi r24,lo8(127)
 1677 08b4 8093 0000 		sts n,r24
 620:ServerLLDN.c  **** 				associated = 1;
 1678               		.loc 6 620 0
 1679 08b8 81E0      		ldi r24,lo8(1)
 1680 08ba 8093 0000 		sts associated,r24
 621:ServerLLDN.c  **** 				printf("\nAssociado!");
 1681               		.loc 6 621 0
 1682 08be 80E0      		ldi r24,lo8(.LC8)
 1683 08c0 90E0      		ldi r25,hi8(.LC8)
 1684 08c2 892F      		mov r24,r25
 1685 08c4 8F93      		push r24
 1686 08c6 80E0      		ldi r24,lo8(.LC8)
 1687 08c8 90E0      		ldi r25,hi8(.LC8)
 1688 08ca 8F93      		push r24
 1689 08cc 0E94 0000 		call printf
 1690 08d0 0F90      		pop __tmp_reg__
 1691 08d2 0F90      		pop __tmp_reg__
 1692               	.L48:
 1693               	.LBE6:
 622:ServerLLDN.c  **** 			}
 623:ServerLLDN.c  **** 		}
 624:ServerLLDN.c  **** 		return true;
 1694               		.loc 6 624 0
 1695 08d4 81E0      		ldi r24,lo8(1)
 1696               	/* epilogue start */
 625:ServerLLDN.c  **** 	}
 1697               		.loc 6 625 0
 1698 08d6 0F90      		pop __tmp_reg__
 1699 08d8 0F90      		pop __tmp_reg__
 1700 08da 0F90      		pop __tmp_reg__
 1701 08dc 0F90      		pop __tmp_reg__
 1702 08de DF91      		pop r29
 1703 08e0 CF91      		pop r28
 1704 08e2 0895      		ret
 1705               		.cfi_endproc
 1706               	.LFE136:
 1708               	.global	appPrepareDiscoverResponse
 1710               	appPrepareDiscoverResponse:
 1711               	.LFB137:
 626:ServerLLDN.c  **** 
 627:ServerLLDN.c  **** 	void appPrepareDiscoverResponse()
 628:ServerLLDN.c  **** 	{
 1712               		.loc 6 628 0
 1713               		.cfi_startproc
 1714 08e4 CF93      		push r28
 1715               	.LCFI55:
 1716               		.cfi_def_cfa_offset 3
 1717               		.cfi_offset 28, -2
 1718 08e6 DF93      		push r29
 1719               	.LCFI56:
 1720               		.cfi_def_cfa_offset 4
 1721               		.cfi_offset 29, -3
 1722 08e8 CDB7      		in r28,__SP_L__
 1723 08ea DEB7      		in r29,__SP_H__
 1724               	.LCFI57:
 1725               		.cfi_def_cfa_register 28
 1726               	/* prologue: function */
 1727               	/* frame size = 0 */
 1728               	/* stack size = 2 */
 1729               	.L__stack_usage = 2
 629:ServerLLDN.c  **** 		msgReq.dstAddr				= 0;
 1730               		.loc 6 629 0
 1731 08ec 1092 0000 		sts msgReq+5+1,__zero_reg__
 1732 08f0 1092 0000 		sts msgReq+5,__zero_reg__
 630:ServerLLDN.c  **** 		msgReq.dstEndpoint			= APP_COMMAND_ENDPOINT;
 1733               		.loc 6 630 0
 1734 08f4 83E0      		ldi r24,lo8(3)
 1735 08f6 8093 0000 		sts msgReq+7,r24
 631:ServerLLDN.c  **** 		msgReq.srcEndpoint			= APP_COMMAND_ENDPOINT;
 1736               		.loc 6 631 0
 1737 08fa 83E0      		ldi r24,lo8(3)
 1738 08fc 8093 0000 		sts msgReq+8,r24
 632:ServerLLDN.c  **** 		msgReq.options				= NWK_OPT_MAC_COMMAND;
 1739               		.loc 6 632 0
 1740 0900 80E0      		ldi r24,0
 1741 0902 90E8      		ldi r25,lo8(-128)
 1742 0904 9093 0000 		sts msgReq+9+1,r25
 1743 0908 8093 0000 		sts msgReq+9,r24
 633:ServerLLDN.c  **** 		msgReq.data					= (uint8_t*)&msgDiscResponse;
 1744               		.loc 6 633 0
 1745 090c 80E0      		ldi r24,lo8(msgDiscResponse)
 1746 090e 90E0      		ldi r25,hi8(msgDiscResponse)
 1747 0910 9093 0000 		sts msgReq+13+1,r25
 1748 0914 8093 0000 		sts msgReq+13,r24
 634:ServerLLDN.c  **** 		msgReq.size					= sizeof(msgDiscResponse);
 1749               		.loc 6 634 0
 1750 0918 83E0      		ldi r24,lo8(3)
 1751 091a 8093 0000 		sts msgReq+15,r24
 635:ServerLLDN.c  **** 	}
 1752               		.loc 6 635 0
 1753 091e 0000      		nop
 1754               	/* epilogue start */
 1755 0920 DF91      		pop r29
 1756 0922 CF91      		pop r28
 1757 0924 0895      		ret
 1758               		.cfi_endproc
 1759               	.LFE137:
 1761               	.global	appPrepareConfigurationStatus
 1763               	appPrepareConfigurationStatus:
 1764               	.LFB138:
 636:ServerLLDN.c  **** 	
 637:ServerLLDN.c  **** 	void appPrepareConfigurationStatus()
 638:ServerLLDN.c  **** 	{		
 1765               		.loc 6 638 0
 1766               		.cfi_startproc
 1767 0926 CF93      		push r28
 1768               	.LCFI58:
 1769               		.cfi_def_cfa_offset 3
 1770               		.cfi_offset 28, -2
 1771 0928 DF93      		push r29
 1772               	.LCFI59:
 1773               		.cfi_def_cfa_offset 4
 1774               		.cfi_offset 29, -3
 1775 092a CDB7      		in r28,__SP_L__
 1776 092c DEB7      		in r29,__SP_H__
 1777               	.LCFI60:
 1778               		.cfi_def_cfa_register 28
 1779               	/* prologue: function */
 1780               	/* frame size = 0 */
 1781               	/* stack size = 2 */
 1782               	.L__stack_usage = 2
 639:ServerLLDN.c  **** 		msgReq.dstAddr				= 0;
 1783               		.loc 6 639 0
 1784 092e 1092 0000 		sts msgReq+5+1,__zero_reg__
 1785 0932 1092 0000 		sts msgReq+5,__zero_reg__
 640:ServerLLDN.c  **** 		msgReq.dstEndpoint			= APP_COMMAND_ENDPOINT;
 1786               		.loc 6 640 0
 1787 0936 83E0      		ldi r24,lo8(3)
 1788 0938 8093 0000 		sts msgReq+7,r24
 641:ServerLLDN.c  **** 		msgReq.srcEndpoint			= APP_COMMAND_ENDPOINT;
 1789               		.loc 6 641 0
 1790 093c 83E0      		ldi r24,lo8(3)
 1791 093e 8093 0000 		sts msgReq+8,r24
 642:ServerLLDN.c  **** 		msgReq.options				= NWK_OPT_MAC_COMMAND;
 1792               		.loc 6 642 0
 1793 0942 80E0      		ldi r24,0
 1794 0944 90E8      		ldi r25,lo8(-128)
 1795 0946 9093 0000 		sts msgReq+9+1,r25
 1796 094a 8093 0000 		sts msgReq+9,r24
 643:ServerLLDN.c  **** 		msgReq.data					= (uint8_t*)&msgConfigStatus;
 1797               		.loc 6 643 0
 1798 094e 80E0      		ldi r24,lo8(msgConfigStatus)
 1799 0950 90E0      		ldi r25,hi8(msgConfigStatus)
 1800 0952 9093 0000 		sts msgReq+13+1,r25
 1801 0956 8093 0000 		sts msgReq+13,r24
 644:ServerLLDN.c  **** 		msgReq.size					= sizeof(msgConfigStatus);
 1802               		.loc 6 644 0
 1803 095a 85E0      		ldi r24,lo8(5)
 1804 095c 8093 0000 		sts msgReq+15,r24
 645:ServerLLDN.c  **** 	}
 1805               		.loc 6 645 0
 1806 0960 0000      		nop
 1807               	/* epilogue start */
 1808 0962 DF91      		pop r29
 1809 0964 CF91      		pop r28
 1810 0966 0895      		ret
 1811               		.cfi_endproc
 1812               	.LFE138:
 1814               	.global	appPrepareDataFrame
 1816               	appPrepareDataFrame:
 1817               	.LFB139:
 646:ServerLLDN.c  **** 	
 647:ServerLLDN.c  **** 	void appPrepareDataFrame(void)
 648:ServerLLDN.c  **** 	{
 1818               		.loc 6 648 0
 1819               		.cfi_startproc
 1820 0968 CF93      		push r28
 1821               	.LCFI61:
 1822               		.cfi_def_cfa_offset 3
 1823               		.cfi_offset 28, -2
 1824 096a DF93      		push r29
 1825               	.LCFI62:
 1826               		.cfi_def_cfa_offset 4
 1827               		.cfi_offset 29, -3
 1828 096c CDB7      		in r28,__SP_L__
 1829 096e DEB7      		in r29,__SP_H__
 1830               	.LCFI63:
 1831               		.cfi_def_cfa_register 28
 1832               	/* prologue: function */
 1833               	/* frame size = 0 */
 1834               	/* stack size = 2 */
 1835               	.L__stack_usage = 2
 649:ServerLLDN.c  **** 		
 650:ServerLLDN.c  **** 		PHY_SetTdmaMode(true);
 1836               		.loc 6 650 0
 1837 0970 81E0      		ldi r24,lo8(1)
 1838 0972 0E94 0000 		call PHY_SetTdmaMode
 651:ServerLLDN.c  **** 
 652:ServerLLDN.c  **** 	
 653:ServerLLDN.c  **** 		msgReq.dstAddr				= 0;
 1839               		.loc 6 653 0
 1840 0976 1092 0000 		sts msgReq+5+1,__zero_reg__
 1841 097a 1092 0000 		sts msgReq+5,__zero_reg__
 654:ServerLLDN.c  **** 		msgReq.dstEndpoint			= APP_COMMAND_ENDPOINT;
 1842               		.loc 6 654 0
 1843 097e 83E0      		ldi r24,lo8(3)
 1844 0980 8093 0000 		sts msgReq+7,r24
 655:ServerLLDN.c  **** 		msgReq.srcEndpoint			= APP_COMMAND_ENDPOINT;
 1845               		.loc 6 655 0
 1846 0984 83E0      		ldi r24,lo8(3)
 1847 0986 8093 0000 		sts msgReq+8,r24
 656:ServerLLDN.c  **** 		msgReq.options				= NWK_OPT_LLDN_DATA;
 1848               		.loc 6 656 0
 1849 098a 80E0      		ldi r24,0
 1850 098c 90E2      		ldi r25,lo8(32)
 1851 098e 9093 0000 		sts msgReq+9+1,r25
 1852 0992 8093 0000 		sts msgReq+9,r24
 657:ServerLLDN.c  **** 		msgReq.data					= (uint8_t *)&data_payload;
 1853               		.loc 6 657 0
 1854 0996 80E0      		ldi r24,lo8(data_payload)
 1855 0998 90E0      		ldi r25,hi8(data_payload)
 1856 099a 9093 0000 		sts msgReq+13+1,r25
 1857 099e 8093 0000 		sts msgReq+13,r24
 658:ServerLLDN.c  **** 		msgReq.size					= sizeof(data_payload);
 1858               		.loc 6 658 0
 1859 09a2 81E0      		ldi r24,lo8(1)
 1860 09a4 8093 0000 		sts msgReq+15,r24
 659:ServerLLDN.c  **** 	}
 1861               		.loc 6 659 0
 1862 09a8 0000      		nop
 1863               	/* epilogue start */
 1864 09aa DF91      		pop r29
 1865 09ac CF91      		pop r28
 1866 09ae 0895      		ret
 1867               		.cfi_endproc
 1868               	.LFE139:
 1871               	appInit:
 1872               	.LFB140:
 660:ServerLLDN.c  **** 	
 661:ServerLLDN.c  **** 	
 662:ServerLLDN.c  **** #endif // APP_COORDINATOR
 663:ServerLLDN.c  **** 
 664:ServerLLDN.c  **** static void appInit(void)
 665:ServerLLDN.c  **** {
 1873               		.loc 6 665 0
 1874               		.cfi_startproc
 1875 09b0 CF93      		push r28
 1876               	.LCFI64:
 1877               		.cfi_def_cfa_offset 3
 1878               		.cfi_offset 28, -2
 1879 09b2 DF93      		push r29
 1880               	.LCFI65:
 1881               		.cfi_def_cfa_offset 4
 1882               		.cfi_offset 29, -3
 1883 09b4 CDB7      		in r28,__SP_L__
 1884 09b6 DEB7      		in r29,__SP_H__
 1885               	.LCFI66:
 1886               		.cfi_def_cfa_register 28
 1887               	/* prologue: function */
 1888               	/* frame size = 0 */
 1889               	/* stack size = 2 */
 1890               	.L__stack_usage = 2
 666:ServerLLDN.c  **** 	NWK_SetAddr(APP_ADDR);
 1891               		.loc 6 666 0
 1892 09b8 87E0      		ldi r24,lo8(7)
 1893 09ba 90E0      		ldi r25,0
 1894 09bc 0E94 0000 		call NWK_SetAddr
 667:ServerLLDN.c  **** 	PHY_SetChannel(APP_CHANNEL);
 1895               		.loc 6 667 0
 1896 09c0 8FE0      		ldi r24,lo8(15)
 1897 09c2 0E94 0000 		call PHY_SetChannel
 668:ServerLLDN.c  **** 	PHY_SetRxState(true);
 1898               		.loc 6 668 0
 1899 09c6 81E0      		ldi r24,lo8(1)
 1900 09c8 0E94 0000 		call PHY_SetRxState
 669:ServerLLDN.c  **** 		
 670:ServerLLDN.c  **** 	#if APP_COORDINATOR	 
 671:ServerLLDN.c  **** 		/* Timer used for delay between messages */
 672:ServerLLDN.c  **** 		tmrDelay.interval = 1;
 673:ServerLLDN.c  **** 		tmrDelay.mode = SYS_TIMER_INTERVAL_MODE;
 674:ServerLLDN.c  **** 		tmrDelay.handler = tmrDelayHandler;
 675:ServerLLDN.c  **** 	  
 676:ServerLLDN.c  **** 		/* 
 677:ServerLLDN.c  **** 		* Disable CSMA/CA
 678:ServerLLDN.c  **** 		* Disable auto ACK
 679:ServerLLDN.c  **** 		*/
 680:ServerLLDN.c  **** 		NWK_SetPanId(APP_PANID);
 681:ServerLLDN.c  **** 		PanId = APP_PANID;
 682:ServerLLDN.c  **** 		ACKFrame.sourceId = APP_PANID;
 683:ServerLLDN.c  **** 		PHY_SetTdmaMode(true);
 684:ServerLLDN.c  **** 	NWK_OpenEndpoint(APP_COMMAND_ENDPOINT, appCommandInd);
 685:ServerLLDN.c  **** 	#else
 686:ServerLLDN.c  **** 		/*
 687:ServerLLDN.c  **** 		 * Enable CSMA/CA
 688:ServerLLDN.c  **** 		 * Enable Random CSMA seed generator
 689:ServerLLDN.c  **** 		 */
 690:ServerLLDN.c  **** 		PHY_SetTdmaMode(false);
 1901               		.loc 6 690 0
 1902 09cc 80E0      		ldi r24,0
 1903 09ce 0E94 0000 		call PHY_SetTdmaMode
 691:ServerLLDN.c  **** 		// PHY_SetOptimizedCSMAValues();
 692:ServerLLDN.c  **** 		
 693:ServerLLDN.c  **** 		payloadSize = 127;
 1904               		.loc 6 693 0
 1905 09d2 8FE7      		ldi r24,lo8(127)
 1906 09d4 8093 0000 		sts payloadSize,r24
 694:ServerLLDN.c  **** 		NWK_OpenEndpoint(APP_BEACON_ENDPOINT, appBeaconInd);
 1907               		.loc 6 694 0
 1908 09d8 60E0      		ldi r22,lo8(gs(appBeaconInd))
 1909 09da 70E0      		ldi r23,hi8(gs(appBeaconInd))
 1910 09dc 80E0      		ldi r24,0
 1911 09de 0E94 0000 		call NWK_OpenEndpoint
 695:ServerLLDN.c  **** 		NWK_OpenEndpoint(APP_ACK_ENDPOINT, appAckInd);
 1912               		.loc 6 695 0
 1913 09e2 60E0      		ldi r22,lo8(gs(appAckInd))
 1914 09e4 70E0      		ldi r23,hi8(gs(appAckInd))
 1915 09e6 84E0      		ldi r24,lo8(4)
 1916 09e8 0E94 0000 		call NWK_OpenEndpoint
 696:ServerLLDN.c  **** 		NWK_OpenEndpoint(APP_COMMAND_ENDPOINT, appCommandInd);
 1917               		.loc 6 696 0
 1918 09ec 60E0      		ldi r22,lo8(gs(appCommandInd))
 1919 09ee 70E0      		ldi r23,hi8(gs(appCommandInd))
 1920 09f0 83E0      		ldi r24,lo8(3)
 1921 09f2 0E94 0000 		call NWK_OpenEndpoint
 697:ServerLLDN.c  **** 		/*
 698:ServerLLDN.c  **** 		* Configure interrupts callback functions
 699:ServerLLDN.c  **** 		*/
 700:ServerLLDN.c  **** 		
 701:ServerLLDN.c  **** 	#endif // APP_COORDENATOR
 702:ServerLLDN.c  **** 	PHY_SetPromiscuousMode(true);
 1922               		.loc 6 702 0
 1923 09f6 81E0      		ldi r24,lo8(1)
 1924 09f8 0E94 0000 		call PHY_SetPromiscuousMode
 703:ServerLLDN.c  **** 
 704:ServerLLDN.c  **** }
 1925               		.loc 6 704 0
 1926 09fc 0000      		nop
 1927               	/* epilogue start */
 1928 09fe DF91      		pop r29
 1929 0a00 CF91      		pop r28
 1930 0a02 0895      		ret
 1931               		.cfi_endproc
 1932               	.LFE140:
 1934               		.section	.rodata
 1935               	.LC9:
 1936 0085 0A72 6574 		.string	"\nretransmition_slot %d"
 1936      7261 6E73 
 1936      6D69 7469 
 1936      6F6E 5F73 
 1936      6C6F 7420 
 1937               		.text
 1939               	APP_TaskHandler:
 1940               	.LFB141:
 705:ServerLLDN.c  **** 
 706:ServerLLDN.c  **** static void APP_TaskHandler(void)
 707:ServerLLDN.c  **** {
 1941               		.loc 6 707 0
 1942               		.cfi_startproc
 1943 0a04 CF93      		push r28
 1944               	.LCFI67:
 1945               		.cfi_def_cfa_offset 3
 1946               		.cfi_offset 28, -2
 1947 0a06 DF93      		push r29
 1948               	.LCFI68:
 1949               		.cfi_def_cfa_offset 4
 1950               		.cfi_offset 29, -3
 1951 0a08 00D0      		rcall .
 1952 0a0a 00D0      		rcall .
 1953               	.LCFI69:
 1954               		.cfi_def_cfa_offset 8
 1955 0a0c CDB7      		in r28,__SP_L__
 1956 0a0e DEB7      		in r29,__SP_H__
 1957               	.LCFI70:
 1958               		.cfi_def_cfa_register 28
 1959               	/* prologue: function */
 1960               	/* frame size = 4 */
 1961               	/* stack size = 6 */
 1962               	.L__stack_usage = 6
 708:ServerLLDN.c  **** 	switch (appState){
 1963               		.loc 6 708 0
 1964 0a10 8091 0000 		lds r24,appState
 1965 0a14 882F      		mov r24,r24
 1966 0a16 90E0      		ldi r25,0
 1967 0a18 8430      		cpi r24,4
 1968 0a1a 9105      		cpc r25,__zero_reg__
 1969 0a1c 01F0      		breq .L56
 1970 0a1e 8530      		cpi r24,5
 1971 0a20 9105      		cpc r25,__zero_reg__
 1972 0a22 04F4      		brge .L57
 1973 0a24 0097      		sbiw r24,0
 1974 0a26 01F0      		breq .L58
 1975 0a28 0297      		sbiw r24,2
 1976 0a2a 01F0      		breq .L59
 709:ServerLLDN.c  **** 		case APP_STATE_INITIAL:
 710:ServerLLDN.c  **** 		{
 711:ServerLLDN.c  **** 			appInit();
 712:ServerLLDN.c  **** 			#if APP_COORDINATOR
 713:ServerLLDN.c  **** 				appState = APP_STATE_ATT_PAN_STATE;
 714:ServerLLDN.c  **** 			#else
 715:ServerLLDN.c  **** 				appState = APP_STATE_IDLE;
 716:ServerLLDN.c  **** 			#endif
 717:ServerLLDN.c  **** 			break;
 718:ServerLLDN.c  **** 		}
 719:ServerLLDN.c  **** 		case APP_STATE_SEND:
 720:ServerLLDN.c  **** 		{
 721:ServerLLDN.c  **** 			appSendData();
 722:ServerLLDN.c  **** 			#if APP_COORDINATOR
 723:ServerLLDN.c  **** 				/* Every time a message is send updates coordinator to prepare next message */
 724:ServerLLDN.c  **** 				appState = APP_STATE_ATT_PAN_STATE;
 725:ServerLLDN.c  **** 			#else
 726:ServerLLDN.c  **** 				appState = APP_STATE_IDLE;
 727:ServerLLDN.c  **** 			#endif
 728:ServerLLDN.c  **** 			break;
 729:ServerLLDN.c  **** 		}
 730:ServerLLDN.c  **** 		#if APP_COORDINATOR // COORDINATOR SPECIFIC STATE MACHINE
 731:ServerLLDN.c  **** 		case APP_STATE_ATT_PAN_STATE:
 732:ServerLLDN.c  **** 		{
 733:ServerLLDN.c  **** 			switch(appPanState)
 734:ServerLLDN.c  **** 			{
 735:ServerLLDN.c  **** 				/* Prepare beacon to desassociate all nodes */
 736:ServerLLDN.c  **** 				case APP_PAN_STATE_RESET:
 737:ServerLLDN.c  **** 				{
 738:ServerLLDN.c  **** 					appPanReset();
 739:ServerLLDN.c  **** 					appPanState = APP_PAN_STATE_DISC_INITIAL;
 740:ServerLLDN.c  **** 					appState	= APP_STATE_SEND;
 741:ServerLLDN.c  **** 					cycles_counter = 0;
 742:ServerLLDN.c  **** 					break;
 743:ServerLLDN.c  **** 				}
 744:ServerLLDN.c  **** 				/* Prepare first Beacon of Discovery */
 745:ServerLLDN.c  **** 				case APP_PAN_STATE_DISC_INITIAL:
 746:ServerLLDN.c  **** 				{
 747:ServerLLDN.c  **** 					/* if nodes associated is equal to expected number of associated nodes stop association proces
 748:ServerLLDN.c  **** 					 * this implementation was done as is to be used in tests, for real network functionality 
 749:ServerLLDN.c  **** 					 * the number of max association processes must be done through macLLDNdiscoveryModeTimeout
 750:ServerLLDN.c  **** 					 */
 751:ServerLLDN.c  **** 					if(counter_associados == NODOS_ASSOCIADOS_ESPERADOS || cycles_counter >= 2)
 752:ServerLLDN.c  **** 					{	
 753:ServerLLDN.c  **** 						printf("\n%d, %d", cycles_counter, counter_associados);
 754:ServerLLDN.c  **** 						counter_associados = 0;
 755:ServerLLDN.c  **** 						/* if all nodes expected where associated stop beacon generation interruptions */
 756:ServerLLDN.c  **** 						// macsc_disable_cmp_int(MACSC_CC1);
 757:ServerLLDN.c  **** 						macsc_disable_cmp_int(MACSC_CC2);
 758:ServerLLDN.c  **** 						msgReq.options = 0;
 759:ServerLLDN.c  **** 						
 760:ServerLLDN.c  **** 						for(int i = 0; i < 32; i++)
 761:ServerLLDN.c  **** 						ACKFrame.ackFlags[i] = 0;
 762:ServerLLDN.c  **** 						ACKFrame_size = 0;
 763:ServerLLDN.c  **** 						
 764:ServerLLDN.c  **** 						appState = APP_STATE_IDLE;
 765:ServerLLDN.c  **** 						appPanState = APP_PAN_STATE_ONLINE_INITIAL; // APP_PAN_STATE_ONLINE_INIT
 766:ServerLLDN.c  **** 						cycles_counter = NUMERO_CICLOS_ONLINE;
 767:ServerLLDN.c  **** 					}
 768:ServerLLDN.c  **** 					/* if not all nodes expected where associated run through association process again */
 769:ServerLLDN.c  **** 					else 
 770:ServerLLDN.c  **** 					{
 771:ServerLLDN.c  **** 						/* prepare beacon message and start timers for beacon */
 772:ServerLLDN.c  **** 						appPanDiscInit();
 773:ServerLLDN.c  **** 						appState	= APP_STATE_IDLE;
 774:ServerLLDN.c  **** 						appPanState = APP_PAN_STATE_DISC_SECOND_BE;
 775:ServerLLDN.c  **** 					}
 776:ServerLLDN.c  **** 					break;
 777:ServerLLDN.c  **** 				}
 778:ServerLLDN.c  **** 				case APP_PAN_STATE_DISC_SECOND_BE:
 779:ServerLLDN.c  **** 				{
 780:ServerLLDN.c  **** 					/* Prepares message as: Discovery Beacon and Second Beacon */
 781:ServerLLDN.c  **** 					msgReq.options = NWK_OPT_LLDN_BEACON | NWK_OPT_DISCOVERY_STATE | NWK_OPT_SECOND_BEACON ;
 782:ServerLLDN.c  **** 					msgReq.data = NULL;
 783:ServerLLDN.c  **** 					msgReq.size = 0;
 784:ServerLLDN.c  **** 					
 785:ServerLLDN.c  **** 					appState	= APP_PAN_STATE_DISC_PREPARE_ACK;
 786:ServerLLDN.c  **** 					appPanState = APP_PAN_STATE_DISC_PREPARE_ACK;
 787:ServerLLDN.c  **** 					break;
 788:ServerLLDN.c  **** 				}
 789:ServerLLDN.c  **** 				case APP_PAN_STATE_DISC_PREPARE_ACK:
 790:ServerLLDN.c  **** 				{
 791:ServerLLDN.c  **** 					/* This timer implements a delay between messages, 
 792:ServerLLDN.c  **** 					 * if not used the nodes are not able to receive the message
 793:ServerLLDN.c  **** 					 */
 794:ServerLLDN.c  **** 					appPanPrepareACK();
 795:ServerLLDN.c  **** 					SYS_TimerStart(&tmrDelay);
 796:ServerLLDN.c  **** 					
 797:ServerLLDN.c  **** 					appPanState = APP_PAN_STATE_CONFIG_INITIAL;
 798:ServerLLDN.c  **** 					appState = APP_STATE_IDLE;
 799:ServerLLDN.c  **** 					break;
 800:ServerLLDN.c  **** 				}
 801:ServerLLDN.c  **** 				case APP_PAN_STATE_CONFIG_INITIAL:
 802:ServerLLDN.c  **** 				{
 803:ServerLLDN.c  **** 					/* Prepares the message as: Configuration Beacon and First State Beacon */
 804:ServerLLDN.c  **** 					msgReq.options = NWK_OPT_LLDN_BEACON | NWK_OPT_CONFIG_STATE;
 805:ServerLLDN.c  **** 					msgReq.data = NULL;
 806:ServerLLDN.c  **** 					msgReq.size = 0;
 807:ServerLLDN.c  **** 					
 808:ServerLLDN.c  **** 					appState	= APP_STATE_IDLE;
 809:ServerLLDN.c  **** 					appPanState = APP_PAN_STATE_CONFIG_SECOND_BEACON;
 810:ServerLLDN.c  **** 					break;
 811:ServerLLDN.c  **** 
 812:ServerLLDN.c  **** 				}
 813:ServerLLDN.c  **** 				case APP_PAN_STATE_CONFIG_SECOND_BEACON:
 814:ServerLLDN.c  **** 				{
 815:ServerLLDN.c  **** 					/* Prepares the message as: Configuration Beacon and Second State Beacon */
 816:ServerLLDN.c  **** 					msgReq.options = NWK_OPT_LLDN_BEACON | NWK_OPT_CONFIG_STATE | NWK_OPT_SECOND_BEACON;
 817:ServerLLDN.c  **** 					msgReq.data = NULL;
 818:ServerLLDN.c  **** 					msgReq.size = 0;
 819:ServerLLDN.c  **** 					
 820:ServerLLDN.c  **** 					counter_delay_msg = 0;
 821:ServerLLDN.c  **** 					
 822:ServerLLDN.c  **** 					appState	= APP_STATE_IDLE;
 823:ServerLLDN.c  **** 					appPanState = APP_PAN_STATE_SEND_CONF_REQUEST;
 824:ServerLLDN.c  **** 					
 825:ServerLLDN.c  **** 					break;
 826:ServerLLDN.c  **** 				}
 827:ServerLLDN.c  **** 				case APP_PAN_STATE_SEND_CONF_REQUEST:
 828:ServerLLDN.c  **** 				{
 829:ServerLLDN.c  **** 					if(conf_req_list != NULL)
 830:ServerLLDN.c  **** 					{
 831:ServerLLDN.c  **** 						CopyToConfigRequest();
 832:ServerLLDN.c  **** 						msgReq.options		= NWK_OPT_MAC_COMMAND;
 833:ServerLLDN.c  **** 						msgReq.data			= (uint8_t*)&config_request_frame;
 834:ServerLLDN.c  **** 						msgReq.size			= sizeof(NWK_ConfigRequest_t);
 835:ServerLLDN.c  **** 						appState	= APP_STATE_IDLE;
 836:ServerLLDN.c  **** 						appPanState = APP_PAN_STATE_SEND_CONF_REQUEST;
 837:ServerLLDN.c  **** 						
 838:ServerLLDN.c  **** 						// Delay between messages
 839:ServerLLDN.c  **** 						macsc_set_cmp1_int_cb(downlink_delay_handler);
 840:ServerLLDN.c  **** 						macsc_disable_cmp_int(MACSC_CC1);
 841:ServerLLDN.c  **** 						macsc_enable_manual_bts();
 842:ServerLLDN.c  **** 						macsc_enable_cmp_int(MACSC_CC1);
 843:ServerLLDN.c  **** 						macsc_use_cmp(MACSC_RELATIVE_CMP, DELAY, MACSC_CC1);
 844:ServerLLDN.c  **** 						
 845:ServerLLDN.c  **** 						counter_associados++;
 846:ServerLLDN.c  **** 					}
 847:ServerLLDN.c  **** 					else
 848:ServerLLDN.c  **** 					{
 849:ServerLLDN.c  **** 						if(counter_delay_msg > 0)
 850:ServerLLDN.c  **** 						{
 851:ServerLLDN.c  **** 							macsc_set_cmp1_int_cb(lldn_server_beacon);
 852:ServerLLDN.c  **** 							macsc_disable_cmp_int(MACSC_CC1);
 853:ServerLLDN.c  **** 							macsc_enable_manual_bts();
 854:ServerLLDN.c  **** 							macsc_enable_cmp_int(MACSC_CC1);
 855:ServerLLDN.c  **** 							macsc_use_cmp(MACSC_RELATIVE_CMP,beaconInterval_association - counter_delay_msg * DELAY, MAC
 856:ServerLLDN.c  **** 						}
 857:ServerLLDN.c  **** 						
 858:ServerLLDN.c  **** 						appState	= APP_STATE_ATT_PAN_STATE;
 859:ServerLLDN.c  **** 						appPanState = APP_PAN_STATE_CONFIG_THIRD_BEACON;
 860:ServerLLDN.c  **** 					}
 861:ServerLLDN.c  **** 					break;
 862:ServerLLDN.c  **** 				}
 863:ServerLLDN.c  **** 				case APP_PAN_STATE_CONFIG_THIRD_BEACON:
 864:ServerLLDN.c  **** 				{
 865:ServerLLDN.c  **** 					msgReq.options = NWK_OPT_LLDN_BEACON | NWK_OPT_CONFIG_STATE | NWK_OPT_THIRD_BEACON;
 866:ServerLLDN.c  **** 					msgReq.data = NULL;
 867:ServerLLDN.c  **** 					msgReq.size = 0;
 868:ServerLLDN.c  **** 					
 869:ServerLLDN.c  **** 					appState	= APP_STATE_IDLE;
 870:ServerLLDN.c  **** 					appPanState = APP_PAN_STATE_DISC_INITIAL;
 871:ServerLLDN.c  **** 					cycles_counter++;	
 872:ServerLLDN.c  **** 					
 873:ServerLLDN.c  **** 					break;
 874:ServerLLDN.c  **** 				}
 875:ServerLLDN.c  **** 				case APP_PAN_STATE_ONLINE_INITIAL:
 876:ServerLLDN.c  **** 				{
 877:ServerLLDN.c  **** 					if(cycles_counter != 0)
 878:ServerLLDN.c  **** 					{
 879:ServerLLDN.c  **** 						appPanOnlineInit();
 880:ServerLLDN.c  **** 						appState = APP_STATE_SEND;
 881:ServerLLDN.c  **** 						appPanState = APP_PAN_STATE_ONLINE_PREPARE_ACK_GROUP;
 882:ServerLLDN.c  **** 						
 883:ServerLLDN.c  **** 						cycles_counter--;
 884:ServerLLDN.c  **** 					}
 885:ServerLLDN.c  **** 					else
 886:ServerLLDN.c  **** 					{
 887:ServerLLDN.c  **** 						appState = APP_STATE_IDLE;
 888:ServerLLDN.c  **** 						appPanState = APP_PAN_STATE_IDLE;
 889:ServerLLDN.c  **** 						macsc_disable_cmp_int(MACSC_CC1);
 890:ServerLLDN.c  **** 						
 891:ServerLLDN.c  **** 						printf("\n\n Mtricas:\n");
 892:ServerLLDN.c  **** 						int total_msg = 0;
 893:ServerLLDN.c  **** 						for(int i = 0; nodes_info_arr[i].mac_addr != 0 && assTimeSlot > i; i++)
 894:ServerLLDN.c  **** 						{
 895:ServerLLDN.c  **** 							printf("\nAddrs %hhx", nodes_info_arr[i].mac_addr);
 896:ServerLLDN.c  **** 							printf("\nMensagens Recebidas  %d", nodes_info_arr[i].msg_rec);
 897:ServerLLDN.c  **** 							printf("\nMensagens Recebidas  %d", nodes_info_arr[i].msg_not_rec);
 898:ServerLLDN.c  **** 							printf("\nRssi Mdio %f\n", nodes_info_arr[i].average_rssi);
 899:ServerLLDN.c  **** 							
 900:ServerLLDN.c  **** 							total_msg = total_msg + nodes_info_arr[i].msg_rec;
 901:ServerLLDN.c  **** 						}
 902:ServerLLDN.c  **** 						if(assTimeSlot > 0 && total_msg > 0)
 903:ServerLLDN.c  **** 						{
 904:ServerLLDN.c  **** 							succes_rate = total_msg /(assTimeSlot * (float)NUMERO_CICLOS_ONLINE);
 905:ServerLLDN.c  **** 							printf("Taxa de Sucesso : %.2f", succes_rate);
 906:ServerLLDN.c  **** 						}
 907:ServerLLDN.c  **** 					}
 908:ServerLLDN.c  **** 					break;
 909:ServerLLDN.c  **** 				}
 910:ServerLLDN.c  **** 				case APP_PAN_STATE_ONLINE_PREPARE_ACK_GROUP:
 911:ServerLLDN.c  **** 				{
 912:ServerLLDN.c  **** 					for(int i = 0; i < 32; i++)
 913:ServerLLDN.c  **** 					{
 914:ServerLLDN.c  **** 						ACKFrame.ackFlags[i] = 0;
 915:ServerLLDN.c  **** 						retransmit_ts_array[i] = 0;
 916:ServerLLDN.c  **** 					}
 917:ServerLLDN.c  **** 					retransmit_ts_array_counter = 0;
 918:ServerLLDN.c  **** 					ACKFrame_size = 0;
 919:ServerLLDN.c  **** 					
 920:ServerLLDN.c  **** 					msgReq.dstAddr		= 0;
 921:ServerLLDN.c  **** 					msgReq.dstEndpoint	= APP_BEACON_ENDPOINT;
 922:ServerLLDN.c  **** 					msgReq.srcEndpoint	= APP_BEACON_ENDPOINT;
 923:ServerLLDN.c  **** 					msgReq.options		= NWK_OPT_LLDN_ACK;
 924:ServerLLDN.c  **** 					msgReq.data	= (uint8_t *)&ACKFrame;
 925:ServerLLDN.c  **** 					msgReq.size	= sizeof(uint8_t)*(macLLDNRetransmitTS + 1);
 926:ServerLLDN.c  **** 					
 927:ServerLLDN.c  **** 					appState = APP_STATE_IDLE;
 928:ServerLLDN.c  **** 					appPanState = APP_PAN_STATE_IDLE;
 929:ServerLLDN.c  **** 					break;
 930:ServerLLDN.c  **** 				}				
 931:ServerLLDN.c  **** 				case APP_PAN_STATE_CHECK_TS:
 932:ServerLLDN.c  **** 				{
 933:ServerLLDN.c  **** 					if(timeslot_counter >= (macLLDNnumUplinkTS + MacLLDNMgmtTS))
 934:ServerLLDN.c  **** 					{
 935:ServerLLDN.c  **** 						if(!association_request)
 936:ServerLLDN.c  **** 						{
 937:ServerLLDN.c  **** 							macsc_set_cmp1_int_cb(end_of_association_delay_handler);
 938:ServerLLDN.c  **** 							macsc_disable_cmp_int(MACSC_CC1);
 939:ServerLLDN.c  **** 							macsc_enable_manual_bts();
 940:ServerLLDN.c  **** 							macsc_enable_cmp_int(MACSC_CC1);
 941:ServerLLDN.c  **** 							macsc_use_cmp(MACSC_RELATIVE_CMP, 5 * beaconInterval_association, MACSC_CC1);
 942:ServerLLDN.c  **** 						}
 943:ServerLLDN.c  **** 						/* implementar futuramente pedidos de reassociao */		
 944:ServerLLDN.c  **** 						appState = APP_STATE_IDLE;
 945:ServerLLDN.c  **** 						appPanState = APP_PAN_STATE_IDLE;
 946:ServerLLDN.c  **** 					}
 947:ServerLLDN.c  **** 					else
 948:ServerLLDN.c  **** 					{
 949:ServerLLDN.c  **** 
 950:ServerLLDN.c  **** 						/* check if coordinator received any message in last time slot, used to calculate success rat
 951:ServerLLDN.c  **** 						if(timeslot_counter >= 2*MacLLDNMgmtTS && !data_received && timeslot_counter < 2*MacLLDNMgmtT
 952:ServerLLDN.c  **** 						{
 953:ServerLLDN.c  **** 							nodes_info_arr[timeslot_counter - 2*MacLLDNMgmtTS].msg_not_rec++;
 954:ServerLLDN.c  **** 							retransmit_ts_array[retransmit_ts_array_counter++] = timeslot_counter - 2*MacLLDNMgmtTS; 
 955:ServerLLDN.c  **** 						}
 956:ServerLLDN.c  **** 						data_received = false;
 957:ServerLLDN.c  **** 						
 958:ServerLLDN.c  **** 						printf("\n------- slot %d --------", timeslot_counter);
 959:ServerLLDN.c  **** 						
 960:ServerLLDN.c  **** 						if(timeslot_counter == 1)
 961:ServerLLDN.c  **** 						{
 962:ServerLLDN.c  **** 							macsc_disable_cmp_int(MACSC_CC1);
 963:ServerLLDN.c  **** 							macsc_use_cmp(MACSC_RELATIVE_CMP, tTS / (SYMBOL_TIME), MACSC_CC1);
 964:ServerLLDN.c  **** 							macsc_enable_cmp_int(MACSC_CC1);
 965:ServerLLDN.c  **** 						}
 966:ServerLLDN.c  **** 							
 967:ServerLLDN.c  **** 						if(timeslot_counter == MacLLDNMgmtTS + macLLDNRetransmitTS)
 968:ServerLLDN.c  **** 						{
 969:ServerLLDN.c  **** 							data_received = true;
 970:ServerLLDN.c  **** 							printf("\nack_frame %hhx", ACKFrame.ackFlags[0]);
 971:ServerLLDN.c  **** 							appSendData();
 972:ServerLLDN.c  **** 							appPanState = APP_PAN_STATE_IDLE;
 973:ServerLLDN.c  **** 						}
 974:ServerLLDN.c  **** 						else
 975:ServerLLDN.c  **** 							appState = APP_STATE_IDLE;
 976:ServerLLDN.c  **** 						timeslot_counter++;
 977:ServerLLDN.c  **** 						appPanState = APP_PAN_STATE_IDLE;
 978:ServerLLDN.c  **** 						appState = APP_STATE_IDLE;
 979:ServerLLDN.c  **** 
 980:ServerLLDN.c  **** 						macsc_enable_manual_bts();
 981:ServerLLDN.c  **** 						
 982:ServerLLDN.c  **** 					}
 983:ServerLLDN.c  **** 					break;
 984:ServerLLDN.c  **** 				}
 985:ServerLLDN.c  **** 				case APP_PAN_STATE_IDLE:
 986:ServerLLDN.c  **** 				{
 987:ServerLLDN.c  **** 					msgReq.options = 0;
 988:ServerLLDN.c  **** 					appState = APP_STATE_IDLE;
 989:ServerLLDN.c  **** 					break;
 990:ServerLLDN.c  **** 				}
 991:ServerLLDN.c  **** 			}
 992:ServerLLDN.c  **** 			break;	
 993:ServerLLDN.c  **** 		}
 994:ServerLLDN.c  **** 		#else // NODES SPECIFIC STATE MACHINE
 995:ServerLLDN.c  **** 		case APP_STATE_PREP_DISC_REPONSE:
 996:ServerLLDN.c  **** 		{
 997:ServerLLDN.c  **** 			appPrepareDiscoverResponse();
 998:ServerLLDN.c  **** 			appState = APP_STATE_IDLE;	
 999:ServerLLDN.c  **** 			break;
1000:ServerLLDN.c  **** 		}
1001:ServerLLDN.c  **** 		
1002:ServerLLDN.c  **** 		case APP_STATE_PREP_CONFIG_STATUS:
1003:ServerLLDN.c  **** 		{
1004:ServerLLDN.c  **** 			// se o nodo recebeu ack na fase do discovery prepara a mensagem de configuration status
1005:ServerLLDN.c  **** 			if(ack_received && rec_beacon.confSeqNumber == 0 && associated == 0 && STATE != ONLINE_MODE) {
1006:ServerLLDN.c  **** 				appPrepareConfigurationStatus();
1007:ServerLLDN.c  **** 			}
1008:ServerLLDN.c  **** 			// se o nodo no recebeu desativa o timer e fica em idle
1009:ServerLLDN.c  **** 			else {
1010:ServerLLDN.c  **** 				#if MASTER_MACSC
1011:ServerLLDN.c  **** 				macsc_disable_cmp_int(MACSC_CC1);
1012:ServerLLDN.c  **** 				#else
1013:ServerLLDN.c  **** 				timer_stop();
1014:ServerLLDN.c  **** 				#endif
1015:ServerLLDN.c  **** 			}
1016:ServerLLDN.c  **** 			ack_received = 0;
1017:ServerLLDN.c  **** 			appState = APP_STATE_IDLE;
1018:ServerLLDN.c  **** 			break;
1019:ServerLLDN.c  **** 		}
1020:ServerLLDN.c  **** 		case APP_STATE_PREP_DATA_FRAME:
1021:ServerLLDN.c  **** 		{
1022:ServerLLDN.c  **** 			appPrepareDataFrame();
1023:ServerLLDN.c  **** 			appState = APP_STATE_IDLE;
1024:ServerLLDN.c  **** 			break;
1025:ServerLLDN.c  **** 		}
1026:ServerLLDN.c  **** 		case APP_STATE_RETRANSMIT_DATA:
1027:ServerLLDN.c  **** 		{
1028:ServerLLDN.c  **** 			if(!ack_received)
1029:ServerLLDN.c  **** 			{
1030:ServerLLDN.c  **** 				appState = APP_STATE_IDLE;
1031:ServerLLDN.c  **** 				
1032:ServerLLDN.c  **** 				int retransmition_slot = 0;
1033:ServerLLDN.c  **** 				
1034:ServerLLDN.c  **** 				
1035:ServerLLDN.c  **** 				for(int i = 0; i < assTimeSlot - 1 && i < (rec_beacon.NumberOfBaseTimeslotsinSuperframe - 3)/2;
1036:ServerLLDN.c  **** 					if( !check_ack(i) )
1037:ServerLLDN.c  **** 						retransmition_slot++;
1038:ServerLLDN.c  **** 					
1039:ServerLLDN.c  **** 				printf("\nretransmition_slot %d", retransmition_slot);
1040:ServerLLDN.c  **** 				
1041:ServerLLDN.c  **** 				if(retransmition_slot == 0)
1042:ServerLLDN.c  **** 				{
1043:ServerLLDN.c  **** 					appSendData();
1044:ServerLLDN.c  **** 					// appState = APP_STATE_SEND;			
1045:ServerLLDN.c  **** 				}
1046:ServerLLDN.c  **** 				else
1047:ServerLLDN.c  **** 				{
1048:ServerLLDN.c  **** 					#if MASTER_MACSC
1049:ServerLLDN.c  **** 					macsc_enable_manual_bts();
1050:ServerLLDN.c  **** 					macsc_set_cmp1_int_cb(send_message_timeHandler);
1051:ServerLLDN.c  **** 					macsc_enable_cmp_int(MACSC_CC1);
1052:ServerLLDN.c  **** 					macsc_use_cmp(MACSC_RELATIVE_CMP, ts_time * retransmition_slot, MACSC_CC1);
1053:ServerLLDN.c  **** 					#endif
1054:ServerLLDN.c  **** 				}
1055:ServerLLDN.c  **** 				
1056:ServerLLDN.c  **** 			}
1057:ServerLLDN.c  **** 			else
1058:ServerLLDN.c  **** 			{
1059:ServerLLDN.c  **** 				appState = APP_STATE_IDLE;
1060:ServerLLDN.c  **** 			}
1061:ServerLLDN.c  **** 			
1062:ServerLLDN.c  **** 			break;
1063:ServerLLDN.c  **** 		}
1064:ServerLLDN.c  **** 		#endif
1065:ServerLLDN.c  **** 		default:
1066:ServerLLDN.c  **** 		{
1067:ServerLLDN.c  **** 			break;
 1977               		.loc 6 1067 0
 1978 0a2c 00C0      		rjmp .L63
 1979               	.L57:
 708:ServerLLDN.c  **** 	switch (appState){
 1980               		.loc 6 708 0
 1981 0a2e 8630      		cpi r24,6
 1982 0a30 9105      		cpc r25,__zero_reg__
 1983 0a32 01F0      		breq .L60
 1984 0a34 8630      		cpi r24,6
 1985 0a36 9105      		cpc r25,__zero_reg__
 1986 0a38 04F0      		brlt .L61
 1987 0a3a 0797      		sbiw r24,7
 1988 0a3c 01F0      		breq .L62
 1989               		.loc 6 1067 0
 1990 0a3e 00C0      		rjmp .L63
 1991               	.L58:
 711:ServerLLDN.c  **** 			#if APP_COORDINATOR
 1992               		.loc 6 711 0
 1993 0a40 0E94 0000 		call appInit
 715:ServerLLDN.c  **** 			#endif
 1994               		.loc 6 715 0
 1995 0a44 81E0      		ldi r24,lo8(1)
 1996 0a46 8093 0000 		sts appState,r24
 717:ServerLLDN.c  **** 		}
 1997               		.loc 6 717 0
 1998 0a4a 00C0      		rjmp .L63
 1999               	.L59:
 721:ServerLLDN.c  **** 			#if APP_COORDINATOR
 2000               		.loc 6 721 0
 2001 0a4c 0E94 0000 		call appSendData
 726:ServerLLDN.c  **** 			#endif
 2002               		.loc 6 726 0
 2003 0a50 81E0      		ldi r24,lo8(1)
 2004 0a52 8093 0000 		sts appState,r24
 728:ServerLLDN.c  **** 		}
 2005               		.loc 6 728 0
 2006 0a56 00C0      		rjmp .L63
 2007               	.L56:
 997:ServerLLDN.c  **** 			appState = APP_STATE_IDLE;	
 2008               		.loc 6 997 0
 2009 0a58 0E94 0000 		call appPrepareDiscoverResponse
 998:ServerLLDN.c  **** 			break;
 2010               		.loc 6 998 0
 2011 0a5c 81E0      		ldi r24,lo8(1)
 2012 0a5e 8093 0000 		sts appState,r24
 999:ServerLLDN.c  **** 		}
 2013               		.loc 6 999 0
 2014 0a62 00C0      		rjmp .L63
 2015               	.L61:
1005:ServerLLDN.c  **** 				appPrepareConfigurationStatus();
 2016               		.loc 6 1005 0
 2017 0a64 8091 0000 		lds r24,ack_received
 2018 0a68 8823      		tst r24
 2019 0a6a 01F0      		breq .L64
1005:ServerLLDN.c  **** 				appPrepareConfigurationStatus();
 2020               		.loc 6 1005 0 is_stmt 0 discriminator 1
 2021 0a6c 8091 0000 		lds r24,rec_beacon+5
 2022 0a70 8823      		tst r24
 2023 0a72 01F4      		brne .L64
1005:ServerLLDN.c  **** 				appPrepareConfigurationStatus();
 2024               		.loc 6 1005 0 discriminator 2
 2025 0a74 9091 0000 		lds r25,associated
 2026 0a78 81E0      		ldi r24,lo8(1)
 2027 0a7a 8927      		eor r24,r25
 2028 0a7c 8823      		tst r24
 2029 0a7e 01F0      		breq .L64
1005:ServerLLDN.c  **** 				appPrepareConfigurationStatus();
 2030               		.loc 6 1005 0 discriminator 3
 2031 0a80 8091 0000 		lds r24,STATE
 2032 0a84 8823      		tst r24
 2033 0a86 01F0      		breq .L64
1006:ServerLLDN.c  **** 			}
 2034               		.loc 6 1006 0 is_stmt 1
 2035 0a88 0E94 0000 		call appPrepareConfigurationStatus
 2036 0a8c 00C0      		rjmp .L65
 2037               	.L64:
1011:ServerLLDN.c  **** 				#else
 2038               		.loc 6 1011 0
 2039 0a8e 81E0      		ldi r24,lo8(1)
 2040 0a90 0E94 0000 		call macsc_disable_cmp_int
 2041               	.L65:
1016:ServerLLDN.c  **** 			appState = APP_STATE_IDLE;
 2042               		.loc 6 1016 0
 2043 0a94 1092 0000 		sts ack_received,__zero_reg__
1017:ServerLLDN.c  **** 			break;
 2044               		.loc 6 1017 0
 2045 0a98 81E0      		ldi r24,lo8(1)
 2046 0a9a 8093 0000 		sts appState,r24
1018:ServerLLDN.c  **** 		}
 2047               		.loc 6 1018 0
 2048 0a9e 00C0      		rjmp .L63
 2049               	.L60:
1022:ServerLLDN.c  **** 			appState = APP_STATE_IDLE;
 2050               		.loc 6 1022 0
 2051 0aa0 0E94 0000 		call appPrepareDataFrame
1023:ServerLLDN.c  **** 			break;
 2052               		.loc 6 1023 0
 2053 0aa4 81E0      		ldi r24,lo8(1)
 2054 0aa6 8093 0000 		sts appState,r24
1024:ServerLLDN.c  **** 		}
 2055               		.loc 6 1024 0
 2056 0aaa 00C0      		rjmp .L63
 2057               	.L62:
1028:ServerLLDN.c  **** 			{
 2058               		.loc 6 1028 0
 2059 0aac 9091 0000 		lds r25,ack_received
 2060 0ab0 81E0      		ldi r24,lo8(1)
 2061 0ab2 8927      		eor r24,r25
 2062 0ab4 8823      		tst r24
 2063 0ab6 01F4      		brne .+2
 2064 0ab8 00C0      		rjmp .L66
 2065               	.LBB7:
1030:ServerLLDN.c  **** 				
 2066               		.loc 6 1030 0
 2067 0aba 81E0      		ldi r24,lo8(1)
 2068 0abc 8093 0000 		sts appState,r24
1032:ServerLLDN.c  **** 				
 2069               		.loc 6 1032 0
 2070 0ac0 1A82      		std Y+2,__zero_reg__
 2071 0ac2 1982      		std Y+1,__zero_reg__
 2072               	.LBB8:
1035:ServerLLDN.c  **** 					if( !check_ack(i) )
 2073               		.loc 6 1035 0
 2074 0ac4 1C82      		std Y+4,__zero_reg__
 2075 0ac6 1B82      		std Y+3,__zero_reg__
 2076 0ac8 00C0      		rjmp .L67
 2077               	.L71:
1036:ServerLLDN.c  **** 						retransmition_slot++;
 2078               		.loc 6 1036 0
 2079 0aca 8B81      		ldd r24,Y+3
 2080 0acc 9C81      		ldd r25,Y+4
 2081 0ace 0E94 0000 		call check_ack
 2082 0ad2 982F      		mov r25,r24
 2083 0ad4 81E0      		ldi r24,lo8(1)
 2084 0ad6 8927      		eor r24,r25
 2085 0ad8 8823      		tst r24
 2086 0ada 01F0      		breq .L68
1037:ServerLLDN.c  **** 					
 2087               		.loc 6 1037 0
 2088 0adc 8981      		ldd r24,Y+1
 2089 0ade 9A81      		ldd r25,Y+2
 2090 0ae0 0196      		adiw r24,1
 2091 0ae2 9A83      		std Y+2,r25
 2092 0ae4 8983      		std Y+1,r24
 2093               	.L68:
1035:ServerLLDN.c  **** 					if( !check_ack(i) )
 2094               		.loc 6 1035 0 discriminator 2
 2095 0ae6 8B81      		ldd r24,Y+3
 2096 0ae8 9C81      		ldd r25,Y+4
 2097 0aea 0196      		adiw r24,1
 2098 0aec 9C83      		std Y+4,r25
 2099 0aee 8B83      		std Y+3,r24
 2100               	.L67:
1035:ServerLLDN.c  **** 					if( !check_ack(i) )
 2101               		.loc 6 1035 0 is_stmt 0 discriminator 1
 2102 0af0 8091 0000 		lds r24,assTimeSlot
 2103 0af4 882F      		mov r24,r24
 2104 0af6 90E0      		ldi r25,0
 2105 0af8 9C01      		movw r18,r24
 2106 0afa 2150      		subi r18,1
 2107 0afc 3109      		sbc r19,__zero_reg__
 2108 0afe 8B81      		ldd r24,Y+3
 2109 0b00 9C81      		ldd r25,Y+4
 2110 0b02 8217      		cp r24,r18
 2111 0b04 9307      		cpc r25,r19
 2112 0b06 04F4      		brge .L69
1035:ServerLLDN.c  **** 					if( !check_ack(i) )
 2113               		.loc 6 1035 0 discriminator 3
 2114 0b08 8091 0000 		lds r24,rec_beacon+7
 2115 0b0c 882F      		mov r24,r24
 2116 0b0e 90E0      		ldi r25,0
 2117 0b10 0397      		sbiw r24,3
 2118 0b12 9923      		tst r25
 2119 0b14 04F4      		brge .L70
 2120 0b16 0196      		adiw r24,1
 2121               	.L70:
 2122 0b18 9595      		asr r25
 2123 0b1a 8795      		ror r24
 2124 0b1c 9C01      		movw r18,r24
 2125 0b1e 8B81      		ldd r24,Y+3
 2126 0b20 9C81      		ldd r25,Y+4
 2127 0b22 8217      		cp r24,r18
 2128 0b24 9307      		cpc r25,r19
 2129 0b26 04F0      		brlt .L71
 2130               	.L69:
 2131               	.LBE8:
1039:ServerLLDN.c  **** 				
 2132               		.loc 6 1039 0 is_stmt 1
 2133 0b28 8A81      		ldd r24,Y+2
 2134 0b2a 8F93      		push r24
 2135 0b2c 8981      		ldd r24,Y+1
 2136 0b2e 8F93      		push r24
 2137 0b30 80E0      		ldi r24,lo8(.LC9)
 2138 0b32 90E0      		ldi r25,hi8(.LC9)
 2139 0b34 892F      		mov r24,r25
 2140 0b36 8F93      		push r24
 2141 0b38 80E0      		ldi r24,lo8(.LC9)
 2142 0b3a 90E0      		ldi r25,hi8(.LC9)
 2143 0b3c 8F93      		push r24
 2144 0b3e 0E94 0000 		call printf
 2145 0b42 0F90      		pop __tmp_reg__
 2146 0b44 0F90      		pop __tmp_reg__
 2147 0b46 0F90      		pop __tmp_reg__
 2148 0b48 0F90      		pop __tmp_reg__
1041:ServerLLDN.c  **** 				{
 2149               		.loc 6 1041 0
 2150 0b4a 8981      		ldd r24,Y+1
 2151 0b4c 9A81      		ldd r25,Y+2
 2152 0b4e 892B      		or r24,r25
 2153 0b50 01F4      		brne .L72
1043:ServerLLDN.c  **** 					// appState = APP_STATE_SEND;			
 2154               		.loc 6 1043 0
 2155 0b52 0E94 0000 		call appSendData
 2156               	.LBE7:
1062:ServerLLDN.c  **** 		}
 2157               		.loc 6 1062 0
 2158 0b56 00C0      		rjmp .L75
 2159               	.L72:
 2160               	.LBB9:
1049:ServerLLDN.c  **** 					macsc_set_cmp1_int_cb(send_message_timeHandler);
 2161               		.loc 6 1049 0
 2162 0b58 0E94 0000 		call macsc_enable_manual_bts
1050:ServerLLDN.c  **** 					macsc_enable_cmp_int(MACSC_CC1);
 2163               		.loc 6 1050 0
 2164 0b5c 80E0      		ldi r24,lo8(gs(send_message_timeHandler))
 2165 0b5e 90E0      		ldi r25,hi8(gs(send_message_timeHandler))
 2166 0b60 0E94 0000 		call macsc_set_cmp1_int_cb
1051:ServerLLDN.c  **** 					macsc_use_cmp(MACSC_RELATIVE_CMP, ts_time * retransmition_slot, MACSC_CC1);
 2167               		.loc 6 1051 0
 2168 0b64 81E0      		ldi r24,lo8(1)
 2169 0b66 0E94 0000 		call macsc_enable_cmp_int
1052:ServerLLDN.c  **** 					#endif
 2170               		.loc 6 1052 0
 2171 0b6a 4091 0000 		lds r20,ts_time
 2172 0b6e 5091 0000 		lds r21,ts_time+1
 2173 0b72 2981      		ldd r18,Y+1
 2174 0b74 3A81      		ldd r19,Y+2
 2175 0b76 429F      		mul r20,r18
 2176 0b78 C001      		movw r24,r0
 2177 0b7a 439F      		mul r20,r19
 2178 0b7c 900D      		add r25,r0
 2179 0b7e 529F      		mul r21,r18
 2180 0b80 900D      		add r25,r0
 2181 0b82 1124      		clr r1
 2182 0b84 092E      		mov __tmp_reg__,r25
 2183 0b86 000C      		lsl r0
 2184 0b88 AA0B      		sbc r26,r26
 2185 0b8a BB0B      		sbc r27,r27
 2186 0b8c 21E0      		ldi r18,lo8(1)
 2187 0b8e AC01      		movw r20,r24
 2188 0b90 BD01      		movw r22,r26
 2189 0b92 81E0      		ldi r24,lo8(1)
 2190 0b94 0E94 0000 		call macsc_use_cmp
 2191               	.LBE9:
1062:ServerLLDN.c  **** 		}
 2192               		.loc 6 1062 0
 2193 0b98 00C0      		rjmp .L75
 2194               	.L66:
1059:ServerLLDN.c  **** 			}
 2195               		.loc 6 1059 0
 2196 0b9a 81E0      		ldi r24,lo8(1)
 2197 0b9c 8093 0000 		sts appState,r24
 2198               	.L75:
1062:ServerLLDN.c  **** 		}
 2199               		.loc 6 1062 0
 2200 0ba0 0000      		nop
 2201               	.L63:
1068:ServerLLDN.c  **** 		}
1069:ServerLLDN.c  **** 	}
1070:ServerLLDN.c  **** }
 2202               		.loc 6 1070 0
 2203 0ba2 0000      		nop
 2204               	/* epilogue start */
 2205 0ba4 0F90      		pop __tmp_reg__
 2206 0ba6 0F90      		pop __tmp_reg__
 2207 0ba8 0F90      		pop __tmp_reg__
 2208 0baa 0F90      		pop __tmp_reg__
 2209 0bac DF91      		pop r29
 2210 0bae CF91      		pop r28
 2211 0bb0 0895      		ret
 2212               		.cfi_endproc
 2213               	.LFE141:
 2215               		.section	.rodata
 2216               	.LC0:
 2217 009c 00        		.byte	0
 2218 009d C2        		.byte	-62
 2219 009e 01        		.byte	1
 2220 009f 00        		.byte	0
 2221 00a0 03        		.byte	3
 2222 00a1 00        		.byte	0
 2223 00a2 00        		.byte	0
 2224               		.text
 2225               	.global	main
 2227               	main:
 2228               	.LFB142:
1071:ServerLLDN.c  **** 
1072:ServerLLDN.c  **** 	/*****************************************************************************
1073:ServerLLDN.c  **** 	*****************************************************************************/
1074:ServerLLDN.c  **** 	int main(void)
1075:ServerLLDN.c  **** 	{
 2229               		.loc 6 1075 0
 2230               		.cfi_startproc
 2231 0bb2 0F93      		push r16
 2232               	.LCFI71:
 2233               		.cfi_def_cfa_offset 3
 2234               		.cfi_offset 16, -2
 2235 0bb4 1F93      		push r17
 2236               	.LCFI72:
 2237               		.cfi_def_cfa_offset 4
 2238               		.cfi_offset 17, -3
 2239 0bb6 CF93      		push r28
 2240               	.LCFI73:
 2241               		.cfi_def_cfa_offset 5
 2242               		.cfi_offset 28, -4
 2243 0bb8 DF93      		push r29
 2244               	.LCFI74:
 2245               		.cfi_def_cfa_offset 6
 2246               		.cfi_offset 29, -5
 2247 0bba CDB7      		in r28,__SP_L__
 2248 0bbc DEB7      		in r29,__SP_H__
 2249               	.LCFI75:
 2250               		.cfi_def_cfa_register 28
 2251 0bbe 2797      		sbiw r28,7
 2252               	.LCFI76:
 2253               		.cfi_def_cfa_offset 13
 2254 0bc0 0FB6      		in __tmp_reg__,__SREG__
 2255 0bc2 F894      		cli
 2256 0bc4 DEBF      		out __SP_H__,r29
 2257 0bc6 0FBE      		out __SREG__,__tmp_reg__
 2258 0bc8 CDBF      		out __SP_L__,r28
 2259               	/* prologue: function */
 2260               	/* frame size = 7 */
 2261               	/* stack size = 11 */
 2262               	.L__stack_usage = 11
1076:ServerLLDN.c  **** 		sysclk_init();
 2263               		.loc 6 1076 0
 2264 0bca 0E94 0000 		call sysclk_init
1077:ServerLLDN.c  **** 		board_init();
 2265               		.loc 6 1077 0
 2266 0bce 0E94 0000 		call board_init
1078:ServerLLDN.c  **** 
1079:ServerLLDN.c  **** 		SYS_Init();
 2267               		.loc 6 1079 0
 2268 0bd2 0E94 0000 		call SYS_Init
1080:ServerLLDN.c  **** 		/* Disable CSMA/CA
1081:ServerLLDN.c  **** 		 * Disable auto ACK
1082:ServerLLDN.c  **** 		 * Enable Rx of LLDN Frame Type as described in 802.15.4e - 2012 
1083:ServerLLDN.c  **** 		 */
1084:ServerLLDN.c  **** 
1085:ServerLLDN.c  **** 		sm_init();
 2269               		.loc 6 1085 0
 2270 0bd6 0E94 0000 		call sm_init
1086:ServerLLDN.c  **** 
1087:ServerLLDN.c  **** 		// Initialize interrupt vector table support.
1088:ServerLLDN.c  **** 	#if (SIO2HOST_CHANNEL == SIO_USB)
1089:ServerLLDN.c  **** 		irq_initialize_vectors();
1090:ServerLLDN.c  **** 	#endif
1091:ServerLLDN.c  **** 		cpu_irq_enable();
 2271               		.loc 6 1091 0
 2272               	/* #APP */
 2273               	 ;  1091 "ServerLLDN.c" 1
 2274 0bda 7894      		sei
 2275               	 ;  0 "" 2
1092:ServerLLDN.c  **** 
1093:ServerLLDN.c  **** 	#if 1
1094:ServerLLDN.c  **** 	#if (SIO2HOST_CHANNEL == SIO_USB)
1095:ServerLLDN.c  **** 		stdio_usb_init();
1096:ServerLLDN.c  **** 	#else
1097:ServerLLDN.c  **** 		const usart_serial_options_t usart_serial_options =
 2276               		.loc 6 1097 0
 2277               	/* #NOAPP */
 2278 0bdc 27E0      		ldi r18,lo8(7)
 2279 0bde E0E0      		ldi r30,lo8(.LC0)
 2280 0be0 F0E0      		ldi r31,hi8(.LC0)
 2281 0be2 CE01      		movw r24,r28
 2282 0be4 0196      		adiw r24,1
 2283 0be6 DC01      		movw r26,r24
 2284               		0:
 2285 0be8 0190      		ld r0,Z+
 2286 0bea 0D92      		st X+,r0
 2287 0bec 2A95      		dec r18
 2288 0bee 01F4      		brne 0b
1098:ServerLLDN.c  **** 		{
1099:ServerLLDN.c  **** 			.baudrate     = USART_HOST_BAUDRATE,
1100:ServerLLDN.c  **** 			.charlength   = USART_HOST_CHAR_LENGTH,
1101:ServerLLDN.c  **** 			.paritytype   = USART_HOST_PARITY,
1102:ServerLLDN.c  **** 			.stopbits     = USART_HOST_STOP_BITS
1103:ServerLLDN.c  **** 		};
1104:ServerLLDN.c  **** 
1105:ServerLLDN.c  **** 		stdio_serial_init(USART_HOST, &usart_serial_options);
 2289               		.loc 6 1105 0
 2290 0bf0 CE01      		movw r24,r28
 2291 0bf2 0196      		adiw r24,1
 2292 0bf4 BC01      		movw r22,r24
 2293 0bf6 80EC      		ldi r24,lo8(-64)
 2294 0bf8 90E0      		ldi r25,0
 2295 0bfa 0E94 0000 		call stdio_serial_init
1106:ServerLLDN.c  **** 		usart_double_baud_enable(USART_HOST);
 2296               		.loc 6 1106 0
 2297 0bfe 80EC      		ldi r24,lo8(-64)
 2298 0c00 90E0      		ldi r25,0
 2299 0c02 0E94 0000 		call usart_double_baud_enable
1107:ServerLLDN.c  **** 		usart_set_baudrate_precalculated(USART_HOST, USART_HOST_BAUDRATE, sysclk_get_source_clock_hz());
 2300               		.loc 6 1107 0
 2301 0c06 0E94 0000 		call sysclk_get_source_clock_hz
 2302 0c0a DC01      		movw r26,r24
 2303 0c0c CB01      		movw r24,r22
 2304 0c0e 8C01      		movw r16,r24
 2305 0c10 9D01      		movw r18,r26
 2306 0c12 40E0      		ldi r20,0
 2307 0c14 52EC      		ldi r21,lo8(-62)
 2308 0c16 61E0      		ldi r22,lo8(1)
 2309 0c18 70E0      		ldi r23,0
 2310 0c1a 80EC      		ldi r24,lo8(-64)
 2311 0c1c 90E0      		ldi r25,0
 2312 0c1e 0E94 0000 		call usart_set_baudrate_precalculated
 2313               	.L77:
1108:ServerLLDN.c  **** 
1109:ServerLLDN.c  **** 	#endif
1110:ServerLLDN.c  **** 	#endif
1111:ServerLLDN.c  **** 		for(;;)
1112:ServerLLDN.c  **** 		{
1113:ServerLLDN.c  **** 			SYS_TaskHandler();
 2314               		.loc 6 1113 0 discriminator 1
 2315 0c22 0E94 0000 		call SYS_TaskHandler
1114:ServerLLDN.c  **** 			APP_TaskHandler();
 2316               		.loc 6 1114 0 discriminator 1
 2317 0c26 0E94 0000 		call APP_TaskHandler
1115:ServerLLDN.c  **** 		}
 2318               		.loc 6 1115 0 discriminator 1
 2319 0c2a 00C0      		rjmp .L77
 2320               		.cfi_endproc
 2321               	.LFE142:
 2323               	.Letext0:
 2324               		.file 7 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\in
 2325               		.file 8 "../../../stack/LwMesh/TDMA/nwk/inc/nwkFrame.h"
 2326               		.file 9 "../../../stack/LwMesh/TDMA/nwk/inc/nwkRx.h"
 2327               		.file 10 "../../../stack/LwMesh/TDMA/nwk/inc/nwkDataReq.h"
 2328               		.file 11 "lldn.h"
 2329               		.file 12 "../../../platform/mega_rf/drivers/sleep/sleep.h"
 2330               		.file 13 "../../../platform/mega_rf/utils/status_codes.h"
 2331               		.file 14 "config/config.h"
 2332               		.file 15 "../../../platform/common/services/sleepmgr/mega_rf/sleepmgr.h"
DEFINED SYMBOLS
                            *ABS*:00000000 ServerLLDN.c
C:\Users\GUILHE~1\AppData\Local\Temp\cckab22O.s:2      *ABS*:0000003e __SP_H__
C:\Users\GUILHE~1\AppData\Local\Temp\cckab22O.s:3      *ABS*:0000003d __SP_L__
C:\Users\GUILHE~1\AppData\Local\Temp\cckab22O.s:4      *ABS*:0000003f __SREG__
C:\Users\GUILHE~1\AppData\Local\Temp\cckab22O.s:5      *ABS*:0000003b __RAMPZ__
C:\Users\GUILHE~1\AppData\Local\Temp\cckab22O.s:6      *ABS*:00000000 __tmp_reg__
C:\Users\GUILHE~1\AppData\Local\Temp\cckab22O.s:7      *ABS*:00000001 __zero_reg__
C:\Users\GUILHE~1\AppData\Local\Temp\cckab22O.s:15     .bss.n:00000000 n
                            *COM*:00000004 tTS
                            *COM*:00000002 macLLDNnumTimeSlots
                            *COM*:00000002 macLLDNnumUplinkTS
                            *COM*:00000002 macLLDNRetransmitTS
C:\Users\GUILHE~1\AppData\Local\Temp\cckab22O.s:23     .text:00000000 sysclk_get_main_hz
C:\Users\GUILHE~1\AppData\Local\Temp\cckab22O.s:60     .text:0000001a sysclk_get_source_clock_hz
C:\Users\GUILHE~1\AppData\Local\Temp\cckab22O.s:97     .progmem.data.baudctrl_1mhz:00000000 baudctrl_1mhz
C:\Users\GUILHE~1\AppData\Local\Temp\cckab22O.s:109    .progmem.data.baudctrl_8mhz:00000000 baudctrl_8mhz
C:\Users\GUILHE~1\AppData\Local\Temp\cckab22O.s:121    .progmem.data.baudctrl_16mhz:00000000 baudctrl_16mhz
C:\Users\GUILHE~1\AppData\Local\Temp\cckab22O.s:132    .text:00000034 usart_double_baud_enable
C:\Users\GUILHE~1\AppData\Local\Temp\cckab22O.s:181    .text:00000062 usart_serial_init
C:\Users\GUILHE~1\AppData\Local\Temp\cckab22O.s:276    .text:000000de usart_serial_putchar
C:\Users\GUILHE~1\AppData\Local\Temp\cckab22O.s:320    .text:00000106 usart_serial_getchar
C:\Users\GUILHE~1\AppData\Local\Temp\cckab22O.s:371    .text:0000013c stdio_serial_init
C:\Users\GUILHE~1\AppData\Local\Temp\cckab22O.s:442    .text:0000019e macsc_enable_manual_bts
C:\Users\GUILHE~1\AppData\Local\Temp\cckab22O.s:496    .bss.appState:00000000 appState
C:\Users\GUILHE~1\AppData\Local\Temp\cckab22O.s:501    .bss.msgReq:00000000 msgReq
C:\Users\GUILHE~1\AppData\Local\Temp\cckab22O.s:506    .bss.PanId:00000000 PanId
C:\Users\GUILHE~1\AppData\Local\Temp\cckab22O.s:514    .text:000001d2 appSendData
C:\Users\GUILHE~1\AppData\Local\Temp\cckab22O.s:576    .data.payloadSize:00000000 payloadSize
C:\Users\GUILHE~1\AppData\Local\Temp\cckab22O.s:582    .data.assTimeSlot:00000000 assTimeSlot
                            *COM*:00000008 rec_beacon
                            *COM*:00000002 ackframe
C:\Users\GUILHE~1\AppData\Local\Temp\cckab22O.s:589    .data.msgDiscResponse:00000000 msgDiscResponse
C:\Users\GUILHE~1\AppData\Local\Temp\cckab22O.s:596    .data.msgConfigStatus:00000000 msgConfigStatus
C:\Users\GUILHE~1\AppData\Local\Temp\cckab22O.s:606    .data.data_payload:00000000 data_payload
C:\Users\GUILHE~1\AppData\Local\Temp\cckab22O.s:611    .bss.ack_received:00000000 ack_received
C:\Users\GUILHE~1\AppData\Local\Temp\cckab22O.s:617    .bss.MacLLDNMgmtTS:00000000 MacLLDNMgmtTS
C:\Users\GUILHE~1\AppData\Local\Temp\cckab22O.s:623    .bss.associated:00000000 associated
                            *COM*:00000002 ts_time
C:\Users\GUILHE~1\AppData\Local\Temp\cckab22O.s:630    .data.STATE:00000000 STATE
C:\Users\GUILHE~1\AppData\Local\Temp\cckab22O.s:637    .text:0000021e send_message_timeHandler
C:\Users\GUILHE~1\AppData\Local\Temp\cckab22O.s:687    .text:00000256 start_timer
C:\Users\GUILHE~1\AppData\Local\Temp\cckab22O.s:756    .text:0000029c appBeaconInd
C:\Users\GUILHE~1\AppData\Local\Temp\cckab22O.s:1199   .text:000005be check_ack
C:\Users\GUILHE~1\AppData\Local\Temp\cckab22O.s:1348   .text:000006a2 appAckInd
C:\Users\GUILHE~1\AppData\Local\Temp\cckab22O.s:1593   .text:0000083a appCommandInd
C:\Users\GUILHE~1\AppData\Local\Temp\cckab22O.s:1710   .text:000008e4 appPrepareDiscoverResponse
C:\Users\GUILHE~1\AppData\Local\Temp\cckab22O.s:1763   .text:00000926 appPrepareConfigurationStatus
C:\Users\GUILHE~1\AppData\Local\Temp\cckab22O.s:1816   .text:00000968 appPrepareDataFrame
C:\Users\GUILHE~1\AppData\Local\Temp\cckab22O.s:1871   .text:000009b0 appInit
C:\Users\GUILHE~1\AppData\Local\Temp\cckab22O.s:1939   .text:00000a04 APP_TaskHandler
C:\Users\GUILHE~1\AppData\Local\Temp\cckab22O.s:2227   .text:00000bb2 main

UNDEFINED SYMBOLS
usart_init_rs232
usart_putchar
usart_getchar
stdio_base
ptr_put
ptr_get
_read
_write
fdevopen
printf
NWK_DataReq
macsc_disable_cmp_int
macsc_set_cmp1_int_cb
macsc_enable_cmp_int
macsc_use_cmp
__floatsisf
__addsf3
__divsf3
__fixsfsi
PHY_SetChannel
NWK_SetPanId
PHY_SetTdmaMode
NWK_SetAddr
PHY_SetRxState
NWK_OpenEndpoint
PHY_SetPromiscuousMode
sysclk_init
board_init
SYS_Init
sm_init
usart_set_baudrate_precalculated
SYS_TaskHandler
__do_copy_data
__do_clear_bss
