   1               		.file	"ServerLLDN.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__RAMPZ__ = 0x3b
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.text
   9               	.Ltext0:
  10               		.cfi_sections	.debug_frame
  11               		.comm	n,1,1
  12               		.section	.bss.tTS,"aw",@nobits
  15               	tTS:
  16 0000 0000 0000 		.zero	4
  17               		.text
  19               	sysclk_get_main_hz:
  20               	.LFB67:
  21               		.file 1 "../../../platform/common/services/clock/mega/sysclk.h"
   1:../../../platform/common/services/clock/mega/sysclk.h **** /**
   2:../../../platform/common/services/clock/mega/sysclk.h ****  * \file
   3:../../../platform/common/services/clock/mega/sysclk.h ****  *
   4:../../../platform/common/services/clock/mega/sysclk.h ****  * \brief Chip-specific system clock management functions
   5:../../../platform/common/services/clock/mega/sysclk.h ****  *
   6:../../../platform/common/services/clock/mega/sysclk.h ****  * Copyright (c) 2012 Atmel Corporation. All rights reserved.
   7:../../../platform/common/services/clock/mega/sysclk.h ****  *
   8:../../../platform/common/services/clock/mega/sysclk.h ****  * \asf_license_start
   9:../../../platform/common/services/clock/mega/sysclk.h ****  *
  10:../../../platform/common/services/clock/mega/sysclk.h ****  * \page License
  11:../../../platform/common/services/clock/mega/sysclk.h ****  *
  12:../../../platform/common/services/clock/mega/sysclk.h ****  * Redistribution and use in source and binary forms, with or without
  13:../../../platform/common/services/clock/mega/sysclk.h ****  * modification, are permitted provided that the following conditions are met:
  14:../../../platform/common/services/clock/mega/sysclk.h ****  *
  15:../../../platform/common/services/clock/mega/sysclk.h ****  * 1. Redistributions of source code must retain the above copyright notice,
  16:../../../platform/common/services/clock/mega/sysclk.h ****  *    this list of conditions and the following disclaimer.
  17:../../../platform/common/services/clock/mega/sysclk.h ****  *
  18:../../../platform/common/services/clock/mega/sysclk.h ****  * 2. Redistributions in binary form must reproduce the above copyright notice,
  19:../../../platform/common/services/clock/mega/sysclk.h ****  *    this list of conditions and the following disclaimer in the documentation
  20:../../../platform/common/services/clock/mega/sysclk.h ****  *    and/or other materials provided with the distribution.
  21:../../../platform/common/services/clock/mega/sysclk.h ****  *
  22:../../../platform/common/services/clock/mega/sysclk.h ****  * 3. The name of Atmel may not be used to endorse or promote products derived
  23:../../../platform/common/services/clock/mega/sysclk.h ****  *    from this software without specific prior written permission.
  24:../../../platform/common/services/clock/mega/sysclk.h ****  *
  25:../../../platform/common/services/clock/mega/sysclk.h ****  * 4. This software may only be redistributed and used in connection with an
  26:../../../platform/common/services/clock/mega/sysclk.h ****  *    Atmel microcontroller product.
  27:../../../platform/common/services/clock/mega/sysclk.h ****  *
  28:../../../platform/common/services/clock/mega/sysclk.h ****  * THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR IMPLIED
  29:../../../platform/common/services/clock/mega/sysclk.h ****  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
  30:../../../platform/common/services/clock/mega/sysclk.h ****  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
  31:../../../platform/common/services/clock/mega/sysclk.h ****  * EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR
  32:../../../platform/common/services/clock/mega/sysclk.h ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  33:../../../platform/common/services/clock/mega/sysclk.h ****  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
  34:../../../platform/common/services/clock/mega/sysclk.h ****  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  35:../../../platform/common/services/clock/mega/sysclk.h ****  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
  36:../../../platform/common/services/clock/mega/sysclk.h ****  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  37:../../../platform/common/services/clock/mega/sysclk.h ****  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  38:../../../platform/common/services/clock/mega/sysclk.h ****  * POSSIBILITY OF SUCH DAMAGE.
  39:../../../platform/common/services/clock/mega/sysclk.h ****  *
  40:../../../platform/common/services/clock/mega/sysclk.h ****  * \asf_license_stop
  41:../../../platform/common/services/clock/mega/sysclk.h ****  *
  42:../../../platform/common/services/clock/mega/sysclk.h ****  */
  43:../../../platform/common/services/clock/mega/sysclk.h **** #ifndef MEGA_SYSCLK_H_INCLUDED
  44:../../../platform/common/services/clock/mega/sysclk.h **** #define MEGA_SYSCLK_H_INCLUDED
  45:../../../platform/common/services/clock/mega/sysclk.h **** 
  46:../../../platform/common/services/clock/mega/sysclk.h **** #include <board.h>
  47:../../../platform/common/services/clock/mega/sysclk.h **** #include <compiler.h>
  48:../../../platform/common/services/clock/mega/sysclk.h **** #include <parts.h>
  49:../../../platform/common/services/clock/mega/sysclk.h **** 
  50:../../../platform/common/services/clock/mega/sysclk.h **** /* Include clock configuration for the project. */
  51:../../../platform/common/services/clock/mega/sysclk.h **** #include <conf_clock.h>
  52:../../../platform/common/services/clock/mega/sysclk.h **** 
  53:../../../platform/common/services/clock/mega/sysclk.h **** #ifdef __cplusplus
  54:../../../platform/common/services/clock/mega/sysclk.h **** extern "C" {
  55:../../../platform/common/services/clock/mega/sysclk.h **** #endif
  56:../../../platform/common/services/clock/mega/sysclk.h **** #define ASM __asm__
  57:../../../platform/common/services/clock/mega/sysclk.h **** 
  58:../../../platform/common/services/clock/mega/sysclk.h **** /* CONFIG_SYSCLK_PSDIV  to use default if not defined*/
  59:../../../platform/common/services/clock/mega/sysclk.h **** #ifndef CONFIG_SYSCLK_PSDIV
  60:../../../platform/common/services/clock/mega/sysclk.h **** # define CONFIG_SYSCLK_PSDIV    SYSCLK_PSDIV_8
  61:../../../platform/common/services/clock/mega/sysclk.h **** #endif
  62:../../../platform/common/services/clock/mega/sysclk.h **** 
  63:../../../platform/common/services/clock/mega/sysclk.h **** /* ! \name Prescaler Setting (relative to CLKsys) */
  64:../../../platform/common/services/clock/mega/sysclk.h **** /* @{ */
  65:../../../platform/common/services/clock/mega/sysclk.h **** #define SYSCLK_PSDIV_1      0   /* !< Do not prescale */
  66:../../../platform/common/services/clock/mega/sysclk.h **** #define SYSCLK_PSDIV_2      1   /* !< Prescale CLKper4 by 2 */
  67:../../../platform/common/services/clock/mega/sysclk.h **** #define SYSCLK_PSDIV_4      2   /* !< Prescale CLKper4 by 4 */
  68:../../../platform/common/services/clock/mega/sysclk.h **** #define SYSCLK_PSDIV_8      3   /* !< Prescale CLKper4 by 8 */
  69:../../../platform/common/services/clock/mega/sysclk.h **** #define SYSCLK_PSDIV_16     4   /* !< Prescale CLKper4 by 16 */
  70:../../../platform/common/services/clock/mega/sysclk.h **** #define SYSCLK_PSDIV_32     5   /* !< Prescale CLKper4 by 32 */
  71:../../../platform/common/services/clock/mega/sysclk.h **** #define SYSCLK_PSDIV_64     6   /* !< Prescale CLKper4 by 64 */
  72:../../../platform/common/services/clock/mega/sysclk.h **** #define SYSCLK_PSDIV_128    7   /* !< Prescale CLKper4 by 128 */
  73:../../../platform/common/services/clock/mega/sysclk.h **** #define SYSCLK_PSDIV_256    8   /* !< Prescale CLKper4 by 256 */
  74:../../../platform/common/services/clock/mega/sysclk.h **** 
  75:../../../platform/common/services/clock/mega/sysclk.h **** /* @} */
  76:../../../platform/common/services/clock/mega/sysclk.h **** 
  77:../../../platform/common/services/clock/mega/sysclk.h **** #if MEGA_RF || MEGA_XX0_1 || MEGA_XX4 || MEGA_XX4_A
  78:../../../platform/common/services/clock/mega/sysclk.h **** 
  79:../../../platform/common/services/clock/mega/sysclk.h **** #define NUMBER_OF_POWER_REG       2
  80:../../../platform/common/services/clock/mega/sysclk.h **** /*Starting Address for power reduction*/
  81:../../../platform/common/services/clock/mega/sysclk.h **** #define POWER_REG_ADD             PRR0
  82:../../../platform/common/services/clock/mega/sysclk.h **** 
  83:../../../platform/common/services/clock/mega/sysclk.h **** /* ! \name Power Reduction  Clock Port Numbers */
  84:../../../platform/common/services/clock/mega/sysclk.h **** enum power_red_id {
  85:../../../platform/common/services/clock/mega/sysclk.h **** 	POWER_RED_REG0,     /* !< Devices on PRR0 */
  86:../../../platform/common/services/clock/mega/sysclk.h **** #if !MEGA_XX4 || !MEGA_XX4_A || MEGA_XX0_1
  87:../../../platform/common/services/clock/mega/sysclk.h **** 	POWER_RED_REG1,     /* !< Devices on PRR1 */
  88:../../../platform/common/services/clock/mega/sysclk.h **** #endif
  89:../../../platform/common/services/clock/mega/sysclk.h **** };
  90:../../../platform/common/services/clock/mega/sysclk.h **** #endif
  91:../../../platform/common/services/clock/mega/sysclk.h **** 
  92:../../../platform/common/services/clock/mega/sysclk.h **** /****************************************************
  93:../../../platform/common/services/clock/mega/sysclk.h ****  * Given a dummy type but not used for these groups
  94:../../../platform/common/services/clock/mega/sysclk.h ****  * to support for otherthen megaRF device.
  95:../../../platform/common/services/clock/mega/sysclk.h ****  **************************************************/
  96:../../../platform/common/services/clock/mega/sysclk.h **** #if MEGA_XX8 || MEGA_XX8_A || MEGA_UNSPECIFIED
  97:../../../platform/common/services/clock/mega/sysclk.h **** #define NUMBER_OF_POWER_REG       1
  98:../../../platform/common/services/clock/mega/sysclk.h **** /*Starting Address for power reduction*/
  99:../../../platform/common/services/clock/mega/sysclk.h **** #define POWER_REG_ADD             PRR
 100:../../../platform/common/services/clock/mega/sysclk.h **** 
 101:../../../platform/common/services/clock/mega/sysclk.h **** /* ! \name Power Reduction  Clock Port Numbers */
 102:../../../platform/common/services/clock/mega/sysclk.h **** enum power_red_id {
 103:../../../platform/common/services/clock/mega/sysclk.h **** 	POWER_RED_REG0,     /* !< Devices on PRR */
 104:../../../platform/common/services/clock/mega/sysclk.h **** };
 105:../../../platform/common/services/clock/mega/sysclk.h **** #endif
 106:../../../platform/common/services/clock/mega/sysclk.h **** 
 107:../../../platform/common/services/clock/mega/sysclk.h **** /* Bit mask for the power reduction register based on */
 108:../../../platform/common/services/clock/mega/sysclk.h **** /*   MCU ARCH.                                        */
 109:../../../platform/common/services/clock/mega/sysclk.h **** #if MEGA_RF
 110:../../../platform/common/services/clock/mega/sysclk.h **** /*Bit mask for PRR2 */
 111:../../../platform/common/services/clock/mega/sysclk.h **** 
 112:../../../platform/common/services/clock/mega/sysclk.h **** #define PRRAM0_bm                       1 << PRRAM0
 113:../../../platform/common/services/clock/mega/sysclk.h **** #define PRRAM1_bm                       1 << PRRAM1
 114:../../../platform/common/services/clock/mega/sysclk.h **** #define PRRAM2_bm                       1 << PRRAM2
 115:../../../platform/common/services/clock/mega/sysclk.h **** #define PRRAM3_bm                       1 << PRRAM3
 116:../../../platform/common/services/clock/mega/sysclk.h **** #endif
 117:../../../platform/common/services/clock/mega/sysclk.h **** 
 118:../../../platform/common/services/clock/mega/sysclk.h **** /*Bit mask for the power reduction 0 or PRR*/
 119:../../../platform/common/services/clock/mega/sysclk.h **** #if !MEGA_XX_UN0 && !MEGA_XX_UN0
 120:../../../platform/common/services/clock/mega/sysclk.h **** #define PRADC_bm                        1 << PRADC
 121:../../../platform/common/services/clock/mega/sysclk.h **** #define PRUSART0_bm                     1 << PRUSART0
 122:../../../platform/common/services/clock/mega/sysclk.h **** #define PRSPI_bm                        1 << PRSPI
 123:../../../platform/common/services/clock/mega/sysclk.h **** #define PRTIM1_bm                       1 << PRTIM1
 124:../../../platform/common/services/clock/mega/sysclk.h **** #endif
 125:../../../platform/common/services/clock/mega/sysclk.h **** 
 126:../../../platform/common/services/clock/mega/sysclk.h **** #if MEGA_RF
 127:../../../platform/common/services/clock/mega/sysclk.h **** #define PRPGA_bm                        1 << PRPGA
 128:../../../platform/common/services/clock/mega/sysclk.h **** #endif
 129:../../../platform/common/services/clock/mega/sysclk.h **** 
 130:../../../platform/common/services/clock/mega/sysclk.h **** #if !MEGA_UNSPECIFIED
 131:../../../platform/common/services/clock/mega/sysclk.h **** #define PRTIM0_bm                       1 << PRTIM0
 132:../../../platform/common/services/clock/mega/sysclk.h **** #define PRTIM2_bm                       1 << PRTIM2
 133:../../../platform/common/services/clock/mega/sysclk.h **** #define PRTWI_bm                        1 << PRTWI
 134:../../../platform/common/services/clock/mega/sysclk.h **** #endif
 135:../../../platform/common/services/clock/mega/sysclk.h **** 
 136:../../../platform/common/services/clock/mega/sysclk.h **** #if MEGA_XX_UN2
 137:../../../platform/common/services/clock/mega/sysclk.h **** #define PRLCD_bm                        1 << PRLCD
 138:../../../platform/common/services/clock/mega/sysclk.h **** #endif
 139:../../../platform/common/services/clock/mega/sysclk.h **** 
 140:../../../platform/common/services/clock/mega/sysclk.h **** /*Bit mask for  PRR1  */
 141:../../../platform/common/services/clock/mega/sysclk.h **** #ifdef PRR1
 142:../../../platform/common/services/clock/mega/sysclk.h **** #if (MEGA_XX4 || MEGA_XX4_A)
 143:../../../platform/common/services/clock/mega/sysclk.h **** #define PRTIM3_bm                       1 << PRTIM3
 144:../../../platform/common/services/clock/mega/sysclk.h **** #endif
 145:../../../platform/common/services/clock/mega/sysclk.h **** #endif
 146:../../../platform/common/services/clock/mega/sysclk.h **** 
 147:../../../platform/common/services/clock/mega/sysclk.h **** #if MEGA_RF || MEGA_XX4 || MEGA_XX4_A
 148:../../../platform/common/services/clock/mega/sysclk.h **** #define PRUSART1_bm                     1 << PRUSART1
 149:../../../platform/common/services/clock/mega/sysclk.h **** #define PRUSART2_bm                     1 << PRUSART2
 150:../../../platform/common/services/clock/mega/sysclk.h **** #define PRUSART3_bm                     1 << PRUSART3
 151:../../../platform/common/services/clock/mega/sysclk.h **** #define PRTIM3_bm                       1 << PRTIM3
 152:../../../platform/common/services/clock/mega/sysclk.h **** #define PRTIM4_bm                       1 << PRTIM4
 153:../../../platform/common/services/clock/mega/sysclk.h **** #define PRTIM5_bm                       1 << PRTIM5
 154:../../../platform/common/services/clock/mega/sysclk.h **** #endif
 155:../../../platform/common/services/clock/mega/sysclk.h **** 
 156:../../../platform/common/services/clock/mega/sysclk.h **** #if MEGA_RF
 157:../../../platform/common/services/clock/mega/sysclk.h **** #define PRTRX24_bm                      1 << PRTRX24
 158:../../../platform/common/services/clock/mega/sysclk.h **** #endif
 159:../../../platform/common/services/clock/mega/sysclk.h **** 
 160:../../../platform/common/services/clock/mega/sysclk.h **** /**
 161:../../../platform/common/services/clock/mega/sysclk.h ****  * \name Querying the system clock and its derived clocks
 162:../../../platform/common/services/clock/mega/sysclk.h ****  */
 163:../../../platform/common/services/clock/mega/sysclk.h **** /* @{ */
 164:../../../platform/common/services/clock/mega/sysclk.h **** 
 165:../../../platform/common/services/clock/mega/sysclk.h **** /**
 166:../../../platform/common/services/clock/mega/sysclk.h ****  * \brief Return the current rate in Hz of the main system clock
 167:../../../platform/common/services/clock/mega/sysclk.h ****  * To know the clock value at what frequency the main clock is running
 168:../../../platform/common/services/clock/mega/sysclk.h ****  * \return Frequency of the main system clock, in Hz.
 169:../../../platform/common/services/clock/mega/sysclk.h ****  * \todo : please initialize the SYSCLK_SOURCE in conf_clock.h file for
 170:../../../platform/common/services/clock/mega/sysclk.h ****  * configured source clock using fuses.
 171:../../../platform/common/services/clock/mega/sysclk.h ****  * \eg. #define SYSCLK_SOURCE SYSCLK_SRC_RC16MHZ to use internal RC
 172:../../../platform/common/services/clock/mega/sysclk.h ****  * oscillator for clock source.
 173:../../../platform/common/services/clock/mega/sysclk.h ****  */
 174:../../../platform/common/services/clock/mega/sysclk.h **** static inline uint32_t sysclk_get_main_hz(void)
 175:../../../platform/common/services/clock/mega/sysclk.h **** {
  22               		.loc 1 175 0
  23               		.cfi_startproc
  24 0000 CF93      		push r28
  25               	.LCFI0:
  26               		.cfi_def_cfa_offset 3
  27               		.cfi_offset 28, -2
  28 0002 DF93      		push r29
  29               	.LCFI1:
  30               		.cfi_def_cfa_offset 4
  31               		.cfi_offset 29, -3
  32 0004 CDB7      		in r28,__SP_L__
  33 0006 DEB7      		in r29,__SP_H__
  34               	.LCFI2:
  35               		.cfi_def_cfa_register 28
  36               	/* prologue: function */
  37               	/* frame size = 0 */
  38               	/* stack size = 2 */
  39               	.L__stack_usage = 2
 176:../../../platform/common/services/clock/mega/sysclk.h **** 	switch (SYSCLK_SOURCE) {
 177:../../../platform/common/services/clock/mega/sysclk.h **** 	case SYSCLK_SRC_RC16MHZ:
 178:../../../platform/common/services/clock/mega/sysclk.h **** 		return 16000000UL;
 179:../../../platform/common/services/clock/mega/sysclk.h **** 
 180:../../../platform/common/services/clock/mega/sysclk.h **** 	case SYSCLK_SRC_RC128KHZ:
 181:../../../platform/common/services/clock/mega/sysclk.h **** 		return 128000UL;
 182:../../../platform/common/services/clock/mega/sysclk.h **** 
 183:../../../platform/common/services/clock/mega/sysclk.h **** #if MEGA_RF
 184:../../../platform/common/services/clock/mega/sysclk.h **** 	case SYSCLK_SRC_TRS16MHZ:
 185:../../../platform/common/services/clock/mega/sysclk.h **** 		return 16000000UL;
  40               		.loc 1 185 0
  41 0008 80E0      		ldi r24,0
  42 000a 94E2      		ldi r25,lo8(36)
  43 000c A4EF      		ldi r26,lo8(-12)
  44 000e B0E0      		ldi r27,0
 186:../../../platform/common/services/clock/mega/sysclk.h **** #endif
 187:../../../platform/common/services/clock/mega/sysclk.h **** #ifdef BOARD_EXTERNAL_CLK
 188:../../../platform/common/services/clock/mega/sysclk.h **** 	case SYSCLK_SRC_EXTERNAL:
 189:../../../platform/common/services/clock/mega/sysclk.h **** 		return BOARD_EXTERNAL_CLK;
 190:../../../platform/common/services/clock/mega/sysclk.h **** #endif
 191:../../../platform/common/services/clock/mega/sysclk.h **** 	default:
 192:../../../platform/common/services/clock/mega/sysclk.h **** 
 193:../../../platform/common/services/clock/mega/sysclk.h **** 		return 1000000UL;
 194:../../../platform/common/services/clock/mega/sysclk.h **** 	}
 195:../../../platform/common/services/clock/mega/sysclk.h **** }
  45               		.loc 1 195 0
  46 0010 BC01      		movw r22,r24
  47 0012 CD01      		movw r24,r26
  48               	/* epilogue start */
  49 0014 DF91      		pop r29
  50 0016 CF91      		pop r28
  51 0018 0895      		ret
  52               		.cfi_endproc
  53               	.LFE67:
  56               	sysclk_get_source_clock_hz:
  57               	.LFB68:
 196:../../../platform/common/services/clock/mega/sysclk.h **** 
 197:../../../platform/common/services/clock/mega/sysclk.h **** /**
 198:../../../platform/common/services/clock/mega/sysclk.h ****  * \brief Return the current rate in Hz of source clock in Hz.
 199:../../../platform/common/services/clock/mega/sysclk.h ****  *
 200:../../../platform/common/services/clock/mega/sysclk.h ****  * This clock always runs at the same rate as the CPU clock unless the divider
 201:../../../platform/common/services/clock/mega/sysclk.h ****  * is set.
 202:../../../platform/common/services/clock/mega/sysclk.h ****  *
 203:../../../platform/common/services/clock/mega/sysclk.h ****  * \return Frequency of the system clock, in Hz.
 204:../../../platform/common/services/clock/mega/sysclk.h ****  */
 205:../../../platform/common/services/clock/mega/sysclk.h **** static inline uint32_t sysclk_get_source_clock_hz(void)
 206:../../../platform/common/services/clock/mega/sysclk.h **** {
  58               		.loc 1 206 0
  59               		.cfi_startproc
  60 001a CF93      		push r28
  61               	.LCFI3:
  62               		.cfi_def_cfa_offset 3
  63               		.cfi_offset 28, -2
  64 001c DF93      		push r29
  65               	.LCFI4:
  66               		.cfi_def_cfa_offset 4
  67               		.cfi_offset 29, -3
  68 001e CDB7      		in r28,__SP_L__
  69 0020 DEB7      		in r29,__SP_H__
  70               	.LCFI5:
  71               		.cfi_def_cfa_register 28
  72               	/* prologue: function */
  73               	/* frame size = 0 */
  74               	/* stack size = 2 */
  75               	.L__stack_usage = 2
 207:../../../platform/common/services/clock/mega/sysclk.h **** 	switch (CONFIG_SYSCLK_PSDIV) {
 208:../../../platform/common/services/clock/mega/sysclk.h **** 	case SYSCLK_PSDIV_1: /* Fall through */
 209:../../../platform/common/services/clock/mega/sysclk.h **** 		if (SYSCLK_SOURCE == SYSCLK_SRC_RC16MHZ ||
 210:../../../platform/common/services/clock/mega/sysclk.h **** 				SYSCLK_SOURCE == SYSCLK_SRC_RC128KHZ) {
 211:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 2;
 212:../../../platform/common/services/clock/mega/sysclk.h **** 		} else {
 213:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz();
  76               		.loc 1 213 0
  77 0022 0E94 0000 		call sysclk_get_main_hz
  78 0026 DC01      		movw r26,r24
  79 0028 CB01      		movw r24,r22
 214:../../../platform/common/services/clock/mega/sysclk.h **** 		}
 215:../../../platform/common/services/clock/mega/sysclk.h **** 
 216:../../../platform/common/services/clock/mega/sysclk.h **** 	case SYSCLK_PSDIV_2:
 217:../../../platform/common/services/clock/mega/sysclk.h **** 		if (SYSCLK_SOURCE == SYSCLK_SRC_RC16MHZ ||
 218:../../../platform/common/services/clock/mega/sysclk.h **** 				SYSCLK_SOURCE == SYSCLK_SRC_RC128KHZ) {
 219:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 4;
 220:../../../platform/common/services/clock/mega/sysclk.h **** 		} else {
 221:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 2;
 222:../../../platform/common/services/clock/mega/sysclk.h **** 		}
 223:../../../platform/common/services/clock/mega/sysclk.h **** 
 224:../../../platform/common/services/clock/mega/sysclk.h **** 	case SYSCLK_PSDIV_4:
 225:../../../platform/common/services/clock/mega/sysclk.h **** 		if (SYSCLK_SOURCE == SYSCLK_SRC_RC16MHZ ||
 226:../../../platform/common/services/clock/mega/sysclk.h **** 				SYSCLK_SOURCE == SYSCLK_SRC_RC128KHZ) {
 227:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 8;
 228:../../../platform/common/services/clock/mega/sysclk.h **** 		} else {
 229:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 4;
 230:../../../platform/common/services/clock/mega/sysclk.h **** 		}
 231:../../../platform/common/services/clock/mega/sysclk.h **** 
 232:../../../platform/common/services/clock/mega/sysclk.h **** 	case SYSCLK_PSDIV_8:
 233:../../../platform/common/services/clock/mega/sysclk.h **** 		if (SYSCLK_SOURCE == SYSCLK_SRC_RC16MHZ ||
 234:../../../platform/common/services/clock/mega/sysclk.h **** 				SYSCLK_SOURCE == SYSCLK_SRC_RC128KHZ) {
 235:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 16;
 236:../../../platform/common/services/clock/mega/sysclk.h **** 		} else {
 237:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 8;
 238:../../../platform/common/services/clock/mega/sysclk.h **** 		}
 239:../../../platform/common/services/clock/mega/sysclk.h **** 
 240:../../../platform/common/services/clock/mega/sysclk.h **** 	case SYSCLK_PSDIV_16:
 241:../../../platform/common/services/clock/mega/sysclk.h **** 		if (SYSCLK_SOURCE == SYSCLK_SRC_RC16MHZ ||
 242:../../../platform/common/services/clock/mega/sysclk.h **** 				SYSCLK_SOURCE == SYSCLK_SRC_RC128KHZ) {
 243:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 32;
 244:../../../platform/common/services/clock/mega/sysclk.h **** 		} else {
 245:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 16;
 246:../../../platform/common/services/clock/mega/sysclk.h **** 		}
 247:../../../platform/common/services/clock/mega/sysclk.h **** 
 248:../../../platform/common/services/clock/mega/sysclk.h **** 	case SYSCLK_PSDIV_32:
 249:../../../platform/common/services/clock/mega/sysclk.h **** 		if (SYSCLK_SOURCE == SYSCLK_SRC_RC16MHZ ||
 250:../../../platform/common/services/clock/mega/sysclk.h **** 				SYSCLK_SOURCE == SYSCLK_SRC_RC128KHZ) {
 251:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 64;
 252:../../../platform/common/services/clock/mega/sysclk.h **** 		} else {
 253:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 32;
 254:../../../platform/common/services/clock/mega/sysclk.h **** 		}
 255:../../../platform/common/services/clock/mega/sysclk.h **** 
 256:../../../platform/common/services/clock/mega/sysclk.h **** 	case SYSCLK_PSDIV_64:
 257:../../../platform/common/services/clock/mega/sysclk.h **** 		if (SYSCLK_SOURCE == SYSCLK_SRC_RC16MHZ ||
 258:../../../platform/common/services/clock/mega/sysclk.h **** 				SYSCLK_SOURCE == SYSCLK_SRC_RC128KHZ) {
 259:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 128;
 260:../../../platform/common/services/clock/mega/sysclk.h **** 		} else {
 261:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 64;
 262:../../../platform/common/services/clock/mega/sysclk.h **** 		}
 263:../../../platform/common/services/clock/mega/sysclk.h **** 
 264:../../../platform/common/services/clock/mega/sysclk.h **** 	case SYSCLK_PSDIV_128:
 265:../../../platform/common/services/clock/mega/sysclk.h **** 		if (SYSCLK_SOURCE == SYSCLK_SRC_RC16MHZ ||
 266:../../../platform/common/services/clock/mega/sysclk.h **** 				SYSCLK_SOURCE == SYSCLK_SRC_RC128KHZ) {
 267:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 256;
 268:../../../platform/common/services/clock/mega/sysclk.h **** 		} else {
 269:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 128;
 270:../../../platform/common/services/clock/mega/sysclk.h **** 		}
 271:../../../platform/common/services/clock/mega/sysclk.h **** 
 272:../../../platform/common/services/clock/mega/sysclk.h **** 	case SYSCLK_PSDIV_256:
 273:../../../platform/common/services/clock/mega/sysclk.h **** 		if (SYSCLK_SOURCE == SYSCLK_SRC_RC16MHZ ||
 274:../../../platform/common/services/clock/mega/sysclk.h **** 				SYSCLK_SOURCE == SYSCLK_SRC_RC128KHZ) {
 275:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 512;
 276:../../../platform/common/services/clock/mega/sysclk.h **** 		} else {
 277:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 256;
 278:../../../platform/common/services/clock/mega/sysclk.h **** 		}
 279:../../../platform/common/services/clock/mega/sysclk.h **** 
 280:../../../platform/common/services/clock/mega/sysclk.h **** 	default:
 281:../../../platform/common/services/clock/mega/sysclk.h **** 		/*Invalide case*/
 282:../../../platform/common/services/clock/mega/sysclk.h **** 		return 0;
 283:../../../platform/common/services/clock/mega/sysclk.h **** 	}
 284:../../../platform/common/services/clock/mega/sysclk.h **** }
  80               		.loc 1 284 0
  81 002a BC01      		movw r22,r24
  82 002c CD01      		movw r24,r26
  83               	/* epilogue start */
  84 002e DF91      		pop r29
  85 0030 CF91      		pop r28
  86 0032 0895      		ret
  87               		.cfi_endproc
  88               	.LFE68:
  90               		.section	.progmem.data.baudctrl_1mhz,"a",@progbits
  93               	baudctrl_1mhz:
  94 0000 3300      		.word	51
  95 0002 1900      		.word	25
  96 0004 0C00      		.word	12
  97 0006 0600      		.word	6
  98 0008 0300      		.word	3
  99 000a 0200      		.word	2
 100 000c 0100      		.word	1
 101 000e FF00      		.word	255
 102               		.section	.progmem.data.baudctrl_8mhz,"a",@progbits
 105               	baudctrl_8mhz:
 106 0000 A001      		.word	416
 107 0002 CF00      		.word	207
 108 0004 6700      		.word	103
 109 0006 3300      		.word	51
 110 0008 1900      		.word	25
 111 000a 0C00      		.word	12
 112 000c 0700      		.word	7
 113 000e 0800      		.word	8
 114               		.section	.progmem.data.baudctrl_16mhz,"a",@progbits
 117               	baudctrl_16mhz:
 118 0000 4003      		.word	832
 119 0002 A001      		.word	416
 120 0004 CF00      		.word	207
 121 0006 6700      		.word	103
 122 0008 3300      		.word	51
 123 000a 1900      		.word	25
 124 000c 1000      		.word	16
 125 000e 1000      		.word	16
 126               		.text
 128               	usart_double_baud_enable:
 129               	.LFB101:
 130               		.file 2 "../../../platform/mega_rf/drivers/usart/usart_megarf.h"
   1:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
   2:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \file
   3:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
   4:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief USART driver for AVR MEGARF.
   5:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
   6:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * This file contains basic functions for the AVR MEGA USART, with support for
   7:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * all modes, settings and clock speeds.
   8:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
   9:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * Copyright (c) 2013-2015 Atmel Corporation. All rights reserved.
  10:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
  11:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \asf_license_start
  12:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
  13:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \page License
  14:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
  15:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * Redistribution and use in source and binary forms, with or without
  16:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * modification, are permitted provided that the following conditions are met:
  17:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
  18:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * 1. Redistributions of source code must retain the above copyright notice,
  19:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *    this list of conditions and the following disclaimer.
  20:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
  21:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * 2. Redistributions in binary form must reproduce the above copyright notice,
  22:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *    this list of conditions and the following disclaimer in the documentation
  23:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *    and/or other materials provided with the distribution.
  24:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
  25:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * 3. The name of Atmel may not be used to endorse or promote products derived
  26:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *    from this software without specific prior written permission.
  27:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
  28:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * 4. This software may only be redistributed and used in connection with an
  29:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *    Atmel microcontroller product.
  30:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
  31:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR IMPLIED
  32:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
  33:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
  34:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR
  35:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  36:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
  37:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  38:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
  39:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  40:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  41:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * POSSIBILITY OF SUCH DAMAGE.
  42:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
  43:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \asf_license_stop
  44:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
  45:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
  46:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #ifndef _USART_MEGARF_H_
  47:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define _USART_MEGARF_H_
  48:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
  49:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #ifdef __cplusplus
  50:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** extern "C" {
  51:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #endif
  52:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
  53:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #include "compiler.h"
  54:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #include "status_codes.h"
  55:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
  56:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
  57:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \defgroup megarf_usart_group USART module (USART)
  58:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
  59:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * See \ref megarf_usart_quickstart.
  60:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
  61:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * This is a driver for configuring, enabling, disabling and use of the on-chip
  62:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * USART.
  63:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
  64:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \section dependencies Dependencies
  65:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
  66:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * The USART module depends on the following modules:
  67:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *  - \ref sysclk_group for peripheral clock control.
  68:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *  - \ref port_driver_group for peripheral io port control.
  69:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
  70:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * @{
  71:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
  72:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
  73:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* ! Offset in lookup table for baudrate 1200 */
  74:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_BAUD_1200      0x00
  75:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* ! Offset in lookup table for baudrate 2400 */
  76:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_BAUD_2400      0x01
  77:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* ! Offset in lookup table for baudrate 4800 */
  78:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_BAUD_4800      0x02
  79:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* ! Offset in lookup table for baudrate 9600 */
  80:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_BAUD_9600      0x03
  81:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* ! Offset in lookup table for baudrate 19200 */
  82:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_BAUD_19200     0x04
  83:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* ! Offset in lookup table for baudrate 38400 */
  84:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_BAUD_38400     0x05
  85:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* ! Offset in lookup table for baudrate 57600 */
  86:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_BAUD_57600     0x06
  87:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* ! Offset in lookup table for baudrate 115200 */
  88:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_BAUD_115200    0x07
  89:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* ! Baudrate not in lookup table */
  90:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_BAUD_UNDEFINED 0xFF
  91:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
  92:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** typedef volatile uint8_t register8_t;
  93:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** typedef volatile uint16_t register16_t;
  94:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* Universal Synchronous/Asynchronous Receiver/Transmitter */
  95:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** typedef struct USART_struct {
  96:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	register8_t UCSRnA;  /* Control Register A */
  97:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	register8_t UCSRnB;  /* Control Register B */
  98:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	register8_t UCSRnC;  /* Control Register C */
  99:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	register8_t reserved;
 100:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	register16_t UBRR;  /* Baud Rate Register Value */
 101:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	register8_t UDR;  /* I/O Data Register */
 102:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** } USART_t;
 103:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 104:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USARTA0    (*(USART_t *)0xC0)   /* Universal Asynchronous
 105:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	                                 * Receiver-Transmitter A0 */
 106:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USARTA1    (*(USART_t *)0XC8)   /* Universal Asynchronous
 107:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	                                 * Receiver-Transmitter A1 */
 108:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 109:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* USART.UCSRxA  bit masks and bit positions */
 110:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_RXC_bm  0x80 /* RX complete bit mask.*/
 111:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_RXC_bp  7 /* RX complete bit position.*/
 112:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 113:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_TXC_bm  0x40 /* TX complete bit mask.*/
 114:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_TXC_bp  6 /* TX complete bit position.*/
 115:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 116:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_DRE_bm  0x20 /* DATA Register Empty Bit mask.*/
 117:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_DRE_bp  5 /*  DATA Register Empty bit position.*/
 118:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 119:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_FE_bm   0x10 /* Frame Error bit mask.*/
 120:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_FE_bp   4 /*Frame error bit position.*/
 121:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 122:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_DOR_bm  0x08 /* Data Over Run bit mask.*/
 123:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_DOR_bp  3 /* Data Over Run bit position.*/
 124:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 125:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_UPE_bm  0x04 /* Parity error bit mask.*/
 126:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_UPE_bp  2 /* Parity error bit position.*/
 127:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 128:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_U2X_bm  0x02 /* Double TX speed bit mask.*/
 129:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_U2X_bp  1 /* Double TX speed bit position.*/
 130:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 131:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_MPCM_bm  0x01 /* Multi Processor bit mask.*/
 132:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_MPMC_bp  0 /* Multi processor bit position.*/
 133:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 134:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* USART.UCSRxB  bit masks and bit positions */
 135:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_RXCIE_bm  0x80 /* RX complete interrupt Enable bit mask.*/
 136:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_RXCIE_bp  7 /* RX complete interrupt Enable bit position.*/
 137:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 138:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_TXCIE_bm  0x40 /* TX complete interrupt Enable bit mask.*/
 139:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_TXCIE_bp  6 /* TX complete interrupt Enable bit position.*/
 140:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 141:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_DRIE_bm  0x20 /* Data register empty interrupt Enable bit mask.*/
 142:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_DRIE_bp  5 /* Data register empty interrupt Enable bit position.*/
 143:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 144:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_RXEN_bm  0x10  /* Receiver Enable bit mask. */
 145:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_RXEN_bp  4  /* Receiver Enable bit position. */
 146:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 147:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_TXEN_bm  0x08  /* Transmitter Enable bit mask. */
 148:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_TXEN_bp  3  /* Transmitter Enable bit position. */
 149:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 150:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_CHSIZE2_bm  0x04  /* Character Size bit mask. */
 151:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_CHSIZE2_bp  2 /* Character Size bit position. */
 152:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 153:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_RXB8_bm  0x02  /* Transmit bit 8 bit mask. */
 154:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_RXB8_bp  1  /* Transmit bit 8 bit position. */
 155:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 156:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_TXB8_bm  0x01  /* Transmit bit 8 bit mask. */
 157:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_TXB8_bp  0  /* Transmit bit 8 bit position. */
 158:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 159:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* USART.UCSRxC  bit masks and bit positions */
 160:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_UMSEL01_gm  0xC0 /* USART Mode Select 01 grp mask.*/
 161:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_UMSEL01_gp  6 /* USART Mode Select 01 grp position.*/
 162:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 163:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_UMSEL01_bm  0x80 /* USART Mode Select 01 bit mask.*/
 164:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_UMSEL01_bp  7 /* USART Mode Select 01 bit position.*/
 165:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 166:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_UMSEL00_bm  0x40 /* USART Mode Select 00 bit mask.*/
 167:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_UMSEL00_bp  6 /* USART Mode Select 00 bit position.*/
 168:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 169:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_PMODE_gm  0x30 /* USART Parity Mode Select grp mask.*/
 170:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_PMODE_gp  4 /* USART Parity Mode Select grp position.*/
 171:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 172:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_PMODE01_bm  0x20 /* USART Parity Mode Select 01 bit mask.*/
 173:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_PMODE01_bp  5 /* USART Parity Mode Select 01 bit position.*/
 174:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 175:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_PMODE00_bm  0x10 /* USART Parity Mode Select 00 bit mask.*/
 176:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_PMODE00_bp  4 /* USART Parity Mode Select 00 bit position.*/
 177:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 178:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_STOPB_bm  0x08 /* USART stop bit mask.*/
 179:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_STOPB_bp  3 /* USART stop bit Position.*/
 180:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 181:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_CHSIZE01C_gm  0x06  /* Character Size 10 bit 1 mask. */
 182:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_CHSIZE01C_gp  1 /* Character Size 10 bit position. */
 183:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 184:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_CHSIZE01_bm  0x04  /* Character Size 10 bit 1 mask. */
 185:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_CHSIZE01_bp  2 /* Character Size 10 bit position. */
 186:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 187:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_CHSIZE00_bm  0x02  /* Character Size 00 bit 1 mask. */
 188:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_CHSIZE00_bp  1 /* Character Size bit 00 position. */
 189:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 190:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_UCPOL_bm  0x01  /* Sync mode Pol bit 1 mask. */
 191:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_UCPOL_bp  0 /*Sync mode Pol bit 0 position */
 192:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 193:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_UCPHA_bm 0x02 /* Clock Phase bit mask. */
 194:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_UCPHA_bp 1 /* Clock Phase bit position. */
 195:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 196:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_DORD_bm 0x04 /* Data order bit mask. */
 197:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_DORD_bp 2 /* Data order bit position. */
 198:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 199:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* Character Size */
 200:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** typedef enum USART_CHSIZE_enum {
 201:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	USART_CHSIZE_5BIT_gc = (0x00),  /* Character size: 5 bit */
 202:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	USART_CHSIZE_6BIT_gc = (0x01),  /* Character size: 6 bit */
 203:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	USART_CHSIZE_7BIT_gc = (0x02),  /* Character size: 7 bit */
 204:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	USART_CHSIZE_8BIT_gc = (0x03),  /* Character size: 8 bit */
 205:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	USART_CHSIZE_9BIT_gc = (0x07),  /* Character size: 9 bit */
 206:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** } USART_CHSIZE_t;
 207:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 208:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* Communication Mode */
 209:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** typedef enum USART_CMODE_enum {
 210:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	USART_CMODE_ASYNCHRONOUS_gc = (0x00 << USART_UMSEL01_gp),  /*
 211:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	                                                            *
 212:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	                                                            *
 213:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	                                                            *Asynchronous
 214:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	                                                            * Mode */
 215:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	USART_CMODE_SYNCHRONOUS_gc = (0x01 << USART_UMSEL01_gp),  /* Synchronous
 216:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	                                                           * Mode */
 217:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	USART_CMODE_IRDA_gc = (0x02 << USART_UMSEL01_gp),  /* IrDA Mode */
 218:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	USART_CMODE_MSPI_gc = (0x03 << USART_UMSEL01_gp),  /* Master SPI Mode */
 219:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** } USART_CMODE_t;
 220:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 221:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* Parity Mode */
 222:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** typedef enum USART_PMODE_enum {
 223:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	USART_PMODE_DISABLED_gc = (0x00 << USART_PMODE_gp),  /* No Parity */
 224:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	USART_PMODE_EVEN_gc = (0x02 << USART_PMODE_gp),  /* Even Parity */
 225:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	USART_PMODE_ODD_gc = (0x03 << USART_PMODE_gp),  /* Odd Parity */
 226:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** } USART_PMODE_t;
 227:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 228:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* ! Lookup table containing baudctrl values for CPU frequency 1 Mhz */
 229:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static PROGMEM_DECLARE(uint16_t, baudctrl_1mhz[]) = {
 230:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0033, /* Baud: 1200 */
 231:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0019, /* Baud: 2400 */
 232:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x000C, /* Baud: 4800 */
 233:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0006, /* Baud: 9600 */
 234:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0003, /* Baud: 19200 */
 235:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0002, /* Baud: 38400 */
 236:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0001, /* Baud: 57600 */
 237:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	USART_BAUD_UNDEFINED, /* Baud: 115200 */
 238:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** };
 239:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 240:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* ! Lookup table containing baudctrl values for CPU frequency 8 Mhz */
 241:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static PROGMEM_DECLARE(uint16_t, baudctrl_8mhz[]) = {
 242:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x01A0, /* Baud: 1200 */
 243:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x00CF, /* Baud: 2400 */
 244:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0067, /* Baud: 4800 */
 245:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0033, /* Baud: 9600 */
 246:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0019, /* Baud: 19200 */
 247:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x000C, /* Baud: 38400 */
 248:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0007, /* Baud: 57600 */
 249:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0008, /* Baud: 115200 */
 250:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** };
 251:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 252:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* ! Lookup table containing baudctrl values for CPU frequency 16 Mhz */
 253:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static PROGMEM_DECLARE(uint16_t, baudctrl_16mhz[]) = {
 254:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0340, /* Baud: 1200 */
 255:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x01A0, /* Baud: 2400 */
 256:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x00CF, /* Baud: 4800 */
 257:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0067, /* Baud: 9600 */
 258:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0033, /* Baud: 19200 */
 259:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0019, /* Baud: 38400 */
 260:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0010, /* Baud: 57600 */
 261:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0010, /* Baud: 115200 */
 262:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** };
 263:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 264:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 265:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* ! Input parameters when initializing RS232 and similar modes. */
 266:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** typedef struct usart_rs232_options {
 267:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	/* ! Set baud rate of the USART (unused in slave modes). */
 268:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	uint32_t baudrate;
 269:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 270:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	/* ! Number of bits to transmit as a character (5 to 9). */
 271:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	USART_CHSIZE_t charlength;
 272:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 273:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	/* ! Parity type: USART_PMODE_DISABLED_gc, USART_PMODE_EVEN_gc, */
 274:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	/* ! USART_PMODE_ODD_gc. */
 275:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	USART_PMODE_t paritytype;
 276:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 277:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	/* ! Number of stop bits between two characters: */
 278:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	/* ! true: 2 stop bits */
 279:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	/* ! false: 1 stop bit */
 280:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	bool stopbits;
 281:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** } usart_rs232_options_t;
 282:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 283:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* ! Input parameters when initializing SPI master mode. */
 284:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** typedef struct usart_spi_options {
 285:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	/* ! Set baud rate of the USART in SPI mode. */
 286:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	uint32_t baudrate;
 287:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 288:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	/* ! SPI transmission mode. */
 289:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	uint8_t spimode;
 290:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 291:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	uint8_t data_order;
 292:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** } usart_spi_options_t;
 293:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 294:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 295:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 296:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Enable USART receiver.
 297:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 298:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart Pointer to the USART module
 299:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 300:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline void usart_rx_enable(USART_t *usart)
 301:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 302:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	(usart)->UCSRnB |= USART_RXEN_bm;
 303:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 304:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 305:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 306:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Disable USART receiver.
 307:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 308:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart Pointer to the USART module.
 309:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 310:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline void usart_rx_disable(USART_t *usart)
 311:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 312:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	(usart)->UCSRnB &= ~USART_RXEN_bm;
 313:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 314:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 315:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 316:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief  Configure the USART frame format.
 317:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 318:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *  Sets the frame format, Frame Size, parity mode and number of stop bits.
 319:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 320:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *  \param usart Pointer to the USART module
 321:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *  \param charSize The character size. Use USART_CHSIZE_t type.
 322:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *  \param parityMode The parity Mode. Use USART_PMODE_t type.
 323:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *  \param twoStopBits Enable two stop bit mode. Use bool type.
 324:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 325:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline void usart_format_set(USART_t *usart, USART_CHSIZE_t charSize,
 326:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 		USART_PMODE_t parityMode, bool twoStopBits)
 327:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 328:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	(usart)->UCSRnC
 329:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 		= ((usart)->UCSRnC &
 330:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 			(~USART_CHSIZE01C_gm)) | ((charSize & 0x03)
 331:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 			<< USART_CHSIZE01C_gp);
 332:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	(usart)->UCSRnB
 333:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 		= ((usart)->UCSRnB &
 334:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 			(~USART_CHSIZE2_bm)) | ((charSize & 0x04)
 335:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 			<< USART_CHSIZE2_bp);
 336:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 337:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	(usart)->UCSRnC = ((usart)->UCSRnC & (~USART_PMODE_gm)) | parityMode;
 338:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 339:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	(usart)->UCSRnC = ((usart)->UCSRnC & (~USART_STOPB_bm)) | (twoStopBits
 340:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 			<< USART_STOPB_bp);
 341:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 342:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 343:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 344:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Enable USART transmitter.
 345:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 346:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart Pointer to the USART module.
 347:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 348:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline void usart_tx_enable(USART_t *usart)
 349:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 350:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	(usart)->UCSRnB |= USART_TXEN_bm;
 351:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 352:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 353:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 354:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Disable USART transmitter.
 355:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 356:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart Pointer to the USART module.
 357:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 358:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline void usart_tx_disable(USART_t *usart)
 359:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 360:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	(usart)->UCSRnB &= ~USART_TXEN_bm;
 361:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 362:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 363:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 364:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Enable USART transmit complete interrupt.
 365:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 366:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart Pointer to the USART module.
 367:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 368:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline void usart_tx_complete_interrupt_enable(USART_t *usart)
 369:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 370:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	(usart)->UCSRnB |= USART_TXC_bm;
 371:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 372:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 373:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 374:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Enable USART receive complete interrupt.
 375:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 376:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart Pointer to the USART module.
 377:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 378:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline void usart_rx_complete_interrupt_enable(USART_t *usart)
 379:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 380:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	(usart)->UCSRnB |= USART_RXC_bm;
 381:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 382:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 383:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 384:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Enable USART data register empty interrupt.
 385:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 386:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart Pointer to the USART module.
 387:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 388:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline void usart_data_empty_interrupt_enable(USART_t *usart)
 389:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 390:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	(usart)->UCSRnB |= USART_DRIE_bm;
 391:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 392:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 393:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 394:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Disable USART transmit complete interrupt.
 395:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 396:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart Pointer to the USART module.
 397:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 398:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline void usart_tx_complete_interrupt_disable(USART_t *usart)
 399:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 400:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	(usart)->UCSRnB &= ~USART_TXC_bm;
 401:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 402:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 403:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 404:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Disable USART receive complete interrupt.
 405:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 406:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart Pointer to the USART module.
 407:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 408:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline void usart_rx_complete_interrupt_disable(USART_t *usart)
 409:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 410:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	(usart)->UCSRnB &= ~USART_RXC_bm;
 411:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 412:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 413:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 414:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Disable USART data register empty interrupt.
 415:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 416:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart Pointer to the USART module.
 417:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 418:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline void usart_data_empty_interrupt_disable(USART_t *usart)
 419:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 420:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	(usart)->UCSRnB &= ~USART_DRIE_bm;
 421:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 422:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 423:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 424:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Set the mode the USART run in.
 425:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 426:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * Set the mode the USART run in. The default mode is asynchronous mode.
 427:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 428:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart Pointer to the USART module register section.
 429:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usartmode Selects the USART mode. Use USART_CMODE_t type.
 430:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 431:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * USART modes:
 432:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * - 0x0        : Asynchronous mode.
 433:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * - 0x1        : Synchronous mode.
 434:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * - 0x2        : IrDA mode.
 435:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * - 0x3        : Master SPI mode.
 436:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 437:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline void usart_set_mode(USART_t *usart, USART_CMODE_t usartmode)
 438:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 439:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	(usart)->UCSRnC = ((usart)->UCSRnC & (~USART_UMSEL01_gm)) | usartmode;
 440:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 441:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 442:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 443:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Check if data register empty flag is set.
 444:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 445:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart The USART module.
 446:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 447:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline bool usart_data_register_is_empty(USART_t *usart)
 448:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 449:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	return (usart)->UCSRnA & USART_DRE_bm;
 450:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 451:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 452:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 453:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Checks if the RX complete interrupt flag is set.
 454:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 455:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * Checks if the RX complete interrupt flag is set.
 456:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 457:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart The USART module.
 458:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 459:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline bool usart_rx_is_complete(USART_t *usart)
 460:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 461:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	return (usart)->UCSRnA & USART_RXC_bm;
 462:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 463:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 464:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 465:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Checks if the TX complete interrupt flag is set.
 466:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 467:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * Checks if the TX complete interrupt flag is set.
 468:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 469:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart The USART module.
 470:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 471:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline bool usart_tx_is_complete(USART_t *usart)
 472:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 473:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	return (usart)->UCSRnA & USART_TXC_bm;
 474:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 475:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 476:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 477:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Clear TX complete interrupt flag.
 478:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * TX flag is clear after complete transmission, automatically.
 479:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart The USART module.
 480:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 481:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline void usart_clear_tx_complete(USART_t *usart)
 482:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 483:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****          usart->UCSRnA |=  USART_TXC_bm;
 484:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 485:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 486:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 487:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Write a data to the USART data register.
 488:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 489:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart The USART module.
 490:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param txdata The data to be transmitted.
 491:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 492:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline void usart_put(USART_t *usart, uint8_t txdata)
 493:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 494:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	(usart)->UDR = txdata;
 495:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 496:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 497:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 498:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief  Read a data to the USART data register.
 499:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 500:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart The USART module.
 501:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 502:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \return The received data
 503:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 504:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline uint8_t usart_get(USART_t *usart)
 505:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 506:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	return (usart)->UDR;
 507:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 508:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 509:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 510:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Double the USART transmission speed.
 511:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 512:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart The USART module.
 513:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 514:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline void usart_double_baud_enable(USART_t *usart)
 515:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 131               		.loc 2 515 0
 132               		.cfi_startproc
 133 0034 CF93      		push r28
 134               	.LCFI6:
 135               		.cfi_def_cfa_offset 3
 136               		.cfi_offset 28, -2
 137 0036 DF93      		push r29
 138               	.LCFI7:
 139               		.cfi_def_cfa_offset 4
 140               		.cfi_offset 29, -3
 141 0038 00D0      		rcall .
 142               	.LCFI8:
 143               		.cfi_def_cfa_offset 6
 144 003a CDB7      		in r28,__SP_L__
 145 003c DEB7      		in r29,__SP_H__
 146               	.LCFI9:
 147               		.cfi_def_cfa_register 28
 148               	/* prologue: function */
 149               	/* frame size = 2 */
 150               	/* stack size = 4 */
 151               	.L__stack_usage = 4
 152 003e 9A83      		std Y+2,r25
 153 0040 8983      		std Y+1,r24
 516:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	usart->UCSRnA |=  USART_U2X_bm;
 154               		.loc 2 516 0
 155 0042 8981      		ldd r24,Y+1
 156 0044 9A81      		ldd r25,Y+2
 157 0046 FC01      		movw r30,r24
 158 0048 8081      		ld r24,Z
 159 004a 282F      		mov r18,r24
 160 004c 2260      		ori r18,lo8(2)
 161 004e 8981      		ldd r24,Y+1
 162 0050 9A81      		ldd r25,Y+2
 163 0052 FC01      		movw r30,r24
 164 0054 2083      		st Z,r18
 517:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 165               		.loc 2 517 0
 166 0056 0000      		nop
 167               	/* epilogue start */
 168 0058 0F90      		pop __tmp_reg__
 169 005a 0F90      		pop __tmp_reg__
 170 005c DF91      		pop r29
 171 005e CF91      		pop r28
 172 0060 0895      		ret
 173               		.cfi_endproc
 174               	.LFE101:
 177               	usart_serial_init:
 178               	.LFB104:
 179               		.file 3 "../../../platform/common/services/serial/megarf_usart/usart_serial.h"
   1:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** /**
   2:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * \file
   3:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
   4:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * \brief This file defines a useful set of functions for the Serial interface on 
   5:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * AVR MEGARF devices.
   6:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
   7:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * Copyright (c) 2013 Atmel Corporation. All rights reserved.
   8:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
   9:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * \asf_license_start
  10:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
  11:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * \page License
  12:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
  13:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * Redistribution and use in source and binary forms, with or without
  14:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * modification, are permitted provided that the following conditions are met:
  15:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
  16:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * 1. Redistributions of source code must retain the above copyright notice,
  17:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *    this list of conditions and the following disclaimer.
  18:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
  19:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * 2. Redistributions in binary form must reproduce the above copyright notice,
  20:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *    this list of conditions and the following disclaimer in the documentation
  21:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *    and/or other materials provided with the distribution.
  22:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
  23:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * 3. The name of Atmel may not be used to endorse or promote products derived
  24:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *    from this software without specific prior written permission.
  25:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
  26:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * 4. This software may only be redistributed and used in connection with an
  27:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *    Atmel microcontroller product.
  28:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
  29:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR IMPLIED
  30:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
  31:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
  32:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR
  33:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  34:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
  35:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  36:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
  37:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  38:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  39:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * POSSIBILITY OF SUCH DAMAGE.
  40:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
  41:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * \asf_license_stop
  42:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
  43:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  */
  44:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** #ifndef _USART_SERIAL_H_
  45:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** #define _USART_SERIAL_H_
  46:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 
  47:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** #ifdef __cplusplus
  48:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** extern "C" {
  49:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** #endif
  50:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 
  51:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** #include "compiler.h"
  52:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** #include "sysclk.h"
  53:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** #include "status_codes.h"
  54:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** #include "usart_megarf.h"
  55:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 
  56:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** /*! \name Serial Management Configuration
  57:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  */
  58:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** /* ! @{ */
  59:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** #include "conf_usart_serial.h"
  60:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** /* ! @} */
  61:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 
  62:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** typedef usart_rs232_options_t usart_serial_options_t;
  63:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 
  64:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** typedef USART_t *usart_if;
  65:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 
  66:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** /*! \brief Initializes the Usart in master mode.
  67:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
  68:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * \param usart       Base address of the USART instance.
  69:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * \param options     Options needed to set up RS232 communication (see \ref
  70:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * usart_serial_options_t).
  71:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
  72:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * \retval true if the initialization was successful
  73:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * \retval false if initialization failed (error in baud rate calculation)
  74:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  */
  75:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** static inline bool usart_serial_init(usart_if usart, const
  76:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 		usart_serial_options_t *options)
  77:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** {
 180               		.loc 3 77 0
 181               		.cfi_startproc
 182 0062 CF93      		push r28
 183               	.LCFI10:
 184               		.cfi_def_cfa_offset 3
 185               		.cfi_offset 28, -2
 186 0064 DF93      		push r29
 187               	.LCFI11:
 188               		.cfi_def_cfa_offset 4
 189               		.cfi_offset 29, -3
 190 0066 CDB7      		in r28,__SP_L__
 191 0068 DEB7      		in r29,__SP_H__
 192               	.LCFI12:
 193               		.cfi_def_cfa_register 28
 194 006a 2B97      		sbiw r28,11
 195               	.LCFI13:
 196               		.cfi_def_cfa_offset 15
 197 006c 0FB6      		in __tmp_reg__,__SREG__
 198 006e F894      		cli
 199 0070 DEBF      		out __SP_H__,r29
 200 0072 0FBE      		out __SREG__,__tmp_reg__
 201 0074 CDBF      		out __SP_L__,r28
 202               	/* prologue: function */
 203               	/* frame size = 11 */
 204               	/* stack size = 13 */
 205               	.L__stack_usage = 13
 206 0076 9987      		std Y+9,r25
 207 0078 8887      		std Y+8,r24
 208 007a 7B87      		std Y+11,r23
 209 007c 6A87      		std Y+10,r22
  78:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 	/* USART options. */
  79:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 	usart_rs232_options_t usart_rs232_options;
  80:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 	usart_rs232_options.charlength   = options->charlength;
 210               		.loc 3 80 0
 211 007e 8A85      		ldd r24,Y+10
 212 0080 9B85      		ldd r25,Y+11
 213 0082 FC01      		movw r30,r24
 214 0084 8481      		ldd r24,Z+4
 215 0086 8D83      		std Y+5,r24
  81:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 	usart_rs232_options.paritytype   = options->paritytype;
 216               		.loc 3 81 0
 217 0088 8A85      		ldd r24,Y+10
 218 008a 9B85      		ldd r25,Y+11
 219 008c FC01      		movw r30,r24
 220 008e 8581      		ldd r24,Z+5
 221 0090 8E83      		std Y+6,r24
  82:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 	usart_rs232_options.stopbits     = options->stopbits;
 222               		.loc 3 82 0
 223 0092 8A85      		ldd r24,Y+10
 224 0094 9B85      		ldd r25,Y+11
 225 0096 FC01      		movw r30,r24
 226 0098 8681      		ldd r24,Z+6
 227 009a 8F83      		std Y+7,r24
  83:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 	usart_rs232_options.baudrate     = options->baudrate;
 228               		.loc 3 83 0
 229 009c 8A85      		ldd r24,Y+10
 230 009e 9B85      		ldd r25,Y+11
 231 00a0 FC01      		movw r30,r24
 232 00a2 8081      		ld r24,Z
 233 00a4 9181      		ldd r25,Z+1
 234 00a6 A281      		ldd r26,Z+2
 235 00a8 B381      		ldd r27,Z+3
 236 00aa 8983      		std Y+1,r24
 237 00ac 9A83      		std Y+2,r25
 238 00ae AB83      		std Y+3,r26
 239 00b0 BC83      		std Y+4,r27
  84:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 
  85:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 	if (usart_init_rs232(usart, &usart_rs232_options)) {
 240               		.loc 3 85 0
 241 00b2 8885      		ldd r24,Y+8
 242 00b4 9985      		ldd r25,Y+9
 243 00b6 9E01      		movw r18,r28
 244 00b8 2F5F      		subi r18,-1
 245 00ba 3F4F      		sbci r19,-1
 246 00bc B901      		movw r22,r18
 247 00be 0E94 0000 		call usart_init_rs232
 248 00c2 8823      		tst r24
 249 00c4 01F0      		breq .L7
  86:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 		return true;
 250               		.loc 3 86 0
 251 00c6 81E0      		ldi r24,lo8(1)
 252 00c8 00C0      		rjmp .L9
 253               	.L7:
  87:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 	} else {
  88:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 		return false;
 254               		.loc 3 88 0
 255 00ca 80E0      		ldi r24,0
 256               	.L9:
 257               	/* epilogue start */
  89:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 	}
  90:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** }
 258               		.loc 3 90 0 discriminator 1
 259 00cc 2B96      		adiw r28,11
 260 00ce 0FB6      		in __tmp_reg__,__SREG__
 261 00d0 F894      		cli
 262 00d2 DEBF      		out __SP_H__,r29
 263 00d4 0FBE      		out __SREG__,__tmp_reg__
 264 00d6 CDBF      		out __SP_L__,r28
 265 00d8 DF91      		pop r29
 266 00da CF91      		pop r28
 267 00dc 0895      		ret
 268               		.cfi_endproc
 269               	.LFE104:
 272               	usart_serial_putchar:
 273               	.LFB105:
  91:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 
  92:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** /*! \brief Sends a character with the USART.
  93:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
  94:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * \param usart   Base address of the USART instance.
  95:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * \param c       Character to write.
  96:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
  97:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * \return Status code
  98:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  */
  99:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** static inline status_code_t usart_serial_putchar(usart_if usart, uint8_t c)
 100:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** {
 274               		.loc 3 100 0
 275               		.cfi_startproc
 276 00de CF93      		push r28
 277               	.LCFI14:
 278               		.cfi_def_cfa_offset 3
 279               		.cfi_offset 28, -2
 280 00e0 DF93      		push r29
 281               	.LCFI15:
 282               		.cfi_def_cfa_offset 4
 283               		.cfi_offset 29, -3
 284 00e2 00D0      		rcall .
 285 00e4 1F92      		push __zero_reg__
 286               	.LCFI16:
 287               		.cfi_def_cfa_offset 7
 288 00e6 CDB7      		in r28,__SP_L__
 289 00e8 DEB7      		in r29,__SP_H__
 290               	.LCFI17:
 291               		.cfi_def_cfa_register 28
 292               	/* prologue: function */
 293               	/* frame size = 3 */
 294               	/* stack size = 5 */
 295               	.L__stack_usage = 5
 296 00ea 9A83      		std Y+2,r25
 297 00ec 8983      		std Y+1,r24
 298 00ee 6B83      		std Y+3,r22
 101:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 	return usart_putchar(usart, c);
 299               		.loc 3 101 0
 300 00f0 8981      		ldd r24,Y+1
 301 00f2 9A81      		ldd r25,Y+2
 302 00f4 6B81      		ldd r22,Y+3
 303 00f6 0E94 0000 		call usart_putchar
 304               	/* epilogue start */
 102:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** }
 305               		.loc 3 102 0
 306 00fa 0F90      		pop __tmp_reg__
 307 00fc 0F90      		pop __tmp_reg__
 308 00fe 0F90      		pop __tmp_reg__
 309 0100 DF91      		pop r29
 310 0102 CF91      		pop r28
 311 0104 0895      		ret
 312               		.cfi_endproc
 313               	.LFE105:
 316               	usart_serial_getchar:
 317               	.LFB106:
 103:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 
 104:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** /*! \brief Waits until a character is received, and returns it.
 105:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
 106:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * \param usart   Base address of the USART instance.
 107:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * \param data   Data to read
 108:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
 109:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  */
 110:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** static inline void usart_serial_getchar(usart_if usart, uint8_t *data)
 111:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** {
 318               		.loc 3 111 0
 319               		.cfi_startproc
 320 0106 CF93      		push r28
 321               	.LCFI18:
 322               		.cfi_def_cfa_offset 3
 323               		.cfi_offset 28, -2
 324 0108 DF93      		push r29
 325               	.LCFI19:
 326               		.cfi_def_cfa_offset 4
 327               		.cfi_offset 29, -3
 328 010a 00D0      		rcall .
 329 010c 00D0      		rcall .
 330               	.LCFI20:
 331               		.cfi_def_cfa_offset 8
 332 010e CDB7      		in r28,__SP_L__
 333 0110 DEB7      		in r29,__SP_H__
 334               	.LCFI21:
 335               		.cfi_def_cfa_register 28
 336               	/* prologue: function */
 337               	/* frame size = 4 */
 338               	/* stack size = 6 */
 339               	.L__stack_usage = 6
 340 0112 9A83      		std Y+2,r25
 341 0114 8983      		std Y+1,r24
 342 0116 7C83      		std Y+4,r23
 343 0118 6B83      		std Y+3,r22
 112:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 	*data = usart_getchar(usart);
 344               		.loc 3 112 0
 345 011a 8981      		ldd r24,Y+1
 346 011c 9A81      		ldd r25,Y+2
 347 011e 0E94 0000 		call usart_getchar
 348 0122 282F      		mov r18,r24
 349 0124 8B81      		ldd r24,Y+3
 350 0126 9C81      		ldd r25,Y+4
 351 0128 FC01      		movw r30,r24
 352 012a 2083      		st Z,r18
 113:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** }
 353               		.loc 3 113 0
 354 012c 0000      		nop
 355               	/* epilogue start */
 356 012e 0F90      		pop __tmp_reg__
 357 0130 0F90      		pop __tmp_reg__
 358 0132 0F90      		pop __tmp_reg__
 359 0134 0F90      		pop __tmp_reg__
 360 0136 DF91      		pop r29
 361 0138 CF91      		pop r28
 362 013a 0895      		ret
 363               		.cfi_endproc
 364               	.LFE106:
 367               	stdio_serial_init:
 368               	.LFB107:
 369               		.file 4 "../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h"
   1:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** /**
   2:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
   3:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * \file
   4:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
   5:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * \brief Common Standard I/O Serial Management.
   6:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
   7:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * This file defines a useful set of functions for the Stdio Serial interface on AVR
   8:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * and SAM devices.
   9:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
  10:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * Copyright (c) 2009-2013 Atmel Corporation. All rights reserved.
  11:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
  12:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * \asf_license_start
  13:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
  14:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * \page License
  15:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
  16:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * Redistribution and use in source and binary forms, with or without
  17:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * modification, are permitted provided that the following conditions are met:
  18:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
  19:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * 1. Redistributions of source code must retain the above copyright notice,
  20:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *    this list of conditions and the following disclaimer.
  21:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
  22:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * 2. Redistributions in binary form must reproduce the above copyright notice,
  23:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *    this list of conditions and the following disclaimer in the documentation
  24:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *    and/or other materials provided with the distribution.
  25:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
  26:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * 3. The name of Atmel may not be used to endorse or promote products derived
  27:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *    from this software without specific prior written permission.
  28:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
  29:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * 4. This software may only be redistributed and used in connection with an
  30:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *    Atmel microcontroller product.
  31:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
  32:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR IMPLIED
  33:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
  34:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
  35:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR
  36:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  37:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
  38:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  39:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
  40:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  41:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  42:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * POSSIBILITY OF SUCH DAMAGE.
  43:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
  44:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * \asf_license_stop
  45:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
  46:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  ******************************************************************************/
  47:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 
  48:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 
  49:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** #ifndef _STDIO_SERIAL_H_
  50:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** #define _STDIO_SERIAL_H_
  51:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 
  52:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** /**
  53:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * \defgroup group_common_utils_stdio_stdio_serial Standard serial I/O (stdio)
  54:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * \ingroup group_common_utils_stdio
  55:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
  56:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * Common standard serial I/O management driver that
  57:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * implements a stdio serial interface on AVR and SAM devices.
  58:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
  59:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * \{
  60:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  */
  61:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 
  62:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** #include <stdio.h>
  63:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** #include "compiler.h"
  64:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** #ifndef SAMD20
  65:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** # include "sysclk.h"
  66:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** #endif
  67:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** #include "serial.h"
  68:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 
  69:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** #if (XMEGA || MEGA_RF) && defined(__GNUC__)
  70:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	extern int _write (char c, int *f);
  71:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	extern int _read (int *f);
  72:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** #endif
  73:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 
  74:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 
  75:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** //! Pointer to the base of the USART module instance to use for stdio.
  76:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** extern volatile void *volatile stdio_base;
  77:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** //! Pointer to the external low level write function.
  78:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** extern int (*ptr_put)(void volatile*, char);
  79:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 
  80:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** //! Pointer to the external low level read function.
  81:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** extern void (*ptr_get)(void volatile*, char*);
  82:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 
  83:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** /*! \brief Initializes the stdio in Serial Mode.
  84:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
  85:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * \param usart       Base address of the USART instance.
  86:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * \param opt         Options needed to set up RS232 communication (see \ref usart_options_t).
  87:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
  88:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  */
  89:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** static inline void stdio_serial_init(volatile void *usart, const usart_serial_options_t *opt)
  90:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** {
 370               		.loc 4 90 0
 371               		.cfi_startproc
 372 013c CF93      		push r28
 373               	.LCFI22:
 374               		.cfi_def_cfa_offset 3
 375               		.cfi_offset 28, -2
 376 013e DF93      		push r29
 377               	.LCFI23:
 378               		.cfi_def_cfa_offset 4
 379               		.cfi_offset 29, -3
 380 0140 00D0      		rcall .
 381 0142 00D0      		rcall .
 382               	.LCFI24:
 383               		.cfi_def_cfa_offset 8
 384 0144 CDB7      		in r28,__SP_L__
 385 0146 DEB7      		in r29,__SP_H__
 386               	.LCFI25:
 387               		.cfi_def_cfa_register 28
 388               	/* prologue: function */
 389               	/* frame size = 4 */
 390               	/* stack size = 6 */
 391               	.L__stack_usage = 6
 392 0148 9A83      		std Y+2,r25
 393 014a 8983      		std Y+1,r24
 394 014c 7C83      		std Y+4,r23
 395 014e 6B83      		std Y+3,r22
  91:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	stdio_base = (void *)usart;
 396               		.loc 4 91 0
 397 0150 8981      		ldd r24,Y+1
 398 0152 9A81      		ldd r25,Y+2
 399 0154 9093 0000 		sts stdio_base+1,r25
 400 0158 8093 0000 		sts stdio_base,r24
  92:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	ptr_put = (int (*)(void volatile*,char))&usart_serial_putchar;
 401               		.loc 4 92 0
 402 015c 80E0      		ldi r24,lo8(gs(usart_serial_putchar))
 403 015e 90E0      		ldi r25,hi8(gs(usart_serial_putchar))
 404 0160 9093 0000 		sts ptr_put+1,r25
 405 0164 8093 0000 		sts ptr_put,r24
  93:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	ptr_get = (void (*)(void volatile*,char*))&usart_serial_getchar;
 406               		.loc 4 93 0
 407 0168 80E0      		ldi r24,lo8(gs(usart_serial_getchar))
 408 016a 90E0      		ldi r25,hi8(gs(usart_serial_getchar))
 409 016c 9093 0000 		sts ptr_get+1,r25
 410 0170 8093 0000 		sts ptr_get,r24
  94:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** # if (XMEGA || MEGA_RF)
  95:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	usart_serial_init((USART_t *)usart,opt);
 411               		.loc 4 95 0
 412 0174 2B81      		ldd r18,Y+3
 413 0176 3C81      		ldd r19,Y+4
 414 0178 8981      		ldd r24,Y+1
 415 017a 9A81      		ldd r25,Y+2
 416 017c B901      		movw r22,r18
 417 017e 0E94 0000 		call usart_serial_init
  96:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** # elif UC3
  97:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	usart_serial_init(usart,(usart_serial_options_t *)opt);
  98:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** # elif SAM
  99:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	usart_serial_init((Usart *)usart,(usart_serial_options_t *)opt);
 100:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** # else
 101:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** #  error Unsupported chip type
 102:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** # endif
 103:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 
 104:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** # if defined(__GNUC__)
 105:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** #  if (XMEGA || MEGA_RF)
 106:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	// For AVR GCC libc print redirection uses fdevopen.
 107:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	fdevopen((int (*)(char, FILE*))(_write),(int (*)(FILE*))(_read));
 418               		.loc 4 107 0
 419 0182 60E0      		ldi r22,lo8(gs(_read))
 420 0184 70E0      		ldi r23,hi8(gs(_read))
 421 0186 80E0      		ldi r24,lo8(gs(_write))
 422 0188 90E0      		ldi r25,hi8(gs(_write))
 423 018a 0E94 0000 		call fdevopen
 108:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** #  endif
 109:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** #  if UC3 || SAM
 110:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	// For AVR32 and SAM GCC
 111:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	// Specify that stdout and stdin should not be buffered.
 112:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	setbuf(stdout, NULL);
 113:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	setbuf(stdin, NULL);
 114:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	// Note: Already the case in IAR's Normal DLIB default configuration
 115:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	// and AVR GCC library:
 116:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	// - printf() emits one character at a time.
 117:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	// - getchar() requests only 1 byte to exit.
 118:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** #  endif
 119:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** # endif
 120:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** }
 424               		.loc 4 120 0
 425 018e 0000      		nop
 426               	/* epilogue start */
 427 0190 0F90      		pop __tmp_reg__
 428 0192 0F90      		pop __tmp_reg__
 429 0194 0F90      		pop __tmp_reg__
 430 0196 0F90      		pop __tmp_reg__
 431 0198 DF91      		pop r29
 432 019a CF91      		pop r28
 433 019c 0895      		ret
 434               		.cfi_endproc
 435               	.LFE107:
 438               	macsc_enable_manual_bts:
 439               	.LFB121:
 440               		.file 5 "../../../platform/mega_rf/drivers/macsc/macsc_megarf.h"
   1:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
   2:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \file
   3:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
   4:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief AVR MEGARF MAC Symbol Counter Driver Definitions
   5:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
   6:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * Copyright (c) 2013 Atmel Corporation. All rights reserved.
   7:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
   8:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \asf_license_start
   9:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  10:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \page License
  11:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  12:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * Redistribution and use in source and binary forms, with or without
  13:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * modification, are permitted provided that the following conditions are met:
  14:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  15:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * 1. Redistributions of source code must retain the above copyright notice,
  16:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *    this list of conditions and the following disclaimer.
  17:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  18:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * 2. Redistributions in binary form must reproduce the above copyright notice,
  19:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *    this list of conditions and the following disclaimer in the documentation
  20:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *    and/or other materials provided with the distribution.
  21:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  22:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * 3. The name of Atmel may not be used to endorse or promote products derived
  23:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *    from this software without specific prior written permission.
  24:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  25:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * 4. This software may only be redistributed and used in connection with an
  26:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *    Atmel microcontroller product.
  27:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  28:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR IMPLIED
  29:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
  30:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
  31:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR
  32:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  33:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
  34:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  35:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
  36:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  37:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  38:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * POSSIBILITY OF SUCH DAMAGE.
  39:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  40:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \asf_license_stop
  41:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  42:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
  43:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** #ifndef MACSC_MEGARF_H
  44:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** #define MACSC_MEGARF_H
  45:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
  46:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** #include <compiler.h>
  47:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** #include <parts.h>
  48:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** #include "status_codes.h"
  49:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
  50:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** #ifdef __cplusplus
  51:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** extern "C" {
  52:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** #endif
  53:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
  54:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
  55:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \defgroup macsc_group MAC Symbol Counter Driver(MACSC)
  56:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  57:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * See \ref megarf_macsc_quickstart
  58:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  59:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * This is a driver for the AVR MEGARF MAC Symbol Counter Driver(MACSC).
  60:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * It provides functions for enabling, disabling and configuring the module.
  61:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  62:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \section dependencies Dependencies
  63:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * This driver depends on the following modules:
  64:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * - \ref interrupt_group for ISR definition and disabling interrupts during
  65:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * critical code sections.
  66:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * @{
  67:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
  68:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
  69:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
  70:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Interrupt event callback function type
  71:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  72:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * The interrupt handler can be configured to do a function callback,
  73:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * the callback function must match the macsc_callback_t type.
  74:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  75:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
  76:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** typedef void (*macsc_callback_t)(void);
  77:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
  78:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /* ! MAC symbol counter compare Channel index */
  79:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** enum macsc_cc_channel {
  80:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	/* ! Channel 1 */
  81:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	MACSC_CC1 = 1,
  82:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	/* ! Channel 2 */
  83:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	MACSC_CC2 = 2,
  84:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	/* ! Channel 3 */
  85:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	MACSC_CC3 = 3,
  86:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** };
  87:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
  88:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief MAC SC clock source select
  89:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  90:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * uses the SCCKSEL bit in SSCR register to select macsc clk src
  91:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  92:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * If the bit is one,the RTC clock from TOSC1 is selected, otherwise the symbol
  93:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * counter operates with the clock from XTAL1.
  94:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * During transceiver sleep modes the clock falls back to the RTC clock source,
  95:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * regardless of the selected clock. After wakeup, it switches back to the
  96:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * previosly
  97:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * selected clock source.
  98:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
  99:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 100:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** enum macsc_xtal {
 101:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	/* ! 16MHz as macsc clock */
 102:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	MACSC_16MHz = 0,
 103:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	MACSC_32KHz = 1,
 104:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** };
 105:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 106:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 107:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * @brief Reads the 32-bit timer register in the required order of bytes
 108:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 109:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * @param hh hh octet of 32-bit register
 110:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * @param hl hl octet of 32-bit register
 111:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * @param lh lh octet of 32-bit register
 112:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * @param ll ll octet of 32-bit register
 113:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 114:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * @returns uint32_t Value of timer register
 115:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 116:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** static inline uint32_t macsc_read32(volatile uint8_t *hh,
 117:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		volatile uint8_t *hl,
 118:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		volatile uint8_t *lh,
 119:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		volatile uint8_t *ll)
 120:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** {
 121:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	union {
 122:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		uint8_t a[4];
 123:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		uint32_t rv;
 124:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	}
 125:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	x;
 126:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 127:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	x.a[0] = *ll;
 128:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	x.a[1] = *lh;
 129:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	x.a[2] = *hl;
 130:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	x.a[3] = *hh;
 131:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 132:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	return x.rv;
 133:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** }
 134:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 135:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /* ! compare modes */
 136:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** #define MACSC_ABSOLUTE_CMP 0
 137:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** #define MACSC_RELATIVE_CMP 1
 138:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 139:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /** String concatenation by preprocessor used to create proper register names.
 140:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  **/
 141:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** #define CONCAT(a, b) a ## b
 142:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 143:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /** Creates proper subregister names and reads the corresponding values. */
 144:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** #define MACSC_READ32(reg)                  macsc_read32(&CONCAT(reg, HH), \
 145:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		&CONCAT(reg, HL), \
 146:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		&CONCAT(reg, LH), \
 147:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		&CONCAT(reg, LL))
 148:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 149:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** #define MACSC_WRITE32(reg, val)	\
 150:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	do { \
 151:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		union { uint8_t a[4]; uint32_t v; } \
 152:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		x; \
 153:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		x.v = val; \
 154:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		CONCAT(reg, HH) = x.a[3]; \
 155:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		CONCAT(reg, HL) = x.a[2]; \
 156:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		CONCAT(reg, LH) = x.a[1]; \
 157:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		CONCAT(reg, LL) = x.a[0]; \
 158:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	} \
 159:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	while (0)
 160:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 161:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 162:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Enable MAC SC
 163:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 164:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * Enables the SC
 165:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 166:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param clk_src selection of clk source,avalable options in macsc_xtal,fixed
 167:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *  prescalar
 168:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param sleep_enable enable RTC as clock source during sleep
 169:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param auto_ts enable automatic timestamping
 170:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 171:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 172:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** void macsc_enable(void);
 173:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 174:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 175:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Check if MACSC is enabled
 176:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 177:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * check if the MACSC is enabled.
 178:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 179:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param none
 180:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 181:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 182:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** bool is_macsc_enable(void);
 183:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 184:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 185:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Disable MAC SC
 186:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 187:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * Disables the MAC SC
 188:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 189:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param none
 190:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 191:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 192:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** void macsc_disable(void);
 193:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 194:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 195:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Check if back-off slot counter is enabled
 196:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 197:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * check if the back-off slot counter is enabled.
 198:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 199:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param none
 200:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 201:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 202:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** bool is_macsc_backoff_enable(void);
 203:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 204:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 205:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Enables compare interrupts of the MACSC
 206:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 207:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param channel Compare channel
 208:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 209:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** void macsc_enable_cmp_int(enum macsc_cc_channel channel);
 210:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 211:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 212:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Disables compare interrupts of the MACSC
 213:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 214:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param channel Compare channel
 215:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */void macsc_disable_cmp_int(enum macsc_cc_channel channel);
 216:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 217:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 218:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Usage of Absolute compare mode of the MACSC
 219:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 220:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param abs_rel  0 for absoulte cmp;1 for relative cmp
 221:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param cmp compare value for SCOCRx register
 222:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param channel Compare channel
 223:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 224:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** void macsc_use_cmp(bool abs_rel, uint32_t cmp,enum macsc_cc_channel channel);
 225:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 226:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 227:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \ingroup macsc_group
 228:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \defgroup macsc_interrupt_group MAC Symbol Counter (MACSC) interrupt
 229:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * management
 230:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * This group provides functions to configure MACSC module interrupts
 231:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 232:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * @{
 233:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 234:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 235:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 236:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Set MACSC overflow interrupt callback function
 237:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 238:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * This function allows the caller to set and change the interrupt callback
 239:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * function. Without setting a callback function the interrupt handler in the
 240:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * driver will only clear the interrupt flags.
 241:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 242:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param callback Reference to a callback function
 243:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 244:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** void macsc_set_ovf_int_cb(macsc_callback_t callback);
 245:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 246:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 247:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Set MACSC Compare Channel 1 interrupt callback function
 248:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 249:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * This function allows the caller to set and change the interrupt callback
 250:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * function. Without setting a callback function the interrupt handler in the
 251:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * driver will only clear the interrupt flags.
 252:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 253:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param callback Reference to a callback function
 254:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 255:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** void macsc_set_cmp1_int_cb(macsc_callback_t callback);
 256:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 257:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 258:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Set MACSC Compare Channel 2 interrupt callback function
 259:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 260:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * This function allows the caller to set and change the interrupt callback
 261:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * function. Without setting a callback function the interrupt handler in the
 262:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * driver will only clear the interrupt flags.
 263:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 264:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param callback Reference to a callback function
 265:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 266:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** void macsc_set_cmp2_int_cb(macsc_callback_t callback);
 267:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 268:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 269:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Set MACSC Compare Channel 3 interrupt callback function
 270:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 271:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * This function allows the caller to set and change the interrupt callback
 272:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * function. Without setting a callback function the interrupt handler in the
 273:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * driver will only clear the interrupt flags.
 274:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 275:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param callback Reference to a callback function
 276:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 277:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** void macsc_set_cmp3_int_cb(macsc_callback_t callback);
 278:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 279:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 280:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Set MACSC backoff slot counter interrupt callback function
 281:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 282:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * This function allows the caller to set and change the interrupt callback
 283:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * function. Without setting a callback function the interrupt handler in the
 284:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * driver will only clear the interrupt flags.
 285:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 286:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param callback Reference to a callback function
 287:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 288:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** void macsc_set_backoff_slot_cntr_int_cb(macsc_callback_t callback);
 289:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** //@}
 290:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 291:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 292:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Enable 32.768KHz clk using timer 2 async register
 293:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 294:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param none
 295:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 296:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 297:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** static inline void macsc_sleep_clk_enable(void)
 298:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** {
 299:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	ASSR |= (1 << AS2);
 300:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** }
 301:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 302:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 303:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Disable 32.768KHz clk using timer 2 async register
 304:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 305:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param none
 306:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 307:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** static inline void macsc_sleep_clk_disable(void)
 308:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** {
 309:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	ASSR &= ~(1 << AS2);
 310:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** }
 311:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 312:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /* @} */
 313:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 314:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 315:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Configure MAC Symbol Counter Clock Source
 316:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 317:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param macsc macsc clk src
 318:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 319:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** static inline void macsc_write_clock_source(enum macsc_xtal source)
 320:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** {
 321:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	if (source == MACSC_16MHz) {
 322:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		SCCR0 |= (source << SCCKSEL);
 323:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	} else if (source == MACSC_32KHz) {
 324:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		SCCR0 &= ~(1 << SCCKSEL);
 325:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	}
 326:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** }
 327:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 328:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 329:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Read MAC SC Clock Source
 330:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 331:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param none
 332:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \return macsc_xtal enum Clock source selection
 333:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 334:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** static inline enum macsc_xtal macsc_read_clock_source(void)
 335:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** {
 336:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	return (enum macsc_xtal)(SCCR0 & (1 << SCCKSEL));
 337:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** }
 338:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 339:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 340:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Write the Counter value of the MAC Symbol counter
 341:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 342:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param cnt_value Counter value
 343:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 344:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** static inline void macsc_write_count(uint32_t cnt_value)
 345:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** {
 346:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	MACSC_WRITE32(SCCNT, cnt_value);
 347:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** }
 348:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 349:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 350:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Reads the Counter value of the MAC Symbol counter
 351:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 352:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \note Output the Counter value
 353:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 354:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** static inline uint32_t macsc_read_count(void)
 355:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** {
 356:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	return (MACSC_READ32(SCCNT));
 357:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** }
 358:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 359:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 360:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief enable back-off slot counter
 361:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 362:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param none
 363:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \note  Enables interrupt as well	.
 364:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \note This counter works only if transceiver clock is running.So check Trx
 365:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * state in app before using this function in IEEE802.15.4 applications.
 366:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 367:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** static inline bool macsc_backoff_slot_cnt_enable(void)
 368:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** {
 369:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	if (!(PRR1 & (1 << PRTRX24))) {
 370:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		SCCR1 = (1 << SCENBO);
 371:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		SCIRQS |= (1 << IRQSBO);
 372:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		SCIRQM |= (1 << IRQMBO);
 373:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		return true;
 374:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	}
 375:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	else return false;
 376:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** }
 377:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 378:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 379:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Disable back-off slot counter
 380:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 381:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param none
 382:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \note    Disables interrupt as well	.
 383:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \note This counter works only if transceiver clock is running.So check Trx
 384:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * state in app before using this function in IEEE802.15.4 applications.
 385:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 386:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** static inline void macsc_backoff_slot_cnt_disable(void)
 387:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** {
 388:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	SCCR1 &= ~(1 << SCENBO);
 389:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	SCIRQM &= ~(1 << IRQMBO);
 390:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** }
 391:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 392:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 393:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Tests if the Backoff slot cntr interrupt flag is set
 394:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 395:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \return  backoff slot cntr interrupt has occurred or not : IRQSBO
 396:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 397:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** static inline bool macsc_is_slot_cntr_interrupt_flag_set(void)
 398:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** {
 399:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	return (SCIRQS & (1 << IRQSBO));
 400:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** }
 401:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 402:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 403:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Clears the Backoff Slot cntr interrupt flag
 404:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 405:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \note  IRQSBO is cleared
 406:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 407:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** static inline void macsc_clear_slot_cntr_interrupt_flag(void)
 408:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** {
 409:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	SCIRQS |= (1 << IRQSBO);
 410:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** }
 411:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 412:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 413:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Reads the SFD Timestamp register
 414:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 415:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \return Timestamp of last received frame :SCTSR(read-only register)
 416:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 417:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** static inline uint32_t macsc_read_ts(void)
 418:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** {
 419:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	return (MACSC_READ32(SCTSR));
 420:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** }
 421:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 422:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 423:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Reads the Beacon Timestamp register
 424:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 425:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \return Timestamp of last received beacon frame :SCBTSR
 426:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 427:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** static inline uint32_t macsc_read_bts(void)
 428:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** {
 429:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	return (MACSC_READ32(SCBTSR));
 430:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** }
 431:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 432:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 433:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Write the Beacon Timestamp register of the MAC Symbol counter
 434:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * The manual beacon timestamping can be used in conjunction with the
 435:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * relative compare mode of the three compare units to generate compare match
 436:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * interrupts without having a beacon frame received
 437:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 438:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * If set to 1, the current symbol counter value is stored into the beacon
 439:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * timestamp register.
 440:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * The bit is cleared afterwards.
 441:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 442:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 443:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** static inline void macsc_enable_manual_bts(void)
 444:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** {
 441               		.loc 5 444 0
 442               		.cfi_startproc
 443 019e CF93      		push r28
 444               	.LCFI26:
 445               		.cfi_def_cfa_offset 3
 446               		.cfi_offset 28, -2
 447 01a0 DF93      		push r29
 448               	.LCFI27:
 449               		.cfi_def_cfa_offset 4
 450               		.cfi_offset 29, -3
 451 01a2 CDB7      		in r28,__SP_L__
 452 01a4 DEB7      		in r29,__SP_H__
 453               	.LCFI28:
 454               		.cfi_def_cfa_register 28
 455               	/* prologue: function */
 456               	/* frame size = 0 */
 457               	/* stack size = 2 */
 458               	.L__stack_usage = 2
 445:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	SCCR0 |= (1 << SCMBTS);
 459               		.loc 5 445 0
 460 01a6 8CED      		ldi r24,lo8(-36)
 461 01a8 90E0      		ldi r25,0
 462 01aa 2CED      		ldi r18,lo8(-36)
 463 01ac 30E0      		ldi r19,0
 464 01ae F901      		movw r30,r18
 465 01b0 2081      		ld r18,Z
 466 01b2 2064      		ori r18,lo8(64)
 467 01b4 FC01      		movw r30,r24
 468 01b6 2083      		st Z,r18
 446:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	SCCR0 &= ~(1 << SCTSE);
 469               		.loc 5 446 0
 470 01b8 8CED      		ldi r24,lo8(-36)
 471 01ba 90E0      		ldi r25,0
 472 01bc 2CED      		ldi r18,lo8(-36)
 473 01be 30E0      		ldi r19,0
 474 01c0 F901      		movw r30,r18
 475 01c2 2081      		ld r18,Z
 476 01c4 277F      		andi r18,lo8(-9)
 477 01c6 FC01      		movw r30,r24
 478 01c8 2083      		st Z,r18
 447:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** }
 479               		.loc 5 447 0
 480 01ca 0000      		nop
 481               	/* epilogue start */
 482 01cc DF91      		pop r29
 483 01ce CF91      		pop r28
 484 01d0 0895      		ret
 485               		.cfi_endproc
 486               	.LFE121:
 488               	.global	appState
 489               		.section	.bss.appState,"aw",@nobits
 492               	appState:
 493 0000 00        		.zero	1
 494               		.section	.bss.msgReq,"aw",@nobits
 497               	msgReq:
 498 0000 0000 0000 		.zero	20
 498      0000 0000 
 498      0000 0000 
 498      0000 0000 
 498      0000 0000 
 499               		.section	.bss.PanId,"aw",@nobits
 502               	PanId:
 503 0000 00        		.zero	1
 504               		.section	.rodata
 505               	.LC1:
 506 0000 0A4D 5347 		.string	"\nMSG REQ SENT %d"
 506      2052 4551 
 506      2053 454E 
 506      5420 2564 
 506      00
 507               		.text
 508               	.global	appSendData
 510               	appSendData:
 511               	.LFB130:
 512               		.file 6 "ServerLLDN.c"
   1:ServerLLDN.c  **** /*
   2:ServerLLDN.c  **** 	* ServerLLDN.c
   3:ServerLLDN.c  **** 	*
   4:ServerLLDN.c  **** 	* Created: 10/18/2019 5:15:37 PM
   5:ServerLLDN.c  **** 	*  Author: guilherme
   6:ServerLLDN.c  **** 	*/ 
   7:ServerLLDN.c  **** 
   8:ServerLLDN.c  **** #include <stdlib.h>
   9:ServerLLDN.c  **** #include <stdio.h>
  10:ServerLLDN.c  **** #include <string.h>
  11:ServerLLDN.c  **** #include <inttypes.h>
  12:ServerLLDN.c  **** #include "config.h"
  13:ServerLLDN.c  **** #include "sys.h"
  14:ServerLLDN.c  **** #include "phy.h"
  15:ServerLLDN.c  **** #include "sys.h"
  16:ServerLLDN.c  **** #include "nwk.h"
  17:ServerLLDN.c  **** #include "sysclk.h"
  18:ServerLLDN.c  **** #include "sysTimer.h"
  19:ServerLLDN.c  **** #include "sleep_mgr.h"
  20:ServerLLDN.c  **** #include "sleepmgr.h"
  21:ServerLLDN.c  **** #include "led.h"
  22:ServerLLDN.c  **** #include "ioport.h"
  23:ServerLLDN.c  **** #include "conf_sleepmgr.h"
  24:ServerLLDN.c  **** #include "board.h"
  25:ServerLLDN.c  **** #include "platform.h"
  26:ServerLLDN.c  **** 
  27:ServerLLDN.c  **** #include "lldn.h"
  28:ServerLLDN.c  **** 
  29:ServerLLDN.c  **** #if 1
  30:ServerLLDN.c  **** #if (SIO2HOST_CHANNEL == SIO_USB)
  31:ServerLLDN.c  **** /* Only ARM */
  32:ServerLLDN.c  **** #include "hw_timer_lldn.h"
  33:ServerLLDN.c  **** #include "stdio_usb.h"
  34:ServerLLDN.c  **** #define MASTER_MACSC	0
  35:ServerLLDN.c  **** #else
  36:ServerLLDN.c  **** /* Only megarf series */
  37:ServerLLDN.c  **** #include "conf_sio2host.h"
  38:ServerLLDN.c  **** #define MASTER_MACSC	1
  39:ServerLLDN.c  **** #endif
  40:ServerLLDN.c  **** #else
  41:ServerLLDN.c  **** /* Only megarf series */
  42:ServerLLDN.c  **** #define MASTER_MACSC		1
  43:ServerLLDN.c  **** #endif
  44:ServerLLDN.c  **** 
  45:ServerLLDN.c  **** #define HUMAM_READABLE			1
  46:ServerLLDN.c  **** 
  47:ServerLLDN.c  **** #if (MASTER_MACSC == 1)
  48:ServerLLDN.c  **** #include "macsc_megarf.h"
  49:ServerLLDN.c  **** #define TIMESLOT_TIMER 1
  50:ServerLLDN.c  **** #else
  51:ServerLLDN.c  **** static SYS_Timer_t				tmrBeaconInterval;			// Beacon
  52:ServerLLDN.c  **** static SYS_Timer_t				tmrComputeData;				// Compute data
  53:ServerLLDN.c  **** #endif
  54:ServerLLDN.c  **** 
  55:ServerLLDN.c  **** #define PRINT 1
  56:ServerLLDN.c  **** 
  57:ServerLLDN.c  **** 	
  58:ServerLLDN.c  **** // equation for tTS gives time in seconds, the division by SYMBOL_TIME changes to symbols for count
  59:ServerLLDN.c  **** AppState_t	appState = APP_STATE_INITIAL;
  60:ServerLLDN.c  **** static NWK_DataReq_t msgReq;
  61:ServerLLDN.c  **** static uint8_t PanId;
  62:ServerLLDN.c  **** 
  63:ServerLLDN.c  ****  void appSendData(void)
  64:ServerLLDN.c  **** {
 513               		.loc 6 64 0
 514               		.cfi_startproc
 515 01d2 CF93      		push r28
 516               	.LCFI29:
 517               		.cfi_def_cfa_offset 3
 518               		.cfi_offset 28, -2
 519 01d4 DF93      		push r29
 520               	.LCFI30:
 521               		.cfi_def_cfa_offset 4
 522               		.cfi_offset 29, -3
 523 01d6 CDB7      		in r28,__SP_L__
 524 01d8 DEB7      		in r29,__SP_H__
 525               	.LCFI31:
 526               		.cfi_def_cfa_register 28
 527               	/* prologue: function */
 528               	/* frame size = 0 */
 529               	/* stack size = 2 */
 530               	.L__stack_usage = 2
  65:ServerLLDN.c  **** 	if(msgReq.options != 0)
 531               		.loc 6 65 0
 532 01da 8091 0000 		lds r24,msgReq+9
 533 01de 9091 0000 		lds r25,msgReq+9+1
 534 01e2 892B      		or r24,r25
 535 01e4 01F0      		breq .L17
  66:ServerLLDN.c  **** 	{
  67:ServerLLDN.c  **** 		printf("\nMSG REQ SENT %d",msgReq.options);
 536               		.loc 6 67 0
 537 01e6 8091 0000 		lds r24,msgReq+9
 538 01ea 9091 0000 		lds r25,msgReq+9+1
 539 01ee 292F      		mov r18,r25
 540 01f0 2F93      		push r18
 541 01f2 8F93      		push r24
 542 01f4 80E0      		ldi r24,lo8(.LC1)
 543 01f6 90E0      		ldi r25,hi8(.LC1)
 544 01f8 892F      		mov r24,r25
 545 01fa 8F93      		push r24
 546 01fc 80E0      		ldi r24,lo8(.LC1)
 547 01fe 90E0      		ldi r25,hi8(.LC1)
 548 0200 8F93      		push r24
 549 0202 0E94 0000 		call printf
 550 0206 0F90      		pop __tmp_reg__
 551 0208 0F90      		pop __tmp_reg__
 552 020a 0F90      		pop __tmp_reg__
 553 020c 0F90      		pop __tmp_reg__
  68:ServerLLDN.c  **** 		NWK_DataReq(&msgReq);
 554               		.loc 6 68 0
 555 020e 80E0      		ldi r24,lo8(msgReq)
 556 0210 90E0      		ldi r25,hi8(msgReq)
 557 0212 0E94 0000 		call NWK_DataReq
 558               	.L17:
  69:ServerLLDN.c  **** 	#if !APP_COORDINATOR
  70:ServerLLDN.c  **** 	#endif
  71:ServerLLDN.c  **** 	}
  72:ServerLLDN.c  **** }
 559               		.loc 6 72 0
 560 0216 0000      		nop
 561               	/* epilogue start */
 562 0218 DF91      		pop r29
 563 021a CF91      		pop r28
 564 021c 0895      		ret
 565               		.cfi_endproc
 566               	.LFE130:
 568               	.global	appPanState
 569               		.section	.data.appPanState,"aw",@progbits
 572               	appPanState:
 573 0000 01        		.byte	1
 574               		.comm	nodes_info_arr,1016,1
 575               	.global	config_request_frame
 576               		.section	.data.config_request_frame,"aw",@progbits
 579               	config_request_frame:
 580 0000 0F        		.byte	15
 581 0001 00        		.byte	0
 582 0002 0F        		.byte	15
 583 0003 0000      		.zero	2
 584 0005 80        		.byte	128
 585               	.global	conf_req_list
 586               		.section	.bss.conf_req_list,"aw",@nobits
 589               	conf_req_list:
 590 0000 0000      		.zero	2
 591               		.comm	conf_req_arr,508,1
 592               	.global	conf_req_index
 593               		.section	.bss.conf_req_index,"aw",@nobits
 596               	conf_req_index:
 597 0000 0000      		.zero	2
 598               		.comm	ACKFrame,33,1
 599               	.global	ACKFrame_size
 600               		.section	.bss.ACKFrame_size,"aw",@nobits
 603               	ACKFrame_size:
 604 0000 0000      		.zero	2
 605               	.global	beaconInterval
 606               		.section	.bss.beaconInterval,"aw",@nobits
 609               	beaconInterval:
 610 0000 0000 0000 		.zero	4
 611               	.global	macLLDNnumUplinkTS
 612               		.section	.bss.macLLDNnumUplinkTS,"aw",@nobits
 615               	macLLDNnumUplinkTS:
 616 0000 0000      		.zero	2
 617               		.section	.bss.tmrDelay,"aw",@nobits
 620               	tmrDelay:
 621 0000 0000 0000 		.zero	13
 621      0000 0000 
 621      0000 0000 
 621      00
 622               	.global	counter_associados
 623               		.section	.bss.counter_associados,"aw",@nobits
 626               	counter_associados:
 627 0000 0000      		.zero	2
 628               	.global	cycles_counter
 629               		.section	.data.cycles_counter,"aw",@progbits
 632               	cycles_counter:
 633 0000 01        		.byte	1
 634               		.text
 636               	tmrDelayHandler:
 637               	.LFB131:
  73:ServerLLDN.c  **** 
  74:ServerLLDN.c  **** #if APP_COORDINATOR
  75:ServerLLDN.c  **** 
  76:ServerLLDN.c  **** 	#define NODOS_ASSOCIADOS_ESPERADOS 12
  77:ServerLLDN.c  **** 	
  78:ServerLLDN.c  **** 	AppPanState_t appPanState = APP_PAN_STATE_RESET; // Initial state of PAN node
  79:ServerLLDN.c  **** 	
  80:ServerLLDN.c  **** 	/* Configuration Request Frames */
  81:ServerLLDN.c  **** 	/* Da pra mudar o envio do confrequest pra ja usar essa array com as informas dos nodos */	
  82:ServerLLDN.c  **** 	nodes_info_t nodes_info_arr[254]; // Array for Configure Request messages, one position per node, 
  83:ServerLLDN.c  **** 	NWK_ConfigRequest_t config_request_frame = { .id = LL_CONFIGURATION_REQUEST,
  84:ServerLLDN.c  **** 												 .s_macAddr = APP_ADDR,
  85:ServerLLDN.c  **** 												 .tx_channel = APP_CHANNEL,
  86:ServerLLDN.c  **** 												 .conf.macLLDNmgmtTS = MacLLDNMgmtTS };
  87:ServerLLDN.c  **** 	nodes_info_list_t *conf_req_list = NULL;
  88:ServerLLDN.c  **** 	int conf_req_arr[254];
  89:ServerLLDN.c  **** 	int conf_req_index = 0;
  90:ServerLLDN.c  **** 	/* Acknowledge Frame and Array */
  91:ServerLLDN.c  **** 	NWK_ACKFormat_t ACKFrame;	// ACK Frame Payload used in Discovery State
  92:ServerLLDN.c  **** 	int ACKFrame_size = 0;
  93:ServerLLDN.c  **** 
  94:ServerLLDN.c  **** 	float beaconInterval = 0; // no precisa ser global
  95:ServerLLDN.c  **** 	
  96:ServerLLDN.c  **** 	int macLLDNnumUplinkTS = 0;		// Number of uplink timeslots, is also the control of associated node
  97:ServerLLDN.c  **** 	
  98:ServerLLDN.c  **** 	/* This timer implements a delay between messages, 
  99:ServerLLDN.c  **** 	 * if not used the nodes are not able to receive the message
 100:ServerLLDN.c  **** 	 */
 101:ServerLLDN.c  **** 	static SYS_Timer_t tmrDelay;	
 102:ServerLLDN.c  **** 	
 103:ServerLLDN.c  **** 	/*  Control variables for testing */	
 104:ServerLLDN.c  **** 	int counter_associados = 0;		// Associated nodes counter
 105:ServerLLDN.c  **** 	uint8_t cycles_counter = macLLDNdiscoveryModeTimeout;
 106:ServerLLDN.c  **** 
 107:ServerLLDN.c  **** 	
 108:ServerLLDN.c  **** 	static void tmrDelayHandler(SYS_Timer_t *timer)
 109:ServerLLDN.c  **** 	{
 638               		.loc 6 109 0
 639               		.cfi_startproc
 640 021e CF93      		push r28
 641               	.LCFI32:
 642               		.cfi_def_cfa_offset 3
 643               		.cfi_offset 28, -2
 644 0220 DF93      		push r29
 645               	.LCFI33:
 646               		.cfi_def_cfa_offset 4
 647               		.cfi_offset 29, -3
 648 0222 00D0      		rcall .
 649               	.LCFI34:
 650               		.cfi_def_cfa_offset 6
 651 0224 CDB7      		in r28,__SP_L__
 652 0226 DEB7      		in r29,__SP_H__
 653               	.LCFI35:
 654               		.cfi_def_cfa_register 28
 655               	/* prologue: function */
 656               	/* frame size = 2 */
 657               	/* stack size = 4 */
 658               	.L__stack_usage = 4
 659 0228 9A83      		std Y+2,r25
 660 022a 8983      		std Y+1,r24
 110:ServerLLDN.c  **** 		appState = APP_STATE_SEND;
 661               		.loc 6 110 0
 662 022c 82E0      		ldi r24,lo8(2)
 663 022e 8093 0000 		sts appState,r24
 111:ServerLLDN.c  **** 	}
 664               		.loc 6 111 0
 665 0232 0000      		nop
 666               	/* epilogue start */
 667 0234 0F90      		pop __tmp_reg__
 668 0236 0F90      		pop __tmp_reg__
 669 0238 DF91      		pop r29
 670 023a CF91      		pop r28
 671 023c 0895      		ret
 672               		.cfi_endproc
 673               	.LFE131:
 676               	lldn_server_beacon:
 677               	.LFB132:
 112:ServerLLDN.c  **** 	
 113:ServerLLDN.c  **** 	static void lldn_server_beacon(void)
 114:ServerLLDN.c  **** 	{
 678               		.loc 6 114 0
 679               		.cfi_startproc
 680 023e CF93      		push r28
 681               	.LCFI36:
 682               		.cfi_def_cfa_offset 3
 683               		.cfi_offset 28, -2
 684 0240 DF93      		push r29
 685               	.LCFI37:
 686               		.cfi_def_cfa_offset 4
 687               		.cfi_offset 29, -3
 688 0242 CDB7      		in r28,__SP_L__
 689 0244 DEB7      		in r29,__SP_H__
 690               	.LCFI38:
 691               		.cfi_def_cfa_register 28
 692               	/* prologue: function */
 693               	/* frame size = 0 */
 694               	/* stack size = 2 */
 695               	.L__stack_usage = 2
 115:ServerLLDN.c  **** 		macsc_enable_manual_bts();
 696               		.loc 6 115 0
 697 0246 0E94 0000 		call macsc_enable_manual_bts
 116:ServerLLDN.c  **** 		appState = APP_STATE_SEND;
 698               		.loc 6 116 0
 699 024a 82E0      		ldi r24,lo8(2)
 700 024c 8093 0000 		sts appState,r24
 117:ServerLLDN.c  **** 	}
 701               		.loc 6 117 0
 702 0250 0000      		nop
 703               	/* epilogue start */
 704 0252 DF91      		pop r29
 705 0254 CF91      		pop r28
 706 0256 0895      		ret
 707               		.cfi_endproc
 708               	.LFE132:
 711               	downlink_delay_handler:
 712               	.LFB133:
 118:ServerLLDN.c  **** 	
 119:ServerLLDN.c  **** 	static void downlink_delay_handler(void)
 120:ServerLLDN.c  **** 	{
 713               		.loc 6 120 0
 714               		.cfi_startproc
 715 0258 CF93      		push r28
 716               	.LCFI39:
 717               		.cfi_def_cfa_offset 3
 718               		.cfi_offset 28, -2
 719 025a DF93      		push r29
 720               	.LCFI40:
 721               		.cfi_def_cfa_offset 4
 722               		.cfi_offset 29, -3
 723 025c CDB7      		in r28,__SP_L__
 724 025e DEB7      		in r29,__SP_H__
 725               	.LCFI41:
 726               		.cfi_def_cfa_register 28
 727               	/* prologue: function */
 728               	/* frame size = 0 */
 729               	/* stack size = 2 */
 730               	.L__stack_usage = 2
 121:ServerLLDN.c  **** 		if(msgReq.options == NWK_OPT_LLDN_ACK)
 731               		.loc 6 121 0
 732 0260 8091 0000 		lds r24,msgReq+9
 733 0264 9091 0000 		lds r25,msgReq+9+1
 734 0268 8115      		cp r24,__zero_reg__
 735 026a 9044      		sbci r25,64
 736 026c 01F4      		brne .L22
 122:ServerLLDN.c  **** 		{
 123:ServerLLDN.c  **** 		appState = APP_STATE_SEND;
 737               		.loc 6 123 0
 738 026e 82E0      		ldi r24,lo8(2)
 739 0270 8093 0000 		sts appState,r24
 740               	.L22:
 124:ServerLLDN.c  **** 		}
 125:ServerLLDN.c  **** 	}
 741               		.loc 6 125 0
 742 0274 0000      		nop
 743               	/* epilogue start */
 744 0276 DF91      		pop r29
 745 0278 CF91      		pop r28
 746 027a 0895      		ret
 747               		.cfi_endproc
 748               	.LFE133:
 751               	end_of_online_handler:
 752               	.LFB134:
 126:ServerLLDN.c  **** 
 127:ServerLLDN.c  **** 	static void end_of_online_handler(void)
 128:ServerLLDN.c  **** 	{
 753               		.loc 6 128 0
 754               		.cfi_startproc
 755 027c CF93      		push r28
 756               	.LCFI42:
 757               		.cfi_def_cfa_offset 3
 758               		.cfi_offset 28, -2
 759 027e DF93      		push r29
 760               	.LCFI43:
 761               		.cfi_def_cfa_offset 4
 762               		.cfi_offset 29, -3
 763 0280 CDB7      		in r28,__SP_L__
 764 0282 DEB7      		in r29,__SP_H__
 765               	.LCFI44:
 766               		.cfi_def_cfa_register 28
 767               	/* prologue: function */
 768               	/* frame size = 0 */
 769               	/* stack size = 2 */
 770               	.L__stack_usage = 2
 129:ServerLLDN.c  **** 		appState = APP_STATE_ATT_PAN_STATE;
 771               		.loc 6 129 0
 772 0284 83E0      		ldi r24,lo8(3)
 773 0286 8093 0000 		sts appState,r24
 130:ServerLLDN.c  **** 		appPanState = APP_PAN_STATE_ONLINE_END_BE;
 774               		.loc 6 130 0
 775 028a 8AE0      		ldi r24,lo8(10)
 776 028c 8093 0000 		sts appPanState,r24
 131:ServerLLDN.c  **** 	}
 777               		.loc 6 131 0
 778 0290 0000      		nop
 779               	/* epilogue start */
 780 0292 DF91      		pop r29
 781 0294 CF91      		pop r28
 782 0296 0895      		ret
 783               		.cfi_endproc
 784               	.LFE134:
 786               		.section	.rodata
 787               	.LC2:
 788 0011 0A2A 2A2A 		.string	"\n***TIMESLOT****"
 788      5449 4D45 
 788      534C 4F54 
 788      2A2A 2A2A 
 788      00
 789               		.text
 791               	teste_handler:
 792               	.LFB135:
 132:ServerLLDN.c  **** 	
 133:ServerLLDN.c  **** 	#if TIMESLOT_TIMER
 134:ServerLLDN.c  **** 	static void teste_handler(void)
 135:ServerLLDN.c  **** 	{
 793               		.loc 6 135 0
 794               		.cfi_startproc
 795 0298 CF93      		push r28
 796               	.LCFI45:
 797               		.cfi_def_cfa_offset 3
 798               		.cfi_offset 28, -2
 799 029a DF93      		push r29
 800               	.LCFI46:
 801               		.cfi_def_cfa_offset 4
 802               		.cfi_offset 29, -3
 803 029c CDB7      		in r28,__SP_L__
 804 029e DEB7      		in r29,__SP_H__
 805               	.LCFI47:
 806               		.cfi_def_cfa_register 28
 807               	/* prologue: function */
 808               	/* frame size = 0 */
 809               	/* stack size = 2 */
 810               	.L__stack_usage = 2
 136:ServerLLDN.c  **** 		if(msgReq.options)
 811               		.loc 6 136 0
 812 02a0 8091 0000 		lds r24,msgReq+9
 813 02a4 9091 0000 		lds r25,msgReq+9+1
 814 02a8 892B      		or r24,r25
 815 02aa 01F0      		breq .L25
 137:ServerLLDN.c  **** 			printf("\n***TIMESLOT****");
 816               		.loc 6 137 0
 817 02ac 80E0      		ldi r24,lo8(.LC2)
 818 02ae 90E0      		ldi r25,hi8(.LC2)
 819 02b0 892F      		mov r24,r25
 820 02b2 8F93      		push r24
 821 02b4 80E0      		ldi r24,lo8(.LC2)
 822 02b6 90E0      		ldi r25,hi8(.LC2)
 823 02b8 8F93      		push r24
 824 02ba 0E94 0000 		call printf
 825 02be 0F90      		pop __tmp_reg__
 826 02c0 0F90      		pop __tmp_reg__
 827               	.L25:
 138:ServerLLDN.c  **** 		macsc_disable_cmp_int(MACSC_CC3);
 828               		.loc 6 138 0
 829 02c2 83E0      		ldi r24,lo8(3)
 830 02c4 0E94 0000 		call macsc_disable_cmp_int
 139:ServerLLDN.c  **** 	}
 831               		.loc 6 139 0
 832 02c8 0000      		nop
 833               	/* epilogue start */
 834 02ca DF91      		pop r29
 835 02cc CF91      		pop r28
 836 02ce 0895      		ret
 837               		.cfi_endproc
 838               	.LFE135:
 840               		.section	.rodata
 841               	.LC3:
 842 0022 0A41 6464 		.string	"\nAddres %d is already on ACK Array"
 842      7265 7320 
 842      2564 2069 
 842      7320 616C 
 842      7265 6164 
 843               		.text
 845               	addToAckArray:
 846               	.LFB136:
 140:ServerLLDN.c  **** 	#endif
 141:ServerLLDN.c  **** 	
 142:ServerLLDN.c  **** 	static bool addToAckArray(uint8_t addres)
 143:ServerLLDN.c  **** 	{	
 847               		.loc 6 143 0
 848               		.cfi_startproc
 849 02d0 CF93      		push r28
 850               	.LCFI48:
 851               		.cfi_def_cfa_offset 3
 852               		.cfi_offset 28, -2
 853 02d2 DF93      		push r29
 854               	.LCFI49:
 855               		.cfi_def_cfa_offset 4
 856               		.cfi_offset 29, -3
 857 02d4 00D0      		rcall .
 858 02d6 00D0      		rcall .
 859 02d8 1F92      		push __zero_reg__
 860               	.LCFI50:
 861               		.cfi_def_cfa_offset 9
 862 02da CDB7      		in r28,__SP_L__
 863 02dc DEB7      		in r29,__SP_H__
 864               	.LCFI51:
 865               		.cfi_def_cfa_register 28
 866               	/* prologue: function */
 867               	/* frame size = 5 */
 868               	/* stack size = 7 */
 869               	.L__stack_usage = 7
 870 02de 8D83      		std Y+5,r24
 144:ServerLLDN.c  **** 		int pos =(int) addres / 8;
 871               		.loc 6 144 0
 872 02e0 8D81      		ldd r24,Y+5
 873 02e2 8695      		lsr r24
 874 02e4 8695      		lsr r24
 875 02e6 8695      		lsr r24
 876 02e8 882F      		mov r24,r24
 877 02ea 90E0      		ldi r25,0
 878 02ec 9A83      		std Y+2,r25
 879 02ee 8983      		std Y+1,r24
 145:ServerLLDN.c  **** 		int bit_shift = 8 - (addres % 8);
 880               		.loc 6 145 0
 881 02f0 8D81      		ldd r24,Y+5
 882 02f2 882F      		mov r24,r24
 883 02f4 90E0      		ldi r25,0
 884 02f6 8770      		andi r24,7
 885 02f8 9927      		clr r25
 886 02fa 28E0      		ldi r18,lo8(8)
 887 02fc 30E0      		ldi r19,0
 888 02fe A901      		movw r20,r18
 889 0300 481B      		sub r20,r24
 890 0302 590B      		sbc r21,r25
 891 0304 CA01      		movw r24,r20
 892 0306 9C83      		std Y+4,r25
 893 0308 8B83      		std Y+3,r24
 146:ServerLLDN.c  **** 		
 147:ServerLLDN.c  **** 		if(ACKFrame.ackFlags[pos] & 1 << bit_shift)
 894               		.loc 6 147 0
 895 030a 8981      		ldd r24,Y+1
 896 030c 9A81      		ldd r25,Y+2
 897 030e 8050      		subi r24,lo8(-(ACKFrame+1))
 898 0310 9040      		sbci r25,hi8(-(ACKFrame+1))
 899 0312 FC01      		movw r30,r24
 900 0314 8081      		ld r24,Z
 901 0316 882F      		mov r24,r24
 902 0318 90E0      		ldi r25,0
 903 031a 0B80      		ldd r0,Y+3
 904 031c 00C0      		rjmp 2f
 905               		1:
 906 031e 9595      		asr r25
 907 0320 8795      		ror r24
 908               		2:
 909 0322 0A94      		dec r0
 910 0324 02F4      		brpl 1b
 911 0326 8170      		andi r24,1
 912 0328 9927      		clr r25
 913 032a 892B      		or r24,r25
 914 032c 01F0      		breq .L27
 148:ServerLLDN.c  **** 		{
 149:ServerLLDN.c  **** 			printf("\nAddres %d is already on ACK Array", addres);
 915               		.loc 6 149 0
 916 032e 8D81      		ldd r24,Y+5
 917 0330 882F      		mov r24,r24
 918 0332 90E0      		ldi r25,0
 919 0334 292F      		mov r18,r25
 920 0336 2F93      		push r18
 921 0338 8F93      		push r24
 922 033a 80E0      		ldi r24,lo8(.LC3)
 923 033c 90E0      		ldi r25,hi8(.LC3)
 924 033e 892F      		mov r24,r25
 925 0340 8F93      		push r24
 926 0342 80E0      		ldi r24,lo8(.LC3)
 927 0344 90E0      		ldi r25,hi8(.LC3)
 928 0346 8F93      		push r24
 929 0348 0E94 0000 		call printf
 930 034c 0F90      		pop __tmp_reg__
 931 034e 0F90      		pop __tmp_reg__
 932 0350 0F90      		pop __tmp_reg__
 933 0352 0F90      		pop __tmp_reg__
 150:ServerLLDN.c  **** 			return false;
 934               		.loc 6 150 0
 935 0354 80E0      		ldi r24,0
 936 0356 00C0      		rjmp .L28
 937               	.L27:
 151:ServerLLDN.c  **** 		}
 152:ServerLLDN.c  **** 		ACKFrame.ackFlags[pos] = 1 << bit_shift;
 938               		.loc 6 152 0
 939 0358 81E0      		ldi r24,lo8(1)
 940 035a 90E0      		ldi r25,0
 941 035c 0B80      		ldd r0,Y+3
 942 035e 00C0      		rjmp 2f
 943               		1:
 944 0360 880F      		lsl r24
 945 0362 991F      		rol r25
 946               		2:
 947 0364 0A94      		dec r0
 948 0366 02F4      		brpl 1b
 949 0368 282F      		mov r18,r24
 950 036a 8981      		ldd r24,Y+1
 951 036c 9A81      		ldd r25,Y+2
 952 036e 8050      		subi r24,lo8(-(ACKFrame+1))
 953 0370 9040      		sbci r25,hi8(-(ACKFrame+1))
 954 0372 FC01      		movw r30,r24
 955 0374 2083      		st Z,r18
 153:ServerLLDN.c  **** 		if (pos + 1 > ACKFrame_size)
 956               		.loc 6 153 0
 957 0376 8981      		ldd r24,Y+1
 958 0378 9A81      		ldd r25,Y+2
 959 037a 9C01      		movw r18,r24
 960 037c 2F5F      		subi r18,-1
 961 037e 3F4F      		sbci r19,-1
 962 0380 8091 0000 		lds r24,ACKFrame_size
 963 0384 9091 0000 		lds r25,ACKFrame_size+1
 964 0388 8217      		cp r24,r18
 965 038a 9307      		cpc r25,r19
 966 038c 04F4      		brge .L29
 154:ServerLLDN.c  **** 			ACKFrame_size = pos + 1;
 967               		.loc 6 154 0
 968 038e 8981      		ldd r24,Y+1
 969 0390 9A81      		ldd r25,Y+2
 970 0392 0196      		adiw r24,1
 971 0394 9093 0000 		sts ACKFrame_size+1,r25
 972 0398 8093 0000 		sts ACKFrame_size,r24
 973               	.L29:
 155:ServerLLDN.c  **** 		
 156:ServerLLDN.c  **** 		return true;
 974               		.loc 6 156 0
 975 039c 81E0      		ldi r24,lo8(1)
 976               	.L28:
 977               	/* epilogue start */
 157:ServerLLDN.c  **** 	}
 978               		.loc 6 157 0
 979 039e 0F90      		pop __tmp_reg__
 980 03a0 0F90      		pop __tmp_reg__
 981 03a2 0F90      		pop __tmp_reg__
 982 03a4 0F90      		pop __tmp_reg__
 983 03a6 0F90      		pop __tmp_reg__
 984 03a8 DF91      		pop r29
 985 03aa CF91      		pop r28
 986 03ac 0895      		ret
 987               		.cfi_endproc
 988               	.LFE136:
 991               	addConfRequestArray:
 992               	.LFB137:
 158:ServerLLDN.c  **** 
 159:ServerLLDN.c  **** 	static void addConfRequestArray(NWK_ConfigStatus_t *node)
 160:ServerLLDN.c  **** 	{
 993               		.loc 6 160 0
 994               		.cfi_startproc
 995 03ae CF93      		push r28
 996               	.LCFI52:
 997               		.cfi_def_cfa_offset 3
 998               		.cfi_offset 28, -2
 999 03b0 DF93      		push r29
 1000               	.LCFI53:
 1001               		.cfi_def_cfa_offset 4
 1002               		.cfi_offset 29, -3
 1003 03b2 00D0      		rcall .
 1004               	.LCFI54:
 1005               		.cfi_def_cfa_offset 6
 1006 03b4 CDB7      		in r28,__SP_L__
 1007 03b6 DEB7      		in r29,__SP_H__
 1008               	.LCFI55:
 1009               		.cfi_def_cfa_register 28
 1010               	/* prologue: function */
 1011               	/* frame size = 2 */
 1012               	/* stack size = 4 */
 1013               	.L__stack_usage = 4
 1014 03b8 9A83      		std Y+2,r25
 1015 03ba 8983      		std Y+1,r24
 161:ServerLLDN.c  **** 		//printf("conf_req_index : %d", conf_req_index);
 162:ServerLLDN.c  **** 		conf_req_index++;
 1016               		.loc 6 162 0
 1017 03bc 8091 0000 		lds r24,conf_req_index
 1018 03c0 9091 0000 		lds r25,conf_req_index+1
 1019 03c4 0196      		adiw r24,1
 1020 03c6 9093 0000 		sts conf_req_index+1,r25
 1021 03ca 8093 0000 		sts conf_req_index,r24
 163:ServerLLDN.c  **** 		
 164:ServerLLDN.c  **** 		if(node->ts_dir.tsDuration > config_request_frame.conf.tsDuration)
 1022               		.loc 6 164 0
 1023 03ce 8981      		ldd r24,Y+1
 1024 03d0 9A81      		ldd r25,Y+2
 1025 03d2 FC01      		movw r30,r24
 1026 03d4 8481      		ldd r24,Z+4
 1027 03d6 8F77      		andi r24,lo8(127)
 1028 03d8 282F      		mov r18,r24
 1029 03da 30E0      		ldi r19,0
 1030 03dc 8091 0000 		lds r24,config_request_frame+5
 1031 03e0 8F77      		andi r24,lo8(127)
 1032 03e2 882F      		mov r24,r24
 1033 03e4 90E0      		ldi r25,0
 1034 03e6 8217      		cp r24,r18
 1035 03e8 9307      		cpc r25,r19
 1036 03ea 04F4      		brge .L31
 165:ServerLLDN.c  **** 		config_request_frame.conf.tsDuration = node->ts_dir.tsDuration;
 1037               		.loc 6 165 0
 1038 03ec 8981      		ldd r24,Y+1
 1039 03ee 9A81      		ldd r25,Y+2
 1040 03f0 FC01      		movw r30,r24
 1041 03f2 8481      		ldd r24,Z+4
 1042 03f4 8F77      		andi r24,lo8(127)
 1043 03f6 8F77      		andi r24,lo8(127)
 1044 03f8 9091 0000 		lds r25,config_request_frame+5
 1045 03fc 9078      		andi r25,lo8(-128)
 1046 03fe 892B      		or r24,r25
 1047 0400 8093 0000 		sts config_request_frame+5,r24
 1048               	.L31:
 166:ServerLLDN.c  **** 		
 167:ServerLLDN.c  **** 		// tem que atualizar o tamanho final
 168:ServerLLDN.c  **** 		nodes_info_arr[conf_req_index].req_timeslot_duration = node->ts_dir.tsDuration;
 1049               		.loc 6 168 0
 1050 0404 8091 0000 		lds r24,conf_req_index
 1051 0408 9091 0000 		lds r25,conf_req_index+1
 1052 040c 2981      		ldd r18,Y+1
 1053 040e 3A81      		ldd r19,Y+2
 1054 0410 F901      		movw r30,r18
 1055 0412 2481      		ldd r18,Z+4
 1056 0414 2F77      		andi r18,lo8(127)
 1057 0416 880F      		lsl r24
 1058 0418 991F      		rol r25
 1059 041a 880F      		lsl r24
 1060 041c 991F      		rol r25
 1061 041e 8050      		subi r24,lo8(-(nodes_info_arr+3))
 1062 0420 9040      		sbci r25,hi8(-(nodes_info_arr+3))
 1063 0422 FC01      		movw r30,r24
 1064 0424 2083      		st Z,r18
 169:ServerLLDN.c  **** 		nodes_info_arr[conf_req_index].mac_addr = node->macAddr;
 1065               		.loc 6 169 0
 1066 0426 8091 0000 		lds r24,conf_req_index
 1067 042a 9091 0000 		lds r25,conf_req_index+1
 1068 042e 2981      		ldd r18,Y+1
 1069 0430 3A81      		ldd r19,Y+2
 1070 0432 F901      		movw r30,r18
 1071 0434 2381      		ldd r18,Z+3
 1072 0436 222F      		mov r18,r18
 1073 0438 30E0      		ldi r19,0
 1074 043a 880F      		lsl r24
 1075 043c 991F      		rol r25
 1076 043e 880F      		lsl r24
 1077 0440 991F      		rol r25
 1078 0442 8050      		subi r24,lo8(-(nodes_info_arr+1))
 1079 0444 9040      		sbci r25,hi8(-(nodes_info_arr+1))
 1080 0446 FC01      		movw r30,r24
 1081 0448 3183      		std Z+1,r19
 1082 044a 2083      		st Z,r18
 170:ServerLLDN.c  **** 		nodes_info_arr[conf_req_index].assigned_time_slot = (uint8_t)conf_req_index;
 1083               		.loc 6 170 0
 1084 044c 8091 0000 		lds r24,conf_req_index
 1085 0450 9091 0000 		lds r25,conf_req_index+1
 1086 0454 2091 0000 		lds r18,conf_req_index
 1087 0458 3091 0000 		lds r19,conf_req_index+1
 1088 045c 880F      		lsl r24
 1089 045e 991F      		rol r25
 1090 0460 880F      		lsl r24
 1091 0462 991F      		rol r25
 1092 0464 8050      		subi r24,lo8(-(nodes_info_arr))
 1093 0466 9040      		sbci r25,hi8(-(nodes_info_arr))
 1094 0468 FC01      		movw r30,r24
 1095 046a 2083      		st Z,r18
 171:ServerLLDN.c  **** 
 172:ServerLLDN.c  **** 	}
 1096               		.loc 6 172 0
 1097 046c 0000      		nop
 1098               	/* epilogue start */
 1099 046e 0F90      		pop __tmp_reg__
 1100 0470 0F90      		pop __tmp_reg__
 1101 0472 DF91      		pop r29
 1102 0474 CF91      		pop r28
 1103 0476 0895      		ret
 1104               		.cfi_endproc
 1105               	.LFE137:
 1108               	CopyToConfigRequest:
 1109               	.LFB138:
 173:ServerLLDN.c  **** 
 174:ServerLLDN.c  **** 	static void CopyToConfigRequest(int i)
 175:ServerLLDN.c  **** 	{
 1110               		.loc 6 175 0
 1111               		.cfi_startproc
 1112 0478 CF93      		push r28
 1113               	.LCFI56:
 1114               		.cfi_def_cfa_offset 3
 1115               		.cfi_offset 28, -2
 1116 047a DF93      		push r29
 1117               	.LCFI57:
 1118               		.cfi_def_cfa_offset 4
 1119               		.cfi_offset 29, -3
 1120 047c 00D0      		rcall .
 1121               	.LCFI58:
 1122               		.cfi_def_cfa_offset 6
 1123 047e CDB7      		in r28,__SP_L__
 1124 0480 DEB7      		in r29,__SP_H__
 1125               	.LCFI59:
 1126               		.cfi_def_cfa_register 28
 1127               	/* prologue: function */
 1128               	/* frame size = 2 */
 1129               	/* stack size = 4 */
 1130               	.L__stack_usage = 4
 1131 0482 9A83      		std Y+2,r25
 1132 0484 8983      		std Y+1,r24
 176:ServerLLDN.c  **** 		config_request_frame.assTimeSlot = nodes_info_arr[i].assigned_time_slot;
 1133               		.loc 6 176 0
 1134 0486 8981      		ldd r24,Y+1
 1135 0488 9A81      		ldd r25,Y+2
 1136 048a 880F      		lsl r24
 1137 048c 991F      		rol r25
 1138 048e 880F      		lsl r24
 1139 0490 991F      		rol r25
 1140 0492 8050      		subi r24,lo8(-(nodes_info_arr))
 1141 0494 9040      		sbci r25,hi8(-(nodes_info_arr))
 1142 0496 FC01      		movw r30,r24
 1143 0498 8081      		ld r24,Z
 1144 049a 8093 0000 		sts config_request_frame+3,r24
 177:ServerLLDN.c  **** 		config_request_frame.macAddr = nodes_info_arr[i].mac_addr;
 1145               		.loc 6 177 0
 1146 049e 8981      		ldd r24,Y+1
 1147 04a0 9A81      		ldd r25,Y+2
 1148 04a2 880F      		lsl r24
 1149 04a4 991F      		rol r25
 1150 04a6 880F      		lsl r24
 1151 04a8 991F      		rol r25
 1152 04aa 8050      		subi r24,lo8(-(nodes_info_arr+1))
 1153 04ac 9040      		sbci r25,hi8(-(nodes_info_arr+1))
 1154 04ae FC01      		movw r30,r24
 1155 04b0 8081      		ld r24,Z
 1156 04b2 9181      		ldd r25,Z+1
 1157 04b4 8093 0000 		sts config_request_frame+4,r24
 178:ServerLLDN.c  **** 	}
 1158               		.loc 6 178 0
 1159 04b8 0000      		nop
 1160               	/* epilogue start */
 1161 04ba 0F90      		pop __tmp_reg__
 1162 04bc 0F90      		pop __tmp_reg__
 1163 04be DF91      		pop r29
 1164 04c0 CF91      		pop r28
 1165 04c2 0895      		ret
 1166               		.cfi_endproc
 1167               	.LFE138:
 1169               		.section	.rodata
 1170               	.LC4:
 1171 0045 0A44 4953 		.string	"\nDISC %hhx"
 1171      4320 2568 
 1171      6878 00
 1172               	.LC5:
 1173 0050 0A43 4F4E 		.string	"\nCONF %d"
 1173      4620 2564 
 1173      00
 1174               		.text
 1176               	appCommandInd:
 1177               	.LFB139:
 179:ServerLLDN.c  **** 
 180:ServerLLDN.c  **** 
 181:ServerLLDN.c  **** 	static bool appCommandInd(NWK_DataInd_t *ind)
 182:ServerLLDN.c  **** 	{
 1178               		.loc 6 182 0
 1179               		.cfi_startproc
 1180 04c4 CF93      		push r28
 1181               	.LCFI60:
 1182               		.cfi_def_cfa_offset 3
 1183               		.cfi_offset 28, -2
 1184 04c6 DF93      		push r29
 1185               	.LCFI61:
 1186               		.cfi_def_cfa_offset 4
 1187               		.cfi_offset 29, -3
 1188 04c8 00D0      		rcall .
 1189 04ca 00D0      		rcall .
 1190 04cc 00D0      		rcall .
 1191               	.LCFI62:
 1192               		.cfi_def_cfa_offset 10
 1193 04ce CDB7      		in r28,__SP_L__
 1194 04d0 DEB7      		in r29,__SP_H__
 1195               	.LCFI63:
 1196               		.cfi_def_cfa_register 28
 1197               	/* prologue: function */
 1198               	/* frame size = 6 */
 1199               	/* stack size = 8 */
 1200               	.L__stack_usage = 8
 1201 04d2 9E83      		std Y+6,r25
 1202 04d4 8D83      		std Y+5,r24
 183:ServerLLDN.c  **** 		if(ind->data[0] == LL_DISCOVER_RESPONSE)
 1203               		.loc 6 183 0
 1204 04d6 8D81      		ldd r24,Y+5
 1205 04d8 9E81      		ldd r25,Y+6
 1206 04da FC01      		movw r30,r24
 1207 04dc 8085      		ldd r24,Z+8
 1208 04de 9185      		ldd r25,Z+9
 1209 04e0 FC01      		movw r30,r24
 1210 04e2 8081      		ld r24,Z
 1211 04e4 8D30      		cpi r24,lo8(13)
 1212 04e6 01F4      		brne .L34
 1213               	.LBB2:
 184:ServerLLDN.c  **** 		{
 185:ServerLLDN.c  **** 			NWK_DiscoverResponse_t *msg = (NWK_DiscoverResponse_t*)ind->data;
 1214               		.loc 6 185 0
 1215 04e8 8D81      		ldd r24,Y+5
 1216 04ea 9E81      		ldd r25,Y+6
 1217 04ec FC01      		movw r30,r24
 1218 04ee 8085      		ldd r24,Z+8
 1219 04f0 9185      		ldd r25,Z+9
 1220 04f2 9C83      		std Y+4,r25
 1221 04f4 8B83      		std Y+3,r24
 186:ServerLLDN.c  **** 			addToAckArray(msg->macAddr);	
 1222               		.loc 6 186 0
 1223 04f6 8B81      		ldd r24,Y+3
 1224 04f8 9C81      		ldd r25,Y+4
 1225 04fa FC01      		movw r30,r24
 1226 04fc 8181      		ldd r24,Z+1
 1227 04fe 0E94 0000 		call addToAckArray
 187:ServerLLDN.c  **** 					
 188:ServerLLDN.c  **** 			#if PRINT
 189:ServerLLDN.c  **** 			printf("\nDISC %hhx", msg->macAddr);	
 1228               		.loc 6 189 0
 1229 0502 8B81      		ldd r24,Y+3
 1230 0504 9C81      		ldd r25,Y+4
 1231 0506 FC01      		movw r30,r24
 1232 0508 8181      		ldd r24,Z+1
 1233 050a 882F      		mov r24,r24
 1234 050c 90E0      		ldi r25,0
 1235 050e 292F      		mov r18,r25
 1236 0510 2F93      		push r18
 1237 0512 8F93      		push r24
 1238 0514 80E0      		ldi r24,lo8(.LC4)
 1239 0516 90E0      		ldi r25,hi8(.LC4)
 1240 0518 892F      		mov r24,r25
 1241 051a 8F93      		push r24
 1242 051c 80E0      		ldi r24,lo8(.LC4)
 1243 051e 90E0      		ldi r25,hi8(.LC4)
 1244 0520 8F93      		push r24
 1245 0522 0E94 0000 		call printf
 1246 0526 0F90      		pop __tmp_reg__
 1247 0528 0F90      		pop __tmp_reg__
 1248 052a 0F90      		pop __tmp_reg__
 1249 052c 0F90      		pop __tmp_reg__
 1250               	.LBE2:
 1251 052e 00C0      		rjmp .L35
 1252               	.L34:
 190:ServerLLDN.c  **** 			#endif
 191:ServerLLDN.c  **** 		}
 192:ServerLLDN.c  **** 		else if(ind->data[0] == LL_CONFIGURATION_STATUS)
 1253               		.loc 6 192 0
 1254 0530 8D81      		ldd r24,Y+5
 1255 0532 9E81      		ldd r25,Y+6
 1256 0534 FC01      		movw r30,r24
 1257 0536 8085      		ldd r24,Z+8
 1258 0538 9185      		ldd r25,Z+9
 1259 053a FC01      		movw r30,r24
 1260 053c 8081      		ld r24,Z
 1261 053e 8E30      		cpi r24,lo8(14)
 1262 0540 01F4      		brne .L36
 1263               	.LBB3:
 193:ServerLLDN.c  **** 		{
 194:ServerLLDN.c  **** 			NWK_ConfigStatus_t *msg = (NWK_ConfigStatus_t*)ind->data;
 1264               		.loc 6 194 0
 1265 0542 8D81      		ldd r24,Y+5
 1266 0544 9E81      		ldd r25,Y+6
 1267 0546 FC01      		movw r30,r24
 1268 0548 8085      		ldd r24,Z+8
 1269 054a 9185      		ldd r25,Z+9
 1270 054c 9A83      		std Y+2,r25
 1271 054e 8983      		std Y+1,r24
 195:ServerLLDN.c  **** 			addConfRequestArray(msg);
 1272               		.loc 6 195 0
 1273 0550 8981      		ldd r24,Y+1
 1274 0552 9A81      		ldd r25,Y+2
 1275 0554 0E94 0000 		call addConfRequestArray
 196:ServerLLDN.c  **** 			#if PRINT
 197:ServerLLDN.c  **** 			printf("\nCONF %d", msg->macAddr);	
 1276               		.loc 6 197 0
 1277 0558 8981      		ldd r24,Y+1
 1278 055a 9A81      		ldd r25,Y+2
 1279 055c FC01      		movw r30,r24
 1280 055e 8381      		ldd r24,Z+3
 1281 0560 882F      		mov r24,r24
 1282 0562 90E0      		ldi r25,0
 1283 0564 292F      		mov r18,r25
 1284 0566 2F93      		push r18
 1285 0568 8F93      		push r24
 1286 056a 80E0      		ldi r24,lo8(.LC5)
 1287 056c 90E0      		ldi r25,hi8(.LC5)
 1288 056e 892F      		mov r24,r25
 1289 0570 8F93      		push r24
 1290 0572 80E0      		ldi r24,lo8(.LC5)
 1291 0574 90E0      		ldi r25,hi8(.LC5)
 1292 0576 8F93      		push r24
 1293 0578 0E94 0000 		call printf
 1294 057c 0F90      		pop __tmp_reg__
 1295 057e 0F90      		pop __tmp_reg__
 1296 0580 0F90      		pop __tmp_reg__
 1297 0582 0F90      		pop __tmp_reg__
 1298               	.LBE3:
 1299 0584 00C0      		rjmp .L35
 1300               	.L36:
 198:ServerLLDN.c  **** 			#endif
 199:ServerLLDN.c  **** 		}
 200:ServerLLDN.c  **** 		else return false;			
 1301               		.loc 6 200 0
 1302 0586 80E0      		ldi r24,0
 1303 0588 00C0      		rjmp .L37
 1304               	.L35:
 201:ServerLLDN.c  **** 		return true;
 1305               		.loc 6 201 0
 1306 058a 81E0      		ldi r24,lo8(1)
 1307               	.L37:
 1308               	/* epilogue start */
 202:ServerLLDN.c  **** 	}
 1309               		.loc 6 202 0
 1310 058c 2696      		adiw r28,6
 1311 058e 0FB6      		in __tmp_reg__,__SREG__
 1312 0590 F894      		cli
 1313 0592 DEBF      		out __SP_H__,r29
 1314 0594 0FBE      		out __SREG__,__tmp_reg__
 1315 0596 CDBF      		out __SP_L__,r28
 1316 0598 DF91      		pop r29
 1317 059a CF91      		pop r28
 1318 059c 0895      		ret
 1319               		.cfi_endproc
 1320               	.LFE139:
 1323               	appPanPrepareACK:
 1324               	.LFB140:
 203:ServerLLDN.c  **** 	
 204:ServerLLDN.c  **** 	static void appPanPrepareACK(void)
 205:ServerLLDN.c  **** 	{
 1325               		.loc 6 205 0
 1326               		.cfi_startproc
 1327 059e CF93      		push r28
 1328               	.LCFI64:
 1329               		.cfi_def_cfa_offset 3
 1330               		.cfi_offset 28, -2
 1331 05a0 DF93      		push r29
 1332               	.LCFI65:
 1333               		.cfi_def_cfa_offset 4
 1334               		.cfi_offset 29, -3
 1335 05a2 CDB7      		in r28,__SP_L__
 1336 05a4 DEB7      		in r29,__SP_H__
 1337               	.LCFI66:
 1338               		.cfi_def_cfa_register 28
 1339               	/* prologue: function */
 1340               	/* frame size = 0 */
 1341               	/* stack size = 2 */
 1342               	.L__stack_usage = 2
 206:ServerLLDN.c  **** 		msgReq.dstAddr		= 0;
 1343               		.loc 6 206 0
 1344 05a6 1092 0000 		sts msgReq+5+1,__zero_reg__
 1345 05aa 1092 0000 		sts msgReq+5,__zero_reg__
 207:ServerLLDN.c  **** 		msgReq.dstEndpoint	= APP_BEACON_ENDPOINT;
 1346               		.loc 6 207 0
 1347 05ae 1092 0000 		sts msgReq+7,__zero_reg__
 208:ServerLLDN.c  **** 		msgReq.srcEndpoint	= APP_BEACON_ENDPOINT;
 1348               		.loc 6 208 0
 1349 05b2 1092 0000 		sts msgReq+8,__zero_reg__
 209:ServerLLDN.c  **** 		msgReq.options		= NWK_OPT_LLDN_ACK;
 1350               		.loc 6 209 0
 1351 05b6 80E0      		ldi r24,0
 1352 05b8 90E4      		ldi r25,lo8(64)
 1353 05ba 9093 0000 		sts msgReq+9+1,r25
 1354 05be 8093 0000 		sts msgReq+9,r24
 210:ServerLLDN.c  **** 		msgReq.data	= (uint8_t *)&ACKFrame;
 1355               		.loc 6 210 0
 1356 05c2 80E0      		ldi r24,lo8(ACKFrame)
 1357 05c4 90E0      		ldi r25,hi8(ACKFrame)
 1358 05c6 9093 0000 		sts msgReq+13+1,r25
 1359 05ca 8093 0000 		sts msgReq+13,r24
 211:ServerLLDN.c  **** 		msgReq.size	= sizeof(uint8_t)*(ACKFrame_size + 1);
 1360               		.loc 6 211 0
 1361 05ce 8091 0000 		lds r24,ACKFrame_size
 1362 05d2 9091 0000 		lds r25,ACKFrame_size+1
 1363 05d6 8F5F      		subi r24,lo8(-(1))
 1364 05d8 8093 0000 		sts msgReq+15,r24
 212:ServerLLDN.c  **** 
 213:ServerLLDN.c  **** 	}
 1365               		.loc 6 213 0
 1366 05dc 0000      		nop
 1367               	/* epilogue start */
 1368 05de DF91      		pop r29
 1369 05e0 CF91      		pop r28
 1370 05e2 0895      		ret
 1371               		.cfi_endproc
 1372               	.LFE140:
 1375               	appPanReset:
 1376               	.LFB141:
 214:ServerLLDN.c  **** 
 215:ServerLLDN.c  **** 	static void appPanReset(void)
 216:ServerLLDN.c  **** 	{
 1377               		.loc 6 216 0
 1378               		.cfi_startproc
 1379 05e4 CF93      		push r28
 1380               	.LCFI67:
 1381               		.cfi_def_cfa_offset 3
 1382               		.cfi_offset 28, -2
 1383 05e6 DF93      		push r29
 1384               	.LCFI68:
 1385               		.cfi_def_cfa_offset 4
 1386               		.cfi_offset 29, -3
 1387 05e8 00D0      		rcall .
 1388 05ea 00D0      		rcall .
 1389               	.LCFI69:
 1390               		.cfi_def_cfa_offset 8
 1391 05ec CDB7      		in r28,__SP_L__
 1392 05ee DEB7      		in r29,__SP_H__
 1393               	.LCFI70:
 1394               		.cfi_def_cfa_register 28
 1395               	/* prologue: function */
 1396               	/* frame size = 4 */
 1397               	/* stack size = 6 */
 1398               	.L__stack_usage = 6
 217:ServerLLDN.c  **** 		// prepare beacon reset message
 218:ServerLLDN.c  **** 		msgReq.dstAddr		= 0;
 1399               		.loc 6 218 0
 1400 05f0 1092 0000 		sts msgReq+5+1,__zero_reg__
 1401 05f4 1092 0000 		sts msgReq+5,__zero_reg__
 219:ServerLLDN.c  **** 		msgReq.dstEndpoint	= APP_BEACON_ENDPOINT;
 1402               		.loc 6 219 0
 1403 05f8 1092 0000 		sts msgReq+7,__zero_reg__
 220:ServerLLDN.c  **** 		msgReq.srcEndpoint	= APP_BEACON_ENDPOINT;
 1404               		.loc 6 220 0
 1405 05fc 1092 0000 		sts msgReq+8,__zero_reg__
 221:ServerLLDN.c  **** 		msgReq.options		= NWK_OPT_LLDN_BEACON | NWK_OPT_RESET_STATE;
 1406               		.loc 6 221 0
 1407 0600 80E4      		ldi r24,lo8(64)
 1408 0602 94E0      		ldi r25,lo8(4)
 1409 0604 9093 0000 		sts msgReq+9+1,r25
 1410 0608 8093 0000 		sts msgReq+9,r24
 222:ServerLLDN.c  **** 		msgReq.data			= NULL;
 1411               		.loc 6 222 0
 1412 060c 1092 0000 		sts msgReq+13+1,__zero_reg__
 1413 0610 1092 0000 		sts msgReq+13,__zero_reg__
 223:ServerLLDN.c  **** 		msgReq.size			= 0;
 1414               		.loc 6 223 0
 1415 0614 1092 0000 		sts msgReq+15,__zero_reg__
 1416               	.LBB4:
 224:ServerLLDN.c  **** 
 225:ServerLLDN.c  **** 		for(int i = 0; i < 32; i++)
 1417               		.loc 6 225 0
 1418 0618 1A82      		std Y+2,__zero_reg__
 1419 061a 1982      		std Y+1,__zero_reg__
 1420 061c 00C0      		rjmp .L40
 1421               	.L41:
 226:ServerLLDN.c  **** 			ACKFrame.ackFlags[i] = 0;
 1422               		.loc 6 226 0 discriminator 3
 1423 061e 8981      		ldd r24,Y+1
 1424 0620 9A81      		ldd r25,Y+2
 1425 0622 8050      		subi r24,lo8(-(ACKFrame+1))
 1426 0624 9040      		sbci r25,hi8(-(ACKFrame+1))
 1427 0626 FC01      		movw r30,r24
 1428 0628 1082      		st Z,__zero_reg__
 225:ServerLLDN.c  **** 			ACKFrame.ackFlags[i] = 0;
 1429               		.loc 6 225 0 discriminator 3
 1430 062a 8981      		ldd r24,Y+1
 1431 062c 9A81      		ldd r25,Y+2
 1432 062e 0196      		adiw r24,1
 1433 0630 9A83      		std Y+2,r25
 1434 0632 8983      		std Y+1,r24
 1435               	.L40:
 225:ServerLLDN.c  **** 			ACKFrame.ackFlags[i] = 0;
 1436               		.loc 6 225 0 is_stmt 0 discriminator 1
 1437 0634 8981      		ldd r24,Y+1
 1438 0636 9A81      		ldd r25,Y+2
 1439 0638 8097      		sbiw r24,32
 1440 063a 04F0      		brlt .L41
 1441               	.LBE4:
 1442               	.LBB5:
 227:ServerLLDN.c  **** 		for (int i = 0; i < 255; i++)
 1443               		.loc 6 227 0 is_stmt 1
 1444 063c 1C82      		std Y+4,__zero_reg__
 1445 063e 1B82      		std Y+3,__zero_reg__
 1446 0640 00C0      		rjmp .L42
 1447               	.L43:
 228:ServerLLDN.c  **** 			nodes_info_arr[i].mac_addr = 0;
 1448               		.loc 6 228 0 discriminator 3
 1449 0642 8B81      		ldd r24,Y+3
 1450 0644 9C81      		ldd r25,Y+4
 1451 0646 880F      		lsl r24
 1452 0648 991F      		rol r25
 1453 064a 880F      		lsl r24
 1454 064c 991F      		rol r25
 1455 064e 8050      		subi r24,lo8(-(nodes_info_arr+1))
 1456 0650 9040      		sbci r25,hi8(-(nodes_info_arr+1))
 1457 0652 FC01      		movw r30,r24
 1458 0654 1182      		std Z+1,__zero_reg__
 1459 0656 1082      		st Z,__zero_reg__
 227:ServerLLDN.c  **** 		for (int i = 0; i < 255; i++)
 1460               		.loc 6 227 0 discriminator 3
 1461 0658 8B81      		ldd r24,Y+3
 1462 065a 9C81      		ldd r25,Y+4
 1463 065c 0196      		adiw r24,1
 1464 065e 9C83      		std Y+4,r25
 1465 0660 8B83      		std Y+3,r24
 1466               	.L42:
 227:ServerLLDN.c  **** 		for (int i = 0; i < 255; i++)
 1467               		.loc 6 227 0 is_stmt 0 discriminator 1
 1468 0662 8B81      		ldd r24,Y+3
 1469 0664 9C81      		ldd r25,Y+4
 1470 0666 8F3F      		cpi r24,-1
 1471 0668 9105      		cpc r25,__zero_reg__
 1472 066a 04F0      		brlt .L43
 1473               	.LBE5:
 229:ServerLLDN.c  **** 			
 230:ServerLLDN.c  **** 		ACKFrame_size = 0;
 1474               		.loc 6 230 0 is_stmt 1
 1475 066c 1092 0000 		sts ACKFrame_size+1,__zero_reg__
 1476 0670 1092 0000 		sts ACKFrame_size,__zero_reg__
 231:ServerLLDN.c  **** 		conf_req_index = 0;
 1477               		.loc 6 231 0
 1478 0674 1092 0000 		sts conf_req_index+1,__zero_reg__
 1479 0678 1092 0000 		sts conf_req_index,__zero_reg__
 232:ServerLLDN.c  **** 		counter_associados = 0;
 1480               		.loc 6 232 0
 1481 067c 1092 0000 		sts counter_associados+1,__zero_reg__
 1482 0680 1092 0000 		sts counter_associados,__zero_reg__
 233:ServerLLDN.c  **** 		n = 0;
 1483               		.loc 6 233 0
 1484 0684 1092 0000 		sts n,__zero_reg__
 234:ServerLLDN.c  **** 	}
 1485               		.loc 6 234 0
 1486 0688 0000      		nop
 1487               	/* epilogue start */
 1488 068a 0F90      		pop __tmp_reg__
 1489 068c 0F90      		pop __tmp_reg__
 1490 068e 0F90      		pop __tmp_reg__
 1491 0690 0F90      		pop __tmp_reg__
 1492 0692 DF91      		pop r29
 1493 0694 CF91      		pop r28
 1494 0696 0895      		ret
 1495               		.cfi_endproc
 1496               	.LFE141:
 1498               	.global	__floatsisf
 1499               	.global	__addsf3
 1500               	.global	__divsf3
 1501               	.global	__mulsf3
 1502               	.global	__fixunssfsi
 1504               	appPanDiscInit:
 1505               	.LFB142:
 235:ServerLLDN.c  **** 
 236:ServerLLDN.c  **** 	static void appPanDiscInit(void)
 237:ServerLLDN.c  **** 	{	
 1506               		.loc 6 237 0
 1507               		.cfi_startproc
 1508 0698 CF93      		push r28
 1509               	.LCFI71:
 1510               		.cfi_def_cfa_offset 3
 1511               		.cfi_offset 28, -2
 1512 069a DF93      		push r29
 1513               	.LCFI72:
 1514               		.cfi_def_cfa_offset 4
 1515               		.cfi_offset 29, -3
 1516 069c 00D0      		rcall .
 1517               	.LCFI73:
 1518               		.cfi_def_cfa_offset 6
 1519 069e CDB7      		in r28,__SP_L__
 1520 06a0 DEB7      		in r29,__SP_H__
 1521               	.LCFI74:
 1522               		.cfi_def_cfa_register 28
 1523               	/* prologue: function */
 1524               	/* frame size = 2 */
 1525               	/* stack size = 4 */
 1526               	.L__stack_usage = 4
 1527               	.LBB6:
 238:ServerLLDN.c  **** 		/* clear Ack array of previous discovery state */
 239:ServerLLDN.c  **** 		for(int i = 0; i < 32; i++)
 1528               		.loc 6 239 0
 1529 06a2 1A82      		std Y+2,__zero_reg__
 1530 06a4 1982      		std Y+1,__zero_reg__
 1531 06a6 00C0      		rjmp .L45
 1532               	.L46:
 240:ServerLLDN.c  **** 			ACKFrame.ackFlags[i] = 0;
 1533               		.loc 6 240 0 discriminator 3
 1534 06a8 8981      		ldd r24,Y+1
 1535 06aa 9A81      		ldd r25,Y+2
 1536 06ac 8050      		subi r24,lo8(-(ACKFrame+1))
 1537 06ae 9040      		sbci r25,hi8(-(ACKFrame+1))
 1538 06b0 FC01      		movw r30,r24
 1539 06b2 1082      		st Z,__zero_reg__
 239:ServerLLDN.c  **** 			ACKFrame.ackFlags[i] = 0;
 1540               		.loc 6 239 0 discriminator 3
 1541 06b4 8981      		ldd r24,Y+1
 1542 06b6 9A81      		ldd r25,Y+2
 1543 06b8 0196      		adiw r24,1
 1544 06ba 9A83      		std Y+2,r25
 1545 06bc 8983      		std Y+1,r24
 1546               	.L45:
 239:ServerLLDN.c  **** 			ACKFrame.ackFlags[i] = 0;
 1547               		.loc 6 239 0 is_stmt 0 discriminator 1
 1548 06be 8981      		ldd r24,Y+1
 1549 06c0 9A81      		ldd r25,Y+2
 1550 06c2 8097      		sbiw r24,32
 1551 06c4 04F0      		brlt .L46
 1552               	.LBE6:
 241:ServerLLDN.c  **** 		ACKFrame_size = 0;
 1553               		.loc 6 241 0 is_stmt 1
 1554 06c6 1092 0000 		sts ACKFrame_size+1,__zero_reg__
 1555 06ca 1092 0000 		sts ACKFrame_size,__zero_reg__
 242:ServerLLDN.c  **** 		/* Prepare Beacon Message as first beacon in discovery state */		
 243:ServerLLDN.c  **** 		msgReq.dstAddr				= 0;
 1556               		.loc 6 243 0
 1557 06ce 1092 0000 		sts msgReq+5+1,__zero_reg__
 1558 06d2 1092 0000 		sts msgReq+5,__zero_reg__
 244:ServerLLDN.c  **** 		msgReq.dstEndpoint			= APP_BEACON_ENDPOINT;
 1559               		.loc 6 244 0
 1560 06d6 1092 0000 		sts msgReq+7,__zero_reg__
 245:ServerLLDN.c  **** 		msgReq.srcEndpoint			= APP_BEACON_ENDPOINT;
 1561               		.loc 6 245 0
 1562 06da 1092 0000 		sts msgReq+8,__zero_reg__
 246:ServerLLDN.c  **** 		msgReq.options				= NWK_OPT_LLDN_BEACON | NWK_OPT_DISCOVERY_STATE;
 1563               		.loc 6 246 0
 1564 06de 80E4      		ldi r24,lo8(64)
 1565 06e0 91E0      		ldi r25,lo8(1)
 1566 06e2 9093 0000 		sts msgReq+9+1,r25
 1567 06e6 8093 0000 		sts msgReq+9,r24
 247:ServerLLDN.c  **** 		msgReq.data					= NULL;
 1568               		.loc 6 247 0
 1569 06ea 1092 0000 		sts msgReq+13+1,__zero_reg__
 1570 06ee 1092 0000 		sts msgReq+13,__zero_reg__
 248:ServerLLDN.c  **** 		msgReq.size					= 0;
 1571               		.loc 6 248 0
 1572 06f2 1092 0000 		sts msgReq+15,__zero_reg__
 249:ServerLLDN.c  **** 		
 250:ServerLLDN.c  **** 		
 251:ServerLLDN.c  **** 		/* Only start timers if it is the first association process */
 252:ServerLLDN.c  **** 		if(cycles_counter == 0) 
 1573               		.loc 6 252 0
 1574 06f6 8091 0000 		lds r24,cycles_counter
 1575 06fa 8823      		tst r24
 1576 06fc 01F0      		breq .+2
 1577 06fe 00C0      		rjmp .L48
 253:ServerLLDN.c  **** 		{
 254:ServerLLDN.c  **** 			
 255:ServerLLDN.c  **** 		/* Calculates Beacon Intervals according to 802.15.4e - 2012 p. 70 */
 256:ServerLLDN.c  **** 		n = 127; 
 1578               		.loc 6 256 0
 1579 0700 8FE7      		ldi r24,lo8(127)
 1580 0702 8093 0000 		sts n,r24
 257:ServerLLDN.c  **** 		tTS =  ((p_var*sp + (m+n)*sm + macMinLIFSPeriod)/v_var);
 1581               		.loc 6 257 0
 1582 0706 8091 0000 		lds r24,n
 1583 070a 882F      		mov r24,r24
 1584 070c 90E0      		ldi r25,0
 1585 070e 0396      		adiw r24,3
 1586 0710 880F      		lsl r24
 1587 0712 991F      		rol r25
 1588 0714 092E      		mov __tmp_reg__,r25
 1589 0716 000C      		lsl r0
 1590 0718 AA0B      		sbc r26,r26
 1591 071a BB0B      		sbc r27,r27
 1592 071c BC01      		movw r22,r24
 1593 071e CD01      		movw r24,r26
 1594 0720 0E94 0000 		call __floatsisf
 1595 0724 DC01      		movw r26,r24
 1596 0726 CB01      		movw r24,r22
 1597 0728 20E0      		ldi r18,0
 1598 072a 30E0      		ldi r19,0
 1599 072c 40E4      		ldi r20,lo8(64)
 1600 072e 51E4      		ldi r21,lo8(65)
 1601 0730 BC01      		movw r22,r24
 1602 0732 CD01      		movw r24,r26
 1603 0734 0E94 0000 		call __addsf3
 1604 0738 DC01      		movw r26,r24
 1605 073a CB01      		movw r24,r22
 1606 073c 20E0      		ldi r18,0
 1607 073e 30E0      		ldi r19,0
 1608 0740 40E2      		ldi r20,lo8(32)
 1609 0742 52E4      		ldi r21,lo8(66)
 1610 0744 BC01      		movw r22,r24
 1611 0746 CD01      		movw r24,r26
 1612 0748 0E94 0000 		call __addsf3
 1613 074c DC01      		movw r26,r24
 1614 074e CB01      		movw r24,r22
 1615 0750 20E0      		ldi r18,0
 1616 0752 34E2      		ldi r19,lo8(36)
 1617 0754 44E7      		ldi r20,lo8(116)
 1618 0756 57E4      		ldi r21,lo8(71)
 1619 0758 BC01      		movw r22,r24
 1620 075a CD01      		movw r24,r26
 1621 075c 0E94 0000 		call __divsf3
 1622 0760 DC01      		movw r26,r24
 1623 0762 CB01      		movw r24,r22
 1624 0764 8093 0000 		sts tTS,r24
 1625 0768 9093 0000 		sts tTS+1,r25
 1626 076c A093 0000 		sts tTS+2,r26
 1627 0770 B093 0000 		sts tTS+3,r27
 258:ServerLLDN.c  **** 		#if (MASTER_MACSC == 1)
 259:ServerLLDN.c  **** 		
 260:ServerLLDN.c  **** 			beaconInterval = 2 * numBaseTimeSlotperMgmt * (tTS) / (SYMBOL_TIME);
 1628               		.loc 6 260 0
 1629 0774 8091 0000 		lds r24,tTS
 1630 0778 9091 0000 		lds r25,tTS+1
 1631 077c A091 0000 		lds r26,tTS+2
 1632 0780 B091 0000 		lds r27,tTS+3
 1633 0784 20E0      		ldi r18,0
 1634 0786 30E0      		ldi r19,0
 1635 0788 40E8      		ldi r20,lo8(-128)
 1636 078a 50E4      		ldi r21,lo8(64)
 1637 078c BC01      		movw r22,r24
 1638 078e CD01      		movw r24,r26
 1639 0790 0E94 0000 		call __mulsf3
 1640 0794 DC01      		movw r26,r24
 1641 0796 CB01      		movw r24,r22
 1642 0798 2DEB      		ldi r18,lo8(-67)
 1643 079a 37E3      		ldi r19,lo8(55)
 1644 079c 46E8      		ldi r20,lo8(-122)
 1645 079e 57E3      		ldi r21,lo8(55)
 1646 07a0 BC01      		movw r22,r24
 1647 07a2 CD01      		movw r24,r26
 1648 07a4 0E94 0000 		call __divsf3
 1649 07a8 DC01      		movw r26,r24
 1650 07aa CB01      		movw r24,r22
 1651 07ac 8093 0000 		sts beaconInterval,r24
 1652 07b0 9093 0000 		sts beaconInterval+1,r25
 1653 07b4 A093 0000 		sts beaconInterval+2,r26
 1654 07b8 B093 0000 		sts beaconInterval+3,r27
 261:ServerLLDN.c  **** 			/*
 262:ServerLLDN.c  **** 			* Configure interrupts callback functions
 263:ServerLLDN.c  **** 			* overflow interrupt, compare 1,2,3 interrupts
 264:ServerLLDN.c  **** 			*/
 265:ServerLLDN.c  **** 			macsc_set_cmp1_int_cb(lldn_server_beacon);
 1655               		.loc 6 265 0
 1656 07bc 80E0      		ldi r24,lo8(gs(lldn_server_beacon))
 1657 07be 90E0      		ldi r25,hi8(gs(lldn_server_beacon))
 1658 07c0 0E94 0000 		call macsc_set_cmp1_int_cb
 266:ServerLLDN.c  **** 			/*
 267:ServerLLDN.c  **** 			* Configure MACSC to generate compare interrupts from channels 1,2,3
 268:ServerLLDN.c  **** 			* Set compare mode to absolute, set compare value.
 269:ServerLLDN.c  **** 			*/
 270:ServerLLDN.c  **** 			macsc_enable_manual_bts();
 1659               		.loc 6 270 0
 1660 07c4 0E94 0000 		call macsc_enable_manual_bts
 271:ServerLLDN.c  **** 			macsc_enable_cmp_int(MACSC_CC1);
 1661               		.loc 6 271 0
 1662 07c8 81E0      		ldi r24,lo8(1)
 1663 07ca 0E94 0000 		call macsc_enable_cmp_int
 272:ServerLLDN.c  **** 
 273:ServerLLDN.c  **** 			macsc_use_cmp(MACSC_RELATIVE_CMP, beaconInterval , MACSC_CC1);
 1664               		.loc 6 273 0
 1665 07ce 8091 0000 		lds r24,beaconInterval
 1666 07d2 9091 0000 		lds r25,beaconInterval+1
 1667 07d6 A091 0000 		lds r26,beaconInterval+2
 1668 07da B091 0000 		lds r27,beaconInterval+3
 1669 07de BC01      		movw r22,r24
 1670 07e0 CD01      		movw r24,r26
 1671 07e2 0E94 0000 		call __fixunssfsi
 1672 07e6 DC01      		movw r26,r24
 1673 07e8 CB01      		movw r24,r22
 1674 07ea 21E0      		ldi r18,lo8(1)
 1675 07ec AC01      		movw r20,r24
 1676 07ee BD01      		movw r22,r26
 1677 07f0 81E0      		ldi r24,lo8(1)
 1678 07f2 0E94 0000 		call macsc_use_cmp
 274:ServerLLDN.c  **** 			
 275:ServerLLDN.c  **** 			/* Timer used in testing */
 276:ServerLLDN.c  **** 			#if TIMESLOT_TIMER
 277:ServerLLDN.c  **** 			macsc_set_cmp2_int_cb(teste_handler);	
 1679               		.loc 6 277 0
 1680 07f6 80E0      		ldi r24,lo8(gs(teste_handler))
 1681 07f8 90E0      		ldi r25,hi8(gs(teste_handler))
 1682 07fa 0E94 0000 		call macsc_set_cmp2_int_cb
 278:ServerLLDN.c  **** 			macsc_enable_cmp_int(MACSC_CC2);
 1683               		.loc 6 278 0
 1684 07fe 82E0      		ldi r24,lo8(2)
 1685 0800 0E94 0000 		call macsc_enable_cmp_int
 279:ServerLLDN.c  **** 			macsc_use_cmp(MACSC_RELATIVE_CMP, beaconInterval / 2, MACSC_CC2);
 1686               		.loc 6 279 0
 1687 0804 8091 0000 		lds r24,beaconInterval
 1688 0808 9091 0000 		lds r25,beaconInterval+1
 1689 080c A091 0000 		lds r26,beaconInterval+2
 1690 0810 B091 0000 		lds r27,beaconInterval+3
 1691 0814 20E0      		ldi r18,0
 1692 0816 30E0      		ldi r19,0
 1693 0818 40E0      		ldi r20,0
 1694 081a 50E4      		ldi r21,lo8(64)
 1695 081c BC01      		movw r22,r24
 1696 081e CD01      		movw r24,r26
 1697 0820 0E94 0000 		call __divsf3
 1698 0824 DC01      		movw r26,r24
 1699 0826 CB01      		movw r24,r22
 1700 0828 BC01      		movw r22,r24
 1701 082a CD01      		movw r24,r26
 1702 082c 0E94 0000 		call __fixunssfsi
 1703 0830 DC01      		movw r26,r24
 1704 0832 CB01      		movw r24,r22
 1705 0834 22E0      		ldi r18,lo8(2)
 1706 0836 AC01      		movw r20,r24
 1707 0838 BD01      		movw r22,r26
 1708 083a 81E0      		ldi r24,lo8(1)
 1709 083c 0E94 0000 		call macsc_use_cmp
 1710               	.L48:
 280:ServerLLDN.c  **** 			#endif
 281:ServerLLDN.c  **** 			
 282:ServerLLDN.c  **** 		#endif
 283:ServerLLDN.c  **** 		}
 284:ServerLLDN.c  **** 	}
 1711               		.loc 6 284 0
 1712 0840 0000      		nop
 1713               	/* epilogue start */
 1714 0842 0F90      		pop __tmp_reg__
 1715 0844 0F90      		pop __tmp_reg__
 1716 0846 DF91      		pop r29
 1717 0848 CF91      		pop r28
 1718 084a 0895      		ret
 1719               		.cfi_endproc
 1720               	.LFE142:
 1723               	appPanOnlineInit:
 1724               	.LFB143:
 285:ServerLLDN.c  **** 
 286:ServerLLDN.c  **** 	static void appPanOnlineInit()
 287:ServerLLDN.c  **** 	{
 1725               		.loc 6 287 0
 1726               		.cfi_startproc
 1727 084c CF93      		push r28
 1728               	.LCFI75:
 1729               		.cfi_def_cfa_offset 3
 1730               		.cfi_offset 28, -2
 1731 084e DF93      		push r29
 1732               	.LCFI76:
 1733               		.cfi_def_cfa_offset 4
 1734               		.cfi_offset 29, -3
 1735 0850 CDB7      		in r28,__SP_L__
 1736 0852 DEB7      		in r29,__SP_H__
 1737               	.LCFI77:
 1738               		.cfi_def_cfa_register 28
 1739               	/* prologue: function */
 1740               	/* frame size = 0 */
 1741               	/* stack size = 2 */
 1742               	.L__stack_usage = 2
 288:ServerLLDN.c  **** 		/*
 289:ServerLLDN.c  **** 		tTS =  ((p_var*sp + (m+n)*sm + macMinLIFSPeriod)/v_var);
 290:ServerLLDN.c  **** 		// beaconInterval = (assTimeSlot + MacLLDNMgmtTS*numBaseTimeSlotperMgmt) * tTS / (SYMBOL_TIME); /
 291:ServerLLDN.c  **** 		// Configure Timers
 292:ServerLLDN.c  **** 		macsc_set_cmp1_int_cb(end_of_online_handler);
 293:ServerLLDN.c  **** 		macsc_enable_manual_bts();
 294:ServerLLDN.c  **** 		macsc_enable_cmp_int(MACSC_CC1);
 295:ServerLLDN.c  **** 		macsc_use_cmp(MACSC_RELATIVE_CMP, beaconInterval, MACSC_CC1);
 296:ServerLLDN.c  **** 		
 297:ServerLLDN.c  **** 		/* prepares online beacon , PRECISA SER REVISADO COM A NORMA, ESTOU EM DVIDA NO TIMESLOTE SIZE, 
 298:ServerLLDN.c  **** 		msgReq.dstAddr				= 0;
 1743               		.loc 6 298 0
 1744 0854 1092 0000 		sts msgReq+5+1,__zero_reg__
 1745 0858 1092 0000 		sts msgReq+5,__zero_reg__
 299:ServerLLDN.c  **** 		msgReq.dstEndpoint			= APP_BEACON_ENDPOINT;
 1746               		.loc 6 299 0
 1747 085c 1092 0000 		sts msgReq+7,__zero_reg__
 300:ServerLLDN.c  **** 		msgReq.srcEndpoint			= APP_BEACON_ENDPOINT;
 1748               		.loc 6 300 0
 1749 0860 1092 0000 		sts msgReq+8,__zero_reg__
 301:ServerLLDN.c  **** 		msgReq.options				= NWK_OPT_LLDN_BEACON | NWK_OPT_ONLINE_STATE;
 1750               		.loc 6 301 0
 1751 0864 80EC      		ldi r24,lo8(-64)
 1752 0866 90E0      		ldi r25,0
 1753 0868 9093 0000 		sts msgReq+9+1,r25
 1754 086c 8093 0000 		sts msgReq+9,r24
 302:ServerLLDN.c  **** 		msgReq.data					= NULL;
 1755               		.loc 6 302 0
 1756 0870 1092 0000 		sts msgReq+13+1,__zero_reg__
 1757 0874 1092 0000 		sts msgReq+13,__zero_reg__
 303:ServerLLDN.c  **** 		msgReq.size					= 0;
 1758               		.loc 6 303 0
 1759 0878 1092 0000 		sts msgReq+15,__zero_reg__
 304:ServerLLDN.c  **** 		
 305:ServerLLDN.c  **** 	}
 1760               		.loc 6 305 0
 1761 087c 0000      		nop
 1762               	/* epilogue start */
 1763 087e DF91      		pop r29
 1764 0880 CF91      		pop r28
 1765 0882 0895      		ret
 1766               		.cfi_endproc
 1767               	.LFE143:
 1769               		.section	.rodata
 1770               	.LC6:
 1771 0059 0A20 496E 		.string	"\n Inicio.."
 1771      6963 696F 
 1771      2E2E 00
 1772               		.text
 1774               	appInit:
 1775               	.LFB144:
 306:ServerLLDN.c  **** 
 307:ServerLLDN.c  **** 
 308:ServerLLDN.c  **** #else 
 309:ServerLLDN.c  **** 	uint8_t payloadSize = 0x01;
 310:ServerLLDN.c  **** 	uint8_t assTimeSlot = 0xFF;
 311:ServerLLDN.c  **** 	uint8_t n = 0;
 312:ServerLLDN.c  **** 	
 313:ServerLLDN.c  **** 	static NwkFrameBeaconHeaderLLDN_t *rec_beacon;
 314:ServerLLDN.c  **** 	static NWK_DiscoverResponse_t msgDiscResponse = { .id = LL_DISCOVER_RESPONSE,
 315:ServerLLDN.c  **** 													 .macAddr = APP_ADDR,
 316:ServerLLDN.c  **** 													 .ts_dir.tsDuration = 4,
 317:ServerLLDN.c  **** 													 .ts_dir.dirIndicator = 0b1 };
 318:ServerLLDN.c  **** 	static NWK_ConfigStatus_t msgConfigStatus = { .id = LL_CONFIGURATION_STATUS,
 319:ServerLLDN.c  **** 												 .macAddr = APP_ADDR,
 320:ServerLLDN.c  **** 												 .s_macAddr = APP_ADDR,
 321:ServerLLDN.c  **** 												 .ts_dir.tsDuration = 4,
 322:ServerLLDN.c  **** 												 .ts_dir.dirIndicator = 1,
 323:ServerLLDN.c  **** 												 .assTimeSlot = 0xff };
 324:ServerLLDN.c  **** 	static bool ack_received;
 325:ServerLLDN.c  **** 	bool MacLLDNMgmtTS = 0; 
 326:ServerLLDN.c  **** 	bool associated = 0;
 327:ServerLLDN.c  **** 	
 328:ServerLLDN.c  **** 	static void send_message_timeHandler(void)
 329:ServerLLDN.c  **** 	{
 330:ServerLLDN.c  **** 		appState = APP_STATE_SEND;	
 331:ServerLLDN.c  **** 		#if MASTER_MACSC == 0
 332:ServerLLDN.c  **** 			timer_stop();
 333:ServerLLDN.c  **** 		#endif
 334:ServerLLDN.c  **** 	}
 335:ServerLLDN.c  **** 
 336:ServerLLDN.c  **** 	
 337:ServerLLDN.c  **** 	static bool appBeaconInd(NWK_DataInd_t *ind)
 338:ServerLLDN.c  **** 	{
 339:ServerLLDN.c  **** 		rec_beacon = (NwkFrameBeaconHeaderLLDN_t*)ind->data;
 340:ServerLLDN.c  **** 		//  bom implementar rotinas pra se o nodo estiver associado a um coordeandor e se no estiver
 341:ServerLLDN.c  **** 		PanId = rec_beacon->PanId; // s pode mudar se ele associar
 342:ServerLLDN.c  **** 		if( (rec_beacon->Flags.txState == DISC_MODE && !ack_received && rec_beacon->confSeqNumber == 0x00
 343:ServerLLDN.c  **** 			(rec_beacon->Flags.txState == CONFIG_MODE && ack_received))
 344:ServerLLDN.c  **** 		{
 345:ServerLLDN.c  **** 			int msg_wait_time = rec_beacon->Flags.numBaseMgmtTimeslots * rec_beacon->TimeSlotSize* 2; // sym
 346:ServerLLDN.c  **** 			#if MASTER_MACSC
 347:ServerLLDN.c  **** 				macsc_enable_manual_bts();
 348:ServerLLDN.c  **** 				macsc_set_cmp1_int_cb(send_message_timeHandler);
 349:ServerLLDN.c  **** 				macsc_enable_cmp_int(MACSC_CC1); 
 350:ServerLLDN.c  **** 				macsc_use_cmp(MACSC_RELATIVE_CMP, msg_wait_time - 250, MACSC_CC1);
 351:ServerLLDN.c  **** 			#else
 352:ServerLLDN.c  **** 				timer_init();
 353:ServerLLDN.c  **** 				timer_delay(msg_wait_time/2 - 100);
 354:ServerLLDN.c  **** 				hw_timer_setup_handler(send_message_timeHandler);
 355:ServerLLDN.c  **** 				timer_start();
 356:ServerLLDN.c  **** 			#endif
 357:ServerLLDN.c  **** 			appState = (rec_beacon->Flags.txState == DISC_MODE) ? APP_STATE_PREP_DISC_REPONSE : APP_STATE_PR
 358:ServerLLDN.c  **** 		}
 359:ServerLLDN.c  **** 		else if (rec_beacon->Flags.txState == RESET_MODE)
 360:ServerLLDN.c  **** 		{
 361:ServerLLDN.c  **** 			ack_received = 0;
 362:ServerLLDN.c  **** 			associated = 0;
 363:ServerLLDN.c  **** 		}
 364:ServerLLDN.c  **** 
 365:ServerLLDN.c  **** 		return true;
 366:ServerLLDN.c  **** 	}
 367:ServerLLDN.c  **** 	
 368:ServerLLDN.c  **** 	static bool appAckInd(NWK_DataInd_t *ind)
 369:ServerLLDN.c  **** 	{
 370:ServerLLDN.c  **** 		#if !MASTER_MACSC
 371:ServerLLDN.c  **** 		// ind->data = ind->data - (uint8_t) 1;
 372:ServerLLDN.c  **** 		#endif
 373:ServerLLDN.c  **** 		NWK_ACKFormat_t *ackframe = (NWK_ACKFormat_t*)ind->data;
 374:ServerLLDN.c  **** 		if(PanId == ackframe->sourceId)
 375:ServerLLDN.c  **** 		{
 376:ServerLLDN.c  **** 			int pos = (int) APP_ADDR / 8;
 377:ServerLLDN.c  **** 			int bit_shift = 8 - APP_ADDR % 8;
 378:ServerLLDN.c  **** 			if( ackframe->ackFlags[pos] & 1 << bit_shift)	
 379:ServerLLDN.c  **** 			{
 380:ServerLLDN.c  **** 				printf("\n ack true");
 381:ServerLLDN.c  **** 				ack_received = true;
 382:ServerLLDN.c  **** 			}
 383:ServerLLDN.c  **** 		}
 384:ServerLLDN.c  **** 		return true;
 385:ServerLLDN.c  **** 	}
 386:ServerLLDN.c  **** 	
 387:ServerLLDN.c  **** 	static bool appCommandInd(NWK_DataInd_t *ind)
 388:ServerLLDN.c  **** 	{
 389:ServerLLDN.c  **** 		if(ind->data[0] == LL_CONFIGURATION_REQUEST)
 390:ServerLLDN.c  **** 		{
 391:ServerLLDN.c  **** 			NWK_ConfigRequest_t *msg = (NWK_ConfigRequest_t*)ind->data;
 392:ServerLLDN.c  **** 			if(msg->macAddr == APP_ADDR)
 393:ServerLLDN.c  **** 			{
 394:ServerLLDN.c  **** 				PHY_SetChannel(msg->tx_channel);
 395:ServerLLDN.c  **** 				NWK_SetPanId(msg->s_macAddr);
 396:ServerLLDN.c  **** 				assTimeSlot = msg->assTimeSlot;
 397:ServerLLDN.c  **** 				n = msg->conf.tsDuration;
 398:ServerLLDN.c  **** 				bool associated = 1;
 399:ServerLLDN.c  **** 				printf("\nRecebeu conf request");
 400:ServerLLDN.c  **** 			}
 401:ServerLLDN.c  **** 		}
 402:ServerLLDN.c  **** 		return true;
 403:ServerLLDN.c  **** 	}
 404:ServerLLDN.c  **** 
 405:ServerLLDN.c  **** 	void appPrepareDiscoverResponse()
 406:ServerLLDN.c  **** 	{
 407:ServerLLDN.c  **** 		msgReq.dstAddr				= 0;
 408:ServerLLDN.c  **** 		msgReq.dstEndpoint			= APP_COMMAND_ENDPOINT;
 409:ServerLLDN.c  **** 		msgReq.srcEndpoint			= APP_COMMAND_ENDPOINT;
 410:ServerLLDN.c  **** 		msgReq.options				= NWK_OPT_MAC_COMMAND;
 411:ServerLLDN.c  **** 		msgReq.data					= (uint8_t*)&msgDiscResponse;
 412:ServerLLDN.c  **** 		msgReq.size					= sizeof(msgDiscResponse);
 413:ServerLLDN.c  **** 	}
 414:ServerLLDN.c  **** 	
 415:ServerLLDN.c  **** 	void appPrepareConfigurationStatus()
 416:ServerLLDN.c  **** 	{		
 417:ServerLLDN.c  **** 		msgReq.dstAddr				= 0;
 418:ServerLLDN.c  **** 		msgReq.dstEndpoint			= APP_COMMAND_ENDPOINT;
 419:ServerLLDN.c  **** 		msgReq.srcEndpoint			= APP_COMMAND_ENDPOINT;
 420:ServerLLDN.c  **** 		msgReq.options				= NWK_OPT_MAC_COMMAND;
 421:ServerLLDN.c  **** 		msgReq.data					= (uint8_t*)&msgConfigStatus;
 422:ServerLLDN.c  **** 		msgReq.size					= sizeof(msgConfigStatus);
 423:ServerLLDN.c  **** 	}
 424:ServerLLDN.c  **** 	
 425:ServerLLDN.c  **** #endif // APP_COORDINATOR
 426:ServerLLDN.c  **** 
 427:ServerLLDN.c  **** static void appInit(void)
 428:ServerLLDN.c  **** {
 1776               		.loc 6 428 0
 1777               		.cfi_startproc
 1778 0884 CF93      		push r28
 1779               	.LCFI78:
 1780               		.cfi_def_cfa_offset 3
 1781               		.cfi_offset 28, -2
 1782 0886 DF93      		push r29
 1783               	.LCFI79:
 1784               		.cfi_def_cfa_offset 4
 1785               		.cfi_offset 29, -3
 1786 0888 CDB7      		in r28,__SP_L__
 1787 088a DEB7      		in r29,__SP_H__
 1788               	.LCFI80:
 1789               		.cfi_def_cfa_register 28
 1790               	/* prologue: function */
 1791               	/* frame size = 0 */
 1792               	/* stack size = 2 */
 1793               	.L__stack_usage = 2
 429:ServerLLDN.c  **** 	NWK_SetAddr(APP_ADDR);
 1794               		.loc 6 429 0
 1795 088c 80E0      		ldi r24,0
 1796 088e 90E0      		ldi r25,0
 1797 0890 0E94 0000 		call NWK_SetAddr
 430:ServerLLDN.c  **** 	PHY_SetChannel(APP_CHANNEL);
 1798               		.loc 6 430 0
 1799 0894 8FE0      		ldi r24,lo8(15)
 1800 0896 0E94 0000 		call PHY_SetChannel
 431:ServerLLDN.c  **** 	PHY_SetRxState(true);
 1801               		.loc 6 431 0
 1802 089a 81E0      		ldi r24,lo8(1)
 1803 089c 0E94 0000 		call PHY_SetRxState
 432:ServerLLDN.c  **** 		
 433:ServerLLDN.c  **** 	#if APP_COORDINATOR	 
 434:ServerLLDN.c  **** 	printf("\n Inicio.."); 
 1804               		.loc 6 434 0
 1805 08a0 80E0      		ldi r24,lo8(.LC6)
 1806 08a2 90E0      		ldi r25,hi8(.LC6)
 1807 08a4 892F      		mov r24,r25
 1808 08a6 8F93      		push r24
 1809 08a8 80E0      		ldi r24,lo8(.LC6)
 1810 08aa 90E0      		ldi r25,hi8(.LC6)
 1811 08ac 8F93      		push r24
 1812 08ae 0E94 0000 		call printf
 1813 08b2 0F90      		pop __tmp_reg__
 1814 08b4 0F90      		pop __tmp_reg__
 435:ServerLLDN.c  **** 	  /* Timer used for delay between messages */
 436:ServerLLDN.c  **** 	  tmrDelay.interval = 2;
 1815               		.loc 6 436 0
 1816 08b6 82E0      		ldi r24,lo8(2)
 1817 08b8 90E0      		ldi r25,0
 1818 08ba A0E0      		ldi r26,0
 1819 08bc B0E0      		ldi r27,0
 1820 08be 8093 0000 		sts tmrDelay+6,r24
 1821 08c2 9093 0000 		sts tmrDelay+6+1,r25
 1822 08c6 A093 0000 		sts tmrDelay+6+2,r26
 1823 08ca B093 0000 		sts tmrDelay+6+3,r27
 437:ServerLLDN.c  **** 	  tmrDelay.mode = SYS_TIMER_INTERVAL_MODE;
 1824               		.loc 6 437 0
 1825 08ce 1092 0000 		sts tmrDelay+10,__zero_reg__
 438:ServerLLDN.c  **** 	  tmrDelay.handler = tmrDelayHandler;
 1826               		.loc 6 438 0
 1827 08d2 80E0      		ldi r24,lo8(gs(tmrDelayHandler))
 1828 08d4 90E0      		ldi r25,hi8(gs(tmrDelayHandler))
 1829 08d6 9093 0000 		sts tmrDelay+11+1,r25
 1830 08da 8093 0000 		sts tmrDelay+11,r24
 439:ServerLLDN.c  **** 	  
 440:ServerLLDN.c  **** 		/* 
 441:ServerLLDN.c  **** 		* Disable CSMA/CA
 442:ServerLLDN.c  **** 		* Disable auto ACK
 443:ServerLLDN.c  **** 		*/
 444:ServerLLDN.c  **** 		NWK_SetPanId(APP_PANID);
 1831               		.loc 6 444 0
 1832 08de 8EEF      		ldi r24,lo8(-2)
 1833 08e0 9AEC      		ldi r25,lo8(-54)
 1834 08e2 0E94 0000 		call NWK_SetPanId
 445:ServerLLDN.c  **** 		PanId = APP_PANID;
 1835               		.loc 6 445 0
 1836 08e6 8EEF      		ldi r24,lo8(-2)
 1837 08e8 8093 0000 		sts PanId,r24
 446:ServerLLDN.c  **** 		ACKFrame.sourceId = APP_PANID;
 1838               		.loc 6 446 0
 1839 08ec 8EEF      		ldi r24,lo8(-2)
 1840 08ee 8093 0000 		sts ACKFrame,r24
 447:ServerLLDN.c  **** 		PHY_SetTdmaMode(true);
 1841               		.loc 6 447 0
 1842 08f2 81E0      		ldi r24,lo8(1)
 1843 08f4 0E94 0000 		call PHY_SetTdmaMode
 448:ServerLLDN.c  **** 		NWK_OpenEndpoint(APP_COMMAND_ENDPOINT, appCommandInd);
 1844               		.loc 6 448 0
 1845 08f8 60E0      		ldi r22,lo8(gs(appCommandInd))
 1846 08fa 70E0      		ldi r23,hi8(gs(appCommandInd))
 1847 08fc 83E0      		ldi r24,lo8(3)
 1848 08fe 0E94 0000 		call NWK_OpenEndpoint
 449:ServerLLDN.c  **** 	#else
 450:ServerLLDN.c  **** 		/*
 451:ServerLLDN.c  **** 		 * Enable CSMA/CA
 452:ServerLLDN.c  **** 		 * Enable Random CSMA seed generator
 453:ServerLLDN.c  **** 		 */
 454:ServerLLDN.c  **** 		PHY_SetTdmaMode(false);
 455:ServerLLDN.c  **** 		// PHY_SetOptimizedCSMAValues();
 456:ServerLLDN.c  **** 		
 457:ServerLLDN.c  **** 		payloadSize = 0x01;
 458:ServerLLDN.c  **** 		NWK_OpenEndpoint(APP_BEACON_ENDPOINT, appBeaconInd);
 459:ServerLLDN.c  **** 		NWK_OpenEndpoint(APP_ACK_ENDPOINT, appAckInd);
 460:ServerLLDN.c  **** 		NWK_OpenEndpoint(APP_COMMAND_ENDPOINT, appCommandInd);
 461:ServerLLDN.c  **** 		/*
 462:ServerLLDN.c  **** 		* Configure interrupts callback functions
 463:ServerLLDN.c  **** 		*/
 464:ServerLLDN.c  **** 		
 465:ServerLLDN.c  **** 	#endif // APP_COORDENATOR
 466:ServerLLDN.c  **** 	PHY_SetPromiscuousMode(true);
 1849               		.loc 6 466 0
 1850 0902 81E0      		ldi r24,lo8(1)
 1851 0904 0E94 0000 		call PHY_SetPromiscuousMode
 467:ServerLLDN.c  **** 
 468:ServerLLDN.c  **** }
 1852               		.loc 6 468 0
 1853 0908 0000      		nop
 1854               	/* epilogue start */
 1855 090a DF91      		pop r29
 1856 090c CF91      		pop r28
 1857 090e 0895      		ret
 1858               		.cfi_endproc
 1859               	.LFE144:
 1861               		.section	.rodata
 1862               	.LC7:
 1863 0064 0A25 642C 		.string	"\n%d, %d"
 1863      2025 6400 
 1864               		.text
 1866               	APP_TaskHandler:
 1867               	.LFB145:
 469:ServerLLDN.c  **** 
 470:ServerLLDN.c  **** static void APP_TaskHandler(void)
 471:ServerLLDN.c  **** {
 1868               		.loc 6 471 0
 1869               		.cfi_startproc
 1870 0910 CF93      		push r28
 1871               	.LCFI81:
 1872               		.cfi_def_cfa_offset 3
 1873               		.cfi_offset 28, -2
 1874 0912 DF93      		push r29
 1875               	.LCFI82:
 1876               		.cfi_def_cfa_offset 4
 1877               		.cfi_offset 29, -3
 1878 0914 CDB7      		in r28,__SP_L__
 1879 0916 DEB7      		in r29,__SP_H__
 1880               	.LCFI83:
 1881               		.cfi_def_cfa_register 28
 1882               	/* prologue: function */
 1883               	/* frame size = 0 */
 1884               	/* stack size = 2 */
 1885               	.L__stack_usage = 2
 472:ServerLLDN.c  **** 	switch (appState){
 1886               		.loc 6 472 0
 1887 0918 8091 0000 		lds r24,appState
 1888 091c 882F      		mov r24,r24
 1889 091e 90E0      		ldi r25,0
 1890 0920 8230      		cpi r24,2
 1891 0922 9105      		cpc r25,__zero_reg__
 1892 0924 01F0      		breq .L53
 1893 0926 8330      		cpi r24,3
 1894 0928 9105      		cpc r25,__zero_reg__
 1895 092a 01F0      		breq .L54
 1896 092c 892B      		or r24,r25
 1897 092e 01F0      		breq .L55
 473:ServerLLDN.c  **** 		case APP_STATE_INITIAL:
 474:ServerLLDN.c  **** 		{
 475:ServerLLDN.c  **** 			appInit();
 476:ServerLLDN.c  **** 			#if APP_COORDINATOR
 477:ServerLLDN.c  **** 				appState = APP_STATE_ATT_PAN_STATE;
 478:ServerLLDN.c  **** 			#else
 479:ServerLLDN.c  **** 				appState = APP_STATE_IDLE;
 480:ServerLLDN.c  **** 			#endif
 481:ServerLLDN.c  **** 			break;
 482:ServerLLDN.c  **** 		}
 483:ServerLLDN.c  **** 		case APP_STATE_SEND:
 484:ServerLLDN.c  **** 		{
 485:ServerLLDN.c  **** 			appSendData();
 486:ServerLLDN.c  **** 			#if APP_COORDINATOR
 487:ServerLLDN.c  **** 				/* Every time a message is send updates coordinator to prepare next message */
 488:ServerLLDN.c  **** 				appState = APP_STATE_ATT_PAN_STATE;
 489:ServerLLDN.c  **** 			#else
 490:ServerLLDN.c  **** 				appState = APP_STATE_IDLE;
 491:ServerLLDN.c  **** 			#endif
 492:ServerLLDN.c  **** 			break;
 493:ServerLLDN.c  **** 		}
 494:ServerLLDN.c  **** 		#if APP_COORDINATOR // COORDINATOR SPECIFIC STATE MACHINE
 495:ServerLLDN.c  **** 		case APP_STATE_ATT_PAN_STATE:
 496:ServerLLDN.c  **** 		{
 497:ServerLLDN.c  **** 			switch(appPanState)
 498:ServerLLDN.c  **** 			{
 499:ServerLLDN.c  **** 				/* Prepare beacon to desassociate all nodes */
 500:ServerLLDN.c  **** 				case APP_PAN_STATE_RESET:
 501:ServerLLDN.c  **** 				{
 502:ServerLLDN.c  **** 					appPanReset();
 503:ServerLLDN.c  **** 					appPanState = APP_PAN_STATE_DISC_INITIAL;
 504:ServerLLDN.c  **** 					appState	= APP_STATE_SEND;
 505:ServerLLDN.c  **** 					cycles_counter = 0;
 506:ServerLLDN.c  **** 					break;
 507:ServerLLDN.c  **** 				}
 508:ServerLLDN.c  **** 				/* Prepare first Beacon of Discovery */
 509:ServerLLDN.c  **** 				case APP_PAN_STATE_DISC_INITIAL:
 510:ServerLLDN.c  **** 				{
 511:ServerLLDN.c  **** 					/* if nodes associated is equal to expected number of associated nodes stop association proces
 512:ServerLLDN.c  **** 					 * this implementation was done as is to be used in tests, for real network functionality 
 513:ServerLLDN.c  **** 					 * the number of max association processes must be done through macLLDNdiscoveryModeTimeout
 514:ServerLLDN.c  **** 					 */
 515:ServerLLDN.c  **** 					if(counter_associados == NODOS_ASSOCIADOS_ESPERADOS || cycles_counter >= 2)
 516:ServerLLDN.c  **** 					{	
 517:ServerLLDN.c  **** 						printf("\n%d, %d", cycles_counter, counter_associados);
 518:ServerLLDN.c  **** 						counter_associados = 0;
 519:ServerLLDN.c  **** 						/* if all nodes expected where associated stop beacon generation interruptions */
 520:ServerLLDN.c  **** 						macsc_disable_cmp_int(MACSC_CC1);
 521:ServerLLDN.c  **** 						macsc_disable_cmp_int(MACSC_CC2);
 522:ServerLLDN.c  **** 						msgReq.options = 0;
 523:ServerLLDN.c  **** 						/* set coordinator node to idle further implementation of online state must be done */
 524:ServerLLDN.c  **** 						appState = APP_STATE_IDLE;
 525:ServerLLDN.c  **** 						appPanState = APP_PAN_STATE_IDLE; // APP_PAN_STATE_ONLINE_INIT
 526:ServerLLDN.c  **** 						
 527:ServerLLDN.c  **** 					}
 528:ServerLLDN.c  **** 					/* if not all nodes expected where associated run through association process again */
 529:ServerLLDN.c  **** 					else 
 530:ServerLLDN.c  **** 					{
 531:ServerLLDN.c  **** 						/* prepare beacon message and start timers for beacon */
 532:ServerLLDN.c  **** 						appPanDiscInit();
 533:ServerLLDN.c  **** 						appState	= APP_STATE_IDLE;
 534:ServerLLDN.c  **** 						appPanState = APP_PAN_STATE_DISC_SECOND_BE;
 535:ServerLLDN.c  **** 					}
 536:ServerLLDN.c  **** 					break;
 537:ServerLLDN.c  **** 				}
 538:ServerLLDN.c  **** 				case APP_PAN_STATE_DISC_SECOND_BE:
 539:ServerLLDN.c  **** 				{
 540:ServerLLDN.c  **** 					/* Prepares message as: Discovery Beacon and Second Beacon */
 541:ServerLLDN.c  **** 					msgReq.options = NWK_OPT_LLDN_BEACON | NWK_OPT_DISCOVERY_STATE | NWK_OPT_SECOND_BEACON ;
 542:ServerLLDN.c  **** 					msgReq.data = NULL;
 543:ServerLLDN.c  **** 					msgReq.size = 0;
 544:ServerLLDN.c  **** 					
 545:ServerLLDN.c  **** 					appState	= APP_PAN_STATE_DISC_PREPARE_ACK;
 546:ServerLLDN.c  **** 					appPanState = APP_PAN_STATE_DISC_PREPARE_ACK;
 547:ServerLLDN.c  **** 					break;
 548:ServerLLDN.c  **** 				}
 549:ServerLLDN.c  **** 				case APP_PAN_STATE_DISC_PREPARE_ACK:
 550:ServerLLDN.c  **** 				{
 551:ServerLLDN.c  **** 					/* This timer implements a delay between messages, 
 552:ServerLLDN.c  **** 					 * if not used the nodes are not able to receive the message
 553:ServerLLDN.c  **** 					 */
 554:ServerLLDN.c  **** 					appPanPrepareACK();
 555:ServerLLDN.c  **** 					SYS_TimerStart(&tmrDelay);
 556:ServerLLDN.c  **** 					
 557:ServerLLDN.c  **** 					appPanState = APP_PAN_STATE_CONFIG_INITIAL; 
 558:ServerLLDN.c  **** 					appState = APP_STATE_IDLE;
 559:ServerLLDN.c  **** 					break;
 560:ServerLLDN.c  **** 				}
 561:ServerLLDN.c  **** 				case APP_PAN_STATE_CONFIG_INITIAL:
 562:ServerLLDN.c  **** 				{
 563:ServerLLDN.c  **** 					/* Prepares the message as: Configuration Beacon and First State Beacon */
 564:ServerLLDN.c  **** 					msgReq.options = NWK_OPT_LLDN_BEACON | NWK_OPT_CONFIG_STATE;
 565:ServerLLDN.c  **** 					msgReq.data = NULL;
 566:ServerLLDN.c  **** 					msgReq.size = 0;
 567:ServerLLDN.c  **** 					
 568:ServerLLDN.c  **** 					appState	= APP_STATE_IDLE;
 569:ServerLLDN.c  **** 					appPanState = APP_PAN_STATE_CONFIG_SECOND_BEACON;
 570:ServerLLDN.c  **** 					break;
 571:ServerLLDN.c  **** 
 572:ServerLLDN.c  **** 				}
 573:ServerLLDN.c  **** 				case APP_PAN_STATE_CONFIG_SECOND_BEACON:
 574:ServerLLDN.c  **** 				{
 575:ServerLLDN.c  **** 					/* Prepares the message as: Configuration Beacon and Second State Beacon */
 576:ServerLLDN.c  **** 					msgReq.options = NWK_OPT_LLDN_BEACON | NWK_OPT_CONFIG_STATE | NWK_OPT_SECOND_BEACON;
 577:ServerLLDN.c  **** 					msgReq.data = NULL;
 578:ServerLLDN.c  **** 					msgReq.size = 0;
 579:ServerLLDN.c  **** 					
 580:ServerLLDN.c  **** 					appState	= APP_STATE_IDLE;
 581:ServerLLDN.c  **** 					appPanState = APP_PAN_STATE_SEND_CONF_REQUEST;
 582:ServerLLDN.c  **** 					break;
 583:ServerLLDN.c  **** 				}
 584:ServerLLDN.c  **** 				case APP_PAN_STATE_SEND_CONF_REQUEST:
 585:ServerLLDN.c  **** 				{
 586:ServerLLDN.c  **** 
 587:ServerLLDN.c  **** 					if(conf_req_index > 0)
 588:ServerLLDN.c  **** 					{
 589:ServerLLDN.c  **** 						CopyToConfigRequest(conf_req_index);
 590:ServerLLDN.c  **** 						msgReq.options		= NWK_OPT_MAC_COMMAND;
 591:ServerLLDN.c  **** 						msgReq.data			= (uint8_t*)&config_request_frame;
 592:ServerLLDN.c  **** 						msgReq.size			= sizeof(NWK_ConfigRequest_t);
 593:ServerLLDN.c  **** 						appState	= APP_STATE_IDLE;
 594:ServerLLDN.c  **** 						appPanState = APP_PAN_STATE_SEND_CONF_REQUEST;
 595:ServerLLDN.c  **** 						conf_req_index--;
 596:ServerLLDN.c  **** 						counter_associados++;
 597:ServerLLDN.c  **** 						// SYS_TimerStart(&tmrDelay);
 598:ServerLLDN.c  **** 					}
 599:ServerLLDN.c  **** 					else
 600:ServerLLDN.c  **** 					{
 601:ServerLLDN.c  **** 						appPanState = APP_PAN_STATE_CONFIG_THIRD_BEACON;
 602:ServerLLDN.c  **** 					}
 603:ServerLLDN.c  **** 					break;
 604:ServerLLDN.c  **** 				}
 605:ServerLLDN.c  **** 				case APP_PAN_STATE_CONFIG_THIRD_BEACON:
 606:ServerLLDN.c  **** 				{
 607:ServerLLDN.c  **** 					msgReq.options = NWK_OPT_LLDN_BEACON | NWK_OPT_CONFIG_STATE | NWK_OPT_THIRD_BEACON;
 608:ServerLLDN.c  **** 					msgReq.data = NULL;
 609:ServerLLDN.c  **** 					msgReq.size = 0;
 610:ServerLLDN.c  **** 					
 611:ServerLLDN.c  **** 					appState	= APP_STATE_IDLE;
 612:ServerLLDN.c  **** 					appPanState = APP_PAN_STATE_DISC_INITIAL;
 613:ServerLLDN.c  **** 					cycles_counter++;	
 614:ServerLLDN.c  **** 					
 615:ServerLLDN.c  **** 					break;
 616:ServerLLDN.c  **** 				}
 617:ServerLLDN.c  **** 				case APP_PAN_STATE_ONLINE_INITIAL:
 618:ServerLLDN.c  **** 				{
 619:ServerLLDN.c  **** 					appPanOnlineInit();
 620:ServerLLDN.c  **** 					break;
 621:ServerLLDN.c  **** 				}
 622:ServerLLDN.c  **** 				case APP_PAN_STATE_ONLINE_END_BE:
 623:ServerLLDN.c  **** 				{
 624:ServerLLDN.c  **** 					if(0)
 625:ServerLLDN.c  **** 					{
 626:ServerLLDN.c  **** 						// implementar as condies para entrar no processo de associao
 627:ServerLLDN.c  **** 					}
 628:ServerLLDN.c  **** 					else
 629:ServerLLDN.c  **** 					{
 630:ServerLLDN.c  **** 						// posso calcular esse valor no onlineinit, o tTS precisa ser recalculado, o seu valor muda n
 631:ServerLLDN.c  **** 						// pode voltar pro state_online_initial porque precisa reconfigurar os timers
 632:ServerLLDN.c  **** 						// precisa revisar o macsc_enable_manual_bts()
 633:ServerLLDN.c  **** 						/*
 634:ServerLLDN.c  **** 						int idle_time =  2 * numBaseTimeSlotperMgmt * (tTS) * 5 / (SYMBOL_TIME); // 5 is the total of
 635:ServerLLDN.c  **** 						macsc_set_cmp1_int_cb(lldn_server_beacon); // esta funo pode s mandar o beacon do online, 
 636:ServerLLDN.c  **** 						macsc_enable_manual_bts();
 637:ServerLLDN.c  **** 						macsc_enable_cmp_int(MACSC_CC1);
 638:ServerLLDN.c  **** 						macsc_use_cmp(MACSC_RELATIVE_CMP, idle_time, MACSC_CC1);
 639:ServerLLDN.c  **** 						*/
 640:ServerLLDN.c  **** 					}
 641:ServerLLDN.c  **** 					break;
 642:ServerLLDN.c  **** 				}
 643:ServerLLDN.c  **** 				case APP_PAN_STATE_IDLE:
 644:ServerLLDN.c  **** 				{
 645:ServerLLDN.c  **** 					msgReq.options = 0;
 646:ServerLLDN.c  **** 					appState = APP_STATE_IDLE;
 647:ServerLLDN.c  **** 					break;
 648:ServerLLDN.c  **** 				}
 649:ServerLLDN.c  **** 			}
 650:ServerLLDN.c  **** 			break;	
 651:ServerLLDN.c  **** 		}
 652:ServerLLDN.c  **** 		#else // NODES SPECIFIC STATE MACHINE
 653:ServerLLDN.c  **** 		case APP_STATE_PREP_DISC_REPONSE:
 654:ServerLLDN.c  **** 		{
 655:ServerLLDN.c  **** 			appPrepareDiscoverResponse();
 656:ServerLLDN.c  **** 			appState = APP_STATE_IDLE;	
 657:ServerLLDN.c  **** 			break;
 658:ServerLLDN.c  **** 		}
 659:ServerLLDN.c  **** 		
 660:ServerLLDN.c  **** 		case APP_STATE_PREP_CONFIG_STATUS:
 661:ServerLLDN.c  **** 		{
 662:ServerLLDN.c  **** 			// se o nodo recebeu ack na fase do discovery prepara a mensagem de configuration status
 663:ServerLLDN.c  **** 			if(ack_received && rec_beacon->confSeqNumber == 0 && associated == 0) {
 664:ServerLLDN.c  **** 				appPrepareConfigurationStatus();
 665:ServerLLDN.c  **** 			}
 666:ServerLLDN.c  **** 			// se o nodo no recebeu desativa o timer e fica em idle
 667:ServerLLDN.c  **** 			else {
 668:ServerLLDN.c  **** 				#if MASTER_MACSC
 669:ServerLLDN.c  **** 				macsc_disable_cmp_int(MACSC_CC1);
 670:ServerLLDN.c  **** 				#else
 671:ServerLLDN.c  **** 				timer_stop();
 672:ServerLLDN.c  **** 				#endif
 673:ServerLLDN.c  **** 			}
 674:ServerLLDN.c  **** 			ack_received = 0;
 675:ServerLLDN.c  **** 			appState = APP_STATE_IDLE;
 676:ServerLLDN.c  **** 			break;
 677:ServerLLDN.c  **** 		}
 678:ServerLLDN.c  **** 		#endif
 679:ServerLLDN.c  **** 		default:
 680:ServerLLDN.c  **** 		{
 681:ServerLLDN.c  **** 			break;
 1898               		.loc 6 681 0
 1899 0930 00C0      		rjmp .L56
 1900               	.L55:
 475:ServerLLDN.c  **** 			#if APP_COORDINATOR
 1901               		.loc 6 475 0
 1902 0932 0E94 0000 		call appInit
 477:ServerLLDN.c  **** 			#else
 1903               		.loc 6 477 0
 1904 0936 83E0      		ldi r24,lo8(3)
 1905 0938 8093 0000 		sts appState,r24
 481:ServerLLDN.c  **** 		}
 1906               		.loc 6 481 0
 1907 093c 00C0      		rjmp .L56
 1908               	.L53:
 485:ServerLLDN.c  **** 			#if APP_COORDINATOR
 1909               		.loc 6 485 0
 1910 093e 0E94 0000 		call appSendData
 488:ServerLLDN.c  **** 			#else
 1911               		.loc 6 488 0
 1912 0942 83E0      		ldi r24,lo8(3)
 1913 0944 8093 0000 		sts appState,r24
 492:ServerLLDN.c  **** 		}
 1914               		.loc 6 492 0
 1915 0948 00C0      		rjmp .L56
 1916               	.L54:
 497:ServerLLDN.c  **** 			{
 1917               		.loc 6 497 0
 1918 094a 8091 0000 		lds r24,appPanState
 1919 094e 882F      		mov r24,r24
 1920 0950 90E0      		ldi r25,0
 1921 0952 092E      		mov __tmp_reg__,r25
 1922 0954 000C      		lsl r0
 1923 0956 AA0B      		sbc r26,r26
 1924 0958 BB0B      		sbc r27,r27
 1925 095a 40E0      		ldi r20,0
 1926 095c 50E0      		ldi r21,0
 1927 095e 2AE0      		ldi r18,lo8(10)
 1928 0960 30E0      		ldi r19,0
 1929 0962 841B      		sub r24,r20
 1930 0964 950B      		sbc r25,r21
 1931 0966 2817      		cp r18,r24
 1932 0968 3907      		cpc r19,r25
 1933 096a 00F4      		brsh .+2
 1934 096c 00C0      		rjmp .L75
 1935 096e 8050      		subi r24,lo8(-(gs(.L59)))
 1936 0970 9040      		sbci r25,hi8(-(gs(.L59)))
 1937 0972 FC01      		movw r30,r24
 1938 0974 0C94 0000 		jmp __tablejump2__
 1939               		.section	.progmem.gcc_sw_table,"a",@progbits
 1940               		.p2align	1
 1941               	.L59:
 1942 0000 0000      		.word gs(.L58)
 1943 0002 0000      		.word gs(.L60)
 1944 0004 0000      		.word gs(.L61)
 1945 0006 0000      		.word gs(.L62)
 1946 0008 0000      		.word gs(.L63)
 1947 000a 0000      		.word gs(.L64)
 1948 000c 0000      		.word gs(.L65)
 1949 000e 0000      		.word gs(.L66)
 1950 0010 0000      		.word gs(.L67)
 1951 0012 0000      		.word gs(.L68)
 1952 0014 0000      		.word gs(.L76)
 1953               		.text
 1954               	.L60:
 502:ServerLLDN.c  **** 					appPanState = APP_PAN_STATE_DISC_INITIAL;
 1955               		.loc 6 502 0
 1956 0978 0E94 0000 		call appPanReset
 503:ServerLLDN.c  **** 					appState	= APP_STATE_SEND;
 1957               		.loc 6 503 0
 1958 097c 82E0      		ldi r24,lo8(2)
 1959 097e 8093 0000 		sts appPanState,r24
 504:ServerLLDN.c  **** 					cycles_counter = 0;
 1960               		.loc 6 504 0
 1961 0982 82E0      		ldi r24,lo8(2)
 1962 0984 8093 0000 		sts appState,r24
 505:ServerLLDN.c  **** 					break;
 1963               		.loc 6 505 0
 1964 0988 1092 0000 		sts cycles_counter,__zero_reg__
 506:ServerLLDN.c  **** 				}
 1965               		.loc 6 506 0
 1966 098c 00C0      		rjmp .L57
 1967               	.L61:
 515:ServerLLDN.c  **** 					{	
 1968               		.loc 6 515 0
 1969 098e 8091 0000 		lds r24,counter_associados
 1970 0992 9091 0000 		lds r25,counter_associados+1
 1971 0996 0C97      		sbiw r24,12
 1972 0998 01F0      		breq .L70
 515:ServerLLDN.c  **** 					{	
 1973               		.loc 6 515 0 is_stmt 0 discriminator 1
 1974 099a 8091 0000 		lds r24,cycles_counter
 1975 099e 8230      		cpi r24,lo8(2)
 1976 09a0 00F0      		brlo .L71
 1977               	.L70:
 517:ServerLLDN.c  **** 						counter_associados = 0;
 1978               		.loc 6 517 0 is_stmt 1
 1979 09a2 2091 0000 		lds r18,counter_associados
 1980 09a6 3091 0000 		lds r19,counter_associados+1
 1981 09aa 8091 0000 		lds r24,cycles_counter
 1982 09ae 882F      		mov r24,r24
 1983 09b0 90E0      		ldi r25,0
 1984 09b2 432F      		mov r20,r19
 1985 09b4 4F93      		push r20
 1986 09b6 2F93      		push r18
 1987 09b8 292F      		mov r18,r25
 1988 09ba 2F93      		push r18
 1989 09bc 8F93      		push r24
 1990 09be 80E0      		ldi r24,lo8(.LC7)
 1991 09c0 90E0      		ldi r25,hi8(.LC7)
 1992 09c2 892F      		mov r24,r25
 1993 09c4 8F93      		push r24
 1994 09c6 80E0      		ldi r24,lo8(.LC7)
 1995 09c8 90E0      		ldi r25,hi8(.LC7)
 1996 09ca 8F93      		push r24
 1997 09cc 0E94 0000 		call printf
 1998 09d0 0F90      		pop __tmp_reg__
 1999 09d2 0F90      		pop __tmp_reg__
 2000 09d4 0F90      		pop __tmp_reg__
 2001 09d6 0F90      		pop __tmp_reg__
 2002 09d8 0F90      		pop __tmp_reg__
 2003 09da 0F90      		pop __tmp_reg__
 518:ServerLLDN.c  **** 						/* if all nodes expected where associated stop beacon generation interruptions */
 2004               		.loc 6 518 0
 2005 09dc 1092 0000 		sts counter_associados+1,__zero_reg__
 2006 09e0 1092 0000 		sts counter_associados,__zero_reg__
 520:ServerLLDN.c  **** 						macsc_disable_cmp_int(MACSC_CC2);
 2007               		.loc 6 520 0
 2008 09e4 81E0      		ldi r24,lo8(1)
 2009 09e6 0E94 0000 		call macsc_disable_cmp_int
 521:ServerLLDN.c  **** 						msgReq.options = 0;
 2010               		.loc 6 521 0
 2011 09ea 82E0      		ldi r24,lo8(2)
 2012 09ec 0E94 0000 		call macsc_disable_cmp_int
 522:ServerLLDN.c  **** 						/* set coordinator node to idle further implementation of online state must be done */
 2013               		.loc 6 522 0
 2014 09f0 1092 0000 		sts msgReq+9+1,__zero_reg__
 2015 09f4 1092 0000 		sts msgReq+9,__zero_reg__
 524:ServerLLDN.c  **** 						appPanState = APP_PAN_STATE_IDLE; // APP_PAN_STATE_ONLINE_INIT
 2016               		.loc 6 524 0
 2017 09f8 81E0      		ldi r24,lo8(1)
 2018 09fa 8093 0000 		sts appState,r24
 525:ServerLLDN.c  **** 						
 2019               		.loc 6 525 0
 2020 09fe 1092 0000 		sts appPanState,__zero_reg__
 536:ServerLLDN.c  **** 				}
 2021               		.loc 6 536 0
 2022 0a02 00C0      		rjmp .L57
 2023               	.L71:
 532:ServerLLDN.c  **** 						appState	= APP_STATE_IDLE;
 2024               		.loc 6 532 0
 2025 0a04 0E94 0000 		call appPanDiscInit
 533:ServerLLDN.c  **** 						appPanState = APP_PAN_STATE_DISC_SECOND_BE;
 2026               		.loc 6 533 0
 2027 0a08 81E0      		ldi r24,lo8(1)
 2028 0a0a 8093 0000 		sts appState,r24
 534:ServerLLDN.c  **** 					}
 2029               		.loc 6 534 0
 2030 0a0e 83E0      		ldi r24,lo8(3)
 2031 0a10 8093 0000 		sts appPanState,r24
 536:ServerLLDN.c  **** 				}
 2032               		.loc 6 536 0
 2033 0a14 00C0      		rjmp .L57
 2034               	.L62:
 541:ServerLLDN.c  **** 					msgReq.data = NULL;
 2035               		.loc 6 541 0
 2036 0a16 80E4      		ldi r24,lo8(64)
 2037 0a18 99E0      		ldi r25,lo8(9)
 2038 0a1a 9093 0000 		sts msgReq+9+1,r25
 2039 0a1e 8093 0000 		sts msgReq+9,r24
 542:ServerLLDN.c  **** 					msgReq.size = 0;
 2040               		.loc 6 542 0
 2041 0a22 1092 0000 		sts msgReq+13+1,__zero_reg__
 2042 0a26 1092 0000 		sts msgReq+13,__zero_reg__
 543:ServerLLDN.c  **** 					
 2043               		.loc 6 543 0
 2044 0a2a 1092 0000 		sts msgReq+15,__zero_reg__
 545:ServerLLDN.c  **** 					appPanState = APP_PAN_STATE_DISC_PREPARE_ACK;
 2045               		.loc 6 545 0
 2046 0a2e 84E0      		ldi r24,lo8(4)
 2047 0a30 8093 0000 		sts appState,r24
 546:ServerLLDN.c  **** 					break;
 2048               		.loc 6 546 0
 2049 0a34 84E0      		ldi r24,lo8(4)
 2050 0a36 8093 0000 		sts appPanState,r24
 547:ServerLLDN.c  **** 				}
 2051               		.loc 6 547 0
 2052 0a3a 00C0      		rjmp .L57
 2053               	.L63:
 554:ServerLLDN.c  **** 					SYS_TimerStart(&tmrDelay);
 2054               		.loc 6 554 0
 2055 0a3c 0E94 0000 		call appPanPrepareACK
 555:ServerLLDN.c  **** 					
 2056               		.loc 6 555 0
 2057 0a40 80E0      		ldi r24,lo8(tmrDelay)
 2058 0a42 90E0      		ldi r25,hi8(tmrDelay)
 2059 0a44 0E94 0000 		call SYS_TimerStart
 557:ServerLLDN.c  **** 					appState = APP_STATE_IDLE;
 2060               		.loc 6 557 0
 2061 0a48 85E0      		ldi r24,lo8(5)
 2062 0a4a 8093 0000 		sts appPanState,r24
 558:ServerLLDN.c  **** 					break;
 2063               		.loc 6 558 0
 2064 0a4e 81E0      		ldi r24,lo8(1)
 2065 0a50 8093 0000 		sts appState,r24
 559:ServerLLDN.c  **** 				}
 2066               		.loc 6 559 0
 2067 0a54 00C0      		rjmp .L57
 2068               	.L64:
 564:ServerLLDN.c  **** 					msgReq.data = NULL;
 2069               		.loc 6 564 0
 2070 0a56 80E4      		ldi r24,lo8(64)
 2071 0a58 92E0      		ldi r25,lo8(2)
 2072 0a5a 9093 0000 		sts msgReq+9+1,r25
 2073 0a5e 8093 0000 		sts msgReq+9,r24
 565:ServerLLDN.c  **** 					msgReq.size = 0;
 2074               		.loc 6 565 0
 2075 0a62 1092 0000 		sts msgReq+13+1,__zero_reg__
 2076 0a66 1092 0000 		sts msgReq+13,__zero_reg__
 566:ServerLLDN.c  **** 					
 2077               		.loc 6 566 0
 2078 0a6a 1092 0000 		sts msgReq+15,__zero_reg__
 568:ServerLLDN.c  **** 					appPanState = APP_PAN_STATE_CONFIG_SECOND_BEACON;
 2079               		.loc 6 568 0
 2080 0a6e 81E0      		ldi r24,lo8(1)
 2081 0a70 8093 0000 		sts appState,r24
 569:ServerLLDN.c  **** 					break;
 2082               		.loc 6 569 0
 2083 0a74 87E0      		ldi r24,lo8(7)
 2084 0a76 8093 0000 		sts appPanState,r24
 570:ServerLLDN.c  **** 
 2085               		.loc 6 570 0
 2086 0a7a 00C0      		rjmp .L57
 2087               	.L66:
 576:ServerLLDN.c  **** 					msgReq.data = NULL;
 2088               		.loc 6 576 0
 2089 0a7c 80E4      		ldi r24,lo8(64)
 2090 0a7e 9AE0      		ldi r25,lo8(10)
 2091 0a80 9093 0000 		sts msgReq+9+1,r25
 2092 0a84 8093 0000 		sts msgReq+9,r24
 577:ServerLLDN.c  **** 					msgReq.size = 0;
 2093               		.loc 6 577 0
 2094 0a88 1092 0000 		sts msgReq+13+1,__zero_reg__
 2095 0a8c 1092 0000 		sts msgReq+13,__zero_reg__
 578:ServerLLDN.c  **** 					
 2096               		.loc 6 578 0
 2097 0a90 1092 0000 		sts msgReq+15,__zero_reg__
 580:ServerLLDN.c  **** 					appPanState = APP_PAN_STATE_SEND_CONF_REQUEST;
 2098               		.loc 6 580 0
 2099 0a94 81E0      		ldi r24,lo8(1)
 2100 0a96 8093 0000 		sts appState,r24
 581:ServerLLDN.c  **** 					break;
 2101               		.loc 6 581 0
 2102 0a9a 86E0      		ldi r24,lo8(6)
 2103 0a9c 8093 0000 		sts appPanState,r24
 582:ServerLLDN.c  **** 				}
 2104               		.loc 6 582 0
 2105 0aa0 00C0      		rjmp .L57
 2106               	.L65:
 587:ServerLLDN.c  **** 					{
 2107               		.loc 6 587 0
 2108 0aa2 8091 0000 		lds r24,conf_req_index
 2109 0aa6 9091 0000 		lds r25,conf_req_index+1
 2110 0aaa 1816      		cp __zero_reg__,r24
 2111 0aac 1906      		cpc __zero_reg__,r25
 2112 0aae 04F4      		brge .L73
 589:ServerLLDN.c  **** 						msgReq.options		= NWK_OPT_MAC_COMMAND;
 2113               		.loc 6 589 0
 2114 0ab0 8091 0000 		lds r24,conf_req_index
 2115 0ab4 9091 0000 		lds r25,conf_req_index+1
 2116 0ab8 0E94 0000 		call CopyToConfigRequest
 590:ServerLLDN.c  **** 						msgReq.data			= (uint8_t*)&config_request_frame;
 2117               		.loc 6 590 0
 2118 0abc 80E0      		ldi r24,0
 2119 0abe 90E8      		ldi r25,lo8(-128)
 2120 0ac0 9093 0000 		sts msgReq+9+1,r25
 2121 0ac4 8093 0000 		sts msgReq+9,r24
 591:ServerLLDN.c  **** 						msgReq.size			= sizeof(NWK_ConfigRequest_t);
 2122               		.loc 6 591 0
 2123 0ac8 80E0      		ldi r24,lo8(config_request_frame)
 2124 0aca 90E0      		ldi r25,hi8(config_request_frame)
 2125 0acc 9093 0000 		sts msgReq+13+1,r25
 2126 0ad0 8093 0000 		sts msgReq+13,r24
 592:ServerLLDN.c  **** 						appState	= APP_STATE_IDLE;
 2127               		.loc 6 592 0
 2128 0ad4 86E0      		ldi r24,lo8(6)
 2129 0ad6 8093 0000 		sts msgReq+15,r24
 593:ServerLLDN.c  **** 						appPanState = APP_PAN_STATE_SEND_CONF_REQUEST;
 2130               		.loc 6 593 0
 2131 0ada 81E0      		ldi r24,lo8(1)
 2132 0adc 8093 0000 		sts appState,r24
 594:ServerLLDN.c  **** 						conf_req_index--;
 2133               		.loc 6 594 0
 2134 0ae0 86E0      		ldi r24,lo8(6)
 2135 0ae2 8093 0000 		sts appPanState,r24
 595:ServerLLDN.c  **** 						counter_associados++;
 2136               		.loc 6 595 0
 2137 0ae6 8091 0000 		lds r24,conf_req_index
 2138 0aea 9091 0000 		lds r25,conf_req_index+1
 2139 0aee 0197      		sbiw r24,1
 2140 0af0 9093 0000 		sts conf_req_index+1,r25
 2141 0af4 8093 0000 		sts conf_req_index,r24
 596:ServerLLDN.c  **** 						// SYS_TimerStart(&tmrDelay);
 2142               		.loc 6 596 0
 2143 0af8 8091 0000 		lds r24,counter_associados
 2144 0afc 9091 0000 		lds r25,counter_associados+1
 2145 0b00 0196      		adiw r24,1
 2146 0b02 9093 0000 		sts counter_associados+1,r25
 2147 0b06 8093 0000 		sts counter_associados,r24
 603:ServerLLDN.c  **** 				}
 2148               		.loc 6 603 0
 2149 0b0a 00C0      		rjmp .L57
 2150               	.L73:
 601:ServerLLDN.c  **** 					}
 2151               		.loc 6 601 0
 2152 0b0c 88E0      		ldi r24,lo8(8)
 2153 0b0e 8093 0000 		sts appPanState,r24
 603:ServerLLDN.c  **** 				}
 2154               		.loc 6 603 0
 2155 0b12 00C0      		rjmp .L57
 2156               	.L67:
 607:ServerLLDN.c  **** 					msgReq.data = NULL;
 2157               		.loc 6 607 0
 2158 0b14 80E4      		ldi r24,lo8(64)
 2159 0b16 92E1      		ldi r25,lo8(18)
 2160 0b18 9093 0000 		sts msgReq+9+1,r25
 2161 0b1c 8093 0000 		sts msgReq+9,r24
 608:ServerLLDN.c  **** 					msgReq.size = 0;
 2162               		.loc 6 608 0
 2163 0b20 1092 0000 		sts msgReq+13+1,__zero_reg__
 2164 0b24 1092 0000 		sts msgReq+13,__zero_reg__
 609:ServerLLDN.c  **** 					
 2165               		.loc 6 609 0
 2166 0b28 1092 0000 		sts msgReq+15,__zero_reg__
 611:ServerLLDN.c  **** 					appPanState = APP_PAN_STATE_DISC_INITIAL;
 2167               		.loc 6 611 0
 2168 0b2c 81E0      		ldi r24,lo8(1)
 2169 0b2e 8093 0000 		sts appState,r24
 612:ServerLLDN.c  **** 					cycles_counter++;	
 2170               		.loc 6 612 0
 2171 0b32 82E0      		ldi r24,lo8(2)
 2172 0b34 8093 0000 		sts appPanState,r24
 613:ServerLLDN.c  **** 					
 2173               		.loc 6 613 0
 2174 0b38 8091 0000 		lds r24,cycles_counter
 2175 0b3c 8F5F      		subi r24,lo8(-(1))
 2176 0b3e 8093 0000 		sts cycles_counter,r24
 615:ServerLLDN.c  **** 				}
 2177               		.loc 6 615 0
 2178 0b42 00C0      		rjmp .L57
 2179               	.L68:
 619:ServerLLDN.c  **** 					break;
 2180               		.loc 6 619 0
 2181 0b44 0E94 0000 		call appPanOnlineInit
 620:ServerLLDN.c  **** 				}
 2182               		.loc 6 620 0
 2183 0b48 00C0      		rjmp .L57
 2184               	.L58:
 645:ServerLLDN.c  **** 					appState = APP_STATE_IDLE;
 2185               		.loc 6 645 0
 2186 0b4a 1092 0000 		sts msgReq+9+1,__zero_reg__
 2187 0b4e 1092 0000 		sts msgReq+9,__zero_reg__
 646:ServerLLDN.c  **** 					break;
 2188               		.loc 6 646 0
 2189 0b52 81E0      		ldi r24,lo8(1)
 2190 0b54 8093 0000 		sts appState,r24
 647:ServerLLDN.c  **** 				}
 2191               		.loc 6 647 0
 2192 0b58 00C0      		rjmp .L57
 2193               	.L76:
 641:ServerLLDN.c  **** 				}
 2194               		.loc 6 641 0
 2195 0b5a 0000      		nop
 2196               	.L57:
 2197               	.L75:
 650:ServerLLDN.c  **** 		}
 2198               		.loc 6 650 0
 2199 0b5c 0000      		nop
 2200               	.L56:
 682:ServerLLDN.c  **** 		}
 683:ServerLLDN.c  **** 	}
 684:ServerLLDN.c  **** }
 2201               		.loc 6 684 0
 2202 0b5e 0000      		nop
 2203               	/* epilogue start */
 2204 0b60 DF91      		pop r29
 2205 0b62 CF91      		pop r28
 2206 0b64 0895      		ret
 2207               		.cfi_endproc
 2208               	.LFE145:
 2210               		.section	.rodata
 2211               	.LC0:
 2212 006c 00        		.byte	0
 2213 006d C2        		.byte	-62
 2214 006e 01        		.byte	1
 2215 006f 00        		.byte	0
 2216 0070 03        		.byte	3
 2217 0071 00        		.byte	0
 2218 0072 00        		.byte	0
 2219               		.text
 2220               	.global	main
 2222               	main:
 2223               	.LFB146:
 685:ServerLLDN.c  **** 
 686:ServerLLDN.c  **** 	/*****************************************************************************
 687:ServerLLDN.c  **** 	*****************************************************************************/
 688:ServerLLDN.c  **** 	int main(void)
 689:ServerLLDN.c  **** 	{
 2224               		.loc 6 689 0
 2225               		.cfi_startproc
 2226 0b66 0F93      		push r16
 2227               	.LCFI84:
 2228               		.cfi_def_cfa_offset 3
 2229               		.cfi_offset 16, -2
 2230 0b68 1F93      		push r17
 2231               	.LCFI85:
 2232               		.cfi_def_cfa_offset 4
 2233               		.cfi_offset 17, -3
 2234 0b6a CF93      		push r28
 2235               	.LCFI86:
 2236               		.cfi_def_cfa_offset 5
 2237               		.cfi_offset 28, -4
 2238 0b6c DF93      		push r29
 2239               	.LCFI87:
 2240               		.cfi_def_cfa_offset 6
 2241               		.cfi_offset 29, -5
 2242 0b6e CDB7      		in r28,__SP_L__
 2243 0b70 DEB7      		in r29,__SP_H__
 2244               	.LCFI88:
 2245               		.cfi_def_cfa_register 28
 2246 0b72 2797      		sbiw r28,7
 2247               	.LCFI89:
 2248               		.cfi_def_cfa_offset 13
 2249 0b74 0FB6      		in __tmp_reg__,__SREG__
 2250 0b76 F894      		cli
 2251 0b78 DEBF      		out __SP_H__,r29
 2252 0b7a 0FBE      		out __SREG__,__tmp_reg__
 2253 0b7c CDBF      		out __SP_L__,r28
 2254               	/* prologue: function */
 2255               	/* frame size = 7 */
 2256               	/* stack size = 11 */
 2257               	.L__stack_usage = 11
 690:ServerLLDN.c  **** 		sysclk_init();
 2258               		.loc 6 690 0
 2259 0b7e 0E94 0000 		call sysclk_init
 691:ServerLLDN.c  **** 		board_init();
 2260               		.loc 6 691 0
 2261 0b82 0E94 0000 		call board_init
 692:ServerLLDN.c  **** 
 693:ServerLLDN.c  **** 		SYS_Init();
 2262               		.loc 6 693 0
 2263 0b86 0E94 0000 		call SYS_Init
 694:ServerLLDN.c  **** 		/* Disable CSMA/CA
 695:ServerLLDN.c  **** 		 * Disable auto ACK
 696:ServerLLDN.c  **** 		 * Enable Rx of LLDN Frame Type as described in 802.15.4e - 2012 
 697:ServerLLDN.c  **** 		 */
 698:ServerLLDN.c  **** 
 699:ServerLLDN.c  **** 		sm_init();
 2264               		.loc 6 699 0
 2265 0b8a 0E94 0000 		call sm_init
 700:ServerLLDN.c  **** 
 701:ServerLLDN.c  **** 		// Initialize interrupt vector table support.
 702:ServerLLDN.c  **** 	#if (SIO2HOST_CHANNEL == SIO_USB)
 703:ServerLLDN.c  **** 		irq_initialize_vectors();
 704:ServerLLDN.c  **** 	#endif
 705:ServerLLDN.c  **** 		cpu_irq_enable();
 2266               		.loc 6 705 0
 2267               	/* #APP */
 2268               	 ;  705 "ServerLLDN.c" 1
 2269 0b8e 7894      		sei
 2270               	 ;  0 "" 2
 706:ServerLLDN.c  **** 
 707:ServerLLDN.c  **** 	#if 1
 708:ServerLLDN.c  **** 	#if (SIO2HOST_CHANNEL == SIO_USB)
 709:ServerLLDN.c  **** 		stdio_usb_init();
 710:ServerLLDN.c  **** 	#else
 711:ServerLLDN.c  **** 		const usart_serial_options_t usart_serial_options =
 2271               		.loc 6 711 0
 2272               	/* #NOAPP */
 2273 0b90 27E0      		ldi r18,lo8(7)
 2274 0b92 E0E0      		ldi r30,lo8(.LC0)
 2275 0b94 F0E0      		ldi r31,hi8(.LC0)
 2276 0b96 CE01      		movw r24,r28
 2277 0b98 0196      		adiw r24,1
 2278 0b9a DC01      		movw r26,r24
 2279               		0:
 2280 0b9c 0190      		ld r0,Z+
 2281 0b9e 0D92      		st X+,r0
 2282 0ba0 2A95      		dec r18
 2283 0ba2 01F4      		brne 0b
 712:ServerLLDN.c  **** 		{
 713:ServerLLDN.c  **** 			.baudrate     = USART_HOST_BAUDRATE,
 714:ServerLLDN.c  **** 			.charlength   = USART_HOST_CHAR_LENGTH,
 715:ServerLLDN.c  **** 			.paritytype   = USART_HOST_PARITY,
 716:ServerLLDN.c  **** 			.stopbits     = USART_HOST_STOP_BITS
 717:ServerLLDN.c  **** 		};
 718:ServerLLDN.c  **** 
 719:ServerLLDN.c  **** 		stdio_serial_init(USART_HOST, &usart_serial_options);
 2284               		.loc 6 719 0
 2285 0ba4 CE01      		movw r24,r28
 2286 0ba6 0196      		adiw r24,1
 2287 0ba8 BC01      		movw r22,r24
 2288 0baa 80EC      		ldi r24,lo8(-64)
 2289 0bac 90E0      		ldi r25,0
 2290 0bae 0E94 0000 		call stdio_serial_init
 720:ServerLLDN.c  **** 		usart_double_baud_enable(USART_HOST);
 2291               		.loc 6 720 0
 2292 0bb2 80EC      		ldi r24,lo8(-64)
 2293 0bb4 90E0      		ldi r25,0
 2294 0bb6 0E94 0000 		call usart_double_baud_enable
 721:ServerLLDN.c  **** 		usart_set_baudrate_precalculated(USART_HOST, USART_HOST_BAUDRATE, sysclk_get_source_clock_hz());
 2295               		.loc 6 721 0
 2296 0bba 0E94 0000 		call sysclk_get_source_clock_hz
 2297 0bbe DC01      		movw r26,r24
 2298 0bc0 CB01      		movw r24,r22
 2299 0bc2 8C01      		movw r16,r24
 2300 0bc4 9D01      		movw r18,r26
 2301 0bc6 40E0      		ldi r20,0
 2302 0bc8 52EC      		ldi r21,lo8(-62)
 2303 0bca 61E0      		ldi r22,lo8(1)
 2304 0bcc 70E0      		ldi r23,0
 2305 0bce 80EC      		ldi r24,lo8(-64)
 2306 0bd0 90E0      		ldi r25,0
 2307 0bd2 0E94 0000 		call usart_set_baudrate_precalculated
 2308               	.L78:
 722:ServerLLDN.c  **** 
 723:ServerLLDN.c  **** 	#endif
 724:ServerLLDN.c  **** 	#endif
 725:ServerLLDN.c  **** 		for(;;)
 726:ServerLLDN.c  **** 		{
 727:ServerLLDN.c  **** 			SYS_TaskHandler();
 2309               		.loc 6 727 0 discriminator 1
 2310 0bd6 0E94 0000 		call SYS_TaskHandler
 728:ServerLLDN.c  **** 			APP_TaskHandler();
 2311               		.loc 6 728 0 discriminator 1
 2312 0bda 0E94 0000 		call APP_TaskHandler
 729:ServerLLDN.c  **** 		}
 2313               		.loc 6 729 0 discriminator 1
 2314 0bde 00C0      		rjmp .L78
 2315               		.cfi_endproc
 2316               	.LFE146:
 2318               	.Letext0:
 2319               		.file 7 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\in
 2320               		.file 8 "../../../stack/LwMesh/TDMA/nwk/inc/nwkRx.h"
 2321               		.file 9 "../../../stack/LwMesh/TDMA/nwk/inc/nwkDataReq.h"
 2322               		.file 10 "../../../stack/LwMesh/TDMA/sys/inc/sysTimer.h"
 2323               		.file 11 "../../../platform/mega_rf/drivers/sleep/sleep.h"
 2324               		.file 12 "lldn.h"
 2325               		.file 13 "../../../platform/mega_rf/utils/status_codes.h"
 2326               		.file 14 "config/config.h"
 2327               		.file 15 "../../../platform/common/services/sleepmgr/mega_rf/sleepmgr.h"
DEFINED SYMBOLS
                            *ABS*:00000000 ServerLLDN.c
C:\Users\GUILHE~1\AppData\Local\Temp\ccz8rQvW.s:2      *ABS*:0000003e __SP_H__
C:\Users\GUILHE~1\AppData\Local\Temp\ccz8rQvW.s:3      *ABS*:0000003d __SP_L__
C:\Users\GUILHE~1\AppData\Local\Temp\ccz8rQvW.s:4      *ABS*:0000003f __SREG__
C:\Users\GUILHE~1\AppData\Local\Temp\ccz8rQvW.s:5      *ABS*:0000003b __RAMPZ__
C:\Users\GUILHE~1\AppData\Local\Temp\ccz8rQvW.s:6      *ABS*:00000000 __tmp_reg__
C:\Users\GUILHE~1\AppData\Local\Temp\ccz8rQvW.s:7      *ABS*:00000001 __zero_reg__
                            *COM*:00000001 n
C:\Users\GUILHE~1\AppData\Local\Temp\ccz8rQvW.s:15     .bss.tTS:00000000 tTS
C:\Users\GUILHE~1\AppData\Local\Temp\ccz8rQvW.s:19     .text:00000000 sysclk_get_main_hz
C:\Users\GUILHE~1\AppData\Local\Temp\ccz8rQvW.s:56     .text:0000001a sysclk_get_source_clock_hz
C:\Users\GUILHE~1\AppData\Local\Temp\ccz8rQvW.s:93     .progmem.data.baudctrl_1mhz:00000000 baudctrl_1mhz
C:\Users\GUILHE~1\AppData\Local\Temp\ccz8rQvW.s:105    .progmem.data.baudctrl_8mhz:00000000 baudctrl_8mhz
C:\Users\GUILHE~1\AppData\Local\Temp\ccz8rQvW.s:117    .progmem.data.baudctrl_16mhz:00000000 baudctrl_16mhz
C:\Users\GUILHE~1\AppData\Local\Temp\ccz8rQvW.s:128    .text:00000034 usart_double_baud_enable
C:\Users\GUILHE~1\AppData\Local\Temp\ccz8rQvW.s:177    .text:00000062 usart_serial_init
C:\Users\GUILHE~1\AppData\Local\Temp\ccz8rQvW.s:272    .text:000000de usart_serial_putchar
C:\Users\GUILHE~1\AppData\Local\Temp\ccz8rQvW.s:316    .text:00000106 usart_serial_getchar
C:\Users\GUILHE~1\AppData\Local\Temp\ccz8rQvW.s:367    .text:0000013c stdio_serial_init
C:\Users\GUILHE~1\AppData\Local\Temp\ccz8rQvW.s:438    .text:0000019e macsc_enable_manual_bts
C:\Users\GUILHE~1\AppData\Local\Temp\ccz8rQvW.s:492    .bss.appState:00000000 appState
C:\Users\GUILHE~1\AppData\Local\Temp\ccz8rQvW.s:497    .bss.msgReq:00000000 msgReq
C:\Users\GUILHE~1\AppData\Local\Temp\ccz8rQvW.s:502    .bss.PanId:00000000 PanId
C:\Users\GUILHE~1\AppData\Local\Temp\ccz8rQvW.s:510    .text:000001d2 appSendData
C:\Users\GUILHE~1\AppData\Local\Temp\ccz8rQvW.s:572    .data.appPanState:00000000 appPanState
                            *COM*:000003f8 nodes_info_arr
C:\Users\GUILHE~1\AppData\Local\Temp\ccz8rQvW.s:579    .data.config_request_frame:00000000 config_request_frame
C:\Users\GUILHE~1\AppData\Local\Temp\ccz8rQvW.s:589    .bss.conf_req_list:00000000 conf_req_list
                            *COM*:000001fc conf_req_arr
C:\Users\GUILHE~1\AppData\Local\Temp\ccz8rQvW.s:596    .bss.conf_req_index:00000000 conf_req_index
                            *COM*:00000021 ACKFrame
C:\Users\GUILHE~1\AppData\Local\Temp\ccz8rQvW.s:603    .bss.ACKFrame_size:00000000 ACKFrame_size
C:\Users\GUILHE~1\AppData\Local\Temp\ccz8rQvW.s:609    .bss.beaconInterval:00000000 beaconInterval
C:\Users\GUILHE~1\AppData\Local\Temp\ccz8rQvW.s:615    .bss.macLLDNnumUplinkTS:00000000 macLLDNnumUplinkTS
C:\Users\GUILHE~1\AppData\Local\Temp\ccz8rQvW.s:620    .bss.tmrDelay:00000000 tmrDelay
C:\Users\GUILHE~1\AppData\Local\Temp\ccz8rQvW.s:626    .bss.counter_associados:00000000 counter_associados
C:\Users\GUILHE~1\AppData\Local\Temp\ccz8rQvW.s:632    .data.cycles_counter:00000000 cycles_counter
C:\Users\GUILHE~1\AppData\Local\Temp\ccz8rQvW.s:636    .text:0000021e tmrDelayHandler
C:\Users\GUILHE~1\AppData\Local\Temp\ccz8rQvW.s:676    .text:0000023e lldn_server_beacon
C:\Users\GUILHE~1\AppData\Local\Temp\ccz8rQvW.s:711    .text:00000258 downlink_delay_handler
C:\Users\GUILHE~1\AppData\Local\Temp\ccz8rQvW.s:751    .text:0000027c end_of_online_handler
C:\Users\GUILHE~1\AppData\Local\Temp\ccz8rQvW.s:791    .text:00000298 teste_handler
C:\Users\GUILHE~1\AppData\Local\Temp\ccz8rQvW.s:845    .text:000002d0 addToAckArray
C:\Users\GUILHE~1\AppData\Local\Temp\ccz8rQvW.s:991    .text:000003ae addConfRequestArray
C:\Users\GUILHE~1\AppData\Local\Temp\ccz8rQvW.s:1108   .text:00000478 CopyToConfigRequest
C:\Users\GUILHE~1\AppData\Local\Temp\ccz8rQvW.s:1176   .text:000004c4 appCommandInd
C:\Users\GUILHE~1\AppData\Local\Temp\ccz8rQvW.s:1323   .text:0000059e appPanPrepareACK
C:\Users\GUILHE~1\AppData\Local\Temp\ccz8rQvW.s:1375   .text:000005e4 appPanReset
C:\Users\GUILHE~1\AppData\Local\Temp\ccz8rQvW.s:1504   .text:00000698 appPanDiscInit
C:\Users\GUILHE~1\AppData\Local\Temp\ccz8rQvW.s:1723   .text:0000084c appPanOnlineInit
C:\Users\GUILHE~1\AppData\Local\Temp\ccz8rQvW.s:1774   .text:00000884 appInit
C:\Users\GUILHE~1\AppData\Local\Temp\ccz8rQvW.s:1866   .text:00000910 APP_TaskHandler
C:\Users\GUILHE~1\AppData\Local\Temp\ccz8rQvW.s:2222   .text:00000b66 main

UNDEFINED SYMBOLS
usart_init_rs232
usart_putchar
usart_getchar
stdio_base
ptr_put
ptr_get
_read
_write
fdevopen
printf
NWK_DataReq
macsc_disable_cmp_int
__floatsisf
__addsf3
__divsf3
__mulsf3
__fixunssfsi
macsc_set_cmp1_int_cb
macsc_enable_cmp_int
macsc_use_cmp
macsc_set_cmp2_int_cb
NWK_SetAddr
PHY_SetChannel
PHY_SetRxState
NWK_SetPanId
PHY_SetTdmaMode
NWK_OpenEndpoint
PHY_SetPromiscuousMode
__tablejump2__
SYS_TimerStart
sysclk_init
board_init
SYS_Init
sm_init
usart_set_baudrate_precalculated
SYS_TaskHandler
__do_copy_data
__do_clear_bss
