   1               		.file	"ServerLLDN.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__RAMPZ__ = 0x3b
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.text
   9               	.Ltext0:
  10               		.cfi_sections	.debug_frame
  11               		.comm	n,1,1
  12               		.section	.bss.tTS,"aw",@nobits
  15               	tTS:
  16 0000 0000 0000 		.zero	4
  17               		.text
  19               	sysclk_get_main_hz:
  20               	.LFB67:
  21               		.file 1 "../../../platform/common/services/clock/mega/sysclk.h"
   1:../../../platform/common/services/clock/mega/sysclk.h **** /**
   2:../../../platform/common/services/clock/mega/sysclk.h ****  * \file
   3:../../../platform/common/services/clock/mega/sysclk.h ****  *
   4:../../../platform/common/services/clock/mega/sysclk.h ****  * \brief Chip-specific system clock management functions
   5:../../../platform/common/services/clock/mega/sysclk.h ****  *
   6:../../../platform/common/services/clock/mega/sysclk.h ****  * Copyright (c) 2012 Atmel Corporation. All rights reserved.
   7:../../../platform/common/services/clock/mega/sysclk.h ****  *
   8:../../../platform/common/services/clock/mega/sysclk.h ****  * \asf_license_start
   9:../../../platform/common/services/clock/mega/sysclk.h ****  *
  10:../../../platform/common/services/clock/mega/sysclk.h ****  * \page License
  11:../../../platform/common/services/clock/mega/sysclk.h ****  *
  12:../../../platform/common/services/clock/mega/sysclk.h ****  * Redistribution and use in source and binary forms, with or without
  13:../../../platform/common/services/clock/mega/sysclk.h ****  * modification, are permitted provided that the following conditions are met:
  14:../../../platform/common/services/clock/mega/sysclk.h ****  *
  15:../../../platform/common/services/clock/mega/sysclk.h ****  * 1. Redistributions of source code must retain the above copyright notice,
  16:../../../platform/common/services/clock/mega/sysclk.h ****  *    this list of conditions and the following disclaimer.
  17:../../../platform/common/services/clock/mega/sysclk.h ****  *
  18:../../../platform/common/services/clock/mega/sysclk.h ****  * 2. Redistributions in binary form must reproduce the above copyright notice,
  19:../../../platform/common/services/clock/mega/sysclk.h ****  *    this list of conditions and the following disclaimer in the documentation
  20:../../../platform/common/services/clock/mega/sysclk.h ****  *    and/or other materials provided with the distribution.
  21:../../../platform/common/services/clock/mega/sysclk.h ****  *
  22:../../../platform/common/services/clock/mega/sysclk.h ****  * 3. The name of Atmel may not be used to endorse or promote products derived
  23:../../../platform/common/services/clock/mega/sysclk.h ****  *    from this software without specific prior written permission.
  24:../../../platform/common/services/clock/mega/sysclk.h ****  *
  25:../../../platform/common/services/clock/mega/sysclk.h ****  * 4. This software may only be redistributed and used in connection with an
  26:../../../platform/common/services/clock/mega/sysclk.h ****  *    Atmel microcontroller product.
  27:../../../platform/common/services/clock/mega/sysclk.h ****  *
  28:../../../platform/common/services/clock/mega/sysclk.h ****  * THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR IMPLIED
  29:../../../platform/common/services/clock/mega/sysclk.h ****  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
  30:../../../platform/common/services/clock/mega/sysclk.h ****  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
  31:../../../platform/common/services/clock/mega/sysclk.h ****  * EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR
  32:../../../platform/common/services/clock/mega/sysclk.h ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  33:../../../platform/common/services/clock/mega/sysclk.h ****  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
  34:../../../platform/common/services/clock/mega/sysclk.h ****  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  35:../../../platform/common/services/clock/mega/sysclk.h ****  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
  36:../../../platform/common/services/clock/mega/sysclk.h ****  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  37:../../../platform/common/services/clock/mega/sysclk.h ****  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  38:../../../platform/common/services/clock/mega/sysclk.h ****  * POSSIBILITY OF SUCH DAMAGE.
  39:../../../platform/common/services/clock/mega/sysclk.h ****  *
  40:../../../platform/common/services/clock/mega/sysclk.h ****  * \asf_license_stop
  41:../../../platform/common/services/clock/mega/sysclk.h ****  *
  42:../../../platform/common/services/clock/mega/sysclk.h ****  */
  43:../../../platform/common/services/clock/mega/sysclk.h **** #ifndef MEGA_SYSCLK_H_INCLUDED
  44:../../../platform/common/services/clock/mega/sysclk.h **** #define MEGA_SYSCLK_H_INCLUDED
  45:../../../platform/common/services/clock/mega/sysclk.h **** 
  46:../../../platform/common/services/clock/mega/sysclk.h **** #include <board.h>
  47:../../../platform/common/services/clock/mega/sysclk.h **** #include <compiler.h>
  48:../../../platform/common/services/clock/mega/sysclk.h **** #include <parts.h>
  49:../../../platform/common/services/clock/mega/sysclk.h **** 
  50:../../../platform/common/services/clock/mega/sysclk.h **** /* Include clock configuration for the project. */
  51:../../../platform/common/services/clock/mega/sysclk.h **** #include <conf_clock.h>
  52:../../../platform/common/services/clock/mega/sysclk.h **** 
  53:../../../platform/common/services/clock/mega/sysclk.h **** #ifdef __cplusplus
  54:../../../platform/common/services/clock/mega/sysclk.h **** extern "C" {
  55:../../../platform/common/services/clock/mega/sysclk.h **** #endif
  56:../../../platform/common/services/clock/mega/sysclk.h **** #define ASM __asm__
  57:../../../platform/common/services/clock/mega/sysclk.h **** 
  58:../../../platform/common/services/clock/mega/sysclk.h **** /* CONFIG_SYSCLK_PSDIV  to use default if not defined*/
  59:../../../platform/common/services/clock/mega/sysclk.h **** #ifndef CONFIG_SYSCLK_PSDIV
  60:../../../platform/common/services/clock/mega/sysclk.h **** # define CONFIG_SYSCLK_PSDIV    SYSCLK_PSDIV_8
  61:../../../platform/common/services/clock/mega/sysclk.h **** #endif
  62:../../../platform/common/services/clock/mega/sysclk.h **** 
  63:../../../platform/common/services/clock/mega/sysclk.h **** /* ! \name Prescaler Setting (relative to CLKsys) */
  64:../../../platform/common/services/clock/mega/sysclk.h **** /* @{ */
  65:../../../platform/common/services/clock/mega/sysclk.h **** #define SYSCLK_PSDIV_1      0   /* !< Do not prescale */
  66:../../../platform/common/services/clock/mega/sysclk.h **** #define SYSCLK_PSDIV_2      1   /* !< Prescale CLKper4 by 2 */
  67:../../../platform/common/services/clock/mega/sysclk.h **** #define SYSCLK_PSDIV_4      2   /* !< Prescale CLKper4 by 4 */
  68:../../../platform/common/services/clock/mega/sysclk.h **** #define SYSCLK_PSDIV_8      3   /* !< Prescale CLKper4 by 8 */
  69:../../../platform/common/services/clock/mega/sysclk.h **** #define SYSCLK_PSDIV_16     4   /* !< Prescale CLKper4 by 16 */
  70:../../../platform/common/services/clock/mega/sysclk.h **** #define SYSCLK_PSDIV_32     5   /* !< Prescale CLKper4 by 32 */
  71:../../../platform/common/services/clock/mega/sysclk.h **** #define SYSCLK_PSDIV_64     6   /* !< Prescale CLKper4 by 64 */
  72:../../../platform/common/services/clock/mega/sysclk.h **** #define SYSCLK_PSDIV_128    7   /* !< Prescale CLKper4 by 128 */
  73:../../../platform/common/services/clock/mega/sysclk.h **** #define SYSCLK_PSDIV_256    8   /* !< Prescale CLKper4 by 256 */
  74:../../../platform/common/services/clock/mega/sysclk.h **** 
  75:../../../platform/common/services/clock/mega/sysclk.h **** /* @} */
  76:../../../platform/common/services/clock/mega/sysclk.h **** 
  77:../../../platform/common/services/clock/mega/sysclk.h **** #if MEGA_RF || MEGA_XX0_1 || MEGA_XX4 || MEGA_XX4_A
  78:../../../platform/common/services/clock/mega/sysclk.h **** 
  79:../../../platform/common/services/clock/mega/sysclk.h **** #define NUMBER_OF_POWER_REG       2
  80:../../../platform/common/services/clock/mega/sysclk.h **** /*Starting Address for power reduction*/
  81:../../../platform/common/services/clock/mega/sysclk.h **** #define POWER_REG_ADD             PRR0
  82:../../../platform/common/services/clock/mega/sysclk.h **** 
  83:../../../platform/common/services/clock/mega/sysclk.h **** /* ! \name Power Reduction  Clock Port Numbers */
  84:../../../platform/common/services/clock/mega/sysclk.h **** enum power_red_id {
  85:../../../platform/common/services/clock/mega/sysclk.h **** 	POWER_RED_REG0,     /* !< Devices on PRR0 */
  86:../../../platform/common/services/clock/mega/sysclk.h **** #if !MEGA_XX4 || !MEGA_XX4_A || MEGA_XX0_1
  87:../../../platform/common/services/clock/mega/sysclk.h **** 	POWER_RED_REG1,     /* !< Devices on PRR1 */
  88:../../../platform/common/services/clock/mega/sysclk.h **** #endif
  89:../../../platform/common/services/clock/mega/sysclk.h **** };
  90:../../../platform/common/services/clock/mega/sysclk.h **** #endif
  91:../../../platform/common/services/clock/mega/sysclk.h **** 
  92:../../../platform/common/services/clock/mega/sysclk.h **** /****************************************************
  93:../../../platform/common/services/clock/mega/sysclk.h ****  * Given a dummy type but not used for these groups
  94:../../../platform/common/services/clock/mega/sysclk.h ****  * to support for otherthen megaRF device.
  95:../../../platform/common/services/clock/mega/sysclk.h ****  **************************************************/
  96:../../../platform/common/services/clock/mega/sysclk.h **** #if MEGA_XX8 || MEGA_XX8_A || MEGA_UNSPECIFIED
  97:../../../platform/common/services/clock/mega/sysclk.h **** #define NUMBER_OF_POWER_REG       1
  98:../../../platform/common/services/clock/mega/sysclk.h **** /*Starting Address for power reduction*/
  99:../../../platform/common/services/clock/mega/sysclk.h **** #define POWER_REG_ADD             PRR
 100:../../../platform/common/services/clock/mega/sysclk.h **** 
 101:../../../platform/common/services/clock/mega/sysclk.h **** /* ! \name Power Reduction  Clock Port Numbers */
 102:../../../platform/common/services/clock/mega/sysclk.h **** enum power_red_id {
 103:../../../platform/common/services/clock/mega/sysclk.h **** 	POWER_RED_REG0,     /* !< Devices on PRR */
 104:../../../platform/common/services/clock/mega/sysclk.h **** };
 105:../../../platform/common/services/clock/mega/sysclk.h **** #endif
 106:../../../platform/common/services/clock/mega/sysclk.h **** 
 107:../../../platform/common/services/clock/mega/sysclk.h **** /* Bit mask for the power reduction register based on */
 108:../../../platform/common/services/clock/mega/sysclk.h **** /*   MCU ARCH.                                        */
 109:../../../platform/common/services/clock/mega/sysclk.h **** #if MEGA_RF
 110:../../../platform/common/services/clock/mega/sysclk.h **** /*Bit mask for PRR2 */
 111:../../../platform/common/services/clock/mega/sysclk.h **** 
 112:../../../platform/common/services/clock/mega/sysclk.h **** #define PRRAM0_bm                       1 << PRRAM0
 113:../../../platform/common/services/clock/mega/sysclk.h **** #define PRRAM1_bm                       1 << PRRAM1
 114:../../../platform/common/services/clock/mega/sysclk.h **** #define PRRAM2_bm                       1 << PRRAM2
 115:../../../platform/common/services/clock/mega/sysclk.h **** #define PRRAM3_bm                       1 << PRRAM3
 116:../../../platform/common/services/clock/mega/sysclk.h **** #endif
 117:../../../platform/common/services/clock/mega/sysclk.h **** 
 118:../../../platform/common/services/clock/mega/sysclk.h **** /*Bit mask for the power reduction 0 or PRR*/
 119:../../../platform/common/services/clock/mega/sysclk.h **** #if !MEGA_XX_UN0 && !MEGA_XX_UN0
 120:../../../platform/common/services/clock/mega/sysclk.h **** #define PRADC_bm                        1 << PRADC
 121:../../../platform/common/services/clock/mega/sysclk.h **** #define PRUSART0_bm                     1 << PRUSART0
 122:../../../platform/common/services/clock/mega/sysclk.h **** #define PRSPI_bm                        1 << PRSPI
 123:../../../platform/common/services/clock/mega/sysclk.h **** #define PRTIM1_bm                       1 << PRTIM1
 124:../../../platform/common/services/clock/mega/sysclk.h **** #endif
 125:../../../platform/common/services/clock/mega/sysclk.h **** 
 126:../../../platform/common/services/clock/mega/sysclk.h **** #if MEGA_RF
 127:../../../platform/common/services/clock/mega/sysclk.h **** #define PRPGA_bm                        1 << PRPGA
 128:../../../platform/common/services/clock/mega/sysclk.h **** #endif
 129:../../../platform/common/services/clock/mega/sysclk.h **** 
 130:../../../platform/common/services/clock/mega/sysclk.h **** #if !MEGA_UNSPECIFIED
 131:../../../platform/common/services/clock/mega/sysclk.h **** #define PRTIM0_bm                       1 << PRTIM0
 132:../../../platform/common/services/clock/mega/sysclk.h **** #define PRTIM2_bm                       1 << PRTIM2
 133:../../../platform/common/services/clock/mega/sysclk.h **** #define PRTWI_bm                        1 << PRTWI
 134:../../../platform/common/services/clock/mega/sysclk.h **** #endif
 135:../../../platform/common/services/clock/mega/sysclk.h **** 
 136:../../../platform/common/services/clock/mega/sysclk.h **** #if MEGA_XX_UN2
 137:../../../platform/common/services/clock/mega/sysclk.h **** #define PRLCD_bm                        1 << PRLCD
 138:../../../platform/common/services/clock/mega/sysclk.h **** #endif
 139:../../../platform/common/services/clock/mega/sysclk.h **** 
 140:../../../platform/common/services/clock/mega/sysclk.h **** /*Bit mask for  PRR1  */
 141:../../../platform/common/services/clock/mega/sysclk.h **** #ifdef PRR1
 142:../../../platform/common/services/clock/mega/sysclk.h **** #if (MEGA_XX4 || MEGA_XX4_A)
 143:../../../platform/common/services/clock/mega/sysclk.h **** #define PRTIM3_bm                       1 << PRTIM3
 144:../../../platform/common/services/clock/mega/sysclk.h **** #endif
 145:../../../platform/common/services/clock/mega/sysclk.h **** #endif
 146:../../../platform/common/services/clock/mega/sysclk.h **** 
 147:../../../platform/common/services/clock/mega/sysclk.h **** #if MEGA_RF || MEGA_XX4 || MEGA_XX4_A
 148:../../../platform/common/services/clock/mega/sysclk.h **** #define PRUSART1_bm                     1 << PRUSART1
 149:../../../platform/common/services/clock/mega/sysclk.h **** #define PRUSART2_bm                     1 << PRUSART2
 150:../../../platform/common/services/clock/mega/sysclk.h **** #define PRUSART3_bm                     1 << PRUSART3
 151:../../../platform/common/services/clock/mega/sysclk.h **** #define PRTIM3_bm                       1 << PRTIM3
 152:../../../platform/common/services/clock/mega/sysclk.h **** #define PRTIM4_bm                       1 << PRTIM4
 153:../../../platform/common/services/clock/mega/sysclk.h **** #define PRTIM5_bm                       1 << PRTIM5
 154:../../../platform/common/services/clock/mega/sysclk.h **** #endif
 155:../../../platform/common/services/clock/mega/sysclk.h **** 
 156:../../../platform/common/services/clock/mega/sysclk.h **** #if MEGA_RF
 157:../../../platform/common/services/clock/mega/sysclk.h **** #define PRTRX24_bm                      1 << PRTRX24
 158:../../../platform/common/services/clock/mega/sysclk.h **** #endif
 159:../../../platform/common/services/clock/mega/sysclk.h **** 
 160:../../../platform/common/services/clock/mega/sysclk.h **** /**
 161:../../../platform/common/services/clock/mega/sysclk.h ****  * \name Querying the system clock and its derived clocks
 162:../../../platform/common/services/clock/mega/sysclk.h ****  */
 163:../../../platform/common/services/clock/mega/sysclk.h **** /* @{ */
 164:../../../platform/common/services/clock/mega/sysclk.h **** 
 165:../../../platform/common/services/clock/mega/sysclk.h **** /**
 166:../../../platform/common/services/clock/mega/sysclk.h ****  * \brief Return the current rate in Hz of the main system clock
 167:../../../platform/common/services/clock/mega/sysclk.h ****  * To know the clock value at what frequency the main clock is running
 168:../../../platform/common/services/clock/mega/sysclk.h ****  * \return Frequency of the main system clock, in Hz.
 169:../../../platform/common/services/clock/mega/sysclk.h ****  * \todo : please initialize the SYSCLK_SOURCE in conf_clock.h file for
 170:../../../platform/common/services/clock/mega/sysclk.h ****  * configured source clock using fuses.
 171:../../../platform/common/services/clock/mega/sysclk.h ****  * \eg. #define SYSCLK_SOURCE SYSCLK_SRC_RC16MHZ to use internal RC
 172:../../../platform/common/services/clock/mega/sysclk.h ****  * oscillator for clock source.
 173:../../../platform/common/services/clock/mega/sysclk.h ****  */
 174:../../../platform/common/services/clock/mega/sysclk.h **** static inline uint32_t sysclk_get_main_hz(void)
 175:../../../platform/common/services/clock/mega/sysclk.h **** {
  22               		.loc 1 175 0
  23               		.cfi_startproc
  24 0000 CF93      		push r28
  25               	.LCFI0:
  26               		.cfi_def_cfa_offset 3
  27               		.cfi_offset 28, -2
  28 0002 DF93      		push r29
  29               	.LCFI1:
  30               		.cfi_def_cfa_offset 4
  31               		.cfi_offset 29, -3
  32 0004 CDB7      		in r28,__SP_L__
  33 0006 DEB7      		in r29,__SP_H__
  34               	.LCFI2:
  35               		.cfi_def_cfa_register 28
  36               	/* prologue: function */
  37               	/* frame size = 0 */
  38               	/* stack size = 2 */
  39               	.L__stack_usage = 2
 176:../../../platform/common/services/clock/mega/sysclk.h **** 	switch (SYSCLK_SOURCE) {
 177:../../../platform/common/services/clock/mega/sysclk.h **** 	case SYSCLK_SRC_RC16MHZ:
 178:../../../platform/common/services/clock/mega/sysclk.h **** 		return 16000000UL;
 179:../../../platform/common/services/clock/mega/sysclk.h **** 
 180:../../../platform/common/services/clock/mega/sysclk.h **** 	case SYSCLK_SRC_RC128KHZ:
 181:../../../platform/common/services/clock/mega/sysclk.h **** 		return 128000UL;
 182:../../../platform/common/services/clock/mega/sysclk.h **** 
 183:../../../platform/common/services/clock/mega/sysclk.h **** #if MEGA_RF
 184:../../../platform/common/services/clock/mega/sysclk.h **** 	case SYSCLK_SRC_TRS16MHZ:
 185:../../../platform/common/services/clock/mega/sysclk.h **** 		return 16000000UL;
  40               		.loc 1 185 0
  41 0008 80E0      		ldi r24,0
  42 000a 94E2      		ldi r25,lo8(36)
  43 000c A4EF      		ldi r26,lo8(-12)
  44 000e B0E0      		ldi r27,0
 186:../../../platform/common/services/clock/mega/sysclk.h **** #endif
 187:../../../platform/common/services/clock/mega/sysclk.h **** #ifdef BOARD_EXTERNAL_CLK
 188:../../../platform/common/services/clock/mega/sysclk.h **** 	case SYSCLK_SRC_EXTERNAL:
 189:../../../platform/common/services/clock/mega/sysclk.h **** 		return BOARD_EXTERNAL_CLK;
 190:../../../platform/common/services/clock/mega/sysclk.h **** #endif
 191:../../../platform/common/services/clock/mega/sysclk.h **** 	default:
 192:../../../platform/common/services/clock/mega/sysclk.h **** 
 193:../../../platform/common/services/clock/mega/sysclk.h **** 		return 1000000UL;
 194:../../../platform/common/services/clock/mega/sysclk.h **** 	}
 195:../../../platform/common/services/clock/mega/sysclk.h **** }
  45               		.loc 1 195 0
  46 0010 BC01      		movw r22,r24
  47 0012 CD01      		movw r24,r26
  48               	/* epilogue start */
  49 0014 DF91      		pop r29
  50 0016 CF91      		pop r28
  51 0018 0895      		ret
  52               		.cfi_endproc
  53               	.LFE67:
  56               	sysclk_get_source_clock_hz:
  57               	.LFB68:
 196:../../../platform/common/services/clock/mega/sysclk.h **** 
 197:../../../platform/common/services/clock/mega/sysclk.h **** /**
 198:../../../platform/common/services/clock/mega/sysclk.h ****  * \brief Return the current rate in Hz of source clock in Hz.
 199:../../../platform/common/services/clock/mega/sysclk.h ****  *
 200:../../../platform/common/services/clock/mega/sysclk.h ****  * This clock always runs at the same rate as the CPU clock unless the divider
 201:../../../platform/common/services/clock/mega/sysclk.h ****  * is set.
 202:../../../platform/common/services/clock/mega/sysclk.h ****  *
 203:../../../platform/common/services/clock/mega/sysclk.h ****  * \return Frequency of the system clock, in Hz.
 204:../../../platform/common/services/clock/mega/sysclk.h ****  */
 205:../../../platform/common/services/clock/mega/sysclk.h **** static inline uint32_t sysclk_get_source_clock_hz(void)
 206:../../../platform/common/services/clock/mega/sysclk.h **** {
  58               		.loc 1 206 0
  59               		.cfi_startproc
  60 001a CF93      		push r28
  61               	.LCFI3:
  62               		.cfi_def_cfa_offset 3
  63               		.cfi_offset 28, -2
  64 001c DF93      		push r29
  65               	.LCFI4:
  66               		.cfi_def_cfa_offset 4
  67               		.cfi_offset 29, -3
  68 001e CDB7      		in r28,__SP_L__
  69 0020 DEB7      		in r29,__SP_H__
  70               	.LCFI5:
  71               		.cfi_def_cfa_register 28
  72               	/* prologue: function */
  73               	/* frame size = 0 */
  74               	/* stack size = 2 */
  75               	.L__stack_usage = 2
 207:../../../platform/common/services/clock/mega/sysclk.h **** 	switch (CONFIG_SYSCLK_PSDIV) {
 208:../../../platform/common/services/clock/mega/sysclk.h **** 	case SYSCLK_PSDIV_1: /* Fall through */
 209:../../../platform/common/services/clock/mega/sysclk.h **** 		if (SYSCLK_SOURCE == SYSCLK_SRC_RC16MHZ ||
 210:../../../platform/common/services/clock/mega/sysclk.h **** 				SYSCLK_SOURCE == SYSCLK_SRC_RC128KHZ) {
 211:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 2;
 212:../../../platform/common/services/clock/mega/sysclk.h **** 		} else {
 213:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz();
  76               		.loc 1 213 0
  77 0022 0E94 0000 		call sysclk_get_main_hz
  78 0026 DC01      		movw r26,r24
  79 0028 CB01      		movw r24,r22
 214:../../../platform/common/services/clock/mega/sysclk.h **** 		}
 215:../../../platform/common/services/clock/mega/sysclk.h **** 
 216:../../../platform/common/services/clock/mega/sysclk.h **** 	case SYSCLK_PSDIV_2:
 217:../../../platform/common/services/clock/mega/sysclk.h **** 		if (SYSCLK_SOURCE == SYSCLK_SRC_RC16MHZ ||
 218:../../../platform/common/services/clock/mega/sysclk.h **** 				SYSCLK_SOURCE == SYSCLK_SRC_RC128KHZ) {
 219:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 4;
 220:../../../platform/common/services/clock/mega/sysclk.h **** 		} else {
 221:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 2;
 222:../../../platform/common/services/clock/mega/sysclk.h **** 		}
 223:../../../platform/common/services/clock/mega/sysclk.h **** 
 224:../../../platform/common/services/clock/mega/sysclk.h **** 	case SYSCLK_PSDIV_4:
 225:../../../platform/common/services/clock/mega/sysclk.h **** 		if (SYSCLK_SOURCE == SYSCLK_SRC_RC16MHZ ||
 226:../../../platform/common/services/clock/mega/sysclk.h **** 				SYSCLK_SOURCE == SYSCLK_SRC_RC128KHZ) {
 227:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 8;
 228:../../../platform/common/services/clock/mega/sysclk.h **** 		} else {
 229:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 4;
 230:../../../platform/common/services/clock/mega/sysclk.h **** 		}
 231:../../../platform/common/services/clock/mega/sysclk.h **** 
 232:../../../platform/common/services/clock/mega/sysclk.h **** 	case SYSCLK_PSDIV_8:
 233:../../../platform/common/services/clock/mega/sysclk.h **** 		if (SYSCLK_SOURCE == SYSCLK_SRC_RC16MHZ ||
 234:../../../platform/common/services/clock/mega/sysclk.h **** 				SYSCLK_SOURCE == SYSCLK_SRC_RC128KHZ) {
 235:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 16;
 236:../../../platform/common/services/clock/mega/sysclk.h **** 		} else {
 237:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 8;
 238:../../../platform/common/services/clock/mega/sysclk.h **** 		}
 239:../../../platform/common/services/clock/mega/sysclk.h **** 
 240:../../../platform/common/services/clock/mega/sysclk.h **** 	case SYSCLK_PSDIV_16:
 241:../../../platform/common/services/clock/mega/sysclk.h **** 		if (SYSCLK_SOURCE == SYSCLK_SRC_RC16MHZ ||
 242:../../../platform/common/services/clock/mega/sysclk.h **** 				SYSCLK_SOURCE == SYSCLK_SRC_RC128KHZ) {
 243:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 32;
 244:../../../platform/common/services/clock/mega/sysclk.h **** 		} else {
 245:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 16;
 246:../../../platform/common/services/clock/mega/sysclk.h **** 		}
 247:../../../platform/common/services/clock/mega/sysclk.h **** 
 248:../../../platform/common/services/clock/mega/sysclk.h **** 	case SYSCLK_PSDIV_32:
 249:../../../platform/common/services/clock/mega/sysclk.h **** 		if (SYSCLK_SOURCE == SYSCLK_SRC_RC16MHZ ||
 250:../../../platform/common/services/clock/mega/sysclk.h **** 				SYSCLK_SOURCE == SYSCLK_SRC_RC128KHZ) {
 251:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 64;
 252:../../../platform/common/services/clock/mega/sysclk.h **** 		} else {
 253:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 32;
 254:../../../platform/common/services/clock/mega/sysclk.h **** 		}
 255:../../../platform/common/services/clock/mega/sysclk.h **** 
 256:../../../platform/common/services/clock/mega/sysclk.h **** 	case SYSCLK_PSDIV_64:
 257:../../../platform/common/services/clock/mega/sysclk.h **** 		if (SYSCLK_SOURCE == SYSCLK_SRC_RC16MHZ ||
 258:../../../platform/common/services/clock/mega/sysclk.h **** 				SYSCLK_SOURCE == SYSCLK_SRC_RC128KHZ) {
 259:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 128;
 260:../../../platform/common/services/clock/mega/sysclk.h **** 		} else {
 261:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 64;
 262:../../../platform/common/services/clock/mega/sysclk.h **** 		}
 263:../../../platform/common/services/clock/mega/sysclk.h **** 
 264:../../../platform/common/services/clock/mega/sysclk.h **** 	case SYSCLK_PSDIV_128:
 265:../../../platform/common/services/clock/mega/sysclk.h **** 		if (SYSCLK_SOURCE == SYSCLK_SRC_RC16MHZ ||
 266:../../../platform/common/services/clock/mega/sysclk.h **** 				SYSCLK_SOURCE == SYSCLK_SRC_RC128KHZ) {
 267:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 256;
 268:../../../platform/common/services/clock/mega/sysclk.h **** 		} else {
 269:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 128;
 270:../../../platform/common/services/clock/mega/sysclk.h **** 		}
 271:../../../platform/common/services/clock/mega/sysclk.h **** 
 272:../../../platform/common/services/clock/mega/sysclk.h **** 	case SYSCLK_PSDIV_256:
 273:../../../platform/common/services/clock/mega/sysclk.h **** 		if (SYSCLK_SOURCE == SYSCLK_SRC_RC16MHZ ||
 274:../../../platform/common/services/clock/mega/sysclk.h **** 				SYSCLK_SOURCE == SYSCLK_SRC_RC128KHZ) {
 275:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 512;
 276:../../../platform/common/services/clock/mega/sysclk.h **** 		} else {
 277:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 256;
 278:../../../platform/common/services/clock/mega/sysclk.h **** 		}
 279:../../../platform/common/services/clock/mega/sysclk.h **** 
 280:../../../platform/common/services/clock/mega/sysclk.h **** 	default:
 281:../../../platform/common/services/clock/mega/sysclk.h **** 		/*Invalide case*/
 282:../../../platform/common/services/clock/mega/sysclk.h **** 		return 0;
 283:../../../platform/common/services/clock/mega/sysclk.h **** 	}
 284:../../../platform/common/services/clock/mega/sysclk.h **** }
  80               		.loc 1 284 0
  81 002a BC01      		movw r22,r24
  82 002c CD01      		movw r24,r26
  83               	/* epilogue start */
  84 002e DF91      		pop r29
  85 0030 CF91      		pop r28
  86 0032 0895      		ret
  87               		.cfi_endproc
  88               	.LFE68:
  90               		.section	.progmem.data.baudctrl_1mhz,"a",@progbits
  93               	baudctrl_1mhz:
  94 0000 3300      		.word	51
  95 0002 1900      		.word	25
  96 0004 0C00      		.word	12
  97 0006 0600      		.word	6
  98 0008 0300      		.word	3
  99 000a 0200      		.word	2
 100 000c 0100      		.word	1
 101 000e FF00      		.word	255
 102               		.section	.progmem.data.baudctrl_8mhz,"a",@progbits
 105               	baudctrl_8mhz:
 106 0000 A001      		.word	416
 107 0002 CF00      		.word	207
 108 0004 6700      		.word	103
 109 0006 3300      		.word	51
 110 0008 1900      		.word	25
 111 000a 0C00      		.word	12
 112 000c 0700      		.word	7
 113 000e 0800      		.word	8
 114               		.section	.progmem.data.baudctrl_16mhz,"a",@progbits
 117               	baudctrl_16mhz:
 118 0000 4003      		.word	832
 119 0002 A001      		.word	416
 120 0004 CF00      		.word	207
 121 0006 6700      		.word	103
 122 0008 3300      		.word	51
 123 000a 1900      		.word	25
 124 000c 1000      		.word	16
 125 000e 1000      		.word	16
 126               		.text
 128               	usart_double_baud_enable:
 129               	.LFB101:
 130               		.file 2 "../../../platform/mega_rf/drivers/usart/usart_megarf.h"
   1:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
   2:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \file
   3:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
   4:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief USART driver for AVR MEGARF.
   5:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
   6:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * This file contains basic functions for the AVR MEGA USART, with support for
   7:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * all modes, settings and clock speeds.
   8:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
   9:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * Copyright (c) 2013-2015 Atmel Corporation. All rights reserved.
  10:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
  11:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \asf_license_start
  12:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
  13:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \page License
  14:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
  15:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * Redistribution and use in source and binary forms, with or without
  16:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * modification, are permitted provided that the following conditions are met:
  17:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
  18:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * 1. Redistributions of source code must retain the above copyright notice,
  19:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *    this list of conditions and the following disclaimer.
  20:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
  21:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * 2. Redistributions in binary form must reproduce the above copyright notice,
  22:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *    this list of conditions and the following disclaimer in the documentation
  23:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *    and/or other materials provided with the distribution.
  24:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
  25:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * 3. The name of Atmel may not be used to endorse or promote products derived
  26:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *    from this software without specific prior written permission.
  27:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
  28:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * 4. This software may only be redistributed and used in connection with an
  29:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *    Atmel microcontroller product.
  30:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
  31:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR IMPLIED
  32:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
  33:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
  34:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR
  35:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  36:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
  37:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  38:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
  39:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  40:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  41:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * POSSIBILITY OF SUCH DAMAGE.
  42:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
  43:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \asf_license_stop
  44:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
  45:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
  46:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #ifndef _USART_MEGARF_H_
  47:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define _USART_MEGARF_H_
  48:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
  49:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #ifdef __cplusplus
  50:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** extern "C" {
  51:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #endif
  52:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
  53:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #include "compiler.h"
  54:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #include "status_codes.h"
  55:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
  56:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
  57:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \defgroup megarf_usart_group USART module (USART)
  58:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
  59:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * See \ref megarf_usart_quickstart.
  60:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
  61:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * This is a driver for configuring, enabling, disabling and use of the on-chip
  62:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * USART.
  63:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
  64:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \section dependencies Dependencies
  65:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
  66:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * The USART module depends on the following modules:
  67:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *  - \ref sysclk_group for peripheral clock control.
  68:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *  - \ref port_driver_group for peripheral io port control.
  69:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
  70:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * @{
  71:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
  72:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
  73:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* ! Offset in lookup table for baudrate 1200 */
  74:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_BAUD_1200      0x00
  75:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* ! Offset in lookup table for baudrate 2400 */
  76:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_BAUD_2400      0x01
  77:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* ! Offset in lookup table for baudrate 4800 */
  78:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_BAUD_4800      0x02
  79:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* ! Offset in lookup table for baudrate 9600 */
  80:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_BAUD_9600      0x03
  81:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* ! Offset in lookup table for baudrate 19200 */
  82:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_BAUD_19200     0x04
  83:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* ! Offset in lookup table for baudrate 38400 */
  84:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_BAUD_38400     0x05
  85:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* ! Offset in lookup table for baudrate 57600 */
  86:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_BAUD_57600     0x06
  87:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* ! Offset in lookup table for baudrate 115200 */
  88:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_BAUD_115200    0x07
  89:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* ! Baudrate not in lookup table */
  90:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_BAUD_UNDEFINED 0xFF
  91:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
  92:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** typedef volatile uint8_t register8_t;
  93:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** typedef volatile uint16_t register16_t;
  94:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* Universal Synchronous/Asynchronous Receiver/Transmitter */
  95:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** typedef struct USART_struct {
  96:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	register8_t UCSRnA;  /* Control Register A */
  97:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	register8_t UCSRnB;  /* Control Register B */
  98:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	register8_t UCSRnC;  /* Control Register C */
  99:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	register8_t reserved;
 100:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	register16_t UBRR;  /* Baud Rate Register Value */
 101:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	register8_t UDR;  /* I/O Data Register */
 102:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** } USART_t;
 103:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 104:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USARTA0    (*(USART_t *)0xC0)   /* Universal Asynchronous
 105:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	                                 * Receiver-Transmitter A0 */
 106:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USARTA1    (*(USART_t *)0XC8)   /* Universal Asynchronous
 107:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	                                 * Receiver-Transmitter A1 */
 108:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 109:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* USART.UCSRxA  bit masks and bit positions */
 110:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_RXC_bm  0x80 /* RX complete bit mask.*/
 111:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_RXC_bp  7 /* RX complete bit position.*/
 112:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 113:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_TXC_bm  0x40 /* TX complete bit mask.*/
 114:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_TXC_bp  6 /* TX complete bit position.*/
 115:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 116:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_DRE_bm  0x20 /* DATA Register Empty Bit mask.*/
 117:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_DRE_bp  5 /*  DATA Register Empty bit position.*/
 118:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 119:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_FE_bm   0x10 /* Frame Error bit mask.*/
 120:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_FE_bp   4 /*Frame error bit position.*/
 121:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 122:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_DOR_bm  0x08 /* Data Over Run bit mask.*/
 123:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_DOR_bp  3 /* Data Over Run bit position.*/
 124:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 125:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_UPE_bm  0x04 /* Parity error bit mask.*/
 126:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_UPE_bp  2 /* Parity error bit position.*/
 127:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 128:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_U2X_bm  0x02 /* Double TX speed bit mask.*/
 129:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_U2X_bp  1 /* Double TX speed bit position.*/
 130:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 131:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_MPCM_bm  0x01 /* Multi Processor bit mask.*/
 132:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_MPMC_bp  0 /* Multi processor bit position.*/
 133:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 134:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* USART.UCSRxB  bit masks and bit positions */
 135:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_RXCIE_bm  0x80 /* RX complete interrupt Enable bit mask.*/
 136:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_RXCIE_bp  7 /* RX complete interrupt Enable bit position.*/
 137:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 138:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_TXCIE_bm  0x40 /* TX complete interrupt Enable bit mask.*/
 139:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_TXCIE_bp  6 /* TX complete interrupt Enable bit position.*/
 140:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 141:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_DRIE_bm  0x20 /* Data register empty interrupt Enable bit mask.*/
 142:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_DRIE_bp  5 /* Data register empty interrupt Enable bit position.*/
 143:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 144:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_RXEN_bm  0x10  /* Receiver Enable bit mask. */
 145:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_RXEN_bp  4  /* Receiver Enable bit position. */
 146:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 147:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_TXEN_bm  0x08  /* Transmitter Enable bit mask. */
 148:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_TXEN_bp  3  /* Transmitter Enable bit position. */
 149:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 150:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_CHSIZE2_bm  0x04  /* Character Size bit mask. */
 151:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_CHSIZE2_bp  2 /* Character Size bit position. */
 152:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 153:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_RXB8_bm  0x02  /* Transmit bit 8 bit mask. */
 154:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_RXB8_bp  1  /* Transmit bit 8 bit position. */
 155:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 156:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_TXB8_bm  0x01  /* Transmit bit 8 bit mask. */
 157:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_TXB8_bp  0  /* Transmit bit 8 bit position. */
 158:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 159:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* USART.UCSRxC  bit masks and bit positions */
 160:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_UMSEL01_gm  0xC0 /* USART Mode Select 01 grp mask.*/
 161:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_UMSEL01_gp  6 /* USART Mode Select 01 grp position.*/
 162:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 163:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_UMSEL01_bm  0x80 /* USART Mode Select 01 bit mask.*/
 164:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_UMSEL01_bp  7 /* USART Mode Select 01 bit position.*/
 165:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 166:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_UMSEL00_bm  0x40 /* USART Mode Select 00 bit mask.*/
 167:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_UMSEL00_bp  6 /* USART Mode Select 00 bit position.*/
 168:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 169:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_PMODE_gm  0x30 /* USART Parity Mode Select grp mask.*/
 170:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_PMODE_gp  4 /* USART Parity Mode Select grp position.*/
 171:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 172:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_PMODE01_bm  0x20 /* USART Parity Mode Select 01 bit mask.*/
 173:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_PMODE01_bp  5 /* USART Parity Mode Select 01 bit position.*/
 174:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 175:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_PMODE00_bm  0x10 /* USART Parity Mode Select 00 bit mask.*/
 176:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_PMODE00_bp  4 /* USART Parity Mode Select 00 bit position.*/
 177:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 178:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_STOPB_bm  0x08 /* USART stop bit mask.*/
 179:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_STOPB_bp  3 /* USART stop bit Position.*/
 180:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 181:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_CHSIZE01C_gm  0x06  /* Character Size 10 bit 1 mask. */
 182:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_CHSIZE01C_gp  1 /* Character Size 10 bit position. */
 183:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 184:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_CHSIZE01_bm  0x04  /* Character Size 10 bit 1 mask. */
 185:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_CHSIZE01_bp  2 /* Character Size 10 bit position. */
 186:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 187:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_CHSIZE00_bm  0x02  /* Character Size 00 bit 1 mask. */
 188:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_CHSIZE00_bp  1 /* Character Size bit 00 position. */
 189:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 190:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_UCPOL_bm  0x01  /* Sync mode Pol bit 1 mask. */
 191:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_UCPOL_bp  0 /*Sync mode Pol bit 0 position */
 192:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 193:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_UCPHA_bm 0x02 /* Clock Phase bit mask. */
 194:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_UCPHA_bp 1 /* Clock Phase bit position. */
 195:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 196:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_DORD_bm 0x04 /* Data order bit mask. */
 197:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_DORD_bp 2 /* Data order bit position. */
 198:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 199:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* Character Size */
 200:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** typedef enum USART_CHSIZE_enum {
 201:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	USART_CHSIZE_5BIT_gc = (0x00),  /* Character size: 5 bit */
 202:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	USART_CHSIZE_6BIT_gc = (0x01),  /* Character size: 6 bit */
 203:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	USART_CHSIZE_7BIT_gc = (0x02),  /* Character size: 7 bit */
 204:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	USART_CHSIZE_8BIT_gc = (0x03),  /* Character size: 8 bit */
 205:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	USART_CHSIZE_9BIT_gc = (0x07),  /* Character size: 9 bit */
 206:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** } USART_CHSIZE_t;
 207:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 208:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* Communication Mode */
 209:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** typedef enum USART_CMODE_enum {
 210:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	USART_CMODE_ASYNCHRONOUS_gc = (0x00 << USART_UMSEL01_gp),  /*
 211:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	                                                            *
 212:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	                                                            *
 213:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	                                                            *Asynchronous
 214:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	                                                            * Mode */
 215:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	USART_CMODE_SYNCHRONOUS_gc = (0x01 << USART_UMSEL01_gp),  /* Synchronous
 216:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	                                                           * Mode */
 217:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	USART_CMODE_IRDA_gc = (0x02 << USART_UMSEL01_gp),  /* IrDA Mode */
 218:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	USART_CMODE_MSPI_gc = (0x03 << USART_UMSEL01_gp),  /* Master SPI Mode */
 219:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** } USART_CMODE_t;
 220:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 221:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* Parity Mode */
 222:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** typedef enum USART_PMODE_enum {
 223:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	USART_PMODE_DISABLED_gc = (0x00 << USART_PMODE_gp),  /* No Parity */
 224:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	USART_PMODE_EVEN_gc = (0x02 << USART_PMODE_gp),  /* Even Parity */
 225:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	USART_PMODE_ODD_gc = (0x03 << USART_PMODE_gp),  /* Odd Parity */
 226:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** } USART_PMODE_t;
 227:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 228:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* ! Lookup table containing baudctrl values for CPU frequency 1 Mhz */
 229:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static PROGMEM_DECLARE(uint16_t, baudctrl_1mhz[]) = {
 230:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0033, /* Baud: 1200 */
 231:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0019, /* Baud: 2400 */
 232:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x000C, /* Baud: 4800 */
 233:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0006, /* Baud: 9600 */
 234:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0003, /* Baud: 19200 */
 235:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0002, /* Baud: 38400 */
 236:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0001, /* Baud: 57600 */
 237:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	USART_BAUD_UNDEFINED, /* Baud: 115200 */
 238:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** };
 239:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 240:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* ! Lookup table containing baudctrl values for CPU frequency 8 Mhz */
 241:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static PROGMEM_DECLARE(uint16_t, baudctrl_8mhz[]) = {
 242:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x01A0, /* Baud: 1200 */
 243:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x00CF, /* Baud: 2400 */
 244:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0067, /* Baud: 4800 */
 245:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0033, /* Baud: 9600 */
 246:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0019, /* Baud: 19200 */
 247:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x000C, /* Baud: 38400 */
 248:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0007, /* Baud: 57600 */
 249:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0008, /* Baud: 115200 */
 250:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** };
 251:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 252:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* ! Lookup table containing baudctrl values for CPU frequency 16 Mhz */
 253:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static PROGMEM_DECLARE(uint16_t, baudctrl_16mhz[]) = {
 254:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0340, /* Baud: 1200 */
 255:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x01A0, /* Baud: 2400 */
 256:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x00CF, /* Baud: 4800 */
 257:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0067, /* Baud: 9600 */
 258:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0033, /* Baud: 19200 */
 259:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0019, /* Baud: 38400 */
 260:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0010, /* Baud: 57600 */
 261:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0010, /* Baud: 115200 */
 262:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** };
 263:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 264:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 265:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* ! Input parameters when initializing RS232 and similar modes. */
 266:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** typedef struct usart_rs232_options {
 267:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	/* ! Set baud rate of the USART (unused in slave modes). */
 268:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	uint32_t baudrate;
 269:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 270:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	/* ! Number of bits to transmit as a character (5 to 9). */
 271:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	USART_CHSIZE_t charlength;
 272:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 273:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	/* ! Parity type: USART_PMODE_DISABLED_gc, USART_PMODE_EVEN_gc, */
 274:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	/* ! USART_PMODE_ODD_gc. */
 275:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	USART_PMODE_t paritytype;
 276:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 277:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	/* ! Number of stop bits between two characters: */
 278:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	/* ! true: 2 stop bits */
 279:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	/* ! false: 1 stop bit */
 280:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	bool stopbits;
 281:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** } usart_rs232_options_t;
 282:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 283:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* ! Input parameters when initializing SPI master mode. */
 284:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** typedef struct usart_spi_options {
 285:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	/* ! Set baud rate of the USART in SPI mode. */
 286:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	uint32_t baudrate;
 287:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 288:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	/* ! SPI transmission mode. */
 289:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	uint8_t spimode;
 290:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 291:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	uint8_t data_order;
 292:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** } usart_spi_options_t;
 293:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 294:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 295:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 296:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Enable USART receiver.
 297:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 298:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart Pointer to the USART module
 299:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 300:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline void usart_rx_enable(USART_t *usart)
 301:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 302:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	(usart)->UCSRnB |= USART_RXEN_bm;
 303:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 304:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 305:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 306:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Disable USART receiver.
 307:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 308:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart Pointer to the USART module.
 309:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 310:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline void usart_rx_disable(USART_t *usart)
 311:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 312:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	(usart)->UCSRnB &= ~USART_RXEN_bm;
 313:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 314:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 315:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 316:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief  Configure the USART frame format.
 317:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 318:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *  Sets the frame format, Frame Size, parity mode and number of stop bits.
 319:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 320:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *  \param usart Pointer to the USART module
 321:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *  \param charSize The character size. Use USART_CHSIZE_t type.
 322:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *  \param parityMode The parity Mode. Use USART_PMODE_t type.
 323:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *  \param twoStopBits Enable two stop bit mode. Use bool type.
 324:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 325:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline void usart_format_set(USART_t *usart, USART_CHSIZE_t charSize,
 326:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 		USART_PMODE_t parityMode, bool twoStopBits)
 327:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 328:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	(usart)->UCSRnC
 329:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 		= ((usart)->UCSRnC &
 330:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 			(~USART_CHSIZE01C_gm)) | ((charSize & 0x03)
 331:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 			<< USART_CHSIZE01C_gp);
 332:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	(usart)->UCSRnB
 333:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 		= ((usart)->UCSRnB &
 334:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 			(~USART_CHSIZE2_bm)) | ((charSize & 0x04)
 335:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 			<< USART_CHSIZE2_bp);
 336:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 337:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	(usart)->UCSRnC = ((usart)->UCSRnC & (~USART_PMODE_gm)) | parityMode;
 338:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 339:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	(usart)->UCSRnC = ((usart)->UCSRnC & (~USART_STOPB_bm)) | (twoStopBits
 340:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 			<< USART_STOPB_bp);
 341:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 342:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 343:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 344:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Enable USART transmitter.
 345:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 346:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart Pointer to the USART module.
 347:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 348:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline void usart_tx_enable(USART_t *usart)
 349:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 350:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	(usart)->UCSRnB |= USART_TXEN_bm;
 351:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 352:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 353:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 354:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Disable USART transmitter.
 355:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 356:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart Pointer to the USART module.
 357:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 358:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline void usart_tx_disable(USART_t *usart)
 359:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 360:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	(usart)->UCSRnB &= ~USART_TXEN_bm;
 361:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 362:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 363:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 364:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Enable USART transmit complete interrupt.
 365:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 366:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart Pointer to the USART module.
 367:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 368:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline void usart_tx_complete_interrupt_enable(USART_t *usart)
 369:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 370:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	(usart)->UCSRnB |= USART_TXC_bm;
 371:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 372:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 373:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 374:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Enable USART receive complete interrupt.
 375:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 376:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart Pointer to the USART module.
 377:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 378:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline void usart_rx_complete_interrupt_enable(USART_t *usart)
 379:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 380:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	(usart)->UCSRnB |= USART_RXC_bm;
 381:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 382:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 383:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 384:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Enable USART data register empty interrupt.
 385:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 386:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart Pointer to the USART module.
 387:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 388:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline void usart_data_empty_interrupt_enable(USART_t *usart)
 389:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 390:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	(usart)->UCSRnB |= USART_DRIE_bm;
 391:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 392:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 393:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 394:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Disable USART transmit complete interrupt.
 395:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 396:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart Pointer to the USART module.
 397:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 398:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline void usart_tx_complete_interrupt_disable(USART_t *usart)
 399:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 400:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	(usart)->UCSRnB &= ~USART_TXC_bm;
 401:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 402:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 403:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 404:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Disable USART receive complete interrupt.
 405:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 406:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart Pointer to the USART module.
 407:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 408:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline void usart_rx_complete_interrupt_disable(USART_t *usart)
 409:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 410:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	(usart)->UCSRnB &= ~USART_RXC_bm;
 411:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 412:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 413:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 414:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Disable USART data register empty interrupt.
 415:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 416:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart Pointer to the USART module.
 417:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 418:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline void usart_data_empty_interrupt_disable(USART_t *usart)
 419:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 420:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	(usart)->UCSRnB &= ~USART_DRIE_bm;
 421:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 422:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 423:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 424:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Set the mode the USART run in.
 425:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 426:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * Set the mode the USART run in. The default mode is asynchronous mode.
 427:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 428:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart Pointer to the USART module register section.
 429:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usartmode Selects the USART mode. Use USART_CMODE_t type.
 430:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 431:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * USART modes:
 432:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * - 0x0        : Asynchronous mode.
 433:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * - 0x1        : Synchronous mode.
 434:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * - 0x2        : IrDA mode.
 435:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * - 0x3        : Master SPI mode.
 436:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 437:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline void usart_set_mode(USART_t *usart, USART_CMODE_t usartmode)
 438:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 439:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	(usart)->UCSRnC = ((usart)->UCSRnC & (~USART_UMSEL01_gm)) | usartmode;
 440:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 441:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 442:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 443:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Check if data register empty flag is set.
 444:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 445:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart The USART module.
 446:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 447:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline bool usart_data_register_is_empty(USART_t *usart)
 448:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 449:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	return (usart)->UCSRnA & USART_DRE_bm;
 450:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 451:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 452:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 453:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Checks if the RX complete interrupt flag is set.
 454:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 455:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * Checks if the RX complete interrupt flag is set.
 456:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 457:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart The USART module.
 458:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 459:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline bool usart_rx_is_complete(USART_t *usart)
 460:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 461:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	return (usart)->UCSRnA & USART_RXC_bm;
 462:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 463:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 464:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 465:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Checks if the TX complete interrupt flag is set.
 466:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 467:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * Checks if the TX complete interrupt flag is set.
 468:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 469:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart The USART module.
 470:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 471:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline bool usart_tx_is_complete(USART_t *usart)
 472:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 473:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	return (usart)->UCSRnA & USART_TXC_bm;
 474:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 475:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 476:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 477:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Clear TX complete interrupt flag.
 478:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * TX flag is clear after complete transmission, automatically.
 479:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart The USART module.
 480:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 481:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline void usart_clear_tx_complete(USART_t *usart)
 482:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 483:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****          usart->UCSRnA |=  USART_TXC_bm;
 484:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 485:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 486:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 487:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Write a data to the USART data register.
 488:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 489:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart The USART module.
 490:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param txdata The data to be transmitted.
 491:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 492:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline void usart_put(USART_t *usart, uint8_t txdata)
 493:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 494:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	(usart)->UDR = txdata;
 495:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 496:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 497:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 498:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief  Read a data to the USART data register.
 499:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 500:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart The USART module.
 501:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 502:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \return The received data
 503:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 504:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline uint8_t usart_get(USART_t *usart)
 505:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 506:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	return (usart)->UDR;
 507:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 508:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 509:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 510:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Double the USART transmission speed.
 511:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 512:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart The USART module.
 513:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 514:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline void usart_double_baud_enable(USART_t *usart)
 515:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 131               		.loc 2 515 0
 132               		.cfi_startproc
 133 0034 CF93      		push r28
 134               	.LCFI6:
 135               		.cfi_def_cfa_offset 3
 136               		.cfi_offset 28, -2
 137 0036 DF93      		push r29
 138               	.LCFI7:
 139               		.cfi_def_cfa_offset 4
 140               		.cfi_offset 29, -3
 141 0038 00D0      		rcall .
 142               	.LCFI8:
 143               		.cfi_def_cfa_offset 6
 144 003a CDB7      		in r28,__SP_L__
 145 003c DEB7      		in r29,__SP_H__
 146               	.LCFI9:
 147               		.cfi_def_cfa_register 28
 148               	/* prologue: function */
 149               	/* frame size = 2 */
 150               	/* stack size = 4 */
 151               	.L__stack_usage = 4
 152 003e 9A83      		std Y+2,r25
 153 0040 8983      		std Y+1,r24
 516:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	usart->UCSRnA |=  USART_U2X_bm;
 154               		.loc 2 516 0
 155 0042 8981      		ldd r24,Y+1
 156 0044 9A81      		ldd r25,Y+2
 157 0046 FC01      		movw r30,r24
 158 0048 8081      		ld r24,Z
 159 004a 282F      		mov r18,r24
 160 004c 2260      		ori r18,lo8(2)
 161 004e 8981      		ldd r24,Y+1
 162 0050 9A81      		ldd r25,Y+2
 163 0052 FC01      		movw r30,r24
 164 0054 2083      		st Z,r18
 517:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 165               		.loc 2 517 0
 166 0056 0000      		nop
 167               	/* epilogue start */
 168 0058 0F90      		pop __tmp_reg__
 169 005a 0F90      		pop __tmp_reg__
 170 005c DF91      		pop r29
 171 005e CF91      		pop r28
 172 0060 0895      		ret
 173               		.cfi_endproc
 174               	.LFE101:
 177               	usart_serial_init:
 178               	.LFB104:
 179               		.file 3 "../../../platform/common/services/serial/megarf_usart/usart_serial.h"
   1:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** /**
   2:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * \file
   3:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
   4:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * \brief This file defines a useful set of functions for the Serial interface on 
   5:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * AVR MEGARF devices.
   6:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
   7:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * Copyright (c) 2013 Atmel Corporation. All rights reserved.
   8:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
   9:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * \asf_license_start
  10:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
  11:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * \page License
  12:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
  13:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * Redistribution and use in source and binary forms, with or without
  14:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * modification, are permitted provided that the following conditions are met:
  15:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
  16:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * 1. Redistributions of source code must retain the above copyright notice,
  17:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *    this list of conditions and the following disclaimer.
  18:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
  19:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * 2. Redistributions in binary form must reproduce the above copyright notice,
  20:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *    this list of conditions and the following disclaimer in the documentation
  21:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *    and/or other materials provided with the distribution.
  22:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
  23:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * 3. The name of Atmel may not be used to endorse or promote products derived
  24:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *    from this software without specific prior written permission.
  25:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
  26:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * 4. This software may only be redistributed and used in connection with an
  27:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *    Atmel microcontroller product.
  28:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
  29:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR IMPLIED
  30:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
  31:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
  32:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR
  33:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  34:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
  35:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  36:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
  37:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  38:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  39:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * POSSIBILITY OF SUCH DAMAGE.
  40:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
  41:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * \asf_license_stop
  42:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
  43:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  */
  44:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** #ifndef _USART_SERIAL_H_
  45:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** #define _USART_SERIAL_H_
  46:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 
  47:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** #ifdef __cplusplus
  48:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** extern "C" {
  49:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** #endif
  50:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 
  51:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** #include "compiler.h"
  52:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** #include "sysclk.h"
  53:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** #include "status_codes.h"
  54:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** #include "usart_megarf.h"
  55:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 
  56:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** /*! \name Serial Management Configuration
  57:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  */
  58:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** /* ! @{ */
  59:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** #include "conf_usart_serial.h"
  60:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** /* ! @} */
  61:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 
  62:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** typedef usart_rs232_options_t usart_serial_options_t;
  63:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 
  64:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** typedef USART_t *usart_if;
  65:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 
  66:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** /*! \brief Initializes the Usart in master mode.
  67:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
  68:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * \param usart       Base address of the USART instance.
  69:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * \param options     Options needed to set up RS232 communication (see \ref
  70:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * usart_serial_options_t).
  71:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
  72:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * \retval true if the initialization was successful
  73:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * \retval false if initialization failed (error in baud rate calculation)
  74:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  */
  75:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** static inline bool usart_serial_init(usart_if usart, const
  76:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 		usart_serial_options_t *options)
  77:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** {
 180               		.loc 3 77 0
 181               		.cfi_startproc
 182 0062 CF93      		push r28
 183               	.LCFI10:
 184               		.cfi_def_cfa_offset 3
 185               		.cfi_offset 28, -2
 186 0064 DF93      		push r29
 187               	.LCFI11:
 188               		.cfi_def_cfa_offset 4
 189               		.cfi_offset 29, -3
 190 0066 CDB7      		in r28,__SP_L__
 191 0068 DEB7      		in r29,__SP_H__
 192               	.LCFI12:
 193               		.cfi_def_cfa_register 28
 194 006a 2B97      		sbiw r28,11
 195               	.LCFI13:
 196               		.cfi_def_cfa_offset 15
 197 006c 0FB6      		in __tmp_reg__,__SREG__
 198 006e F894      		cli
 199 0070 DEBF      		out __SP_H__,r29
 200 0072 0FBE      		out __SREG__,__tmp_reg__
 201 0074 CDBF      		out __SP_L__,r28
 202               	/* prologue: function */
 203               	/* frame size = 11 */
 204               	/* stack size = 13 */
 205               	.L__stack_usage = 13
 206 0076 9987      		std Y+9,r25
 207 0078 8887      		std Y+8,r24
 208 007a 7B87      		std Y+11,r23
 209 007c 6A87      		std Y+10,r22
  78:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 	/* USART options. */
  79:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 	usart_rs232_options_t usart_rs232_options;
  80:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 	usart_rs232_options.charlength   = options->charlength;
 210               		.loc 3 80 0
 211 007e 8A85      		ldd r24,Y+10
 212 0080 9B85      		ldd r25,Y+11
 213 0082 FC01      		movw r30,r24
 214 0084 8481      		ldd r24,Z+4
 215 0086 8D83      		std Y+5,r24
  81:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 	usart_rs232_options.paritytype   = options->paritytype;
 216               		.loc 3 81 0
 217 0088 8A85      		ldd r24,Y+10
 218 008a 9B85      		ldd r25,Y+11
 219 008c FC01      		movw r30,r24
 220 008e 8581      		ldd r24,Z+5
 221 0090 8E83      		std Y+6,r24
  82:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 	usart_rs232_options.stopbits     = options->stopbits;
 222               		.loc 3 82 0
 223 0092 8A85      		ldd r24,Y+10
 224 0094 9B85      		ldd r25,Y+11
 225 0096 FC01      		movw r30,r24
 226 0098 8681      		ldd r24,Z+6
 227 009a 8F83      		std Y+7,r24
  83:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 	usart_rs232_options.baudrate     = options->baudrate;
 228               		.loc 3 83 0
 229 009c 8A85      		ldd r24,Y+10
 230 009e 9B85      		ldd r25,Y+11
 231 00a0 FC01      		movw r30,r24
 232 00a2 8081      		ld r24,Z
 233 00a4 9181      		ldd r25,Z+1
 234 00a6 A281      		ldd r26,Z+2
 235 00a8 B381      		ldd r27,Z+3
 236 00aa 8983      		std Y+1,r24
 237 00ac 9A83      		std Y+2,r25
 238 00ae AB83      		std Y+3,r26
 239 00b0 BC83      		std Y+4,r27
  84:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 
  85:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 	if (usart_init_rs232(usart, &usart_rs232_options)) {
 240               		.loc 3 85 0
 241 00b2 8885      		ldd r24,Y+8
 242 00b4 9985      		ldd r25,Y+9
 243 00b6 9E01      		movw r18,r28
 244 00b8 2F5F      		subi r18,-1
 245 00ba 3F4F      		sbci r19,-1
 246 00bc B901      		movw r22,r18
 247 00be 0E94 0000 		call usart_init_rs232
 248 00c2 8823      		tst r24
 249 00c4 01F0      		breq .L7
  86:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 		return true;
 250               		.loc 3 86 0
 251 00c6 81E0      		ldi r24,lo8(1)
 252 00c8 00C0      		rjmp .L9
 253               	.L7:
  87:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 	} else {
  88:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 		return false;
 254               		.loc 3 88 0
 255 00ca 80E0      		ldi r24,0
 256               	.L9:
 257               	/* epilogue start */
  89:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 	}
  90:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** }
 258               		.loc 3 90 0 discriminator 1
 259 00cc 2B96      		adiw r28,11
 260 00ce 0FB6      		in __tmp_reg__,__SREG__
 261 00d0 F894      		cli
 262 00d2 DEBF      		out __SP_H__,r29
 263 00d4 0FBE      		out __SREG__,__tmp_reg__
 264 00d6 CDBF      		out __SP_L__,r28
 265 00d8 DF91      		pop r29
 266 00da CF91      		pop r28
 267 00dc 0895      		ret
 268               		.cfi_endproc
 269               	.LFE104:
 272               	usart_serial_putchar:
 273               	.LFB105:
  91:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 
  92:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** /*! \brief Sends a character with the USART.
  93:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
  94:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * \param usart   Base address of the USART instance.
  95:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * \param c       Character to write.
  96:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
  97:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * \return Status code
  98:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  */
  99:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** static inline status_code_t usart_serial_putchar(usart_if usart, uint8_t c)
 100:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** {
 274               		.loc 3 100 0
 275               		.cfi_startproc
 276 00de CF93      		push r28
 277               	.LCFI14:
 278               		.cfi_def_cfa_offset 3
 279               		.cfi_offset 28, -2
 280 00e0 DF93      		push r29
 281               	.LCFI15:
 282               		.cfi_def_cfa_offset 4
 283               		.cfi_offset 29, -3
 284 00e2 00D0      		rcall .
 285 00e4 1F92      		push __zero_reg__
 286               	.LCFI16:
 287               		.cfi_def_cfa_offset 7
 288 00e6 CDB7      		in r28,__SP_L__
 289 00e8 DEB7      		in r29,__SP_H__
 290               	.LCFI17:
 291               		.cfi_def_cfa_register 28
 292               	/* prologue: function */
 293               	/* frame size = 3 */
 294               	/* stack size = 5 */
 295               	.L__stack_usage = 5
 296 00ea 9A83      		std Y+2,r25
 297 00ec 8983      		std Y+1,r24
 298 00ee 6B83      		std Y+3,r22
 101:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 	return usart_putchar(usart, c);
 299               		.loc 3 101 0
 300 00f0 8981      		ldd r24,Y+1
 301 00f2 9A81      		ldd r25,Y+2
 302 00f4 6B81      		ldd r22,Y+3
 303 00f6 0E94 0000 		call usart_putchar
 304               	/* epilogue start */
 102:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** }
 305               		.loc 3 102 0
 306 00fa 0F90      		pop __tmp_reg__
 307 00fc 0F90      		pop __tmp_reg__
 308 00fe 0F90      		pop __tmp_reg__
 309 0100 DF91      		pop r29
 310 0102 CF91      		pop r28
 311 0104 0895      		ret
 312               		.cfi_endproc
 313               	.LFE105:
 316               	usart_serial_getchar:
 317               	.LFB106:
 103:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 
 104:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** /*! \brief Waits until a character is received, and returns it.
 105:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
 106:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * \param usart   Base address of the USART instance.
 107:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * \param data   Data to read
 108:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
 109:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  */
 110:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** static inline void usart_serial_getchar(usart_if usart, uint8_t *data)
 111:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** {
 318               		.loc 3 111 0
 319               		.cfi_startproc
 320 0106 CF93      		push r28
 321               	.LCFI18:
 322               		.cfi_def_cfa_offset 3
 323               		.cfi_offset 28, -2
 324 0108 DF93      		push r29
 325               	.LCFI19:
 326               		.cfi_def_cfa_offset 4
 327               		.cfi_offset 29, -3
 328 010a 00D0      		rcall .
 329 010c 00D0      		rcall .
 330               	.LCFI20:
 331               		.cfi_def_cfa_offset 8
 332 010e CDB7      		in r28,__SP_L__
 333 0110 DEB7      		in r29,__SP_H__
 334               	.LCFI21:
 335               		.cfi_def_cfa_register 28
 336               	/* prologue: function */
 337               	/* frame size = 4 */
 338               	/* stack size = 6 */
 339               	.L__stack_usage = 6
 340 0112 9A83      		std Y+2,r25
 341 0114 8983      		std Y+1,r24
 342 0116 7C83      		std Y+4,r23
 343 0118 6B83      		std Y+3,r22
 112:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 	*data = usart_getchar(usart);
 344               		.loc 3 112 0
 345 011a 8981      		ldd r24,Y+1
 346 011c 9A81      		ldd r25,Y+2
 347 011e 0E94 0000 		call usart_getchar
 348 0122 282F      		mov r18,r24
 349 0124 8B81      		ldd r24,Y+3
 350 0126 9C81      		ldd r25,Y+4
 351 0128 FC01      		movw r30,r24
 352 012a 2083      		st Z,r18
 113:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** }
 353               		.loc 3 113 0
 354 012c 0000      		nop
 355               	/* epilogue start */
 356 012e 0F90      		pop __tmp_reg__
 357 0130 0F90      		pop __tmp_reg__
 358 0132 0F90      		pop __tmp_reg__
 359 0134 0F90      		pop __tmp_reg__
 360 0136 DF91      		pop r29
 361 0138 CF91      		pop r28
 362 013a 0895      		ret
 363               		.cfi_endproc
 364               	.LFE106:
 367               	stdio_serial_init:
 368               	.LFB107:
 369               		.file 4 "../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h"
   1:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** /**
   2:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
   3:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * \file
   4:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
   5:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * \brief Common Standard I/O Serial Management.
   6:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
   7:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * This file defines a useful set of functions for the Stdio Serial interface on AVR
   8:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * and SAM devices.
   9:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
  10:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * Copyright (c) 2009-2013 Atmel Corporation. All rights reserved.
  11:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
  12:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * \asf_license_start
  13:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
  14:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * \page License
  15:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
  16:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * Redistribution and use in source and binary forms, with or without
  17:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * modification, are permitted provided that the following conditions are met:
  18:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
  19:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * 1. Redistributions of source code must retain the above copyright notice,
  20:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *    this list of conditions and the following disclaimer.
  21:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
  22:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * 2. Redistributions in binary form must reproduce the above copyright notice,
  23:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *    this list of conditions and the following disclaimer in the documentation
  24:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *    and/or other materials provided with the distribution.
  25:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
  26:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * 3. The name of Atmel may not be used to endorse or promote products derived
  27:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *    from this software without specific prior written permission.
  28:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
  29:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * 4. This software may only be redistributed and used in connection with an
  30:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *    Atmel microcontroller product.
  31:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
  32:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR IMPLIED
  33:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
  34:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
  35:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR
  36:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  37:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
  38:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  39:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
  40:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  41:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  42:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * POSSIBILITY OF SUCH DAMAGE.
  43:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
  44:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * \asf_license_stop
  45:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
  46:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  ******************************************************************************/
  47:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 
  48:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 
  49:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** #ifndef _STDIO_SERIAL_H_
  50:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** #define _STDIO_SERIAL_H_
  51:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 
  52:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** /**
  53:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * \defgroup group_common_utils_stdio_stdio_serial Standard serial I/O (stdio)
  54:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * \ingroup group_common_utils_stdio
  55:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
  56:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * Common standard serial I/O management driver that
  57:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * implements a stdio serial interface on AVR and SAM devices.
  58:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
  59:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * \{
  60:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  */
  61:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 
  62:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** #include <stdio.h>
  63:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** #include "compiler.h"
  64:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** #ifndef SAMD20
  65:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** # include "sysclk.h"
  66:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** #endif
  67:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** #include "serial.h"
  68:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 
  69:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** #if (XMEGA || MEGA_RF) && defined(__GNUC__)
  70:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	extern int _write (char c, int *f);
  71:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	extern int _read (int *f);
  72:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** #endif
  73:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 
  74:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 
  75:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** //! Pointer to the base of the USART module instance to use for stdio.
  76:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** extern volatile void *volatile stdio_base;
  77:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** //! Pointer to the external low level write function.
  78:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** extern int (*ptr_put)(void volatile*, char);
  79:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 
  80:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** //! Pointer to the external low level read function.
  81:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** extern void (*ptr_get)(void volatile*, char*);
  82:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 
  83:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** /*! \brief Initializes the stdio in Serial Mode.
  84:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
  85:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * \param usart       Base address of the USART instance.
  86:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * \param opt         Options needed to set up RS232 communication (see \ref usart_options_t).
  87:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
  88:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  */
  89:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** static inline void stdio_serial_init(volatile void *usart, const usart_serial_options_t *opt)
  90:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** {
 370               		.loc 4 90 0
 371               		.cfi_startproc
 372 013c CF93      		push r28
 373               	.LCFI22:
 374               		.cfi_def_cfa_offset 3
 375               		.cfi_offset 28, -2
 376 013e DF93      		push r29
 377               	.LCFI23:
 378               		.cfi_def_cfa_offset 4
 379               		.cfi_offset 29, -3
 380 0140 00D0      		rcall .
 381 0142 00D0      		rcall .
 382               	.LCFI24:
 383               		.cfi_def_cfa_offset 8
 384 0144 CDB7      		in r28,__SP_L__
 385 0146 DEB7      		in r29,__SP_H__
 386               	.LCFI25:
 387               		.cfi_def_cfa_register 28
 388               	/* prologue: function */
 389               	/* frame size = 4 */
 390               	/* stack size = 6 */
 391               	.L__stack_usage = 6
 392 0148 9A83      		std Y+2,r25
 393 014a 8983      		std Y+1,r24
 394 014c 7C83      		std Y+4,r23
 395 014e 6B83      		std Y+3,r22
  91:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	stdio_base = (void *)usart;
 396               		.loc 4 91 0
 397 0150 8981      		ldd r24,Y+1
 398 0152 9A81      		ldd r25,Y+2
 399 0154 9093 0000 		sts stdio_base+1,r25
 400 0158 8093 0000 		sts stdio_base,r24
  92:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	ptr_put = (int (*)(void volatile*,char))&usart_serial_putchar;
 401               		.loc 4 92 0
 402 015c 80E0      		ldi r24,lo8(gs(usart_serial_putchar))
 403 015e 90E0      		ldi r25,hi8(gs(usart_serial_putchar))
 404 0160 9093 0000 		sts ptr_put+1,r25
 405 0164 8093 0000 		sts ptr_put,r24
  93:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	ptr_get = (void (*)(void volatile*,char*))&usart_serial_getchar;
 406               		.loc 4 93 0
 407 0168 80E0      		ldi r24,lo8(gs(usart_serial_getchar))
 408 016a 90E0      		ldi r25,hi8(gs(usart_serial_getchar))
 409 016c 9093 0000 		sts ptr_get+1,r25
 410 0170 8093 0000 		sts ptr_get,r24
  94:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** # if (XMEGA || MEGA_RF)
  95:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	usart_serial_init((USART_t *)usart,opt);
 411               		.loc 4 95 0
 412 0174 2B81      		ldd r18,Y+3
 413 0176 3C81      		ldd r19,Y+4
 414 0178 8981      		ldd r24,Y+1
 415 017a 9A81      		ldd r25,Y+2
 416 017c B901      		movw r22,r18
 417 017e 0E94 0000 		call usart_serial_init
  96:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** # elif UC3
  97:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	usart_serial_init(usart,(usart_serial_options_t *)opt);
  98:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** # elif SAM
  99:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	usart_serial_init((Usart *)usart,(usart_serial_options_t *)opt);
 100:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** # else
 101:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** #  error Unsupported chip type
 102:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** # endif
 103:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 
 104:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** # if defined(__GNUC__)
 105:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** #  if (XMEGA || MEGA_RF)
 106:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	// For AVR GCC libc print redirection uses fdevopen.
 107:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	fdevopen((int (*)(char, FILE*))(_write),(int (*)(FILE*))(_read));
 418               		.loc 4 107 0
 419 0182 60E0      		ldi r22,lo8(gs(_read))
 420 0184 70E0      		ldi r23,hi8(gs(_read))
 421 0186 80E0      		ldi r24,lo8(gs(_write))
 422 0188 90E0      		ldi r25,hi8(gs(_write))
 423 018a 0E94 0000 		call fdevopen
 108:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** #  endif
 109:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** #  if UC3 || SAM
 110:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	// For AVR32 and SAM GCC
 111:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	// Specify that stdout and stdin should not be buffered.
 112:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	setbuf(stdout, NULL);
 113:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	setbuf(stdin, NULL);
 114:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	// Note: Already the case in IAR's Normal DLIB default configuration
 115:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	// and AVR GCC library:
 116:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	// - printf() emits one character at a time.
 117:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	// - getchar() requests only 1 byte to exit.
 118:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** #  endif
 119:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** # endif
 120:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** }
 424               		.loc 4 120 0
 425 018e 0000      		nop
 426               	/* epilogue start */
 427 0190 0F90      		pop __tmp_reg__
 428 0192 0F90      		pop __tmp_reg__
 429 0194 0F90      		pop __tmp_reg__
 430 0196 0F90      		pop __tmp_reg__
 431 0198 DF91      		pop r29
 432 019a CF91      		pop r28
 433 019c 0895      		ret
 434               		.cfi_endproc
 435               	.LFE107:
 438               	macsc_enable_manual_bts:
 439               	.LFB121:
 440               		.file 5 "../../../platform/mega_rf/drivers/macsc/macsc_megarf.h"
   1:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
   2:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \file
   3:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
   4:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief AVR MEGARF MAC Symbol Counter Driver Definitions
   5:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
   6:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * Copyright (c) 2013 Atmel Corporation. All rights reserved.
   7:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
   8:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \asf_license_start
   9:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  10:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \page License
  11:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  12:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * Redistribution and use in source and binary forms, with or without
  13:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * modification, are permitted provided that the following conditions are met:
  14:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  15:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * 1. Redistributions of source code must retain the above copyright notice,
  16:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *    this list of conditions and the following disclaimer.
  17:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  18:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * 2. Redistributions in binary form must reproduce the above copyright notice,
  19:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *    this list of conditions and the following disclaimer in the documentation
  20:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *    and/or other materials provided with the distribution.
  21:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  22:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * 3. The name of Atmel may not be used to endorse or promote products derived
  23:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *    from this software without specific prior written permission.
  24:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  25:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * 4. This software may only be redistributed and used in connection with an
  26:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *    Atmel microcontroller product.
  27:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  28:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR IMPLIED
  29:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
  30:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
  31:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR
  32:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  33:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
  34:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  35:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
  36:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  37:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  38:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * POSSIBILITY OF SUCH DAMAGE.
  39:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  40:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \asf_license_stop
  41:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  42:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
  43:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** #ifndef MACSC_MEGARF_H
  44:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** #define MACSC_MEGARF_H
  45:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
  46:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** #include <compiler.h>
  47:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** #include <parts.h>
  48:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** #include "status_codes.h"
  49:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
  50:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** #ifdef __cplusplus
  51:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** extern "C" {
  52:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** #endif
  53:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
  54:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
  55:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \defgroup macsc_group MAC Symbol Counter Driver(MACSC)
  56:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  57:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * See \ref megarf_macsc_quickstart
  58:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  59:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * This is a driver for the AVR MEGARF MAC Symbol Counter Driver(MACSC).
  60:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * It provides functions for enabling, disabling and configuring the module.
  61:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  62:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \section dependencies Dependencies
  63:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * This driver depends on the following modules:
  64:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * - \ref interrupt_group for ISR definition and disabling interrupts during
  65:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * critical code sections.
  66:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * @{
  67:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
  68:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
  69:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
  70:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Interrupt event callback function type
  71:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  72:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * The interrupt handler can be configured to do a function callback,
  73:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * the callback function must match the macsc_callback_t type.
  74:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  75:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
  76:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** typedef void (*macsc_callback_t)(void);
  77:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
  78:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /* ! MAC symbol counter compare Channel index */
  79:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** enum macsc_cc_channel {
  80:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	/* ! Channel 1 */
  81:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	MACSC_CC1 = 1,
  82:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	/* ! Channel 2 */
  83:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	MACSC_CC2 = 2,
  84:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	/* ! Channel 3 */
  85:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	MACSC_CC3 = 3,
  86:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** };
  87:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
  88:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief MAC SC clock source select
  89:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  90:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * uses the SCCKSEL bit in SSCR register to select macsc clk src
  91:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  92:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * If the bit is one,the RTC clock from TOSC1 is selected, otherwise the symbol
  93:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * counter operates with the clock from XTAL1.
  94:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * During transceiver sleep modes the clock falls back to the RTC clock source,
  95:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * regardless of the selected clock. After wakeup, it switches back to the
  96:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * previosly
  97:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * selected clock source.
  98:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
  99:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 100:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** enum macsc_xtal {
 101:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	/* ! 16MHz as macsc clock */
 102:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	MACSC_16MHz = 0,
 103:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	MACSC_32KHz = 1,
 104:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** };
 105:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 106:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 107:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * @brief Reads the 32-bit timer register in the required order of bytes
 108:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 109:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * @param hh hh octet of 32-bit register
 110:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * @param hl hl octet of 32-bit register
 111:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * @param lh lh octet of 32-bit register
 112:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * @param ll ll octet of 32-bit register
 113:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 114:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * @returns uint32_t Value of timer register
 115:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 116:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** static inline uint32_t macsc_read32(volatile uint8_t *hh,
 117:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		volatile uint8_t *hl,
 118:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		volatile uint8_t *lh,
 119:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		volatile uint8_t *ll)
 120:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** {
 121:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	union {
 122:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		uint8_t a[4];
 123:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		uint32_t rv;
 124:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	}
 125:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	x;
 126:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 127:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	x.a[0] = *ll;
 128:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	x.a[1] = *lh;
 129:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	x.a[2] = *hl;
 130:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	x.a[3] = *hh;
 131:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 132:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	return x.rv;
 133:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** }
 134:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 135:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /* ! compare modes */
 136:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** #define MACSC_ABSOLUTE_CMP 0
 137:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** #define MACSC_RELATIVE_CMP 1
 138:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 139:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /** String concatenation by preprocessor used to create proper register names.
 140:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  **/
 141:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** #define CONCAT(a, b) a ## b
 142:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 143:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /** Creates proper subregister names and reads the corresponding values. */
 144:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** #define MACSC_READ32(reg)                  macsc_read32(&CONCAT(reg, HH), \
 145:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		&CONCAT(reg, HL), \
 146:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		&CONCAT(reg, LH), \
 147:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		&CONCAT(reg, LL))
 148:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 149:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** #define MACSC_WRITE32(reg, val)	\
 150:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	do { \
 151:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		union { uint8_t a[4]; uint32_t v; } \
 152:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		x; \
 153:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		x.v = val; \
 154:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		CONCAT(reg, HH) = x.a[3]; \
 155:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		CONCAT(reg, HL) = x.a[2]; \
 156:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		CONCAT(reg, LH) = x.a[1]; \
 157:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		CONCAT(reg, LL) = x.a[0]; \
 158:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	} \
 159:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	while (0)
 160:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 161:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 162:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Enable MAC SC
 163:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 164:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * Enables the SC
 165:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 166:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param clk_src selection of clk source,avalable options in macsc_xtal,fixed
 167:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *  prescalar
 168:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param sleep_enable enable RTC as clock source during sleep
 169:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param auto_ts enable automatic timestamping
 170:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 171:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 172:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** void macsc_enable(void);
 173:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 174:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 175:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Check if MACSC is enabled
 176:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 177:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * check if the MACSC is enabled.
 178:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 179:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param none
 180:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 181:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 182:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** bool is_macsc_enable(void);
 183:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 184:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 185:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Disable MAC SC
 186:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 187:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * Disables the MAC SC
 188:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 189:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param none
 190:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 191:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 192:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** void macsc_disable(void);
 193:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 194:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 195:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Check if back-off slot counter is enabled
 196:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 197:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * check if the back-off slot counter is enabled.
 198:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 199:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param none
 200:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 201:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 202:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** bool is_macsc_backoff_enable(void);
 203:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 204:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 205:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Enables compare interrupts of the MACSC
 206:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 207:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param channel Compare channel
 208:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 209:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** void macsc_enable_cmp_int(enum macsc_cc_channel channel);
 210:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 211:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 212:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Disables compare interrupts of the MACSC
 213:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 214:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param channel Compare channel
 215:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */void macsc_disable_cmp_int(enum macsc_cc_channel channel);
 216:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 217:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 218:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Usage of Absolute compare mode of the MACSC
 219:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 220:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param abs_rel  0 for absoulte cmp;1 for relative cmp
 221:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param cmp compare value for SCOCRx register
 222:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param channel Compare channel
 223:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 224:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** void macsc_use_cmp(bool abs_rel, uint32_t cmp,enum macsc_cc_channel channel);
 225:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 226:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 227:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \ingroup macsc_group
 228:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \defgroup macsc_interrupt_group MAC Symbol Counter (MACSC) interrupt
 229:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * management
 230:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * This group provides functions to configure MACSC module interrupts
 231:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 232:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * @{
 233:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 234:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 235:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 236:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Set MACSC overflow interrupt callback function
 237:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 238:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * This function allows the caller to set and change the interrupt callback
 239:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * function. Without setting a callback function the interrupt handler in the
 240:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * driver will only clear the interrupt flags.
 241:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 242:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param callback Reference to a callback function
 243:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 244:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** void macsc_set_ovf_int_cb(macsc_callback_t callback);
 245:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 246:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 247:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Set MACSC Compare Channel 1 interrupt callback function
 248:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 249:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * This function allows the caller to set and change the interrupt callback
 250:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * function. Without setting a callback function the interrupt handler in the
 251:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * driver will only clear the interrupt flags.
 252:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 253:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param callback Reference to a callback function
 254:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 255:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** void macsc_set_cmp1_int_cb(macsc_callback_t callback);
 256:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 257:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 258:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Set MACSC Compare Channel 2 interrupt callback function
 259:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 260:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * This function allows the caller to set and change the interrupt callback
 261:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * function. Without setting a callback function the interrupt handler in the
 262:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * driver will only clear the interrupt flags.
 263:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 264:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param callback Reference to a callback function
 265:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 266:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** void macsc_set_cmp2_int_cb(macsc_callback_t callback);
 267:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 268:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 269:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Set MACSC Compare Channel 3 interrupt callback function
 270:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 271:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * This function allows the caller to set and change the interrupt callback
 272:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * function. Without setting a callback function the interrupt handler in the
 273:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * driver will only clear the interrupt flags.
 274:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 275:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param callback Reference to a callback function
 276:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 277:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** void macsc_set_cmp3_int_cb(macsc_callback_t callback);
 278:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 279:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 280:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Set MACSC backoff slot counter interrupt callback function
 281:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 282:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * This function allows the caller to set and change the interrupt callback
 283:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * function. Without setting a callback function the interrupt handler in the
 284:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * driver will only clear the interrupt flags.
 285:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 286:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param callback Reference to a callback function
 287:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 288:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** void macsc_set_backoff_slot_cntr_int_cb(macsc_callback_t callback);
 289:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** //@}
 290:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 291:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 292:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Enable 32.768KHz clk using timer 2 async register
 293:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 294:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param none
 295:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 296:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 297:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** static inline void macsc_sleep_clk_enable(void)
 298:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** {
 299:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	ASSR |= (1 << AS2);
 300:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** }
 301:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 302:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 303:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Disable 32.768KHz clk using timer 2 async register
 304:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 305:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param none
 306:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 307:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** static inline void macsc_sleep_clk_disable(void)
 308:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** {
 309:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	ASSR &= ~(1 << AS2);
 310:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** }
 311:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 312:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /* @} */
 313:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 314:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 315:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Configure MAC Symbol Counter Clock Source
 316:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 317:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param macsc macsc clk src
 318:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 319:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** static inline void macsc_write_clock_source(enum macsc_xtal source)
 320:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** {
 321:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	if (source == MACSC_16MHz) {
 322:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		SCCR0 |= (source << SCCKSEL);
 323:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	} else if (source == MACSC_32KHz) {
 324:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		SCCR0 &= ~(1 << SCCKSEL);
 325:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	}
 326:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** }
 327:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 328:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 329:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Read MAC SC Clock Source
 330:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 331:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param none
 332:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \return macsc_xtal enum Clock source selection
 333:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 334:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** static inline enum macsc_xtal macsc_read_clock_source(void)
 335:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** {
 336:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	return (enum macsc_xtal)(SCCR0 & (1 << SCCKSEL));
 337:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** }
 338:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 339:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 340:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Write the Counter value of the MAC Symbol counter
 341:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 342:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param cnt_value Counter value
 343:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 344:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** static inline void macsc_write_count(uint32_t cnt_value)
 345:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** {
 346:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	MACSC_WRITE32(SCCNT, cnt_value);
 347:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** }
 348:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 349:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 350:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Reads the Counter value of the MAC Symbol counter
 351:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 352:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \note Output the Counter value
 353:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 354:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** static inline uint32_t macsc_read_count(void)
 355:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** {
 356:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	return (MACSC_READ32(SCCNT));
 357:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** }
 358:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 359:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 360:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief enable back-off slot counter
 361:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 362:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param none
 363:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \note  Enables interrupt as well	.
 364:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \note This counter works only if transceiver clock is running.So check Trx
 365:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * state in app before using this function in IEEE802.15.4 applications.
 366:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 367:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** static inline bool macsc_backoff_slot_cnt_enable(void)
 368:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** {
 369:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	if (!(PRR1 & (1 << PRTRX24))) {
 370:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		SCCR1 = (1 << SCENBO);
 371:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		SCIRQS |= (1 << IRQSBO);
 372:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		SCIRQM |= (1 << IRQMBO);
 373:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		return true;
 374:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	}
 375:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	else return false;
 376:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** }
 377:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 378:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 379:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Disable back-off slot counter
 380:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 381:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param none
 382:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \note    Disables interrupt as well	.
 383:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \note This counter works only if transceiver clock is running.So check Trx
 384:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * state in app before using this function in IEEE802.15.4 applications.
 385:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 386:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** static inline void macsc_backoff_slot_cnt_disable(void)
 387:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** {
 388:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	SCCR1 &= ~(1 << SCENBO);
 389:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	SCIRQM &= ~(1 << IRQMBO);
 390:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** }
 391:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 392:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 393:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Tests if the Backoff slot cntr interrupt flag is set
 394:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 395:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \return  backoff slot cntr interrupt has occurred or not : IRQSBO
 396:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 397:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** static inline bool macsc_is_slot_cntr_interrupt_flag_set(void)
 398:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** {
 399:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	return (SCIRQS & (1 << IRQSBO));
 400:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** }
 401:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 402:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 403:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Clears the Backoff Slot cntr interrupt flag
 404:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 405:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \note  IRQSBO is cleared
 406:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 407:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** static inline void macsc_clear_slot_cntr_interrupt_flag(void)
 408:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** {
 409:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	SCIRQS |= (1 << IRQSBO);
 410:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** }
 411:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 412:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 413:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Reads the SFD Timestamp register
 414:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 415:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \return Timestamp of last received frame :SCTSR(read-only register)
 416:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 417:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** static inline uint32_t macsc_read_ts(void)
 418:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** {
 419:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	return (MACSC_READ32(SCTSR));
 420:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** }
 421:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 422:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 423:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Reads the Beacon Timestamp register
 424:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 425:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \return Timestamp of last received beacon frame :SCBTSR
 426:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 427:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** static inline uint32_t macsc_read_bts(void)
 428:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** {
 429:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	return (MACSC_READ32(SCBTSR));
 430:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** }
 431:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 432:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 433:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Write the Beacon Timestamp register of the MAC Symbol counter
 434:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * The manual beacon timestamping can be used in conjunction with the
 435:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * relative compare mode of the three compare units to generate compare match
 436:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * interrupts without having a beacon frame received
 437:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 438:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * If set to 1, the current symbol counter value is stored into the beacon
 439:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * timestamp register.
 440:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * The bit is cleared afterwards.
 441:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 442:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 443:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** static inline void macsc_enable_manual_bts(void)
 444:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** {
 441               		.loc 5 444 0
 442               		.cfi_startproc
 443 019e CF93      		push r28
 444               	.LCFI26:
 445               		.cfi_def_cfa_offset 3
 446               		.cfi_offset 28, -2
 447 01a0 DF93      		push r29
 448               	.LCFI27:
 449               		.cfi_def_cfa_offset 4
 450               		.cfi_offset 29, -3
 451 01a2 CDB7      		in r28,__SP_L__
 452 01a4 DEB7      		in r29,__SP_H__
 453               	.LCFI28:
 454               		.cfi_def_cfa_register 28
 455               	/* prologue: function */
 456               	/* frame size = 0 */
 457               	/* stack size = 2 */
 458               	.L__stack_usage = 2
 445:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	SCCR0 |= (1 << SCMBTS);
 459               		.loc 5 445 0
 460 01a6 8CED      		ldi r24,lo8(-36)
 461 01a8 90E0      		ldi r25,0
 462 01aa 2CED      		ldi r18,lo8(-36)
 463 01ac 30E0      		ldi r19,0
 464 01ae F901      		movw r30,r18
 465 01b0 2081      		ld r18,Z
 466 01b2 2064      		ori r18,lo8(64)
 467 01b4 FC01      		movw r30,r24
 468 01b6 2083      		st Z,r18
 446:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	SCCR0 &= ~(1 << SCTSE);
 469               		.loc 5 446 0
 470 01b8 8CED      		ldi r24,lo8(-36)
 471 01ba 90E0      		ldi r25,0
 472 01bc 2CED      		ldi r18,lo8(-36)
 473 01be 30E0      		ldi r19,0
 474 01c0 F901      		movw r30,r18
 475 01c2 2081      		ld r18,Z
 476 01c4 277F      		andi r18,lo8(-9)
 477 01c6 FC01      		movw r30,r24
 478 01c8 2083      		st Z,r18
 447:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** }
 479               		.loc 5 447 0
 480 01ca 0000      		nop
 481               	/* epilogue start */
 482 01cc DF91      		pop r29
 483 01ce CF91      		pop r28
 484 01d0 0895      		ret
 485               		.cfi_endproc
 486               	.LFE121:
 488               	.global	appState
 489               		.section	.bss.appState,"aw",@nobits
 492               	appState:
 493 0000 00        		.zero	1
 494               		.section	.bss.msgReq,"aw",@nobits
 497               	msgReq:
 498 0000 0000 0000 		.zero	20
 498      0000 0000 
 498      0000 0000 
 498      0000 0000 
 498      0000 0000 
 499               		.section	.bss.PanId,"aw",@nobits
 502               	PanId:
 503 0000 00        		.zero	1
 504               		.section	.rodata
 505               	.LC1:
 506 0000 0A4D 5347 		.string	"\nMSG REQ SENT %d"
 506      2052 4551 
 506      2053 454E 
 506      5420 2564 
 506      00
 507               		.text
 509               	appSendData:
 510               	.LFB130:
 511               		.file 6 "ServerLLDN.c"
   1:ServerLLDN.c  **** /*
   2:ServerLLDN.c  **** 	* ServerLLDN.c
   3:ServerLLDN.c  **** 	*
   4:ServerLLDN.c  **** 	* Created: 10/18/2019 5:15:37 PM
   5:ServerLLDN.c  **** 	*  Author: guilherme
   6:ServerLLDN.c  **** 	*/ 
   7:ServerLLDN.c  **** 
   8:ServerLLDN.c  **** #include <stdlib.h>
   9:ServerLLDN.c  **** #include <stdio.h>
  10:ServerLLDN.c  **** #include <string.h>
  11:ServerLLDN.c  **** #include <inttypes.h>
  12:ServerLLDN.c  **** #include "config.h"
  13:ServerLLDN.c  **** #include "sys.h"
  14:ServerLLDN.c  **** #include "phy.h"
  15:ServerLLDN.c  **** #include "sys.h"
  16:ServerLLDN.c  **** #include "nwk.h"
  17:ServerLLDN.c  **** #include "sysclk.h"
  18:ServerLLDN.c  **** #include "sysTimer.h"
  19:ServerLLDN.c  **** #include "sleep_mgr.h"
  20:ServerLLDN.c  **** #include "sleepmgr.h"
  21:ServerLLDN.c  **** #include "led.h"
  22:ServerLLDN.c  **** #include "ioport.h"
  23:ServerLLDN.c  **** #include "conf_sleepmgr.h"
  24:ServerLLDN.c  **** #include "board.h"
  25:ServerLLDN.c  **** #include "platform.h"
  26:ServerLLDN.c  **** #include "lldn.h"
  27:ServerLLDN.c  **** 
  28:ServerLLDN.c  **** #if APP_COORDINATOR
  29:ServerLLDN.c  **** 	#if (SIO2HOST_CHANNEL == SIO_USB)
  30:ServerLLDN.c  **** 		/* Only ARM */
  31:ServerLLDN.c  **** 		#include "stdio_usb.h"
  32:ServerLLDN.c  **** 		#define MASTER_MACSC	0
  33:ServerLLDN.c  **** 		#define TIMESLOT_TIMER	0
  34:ServerLLDN.c  **** 	#else
  35:ServerLLDN.c  **** 		/* Only megarf series */
  36:ServerLLDN.c  **** 		#include "conf_sio2host.h" // necessary for prints
  37:ServerLLDN.c  **** 		#define MASTER_MACSC	1
  38:ServerLLDN.c  **** 		#define TIMESLOT_TIMER	0
  39:ServerLLDN.c  **** 	#endif
  40:ServerLLDN.c  **** #else
  41:ServerLLDN.c  **** 	/* Only megarf series */
  42:ServerLLDN.c  **** 	#include "conf_sio2host.h" // necessary for prints
  43:ServerLLDN.c  **** 	#define MASTER_MACSC		1
  44:ServerLLDN.c  **** #endif
  45:ServerLLDN.c  **** 
  46:ServerLLDN.c  **** 
  47:ServerLLDN.c  **** #if (MASTER_MACSC == 1)
  48:ServerLLDN.c  **** 	#include "macsc_megarf.h"
  49:ServerLLDN.c  **** #else
  50:ServerLLDN.c  **** 	// static SYS_Timer_t				tmrBeaconInterval;			// Beacon
  51:ServerLLDN.c  **** 	// static SYS_Timer_t				tmrComputeData;				// Compute data
  52:ServerLLDN.c  **** #endif
  53:ServerLLDN.c  **** 	
  54:ServerLLDN.c  **** // equation for tTS gives time in seconds, the division by SYMBOL_TIME changes to symbols for count
  55:ServerLLDN.c  **** AppState_t	appState = APP_STATE_INITIAL;
  56:ServerLLDN.c  **** static NWK_DataReq_t msgReq;
  57:ServerLLDN.c  **** static uint8_t PanId;
  58:ServerLLDN.c  **** 
  59:ServerLLDN.c  **** static void appSendData(void)
  60:ServerLLDN.c  **** {
 512               		.loc 6 60 0
 513               		.cfi_startproc
 514 01d2 CF93      		push r28
 515               	.LCFI29:
 516               		.cfi_def_cfa_offset 3
 517               		.cfi_offset 28, -2
 518 01d4 DF93      		push r29
 519               	.LCFI30:
 520               		.cfi_def_cfa_offset 4
 521               		.cfi_offset 29, -3
 522 01d6 CDB7      		in r28,__SP_L__
 523 01d8 DEB7      		in r29,__SP_H__
 524               	.LCFI31:
 525               		.cfi_def_cfa_register 28
 526               	/* prologue: function */
 527               	/* frame size = 0 */
 528               	/* stack size = 2 */
 529               	.L__stack_usage = 2
  61:ServerLLDN.c  **** 	if(msgReq.options != 0)
 530               		.loc 6 61 0
 531 01da 8091 0000 		lds r24,msgReq+9
 532 01de 9091 0000 		lds r25,msgReq+9+1
 533 01e2 892B      		or r24,r25
 534 01e4 01F0      		breq .L17
  62:ServerLLDN.c  **** 	{
  63:ServerLLDN.c  **** 		printf("\nMSG REQ SENT %d",msgReq.options);
 535               		.loc 6 63 0
 536 01e6 8091 0000 		lds r24,msgReq+9
 537 01ea 9091 0000 		lds r25,msgReq+9+1
 538 01ee 292F      		mov r18,r25
 539 01f0 2F93      		push r18
 540 01f2 8F93      		push r24
 541 01f4 80E0      		ldi r24,lo8(.LC1)
 542 01f6 90E0      		ldi r25,hi8(.LC1)
 543 01f8 892F      		mov r24,r25
 544 01fa 8F93      		push r24
 545 01fc 80E0      		ldi r24,lo8(.LC1)
 546 01fe 90E0      		ldi r25,hi8(.LC1)
 547 0200 8F93      		push r24
 548 0202 0E94 0000 		call printf
 549 0206 0F90      		pop __tmp_reg__
 550 0208 0F90      		pop __tmp_reg__
 551 020a 0F90      		pop __tmp_reg__
 552 020c 0F90      		pop __tmp_reg__
  64:ServerLLDN.c  **** 		NWK_DataReq(&msgReq);
 553               		.loc 6 64 0
 554 020e 80E0      		ldi r24,lo8(msgReq)
 555 0210 90E0      		ldi r25,hi8(msgReq)
 556 0212 0E94 0000 		call NWK_DataReq
 557               	.L17:
  65:ServerLLDN.c  **** 	#if !APP_COORDINATOR
  66:ServerLLDN.c  **** 	#endif
  67:ServerLLDN.c  **** 	}
  68:ServerLLDN.c  **** }
 558               		.loc 6 68 0
 559 0216 0000      		nop
 560               	/* epilogue start */
 561 0218 DF91      		pop r29
 562 021a CF91      		pop r28
 563 021c 0895      		ret
 564               		.cfi_endproc
 565               	.LFE130:
 567               		.comm	beaconInterval,4,1
 568               	.global	appPanState
 569               		.section	.data.appPanState,"aw",@progbits
 572               	appPanState:
 573 0000 01        		.byte	1
 574               		.comm	ACKFrame,33,1
 575               	.global	ACKFrame_size
 576               		.section	.bss.ACKFrame_size,"aw",@nobits
 579               	ACKFrame_size:
 580 0000 0000      		.zero	2
 581               	.global	cycles_counter
 582               		.section	.data.cycles_counter,"aw",@progbits
 585               	cycles_counter:
 586 0000 01        		.byte	1
 587               	.global	counter_associados
 588               		.section	.bss.counter_associados,"aw",@nobits
 591               	counter_associados:
 592 0000 0000      		.zero	2
 593               		.comm	msgsConfRequest,1778,1
 594               		.comm	ConfigRequest,7,1
 595               	.global	macLLDNnumUplinkTS
 596               		.section	.bss.macLLDNnumUplinkTS,"aw",@nobits
 599               	macLLDNnumUplinkTS:
 600 0000 0000      		.zero	2
 601               	.global	biggest_timeslot_duration
 602               		.section	.bss.biggest_timeslot_duration,"aw",@nobits
 605               	biggest_timeslot_duration:
 606 0000 0000      		.zero	2
 607               	.global	index_ConfRequest
 608               		.section	.bss.index_ConfRequest,"aw",@nobits
 611               	index_ConfRequest:
 612 0000 0000      		.zero	2
 613               		.comm	max_index,2,1
 614               		.comm	tmrDiscoveryMode,13,1
 615               		.comm	tmrDelay_Discovery,13,1
 616               		.comm	tmrDelay_Configuration,13,1
 617               		.text
 619               	tmrDiscoveryModeHandler:
 620               	.LFB131:
  69:ServerLLDN.c  **** 
  70:ServerLLDN.c  **** #if APP_COORDINATOR
  71:ServerLLDN.c  **** 
  72:ServerLLDN.c  **** 	#define NODOS_ASSOCIADOS_ESPERADOS 3
  73:ServerLLDN.c  **** 
  74:ServerLLDN.c  **** 	float beaconInterval;
  75:ServerLLDN.c  **** 	AppPanState_t appPanState = APP_PAN_STATE_RESET;	// estado inicial do coordenador
  76:ServerLLDN.c  **** 	NWK_ACKFormat_t ACKFrame;									// payload do ACK Frame
  77:ServerLLDN.c  **** 	int ACKFrame_size = 0;										// tamanho do vetor do ACK Frame
  78:ServerLLDN.c  **** 	uint8_t cycles_counter = macLLDNdiscoveryModeTimeout;		// quantidade mxima de repeties das etap
  79:ServerLLDN.c  **** 	int counter_associados = 0;									// contador nmero de nodos associados
  80:ServerLLDN.c  **** 	NWK_ConfigRequest_t msgsConfRequest[254];					// array para mensagens de configure_request, uma po
  81:ServerLLDN.c  **** 	NWK_ConfigRequest_t ConfigRequest;
  82:ServerLLDN.c  **** 	int macLLDNnumUplinkTS = 0;									// nmero de uplink timeslots, tambm  o controle de nodos as
  83:ServerLLDN.c  **** 	int biggest_timeslot_duration  = 0;							
  84:ServerLLDN.c  **** 	int index_ConfRequest = 0;
  85:ServerLLDN.c  **** 	int max_index;
  86:ServerLLDN.c  **** 	SYS_Timer_t tmrDiscoveryMode; // timer para reinciar a rede, utilizado somente em testes
  87:ServerLLDN.c  **** 	SYS_Timer_t tmrDelay_Discovery; // timer para delay entre mensagens
  88:ServerLLDN.c  **** 	SYS_Timer_t tmrDelay_Configuration;
  89:ServerLLDN.c  **** 	
  90:ServerLLDN.c  **** 
  91:ServerLLDN.c  **** 	static void tmrDiscoveryModeHandler(SYS_Timer_t *timer)
  92:ServerLLDN.c  **** 	{
 621               		.loc 6 92 0
 622               		.cfi_startproc
 623 021e CF93      		push r28
 624               	.LCFI32:
 625               		.cfi_def_cfa_offset 3
 626               		.cfi_offset 28, -2
 627 0220 DF93      		push r29
 628               	.LCFI33:
 629               		.cfi_def_cfa_offset 4
 630               		.cfi_offset 29, -3
 631 0222 00D0      		rcall .
 632               	.LCFI34:
 633               		.cfi_def_cfa_offset 6
 634 0224 CDB7      		in r28,__SP_L__
 635 0226 DEB7      		in r29,__SP_H__
 636               	.LCFI35:
 637               		.cfi_def_cfa_register 28
 638               	/* prologue: function */
 639               	/* frame size = 2 */
 640               	/* stack size = 4 */
 641               	.L__stack_usage = 4
 642 0228 9A83      		std Y+2,r25
 643 022a 8983      		std Y+1,r24
  93:ServerLLDN.c  **** 		appState = APP_STATE_INITIAL;
 644               		.loc 6 93 0
 645 022c 1092 0000 		sts appState,__zero_reg__
  94:ServerLLDN.c  **** 		appPanState = APP_PAN_STATE_RESET;
 646               		.loc 6 94 0
 647 0230 81E0      		ldi r24,lo8(1)
 648 0232 8093 0000 		sts appPanState,r24
  95:ServerLLDN.c  **** 	}
 649               		.loc 6 95 0
 650 0236 0000      		nop
 651               	/* epilogue start */
 652 0238 0F90      		pop __tmp_reg__
 653 023a 0F90      		pop __tmp_reg__
 654 023c DF91      		pop r29
 655 023e CF91      		pop r28
 656 0240 0895      		ret
 657               		.cfi_endproc
 658               	.LFE131:
 660               		.section	.rodata
 661               	.LC2:
 662 0011 0A54 696D 		.string	"\nTimer_Software"
 662      6572 5F53 
 662      6F66 7477 
 662      6172 6500 
 663               		.text
 665               	tmrDelayHandler:
 666               	.LFB132:
  96:ServerLLDN.c  **** 	
  97:ServerLLDN.c  **** 	static void tmrDelayHandler(SYS_Timer_t *timer)
  98:ServerLLDN.c  **** 	{
 667               		.loc 6 98 0
 668               		.cfi_startproc
 669 0242 CF93      		push r28
 670               	.LCFI36:
 671               		.cfi_def_cfa_offset 3
 672               		.cfi_offset 28, -2
 673 0244 DF93      		push r29
 674               	.LCFI37:
 675               		.cfi_def_cfa_offset 4
 676               		.cfi_offset 29, -3
 677 0246 00D0      		rcall .
 678               	.LCFI38:
 679               		.cfi_def_cfa_offset 6
 680 0248 CDB7      		in r28,__SP_L__
 681 024a DEB7      		in r29,__SP_H__
 682               	.LCFI39:
 683               		.cfi_def_cfa_register 28
 684               	/* prologue: function */
 685               	/* frame size = 2 */
 686               	/* stack size = 4 */
 687               	.L__stack_usage = 4
 688 024c 9A83      		std Y+2,r25
 689 024e 8983      		std Y+1,r24
  99:ServerLLDN.c  **** 		printf("\nTimer_Software");
 690               		.loc 6 99 0
 691 0250 80E0      		ldi r24,lo8(.LC2)
 692 0252 90E0      		ldi r25,hi8(.LC2)
 693 0254 892F      		mov r24,r25
 694 0256 8F93      		push r24
 695 0258 80E0      		ldi r24,lo8(.LC2)
 696 025a 90E0      		ldi r25,hi8(.LC2)
 697 025c 8F93      		push r24
 698 025e 0E94 0000 		call printf
 699 0262 0F90      		pop __tmp_reg__
 700 0264 0F90      		pop __tmp_reg__
 100:ServerLLDN.c  **** 		appState = APP_STATE_SEND;
 701               		.loc 6 100 0
 702 0266 82E0      		ldi r24,lo8(2)
 703 0268 8093 0000 		sts appState,r24
 101:ServerLLDN.c  **** 		// appPanState = APP_PAN_STATE_RESET;
 102:ServerLLDN.c  **** 	}
 704               		.loc 6 102 0
 705 026c 0000      		nop
 706               	/* epilogue start */
 707 026e 0F90      		pop __tmp_reg__
 708 0270 0F90      		pop __tmp_reg__
 709 0272 DF91      		pop r29
 710 0274 CF91      		pop r28
 711 0276 0895      		ret
 712               		.cfi_endproc
 713               	.LFE132:
 715               		.section	.rodata
 716               	.LC3:
 717 0021 0A42 6561 		.string	"\nBeacon Timer"
 717      636F 6E20 
 717      5469 6D65 
 717      7200 
 718               		.text
 720               	lldn_server_beacon:
 721               	.LFB133:
 103:ServerLLDN.c  **** 	
 104:ServerLLDN.c  **** 	static void lldn_server_beacon(void)
 105:ServerLLDN.c  **** 	{
 722               		.loc 6 105 0
 723               		.cfi_startproc
 724 0278 CF93      		push r28
 725               	.LCFI40:
 726               		.cfi_def_cfa_offset 3
 727               		.cfi_offset 28, -2
 728 027a DF93      		push r29
 729               	.LCFI41:
 730               		.cfi_def_cfa_offset 4
 731               		.cfi_offset 29, -3
 732 027c CDB7      		in r28,__SP_L__
 733 027e DEB7      		in r29,__SP_H__
 734               	.LCFI42:
 735               		.cfi_def_cfa_register 28
 736               	/* prologue: function */
 737               	/* frame size = 0 */
 738               	/* stack size = 2 */
 739               	.L__stack_usage = 2
 106:ServerLLDN.c  **** 		printf("\nBeacon Timer");
 740               		.loc 6 106 0
 741 0280 80E0      		ldi r24,lo8(.LC3)
 742 0282 90E0      		ldi r25,hi8(.LC3)
 743 0284 892F      		mov r24,r25
 744 0286 8F93      		push r24
 745 0288 80E0      		ldi r24,lo8(.LC3)
 746 028a 90E0      		ldi r25,hi8(.LC3)
 747 028c 8F93      		push r24
 748 028e 0E94 0000 		call printf
 749 0292 0F90      		pop __tmp_reg__
 750 0294 0F90      		pop __tmp_reg__
 107:ServerLLDN.c  **** 		macsc_enable_manual_bts();
 751               		.loc 6 107 0
 752 0296 0E94 0000 		call macsc_enable_manual_bts
 108:ServerLLDN.c  **** 		appState = APP_STATE_SEND;
 753               		.loc 6 108 0
 754 029a 82E0      		ldi r24,lo8(2)
 755 029c 8093 0000 		sts appState,r24
 109:ServerLLDN.c  **** 	}
 756               		.loc 6 109 0
 757 02a0 0000      		nop
 758               	/* epilogue start */
 759 02a2 DF91      		pop r29
 760 02a4 CF91      		pop r28
 761 02a6 0895      		ret
 762               		.cfi_endproc
 763               	.LFE133:
 765               		.section	.rodata
 766               	.LC4:
 767 002f 0A64 656C 		.string	"\ndelay timer"
 767      6179 2074 
 767      696D 6572 
 767      00
 768               		.text
 770               	downlink_delay_handler:
 771               	.LFB134:
 110:ServerLLDN.c  **** 	
 111:ServerLLDN.c  **** 	static void downlink_delay_handler(void)
 112:ServerLLDN.c  **** 	{
 772               		.loc 6 112 0
 773               		.cfi_startproc
 774 02a8 CF93      		push r28
 775               	.LCFI43:
 776               		.cfi_def_cfa_offset 3
 777               		.cfi_offset 28, -2
 778 02aa DF93      		push r29
 779               	.LCFI44:
 780               		.cfi_def_cfa_offset 4
 781               		.cfi_offset 29, -3
 782 02ac CDB7      		in r28,__SP_L__
 783 02ae DEB7      		in r29,__SP_H__
 784               	.LCFI45:
 785               		.cfi_def_cfa_register 28
 786               	/* prologue: function */
 787               	/* frame size = 0 */
 788               	/* stack size = 2 */
 789               	.L__stack_usage = 2
 113:ServerLLDN.c  **** 		printf("\ndelay timer");
 790               		.loc 6 113 0
 791 02b0 80E0      		ldi r24,lo8(.LC4)
 792 02b2 90E0      		ldi r25,hi8(.LC4)
 793 02b4 892F      		mov r24,r25
 794 02b6 8F93      		push r24
 795 02b8 80E0      		ldi r24,lo8(.LC4)
 796 02ba 90E0      		ldi r25,hi8(.LC4)
 797 02bc 8F93      		push r24
 798 02be 0E94 0000 		call printf
 799 02c2 0F90      		pop __tmp_reg__
 800 02c4 0F90      		pop __tmp_reg__
 114:ServerLLDN.c  **** 		macsc_disable_cmp_int(MACSC_CC3);
 801               		.loc 6 114 0
 802 02c6 83E0      		ldi r24,lo8(3)
 803 02c8 0E94 0000 		call macsc_disable_cmp_int
 115:ServerLLDN.c  **** 		appState = APP_STATE_SEND;
 804               		.loc 6 115 0
 805 02cc 82E0      		ldi r24,lo8(2)
 806 02ce 8093 0000 		sts appState,r24
 116:ServerLLDN.c  **** 	}
 807               		.loc 6 116 0
 808 02d2 0000      		nop
 809               	/* epilogue start */
 810 02d4 DF91      		pop r29
 811 02d6 CF91      		pop r28
 812 02d8 0895      		ret
 813               		.cfi_endproc
 814               	.LFE134:
 817               	addToAckArray:
 818               	.LFB135:
 117:ServerLLDN.c  **** 	
 118:ServerLLDN.c  **** 	#if TIMESLOT_TIMER
 119:ServerLLDN.c  **** 	static void teste_handler(void)
 120:ServerLLDN.c  **** 	{
 121:ServerLLDN.c  **** 		if(msgReq.options)
 122:ServerLLDN.c  **** 		printf("\n***TIMESLOT****");
 123:ServerLLDN.c  **** 	}
 124:ServerLLDN.c  **** 	#endif
 125:ServerLLDN.c  **** 	
 126:ServerLLDN.c  **** 	static void addToAckArray(uint16_t addres)
 127:ServerLLDN.c  **** 	{	
 819               		.loc 6 127 0
 820               		.cfi_startproc
 821 02da CF93      		push r28
 822               	.LCFI46:
 823               		.cfi_def_cfa_offset 3
 824               		.cfi_offset 28, -2
 825 02dc DF93      		push r29
 826               	.LCFI47:
 827               		.cfi_def_cfa_offset 4
 828               		.cfi_offset 29, -3
 829 02de 00D0      		rcall .
 830 02e0 00D0      		rcall .
 831 02e2 00D0      		rcall .
 832               	.LCFI48:
 833               		.cfi_def_cfa_offset 10
 834 02e4 CDB7      		in r28,__SP_L__
 835 02e6 DEB7      		in r29,__SP_H__
 836               	.LCFI49:
 837               		.cfi_def_cfa_register 28
 838               	/* prologue: function */
 839               	/* frame size = 6 */
 840               	/* stack size = 8 */
 841               	.L__stack_usage = 8
 842 02e8 9E83      		std Y+6,r25
 843 02ea 8D83      		std Y+5,r24
 128:ServerLLDN.c  **** 		int pos =(int) addres / 8;
 844               		.loc 6 128 0
 845 02ec 8D81      		ldd r24,Y+5
 846 02ee 9E81      		ldd r25,Y+6
 847 02f0 9923      		tst r25
 848 02f2 04F4      		brge .L23
 849 02f4 0796      		adiw r24,7
 850               	.L23:
 851 02f6 9595      		asr r25
 852 02f8 8795      		ror r24
 853 02fa 9595      		asr r25
 854 02fc 8795      		ror r24
 855 02fe 9595      		asr r25
 856 0300 8795      		ror r24
 857 0302 9A83      		std Y+2,r25
 858 0304 8983      		std Y+1,r24
 129:ServerLLDN.c  **** 		int bit_shift = 8 - (addres % 8);
 859               		.loc 6 129 0
 860 0306 8D81      		ldd r24,Y+5
 861 0308 9E81      		ldd r25,Y+6
 862 030a 8770      		andi r24,7
 863 030c 9927      		clr r25
 864 030e 28E0      		ldi r18,lo8(8)
 865 0310 30E0      		ldi r19,0
 866 0312 A901      		movw r20,r18
 867 0314 481B      		sub r20,r24
 868 0316 590B      		sbc r21,r25
 869 0318 CA01      		movw r24,r20
 870 031a 9C83      		std Y+4,r25
 871 031c 8B83      		std Y+3,r24
 130:ServerLLDN.c  **** 		ACKFrame.ackFlags[pos] |= 1 << bit_shift;
 872               		.loc 6 130 0
 873 031e 8981      		ldd r24,Y+1
 874 0320 9A81      		ldd r25,Y+2
 875 0322 8050      		subi r24,lo8(-(ACKFrame+1))
 876 0324 9040      		sbci r25,hi8(-(ACKFrame+1))
 877 0326 FC01      		movw r30,r24
 878 0328 8081      		ld r24,Z
 879 032a 282F      		mov r18,r24
 880 032c 81E0      		ldi r24,lo8(1)
 881 032e 90E0      		ldi r25,0
 882 0330 0B80      		ldd r0,Y+3
 883 0332 00C0      		rjmp 2f
 884               		1:
 885 0334 880F      		lsl r24
 886 0336 991F      		rol r25
 887               		2:
 888 0338 0A94      		dec r0
 889 033a 02F4      		brpl 1b
 890 033c 822B      		or r24,r18
 891 033e 282F      		mov r18,r24
 892 0340 8981      		ldd r24,Y+1
 893 0342 9A81      		ldd r25,Y+2
 894 0344 8050      		subi r24,lo8(-(ACKFrame+1))
 895 0346 9040      		sbci r25,hi8(-(ACKFrame+1))
 896 0348 FC01      		movw r30,r24
 897 034a 2083      		st Z,r18
 131:ServerLLDN.c  **** 		if (pos + 1 > ACKFrame_size)
 898               		.loc 6 131 0
 899 034c 8981      		ldd r24,Y+1
 900 034e 9A81      		ldd r25,Y+2
 901 0350 9C01      		movw r18,r24
 902 0352 2F5F      		subi r18,-1
 903 0354 3F4F      		sbci r19,-1
 904 0356 8091 0000 		lds r24,ACKFrame_size
 905 035a 9091 0000 		lds r25,ACKFrame_size+1
 906 035e 8217      		cp r24,r18
 907 0360 9307      		cpc r25,r19
 908 0362 04F4      		brge .L25
 132:ServerLLDN.c  **** 		ACKFrame_size = pos + 1;
 909               		.loc 6 132 0
 910 0364 8981      		ldd r24,Y+1
 911 0366 9A81      		ldd r25,Y+2
 912 0368 0196      		adiw r24,1
 913 036a 9093 0000 		sts ACKFrame_size+1,r25
 914 036e 8093 0000 		sts ACKFrame_size,r24
 915               	.L25:
 133:ServerLLDN.c  **** 	}
 916               		.loc 6 133 0
 917 0372 0000      		nop
 918               	/* epilogue start */
 919 0374 2696      		adiw r28,6
 920 0376 0FB6      		in __tmp_reg__,__SREG__
 921 0378 F894      		cli
 922 037a DEBF      		out __SP_H__,r29
 923 037c 0FBE      		out __SREG__,__tmp_reg__
 924 037e CDBF      		out __SP_L__,r28
 925 0380 DF91      		pop r29
 926 0382 CF91      		pop r28
 927 0384 0895      		ret
 928               		.cfi_endproc
 929               	.LFE135:
 932               	addConfRequestArray:
 933               	.LFB136:
 134:ServerLLDN.c  **** 	
 135:ServerLLDN.c  **** 	static void addConfRequestArray(NWK_ConfigStatus_t *node)
 136:ServerLLDN.c  **** 	{
 934               		.loc 6 136 0
 935               		.cfi_startproc
 936 0386 CF93      		push r28
 937               	.LCFI50:
 938               		.cfi_def_cfa_offset 3
 939               		.cfi_offset 28, -2
 940 0388 DF93      		push r29
 941               	.LCFI51:
 942               		.cfi_def_cfa_offset 4
 943               		.cfi_offset 29, -3
 944 038a 00D0      		rcall .
 945               	.LCFI52:
 946               		.cfi_def_cfa_offset 6
 947 038c CDB7      		in r28,__SP_L__
 948 038e DEB7      		in r29,__SP_H__
 949               	.LCFI53:
 950               		.cfi_def_cfa_register 28
 951               	/* prologue: function */
 952               	/* frame size = 2 */
 953               	/* stack size = 4 */
 954               	.L__stack_usage = 4
 955 0390 9A83      		std Y+2,r25
 956 0392 8983      		std Y+1,r24
 137:ServerLLDN.c  **** 		//printf("index_confRequest : %d", index_confRequest);
 138:ServerLLDN.c  **** 		index_ConfRequest++;
 957               		.loc 6 138 0
 958 0394 8091 0000 		lds r24,index_ConfRequest
 959 0398 9091 0000 		lds r25,index_ConfRequest+1
 960 039c 0196      		adiw r24,1
 961 039e 9093 0000 		sts index_ConfRequest+1,r25
 962 03a2 8093 0000 		sts index_ConfRequest,r24
 139:ServerLLDN.c  **** 		if(node->ts_dir.tsDuration > biggest_timeslot_duration)
 963               		.loc 6 139 0
 964 03a6 8981      		ldd r24,Y+1
 965 03a8 9A81      		ldd r25,Y+2
 966 03aa FC01      		movw r30,r24
 967 03ac 8581      		ldd r24,Z+5
 968 03ae 8F77      		andi r24,lo8(127)
 969 03b0 282F      		mov r18,r24
 970 03b2 30E0      		ldi r19,0
 971 03b4 8091 0000 		lds r24,biggest_timeslot_duration
 972 03b8 9091 0000 		lds r25,biggest_timeslot_duration+1
 973 03bc 8217      		cp r24,r18
 974 03be 9307      		cpc r25,r19
 975 03c0 04F4      		brge .L27
 140:ServerLLDN.c  **** 			biggest_timeslot_duration = node->ts_dir.tsDuration;
 976               		.loc 6 140 0
 977 03c2 8981      		ldd r24,Y+1
 978 03c4 9A81      		ldd r25,Y+2
 979 03c6 FC01      		movw r30,r24
 980 03c8 8581      		ldd r24,Z+5
 981 03ca 8F77      		andi r24,lo8(127)
 982 03cc 882F      		mov r24,r24
 983 03ce 90E0      		ldi r25,0
 984 03d0 9093 0000 		sts biggest_timeslot_duration+1,r25
 985 03d4 8093 0000 		sts biggest_timeslot_duration,r24
 986               	.L27:
 141:ServerLLDN.c  **** 		// tem que atualizar o tamanho final
 142:ServerLLDN.c  **** 		msgsConfRequest[index_ConfRequest].id = LL_CONFIGURATION_REQUEST;
 987               		.loc 6 142 0
 988 03d8 2091 0000 		lds r18,index_ConfRequest
 989 03dc 3091 0000 		lds r19,index_ConfRequest+1
 990 03e0 C901      		movw r24,r18
 991 03e2 880F      		lsl r24
 992 03e4 991F      		rol r25
 993 03e6 880F      		lsl r24
 994 03e8 991F      		rol r25
 995 03ea 880F      		lsl r24
 996 03ec 991F      		rol r25
 997 03ee 821B      		sub r24,r18
 998 03f0 930B      		sbc r25,r19
 999 03f2 8050      		subi r24,lo8(-(msgsConfRequest))
 1000 03f4 9040      		sbci r25,hi8(-(msgsConfRequest))
 1001 03f6 2FE0      		ldi r18,lo8(15)
 1002 03f8 FC01      		movw r30,r24
 1003 03fa 2083      		st Z,r18
 143:ServerLLDN.c  ****  		msgsConfRequest[index_ConfRequest].macAddr = node->macAddr;
 1004               		.loc 6 143 0
 1005 03fc 2091 0000 		lds r18,index_ConfRequest
 1006 0400 3091 0000 		lds r19,index_ConfRequest+1
 1007 0404 8981      		ldd r24,Y+1
 1008 0406 9A81      		ldd r25,Y+2
 1009 0408 FC01      		movw r30,r24
 1010 040a 4381      		ldd r20,Z+3
 1011 040c 5481      		ldd r21,Z+4
 1012 040e C901      		movw r24,r18
 1013 0410 880F      		lsl r24
 1014 0412 991F      		rol r25
 1015 0414 880F      		lsl r24
 1016 0416 991F      		rol r25
 1017 0418 880F      		lsl r24
 1018 041a 991F      		rol r25
 1019 041c 821B      		sub r24,r18
 1020 041e 930B      		sbc r25,r19
 1021 0420 8050      		subi r24,lo8(-(msgsConfRequest+4))
 1022 0422 9040      		sbci r25,hi8(-(msgsConfRequest+4))
 1023 0424 FC01      		movw r30,r24
 1024 0426 5183      		std Z+1,r21
 1025 0428 4083      		st Z,r20
 144:ServerLLDN.c  ****  		msgsConfRequest[index_ConfRequest].s_macAddr = APP_ADDR;
 1026               		.loc 6 144 0
 1027 042a 2091 0000 		lds r18,index_ConfRequest
 1028 042e 3091 0000 		lds r19,index_ConfRequest+1
 1029 0432 C901      		movw r24,r18
 1030 0434 880F      		lsl r24
 1031 0436 991F      		rol r25
 1032 0438 880F      		lsl r24
 1033 043a 991F      		rol r25
 1034 043c 880F      		lsl r24
 1035 043e 991F      		rol r25
 1036 0440 821B      		sub r24,r18
 1037 0442 930B      		sbc r25,r19
 1038 0444 8050      		subi r24,lo8(-(msgsConfRequest+1))
 1039 0446 9040      		sbci r25,hi8(-(msgsConfRequest+1))
 1040 0448 FC01      		movw r30,r24
 1041 044a 1082      		st Z,__zero_reg__
 145:ServerLLDN.c  ****  		msgsConfRequest[index_ConfRequest].tx_channel = APP_CHANNEL;
 1042               		.loc 6 145 0
 1043 044c 2091 0000 		lds r18,index_ConfRequest
 1044 0450 3091 0000 		lds r19,index_ConfRequest+1
 1045 0454 C901      		movw r24,r18
 1046 0456 880F      		lsl r24
 1047 0458 991F      		rol r25
 1048 045a 880F      		lsl r24
 1049 045c 991F      		rol r25
 1050 045e 880F      		lsl r24
 1051 0460 991F      		rol r25
 1052 0462 821B      		sub r24,r18
 1053 0464 930B      		sbc r25,r19
 1054 0466 8050      		subi r24,lo8(-(msgsConfRequest+2))
 1055 0468 9040      		sbci r25,hi8(-(msgsConfRequest+2))
 1056 046a 2FE0      		ldi r18,lo8(15)
 1057 046c FC01      		movw r30,r24
 1058 046e 2083      		st Z,r18
 146:ServerLLDN.c  ****  		msgsConfRequest[index_ConfRequest].assTimeSlot = (uint8_t)index_ConfRequest;
 1059               		.loc 6 146 0
 1060 0470 2091 0000 		lds r18,index_ConfRequest
 1061 0474 3091 0000 		lds r19,index_ConfRequest+1
 1062 0478 8091 0000 		lds r24,index_ConfRequest
 1063 047c 9091 0000 		lds r25,index_ConfRequest+1
 1064 0480 482F      		mov r20,r24
 1065 0482 C901      		movw r24,r18
 1066 0484 880F      		lsl r24
 1067 0486 991F      		rol r25
 1068 0488 880F      		lsl r24
 1069 048a 991F      		rol r25
 1070 048c 880F      		lsl r24
 1071 048e 991F      		rol r25
 1072 0490 821B      		sub r24,r18
 1073 0492 930B      		sbc r25,r19
 1074 0494 8050      		subi r24,lo8(-(msgsConfRequest+3))
 1075 0496 9040      		sbci r25,hi8(-(msgsConfRequest+3))
 1076 0498 FC01      		movw r30,r24
 1077 049a 4083      		st Z,r20
 147:ServerLLDN.c  ****  		msgsConfRequest[index_ConfRequest].conf.mgmtFrames = 0x01;
 1078               		.loc 6 147 0
 1079 049c 2091 0000 		lds r18,index_ConfRequest
 1080 04a0 3091 0000 		lds r19,index_ConfRequest+1
 1081 04a4 C901      		movw r24,r18
 1082 04a6 880F      		lsl r24
 1083 04a8 991F      		rol r25
 1084 04aa 880F      		lsl r24
 1085 04ac 991F      		rol r25
 1086 04ae 880F      		lsl r24
 1087 04b0 991F      		rol r25
 1088 04b2 821B      		sub r24,r18
 1089 04b4 930B      		sbc r25,r19
 1090 04b6 8050      		subi r24,lo8(-(msgsConfRequest+6))
 1091 04b8 9040      		sbci r25,hi8(-(msgsConfRequest+6))
 1092 04ba FC01      		movw r30,r24
 1093 04bc 2081      		ld r18,Z
 1094 04be 2068      		ori r18,lo8(-128)
 1095 04c0 FC01      		movw r30,r24
 1096 04c2 2083      		st Z,r18
 148:ServerLLDN.c  ****  		max_index = index_ConfRequest;
 1097               		.loc 6 148 0
 1098 04c4 8091 0000 		lds r24,index_ConfRequest
 1099 04c8 9091 0000 		lds r25,index_ConfRequest+1
 1100 04cc 9093 0000 		sts max_index+1,r25
 1101 04d0 8093 0000 		sts max_index,r24
 149:ServerLLDN.c  **** 
 150:ServerLLDN.c  **** 	}
 1102               		.loc 6 150 0
 1103 04d4 0000      		nop
 1104               	/* epilogue start */
 1105 04d6 0F90      		pop __tmp_reg__
 1106 04d8 0F90      		pop __tmp_reg__
 1107 04da DF91      		pop r29
 1108 04dc CF91      		pop r28
 1109 04de 0895      		ret
 1110               		.cfi_endproc
 1111               	.LFE136:
 1114               	CopyToConfigRequest:
 1115               	.LFB137:
 151:ServerLLDN.c  **** 		
 152:ServerLLDN.c  **** 	static void CopyToConfigRequest(int i)
 153:ServerLLDN.c  **** 	{
 1116               		.loc 6 153 0
 1117               		.cfi_startproc
 1118 04e0 CF93      		push r28
 1119               	.LCFI54:
 1120               		.cfi_def_cfa_offset 3
 1121               		.cfi_offset 28, -2
 1122 04e2 DF93      		push r29
 1123               	.LCFI55:
 1124               		.cfi_def_cfa_offset 4
 1125               		.cfi_offset 29, -3
 1126 04e4 00D0      		rcall .
 1127               	.LCFI56:
 1128               		.cfi_def_cfa_offset 6
 1129 04e6 CDB7      		in r28,__SP_L__
 1130 04e8 DEB7      		in r29,__SP_H__
 1131               	.LCFI57:
 1132               		.cfi_def_cfa_register 28
 1133               	/* prologue: function */
 1134               	/* frame size = 2 */
 1135               	/* stack size = 4 */
 1136               	.L__stack_usage = 4
 1137 04ea 9A83      		std Y+2,r25
 1138 04ec 8983      		std Y+1,r24
 154:ServerLLDN.c  **** 		ConfigRequest.id = msgsConfRequest[i].id;
 1139               		.loc 6 154 0
 1140 04ee 2981      		ldd r18,Y+1
 1141 04f0 3A81      		ldd r19,Y+2
 1142 04f2 C901      		movw r24,r18
 1143 04f4 880F      		lsl r24
 1144 04f6 991F      		rol r25
 1145 04f8 880F      		lsl r24
 1146 04fa 991F      		rol r25
 1147 04fc 880F      		lsl r24
 1148 04fe 991F      		rol r25
 1149 0500 821B      		sub r24,r18
 1150 0502 930B      		sbc r25,r19
 1151 0504 8050      		subi r24,lo8(-(msgsConfRequest))
 1152 0506 9040      		sbci r25,hi8(-(msgsConfRequest))
 1153 0508 FC01      		movw r30,r24
 1154 050a 8081      		ld r24,Z
 1155 050c 8093 0000 		sts ConfigRequest,r24
 155:ServerLLDN.c  **** 		ConfigRequest.s_macAddr = msgsConfRequest[i].s_macAddr;
 1156               		.loc 6 155 0
 1157 0510 2981      		ldd r18,Y+1
 1158 0512 3A81      		ldd r19,Y+2
 1159 0514 C901      		movw r24,r18
 1160 0516 880F      		lsl r24
 1161 0518 991F      		rol r25
 1162 051a 880F      		lsl r24
 1163 051c 991F      		rol r25
 1164 051e 880F      		lsl r24
 1165 0520 991F      		rol r25
 1166 0522 821B      		sub r24,r18
 1167 0524 930B      		sbc r25,r19
 1168 0526 8050      		subi r24,lo8(-(msgsConfRequest+1))
 1169 0528 9040      		sbci r25,hi8(-(msgsConfRequest+1))
 1170 052a FC01      		movw r30,r24
 1171 052c 8081      		ld r24,Z
 1172 052e 8093 0000 		sts ConfigRequest+1,r24
 156:ServerLLDN.c  **** 		ConfigRequest.tx_channel = msgsConfRequest[i].tx_channel;
 1173               		.loc 6 156 0
 1174 0532 2981      		ldd r18,Y+1
 1175 0534 3A81      		ldd r19,Y+2
 1176 0536 C901      		movw r24,r18
 1177 0538 880F      		lsl r24
 1178 053a 991F      		rol r25
 1179 053c 880F      		lsl r24
 1180 053e 991F      		rol r25
 1181 0540 880F      		lsl r24
 1182 0542 991F      		rol r25
 1183 0544 821B      		sub r24,r18
 1184 0546 930B      		sbc r25,r19
 1185 0548 8050      		subi r24,lo8(-(msgsConfRequest+2))
 1186 054a 9040      		sbci r25,hi8(-(msgsConfRequest+2))
 1187 054c FC01      		movw r30,r24
 1188 054e 8081      		ld r24,Z
 1189 0550 8093 0000 		sts ConfigRequest+2,r24
 157:ServerLLDN.c  **** 		ConfigRequest.assTimeSlot = msgsConfRequest[i].assTimeSlot;
 1190               		.loc 6 157 0
 1191 0554 2981      		ldd r18,Y+1
 1192 0556 3A81      		ldd r19,Y+2
 1193 0558 C901      		movw r24,r18
 1194 055a 880F      		lsl r24
 1195 055c 991F      		rol r25
 1196 055e 880F      		lsl r24
 1197 0560 991F      		rol r25
 1198 0562 880F      		lsl r24
 1199 0564 991F      		rol r25
 1200 0566 821B      		sub r24,r18
 1201 0568 930B      		sbc r25,r19
 1202 056a 8050      		subi r24,lo8(-(msgsConfRequest+3))
 1203 056c 9040      		sbci r25,hi8(-(msgsConfRequest+3))
 1204 056e FC01      		movw r30,r24
 1205 0570 8081      		ld r24,Z
 1206 0572 8093 0000 		sts ConfigRequest+3,r24
 158:ServerLLDN.c  **** 		ConfigRequest.macAddr = msgsConfRequest[i].macAddr;
 1207               		.loc 6 158 0
 1208 0576 2981      		ldd r18,Y+1
 1209 0578 3A81      		ldd r19,Y+2
 1210 057a C901      		movw r24,r18
 1211 057c 880F      		lsl r24
 1212 057e 991F      		rol r25
 1213 0580 880F      		lsl r24
 1214 0582 991F      		rol r25
 1215 0584 880F      		lsl r24
 1216 0586 991F      		rol r25
 1217 0588 821B      		sub r24,r18
 1218 058a 930B      		sbc r25,r19
 1219 058c 8050      		subi r24,lo8(-(msgsConfRequest+4))
 1220 058e 9040      		sbci r25,hi8(-(msgsConfRequest+4))
 1221 0590 FC01      		movw r30,r24
 1222 0592 8081      		ld r24,Z
 1223 0594 9181      		ldd r25,Z+1
 1224 0596 9093 0000 		sts ConfigRequest+4+1,r25
 1225 059a 8093 0000 		sts ConfigRequest+4,r24
 159:ServerLLDN.c  **** 		ConfigRequest.conf.tsDuration = msgsConfRequest[i].conf.tsDuration;
 1226               		.loc 6 159 0
 1227 059e 2981      		ldd r18,Y+1
 1228 05a0 3A81      		ldd r19,Y+2
 1229 05a2 C901      		movw r24,r18
 1230 05a4 880F      		lsl r24
 1231 05a6 991F      		rol r25
 1232 05a8 880F      		lsl r24
 1233 05aa 991F      		rol r25
 1234 05ac 880F      		lsl r24
 1235 05ae 991F      		rol r25
 1236 05b0 821B      		sub r24,r18
 1237 05b2 930B      		sbc r25,r19
 1238 05b4 8050      		subi r24,lo8(-(msgsConfRequest+6))
 1239 05b6 9040      		sbci r25,hi8(-(msgsConfRequest+6))
 1240 05b8 FC01      		movw r30,r24
 1241 05ba 8081      		ld r24,Z
 1242 05bc 8F77      		andi r24,lo8(127)
 1243 05be 8F77      		andi r24,lo8(127)
 1244 05c0 9091 0000 		lds r25,ConfigRequest+6
 1245 05c4 9078      		andi r25,lo8(-128)
 1246 05c6 892B      		or r24,r25
 1247 05c8 8093 0000 		sts ConfigRequest+6,r24
 160:ServerLLDN.c  **** 		ConfigRequest.conf.mgmtFrames = msgsConfRequest[i].conf.mgmtFrames;
 1248               		.loc 6 160 0
 1249 05cc 2981      		ldd r18,Y+1
 1250 05ce 3A81      		ldd r19,Y+2
 1251 05d0 C901      		movw r24,r18
 1252 05d2 880F      		lsl r24
 1253 05d4 991F      		rol r25
 1254 05d6 880F      		lsl r24
 1255 05d8 991F      		rol r25
 1256 05da 880F      		lsl r24
 1257 05dc 991F      		rol r25
 1258 05de 821B      		sub r24,r18
 1259 05e0 930B      		sbc r25,r19
 1260 05e2 8050      		subi r24,lo8(-(msgsConfRequest+6))
 1261 05e4 9040      		sbci r25,hi8(-(msgsConfRequest+6))
 1262 05e6 FC01      		movw r30,r24
 1263 05e8 8081      		ld r24,Z
 1264 05ea 87FB      		bst r24,7
 1265 05ec 8827      		clr r24
 1266 05ee 80F9      		bld r24,0
 1267 05f0 8795      		ror r24
 1268 05f2 8827      		clr r24
 1269 05f4 8795      		ror r24
 1270 05f6 9091 0000 		lds r25,ConfigRequest+6
 1271 05fa 9F77      		andi r25,lo8(127)
 1272 05fc 892B      		or r24,r25
 1273 05fe 8093 0000 		sts ConfigRequest+6,r24
 161:ServerLLDN.c  **** 	}
 1274               		.loc 6 161 0
 1275 0602 0000      		nop
 1276               	/* epilogue start */
 1277 0604 0F90      		pop __tmp_reg__
 1278 0606 0F90      		pop __tmp_reg__
 1279 0608 DF91      		pop r29
 1280 060a CF91      		pop r28
 1281 060c 0895      		ret
 1282               		.cfi_endproc
 1283               	.LFE137:
 1285               		.section	.rodata
 1286               	.LC5:
 1287 003c 0A44 4953 		.string	"\nDISCOVER STATUS %hhx"
 1287      434F 5645 
 1287      5220 5354 
 1287      4154 5553 
 1287      2025 6868 
 1288               	.LC6:
 1289 0052 0A43 4F4E 		.string	"\nCONFIGURATION STATUS %hhx"
 1289      4649 4755 
 1289      5241 5449 
 1289      4F4E 2053 
 1289      5441 5455 
 1290               		.text
 1292               	appCommandInd:
 1293               	.LFB138:
 162:ServerLLDN.c  **** 	
 163:ServerLLDN.c  **** 	static bool appCommandInd(NWK_DataInd_t *ind)
 164:ServerLLDN.c  **** 	{
 1294               		.loc 6 164 0
 1295               		.cfi_startproc
 1296 060e CF93      		push r28
 1297               	.LCFI58:
 1298               		.cfi_def_cfa_offset 3
 1299               		.cfi_offset 28, -2
 1300 0610 DF93      		push r29
 1301               	.LCFI59:
 1302               		.cfi_def_cfa_offset 4
 1303               		.cfi_offset 29, -3
 1304 0612 00D0      		rcall .
 1305 0614 00D0      		rcall .
 1306 0616 00D0      		rcall .
 1307               	.LCFI60:
 1308               		.cfi_def_cfa_offset 10
 1309 0618 CDB7      		in r28,__SP_L__
 1310 061a DEB7      		in r29,__SP_H__
 1311               	.LCFI61:
 1312               		.cfi_def_cfa_register 28
 1313               	/* prologue: function */
 1314               	/* frame size = 6 */
 1315               	/* stack size = 8 */
 1316               	.L__stack_usage = 8
 1317 061c 9E83      		std Y+6,r25
 1318 061e 8D83      		std Y+5,r24
 165:ServerLLDN.c  **** 		if(ind->data[0] == LL_DISCOVER_RESPONSE)
 1319               		.loc 6 165 0
 1320 0620 8D81      		ldd r24,Y+5
 1321 0622 9E81      		ldd r25,Y+6
 1322 0624 FC01      		movw r30,r24
 1323 0626 8085      		ldd r24,Z+8
 1324 0628 9185      		ldd r25,Z+9
 1325 062a FC01      		movw r30,r24
 1326 062c 8081      		ld r24,Z
 1327 062e 8D30      		cpi r24,lo8(13)
 1328 0630 01F4      		brne .L30
 1329               	.LBB2:
 166:ServerLLDN.c  **** 		{
 167:ServerLLDN.c  **** 			NWK_DiscoverResponse_t *msg = (NWK_DiscoverResponse_t*)ind->data;
 1330               		.loc 6 167 0
 1331 0632 8D81      		ldd r24,Y+5
 1332 0634 9E81      		ldd r25,Y+6
 1333 0636 FC01      		movw r30,r24
 1334 0638 8085      		ldd r24,Z+8
 1335 063a 9185      		ldd r25,Z+9
 1336 063c 9C83      		std Y+4,r25
 1337 063e 8B83      		std Y+3,r24
 168:ServerLLDN.c  **** 			addToAckArray(msg->macAddr);
 1338               		.loc 6 168 0
 1339 0640 8B81      		ldd r24,Y+3
 1340 0642 9C81      		ldd r25,Y+4
 1341 0644 FC01      		movw r30,r24
 1342 0646 8181      		ldd r24,Z+1
 1343 0648 9281      		ldd r25,Z+2
 1344 064a 0E94 0000 		call addToAckArray
 169:ServerLLDN.c  **** 			printf("\nDISCOVER STATUS %hhx", msg->macAddr);	
 1345               		.loc 6 169 0
 1346 064e 8B81      		ldd r24,Y+3
 1347 0650 9C81      		ldd r25,Y+4
 1348 0652 FC01      		movw r30,r24
 1349 0654 8181      		ldd r24,Z+1
 1350 0656 9281      		ldd r25,Z+2
 1351 0658 292F      		mov r18,r25
 1352 065a 2F93      		push r18
 1353 065c 8F93      		push r24
 1354 065e 80E0      		ldi r24,lo8(.LC5)
 1355 0660 90E0      		ldi r25,hi8(.LC5)
 1356 0662 892F      		mov r24,r25
 1357 0664 8F93      		push r24
 1358 0666 80E0      		ldi r24,lo8(.LC5)
 1359 0668 90E0      		ldi r25,hi8(.LC5)
 1360 066a 8F93      		push r24
 1361 066c 0E94 0000 		call printf
 1362 0670 0F90      		pop __tmp_reg__
 1363 0672 0F90      		pop __tmp_reg__
 1364 0674 0F90      		pop __tmp_reg__
 1365 0676 0F90      		pop __tmp_reg__
 1366               	.LBE2:
 1367 0678 00C0      		rjmp .L31
 1368               	.L30:
 170:ServerLLDN.c  **** 		}
 171:ServerLLDN.c  **** 		else if(ind->data[0] == LL_CONFIGURATION_STATUS)
 1369               		.loc 6 171 0
 1370 067a 8D81      		ldd r24,Y+5
 1371 067c 9E81      		ldd r25,Y+6
 1372 067e FC01      		movw r30,r24
 1373 0680 8085      		ldd r24,Z+8
 1374 0682 9185      		ldd r25,Z+9
 1375 0684 FC01      		movw r30,r24
 1376 0686 8081      		ld r24,Z
 1377 0688 8E30      		cpi r24,lo8(14)
 1378 068a 01F4      		brne .L32
 1379               	.LBB3:
 172:ServerLLDN.c  **** 		{
 173:ServerLLDN.c  **** 			NWK_ConfigStatus_t *msg = (NWK_ConfigStatus_t*)ind->data;
 1380               		.loc 6 173 0
 1381 068c 8D81      		ldd r24,Y+5
 1382 068e 9E81      		ldd r25,Y+6
 1383 0690 FC01      		movw r30,r24
 1384 0692 8085      		ldd r24,Z+8
 1385 0694 9185      		ldd r25,Z+9
 1386 0696 9A83      		std Y+2,r25
 1387 0698 8983      		std Y+1,r24
 174:ServerLLDN.c  **** 			addConfRequestArray(msg);
 1388               		.loc 6 174 0
 1389 069a 8981      		ldd r24,Y+1
 1390 069c 9A81      		ldd r25,Y+2
 1391 069e 0E94 0000 		call addConfRequestArray
 175:ServerLLDN.c  **** 			printf("\nCONFIGURATION STATUS %hhx", msg->macAddr);	
 1392               		.loc 6 175 0
 1393 06a2 8981      		ldd r24,Y+1
 1394 06a4 9A81      		ldd r25,Y+2
 1395 06a6 FC01      		movw r30,r24
 1396 06a8 8381      		ldd r24,Z+3
 1397 06aa 9481      		ldd r25,Z+4
 1398 06ac 292F      		mov r18,r25
 1399 06ae 2F93      		push r18
 1400 06b0 8F93      		push r24
 1401 06b2 80E0      		ldi r24,lo8(.LC6)
 1402 06b4 90E0      		ldi r25,hi8(.LC6)
 1403 06b6 892F      		mov r24,r25
 1404 06b8 8F93      		push r24
 1405 06ba 80E0      		ldi r24,lo8(.LC6)
 1406 06bc 90E0      		ldi r25,hi8(.LC6)
 1407 06be 8F93      		push r24
 1408 06c0 0E94 0000 		call printf
 1409 06c4 0F90      		pop __tmp_reg__
 1410 06c6 0F90      		pop __tmp_reg__
 1411 06c8 0F90      		pop __tmp_reg__
 1412 06ca 0F90      		pop __tmp_reg__
 1413               	.LBE3:
 1414 06cc 00C0      		rjmp .L31
 1415               	.L32:
 176:ServerLLDN.c  **** 		}
 177:ServerLLDN.c  **** 		else return false;			
 1416               		.loc 6 177 0
 1417 06ce 80E0      		ldi r24,0
 1418 06d0 00C0      		rjmp .L33
 1419               	.L31:
 178:ServerLLDN.c  **** 		return true;
 1420               		.loc 6 178 0
 1421 06d2 81E0      		ldi r24,lo8(1)
 1422               	.L33:
 1423               	/* epilogue start */
 179:ServerLLDN.c  **** 	}
 1424               		.loc 6 179 0
 1425 06d4 2696      		adiw r28,6
 1426 06d6 0FB6      		in __tmp_reg__,__SREG__
 1427 06d8 F894      		cli
 1428 06da DEBF      		out __SP_H__,r29
 1429 06dc 0FBE      		out __SREG__,__tmp_reg__
 1430 06de CDBF      		out __SP_L__,r28
 1431 06e0 DF91      		pop r29
 1432 06e2 CF91      		pop r28
 1433 06e4 0895      		ret
 1434               		.cfi_endproc
 1435               	.LFE138:
 1438               	appPanPrepareACK:
 1439               	.LFB139:
 180:ServerLLDN.c  **** 	
 181:ServerLLDN.c  **** 	static void appPanPrepareACK(void)
 182:ServerLLDN.c  **** 	{
 1440               		.loc 6 182 0
 1441               		.cfi_startproc
 1442 06e6 CF93      		push r28
 1443               	.LCFI62:
 1444               		.cfi_def_cfa_offset 3
 1445               		.cfi_offset 28, -2
 1446 06e8 DF93      		push r29
 1447               	.LCFI63:
 1448               		.cfi_def_cfa_offset 4
 1449               		.cfi_offset 29, -3
 1450 06ea CDB7      		in r28,__SP_L__
 1451 06ec DEB7      		in r29,__SP_H__
 1452               	.LCFI64:
 1453               		.cfi_def_cfa_register 28
 1454               	/* prologue: function */
 1455               	/* frame size = 0 */
 1456               	/* stack size = 2 */
 1457               	.L__stack_usage = 2
 183:ServerLLDN.c  **** 		msgReq.dstAddr				= 0;
 1458               		.loc 6 183 0
 1459 06ee 1092 0000 		sts msgReq+5+1,__zero_reg__
 1460 06f2 1092 0000 		sts msgReq+5,__zero_reg__
 184:ServerLLDN.c  **** 		msgReq.dstEndpoint			= APP_BEACON_ENDPOINT;
 1461               		.loc 6 184 0
 1462 06f6 1092 0000 		sts msgReq+7,__zero_reg__
 185:ServerLLDN.c  **** 		msgReq.srcEndpoint			= APP_BEACON_ENDPOINT;
 1463               		.loc 6 185 0
 1464 06fa 1092 0000 		sts msgReq+8,__zero_reg__
 186:ServerLLDN.c  **** 		msgReq.options				= NWK_OPT_LLDN_ACK;
 1465               		.loc 6 186 0
 1466 06fe 80E0      		ldi r24,0
 1467 0700 90E4      		ldi r25,lo8(64)
 1468 0702 9093 0000 		sts msgReq+9+1,r25
 1469 0706 8093 0000 		sts msgReq+9,r24
 187:ServerLLDN.c  **** 		msgReq.data					= (uint8_t *)&ACKFrame;
 1470               		.loc 6 187 0
 1471 070a 80E0      		ldi r24,lo8(ACKFrame)
 1472 070c 90E0      		ldi r25,hi8(ACKFrame)
 1473 070e 9093 0000 		sts msgReq+13+1,r25
 1474 0712 8093 0000 		sts msgReq+13,r24
 188:ServerLLDN.c  **** 		msgReq.size					= sizeof(uint8_t)*(ACKFrame_size + 1);
 1475               		.loc 6 188 0
 1476 0716 8091 0000 		lds r24,ACKFrame_size
 1477 071a 9091 0000 		lds r25,ACKFrame_size+1
 1478 071e 8F5F      		subi r24,lo8(-(1))
 1479 0720 8093 0000 		sts msgReq+15,r24
 189:ServerLLDN.c  **** 	}
 1480               		.loc 6 189 0
 1481 0724 0000      		nop
 1482               	/* epilogue start */
 1483 0726 DF91      		pop r29
 1484 0728 CF91      		pop r28
 1485 072a 0895      		ret
 1486               		.cfi_endproc
 1487               	.LFE139:
 1490               	appPanReset:
 1491               	.LFB140:
 190:ServerLLDN.c  **** 
 191:ServerLLDN.c  **** 	static void appPanReset(void)
 192:ServerLLDN.c  **** 	{
 1492               		.loc 6 192 0
 1493               		.cfi_startproc
 1494 072c CF93      		push r28
 1495               	.LCFI65:
 1496               		.cfi_def_cfa_offset 3
 1497               		.cfi_offset 28, -2
 1498 072e DF93      		push r29
 1499               	.LCFI66:
 1500               		.cfi_def_cfa_offset 4
 1501               		.cfi_offset 29, -3
 1502 0730 CDB7      		in r28,__SP_L__
 1503 0732 DEB7      		in r29,__SP_H__
 1504               	.LCFI67:
 1505               		.cfi_def_cfa_register 28
 1506               	/* prologue: function */
 1507               	/* frame size = 0 */
 1508               	/* stack size = 2 */
 1509               	.L__stack_usage = 2
 193:ServerLLDN.c  **** 		// prepara mensagem do beacon reset
 194:ServerLLDN.c  **** 		msgReq.dstAddr		= 0;
 1510               		.loc 6 194 0
 1511 0734 1092 0000 		sts msgReq+5+1,__zero_reg__
 1512 0738 1092 0000 		sts msgReq+5,__zero_reg__
 195:ServerLLDN.c  **** 		msgReq.dstEndpoint	= APP_BEACON_ENDPOINT;
 1513               		.loc 6 195 0
 1514 073c 1092 0000 		sts msgReq+7,__zero_reg__
 196:ServerLLDN.c  **** 		msgReq.srcEndpoint	= APP_BEACON_ENDPOINT;
 1515               		.loc 6 196 0
 1516 0740 1092 0000 		sts msgReq+8,__zero_reg__
 197:ServerLLDN.c  **** 		msgReq.options		= NWK_OPT_LLDN_BEACON | NWK_OPT_RESET_STATE;
 1517               		.loc 6 197 0
 1518 0744 80E4      		ldi r24,lo8(64)
 1519 0746 94E0      		ldi r25,lo8(4)
 1520 0748 9093 0000 		sts msgReq+9+1,r25
 1521 074c 8093 0000 		sts msgReq+9,r24
 198:ServerLLDN.c  **** 		msgReq.data			= NULL;
 1522               		.loc 6 198 0
 1523 0750 1092 0000 		sts msgReq+13+1,__zero_reg__
 1524 0754 1092 0000 		sts msgReq+13,__zero_reg__
 199:ServerLLDN.c  **** 		msgReq.size			= 0;
 1525               		.loc 6 199 0
 1526 0758 1092 0000 		sts msgReq+15,__zero_reg__
 200:ServerLLDN.c  **** 		
 201:ServerLLDN.c  **** 		// preencher o vetor com zeros para impedir lixo de memria
 202:ServerLLDN.c  **** 
 203:ServerLLDN.c  **** 		ACKFrame_size = 0;
 1527               		.loc 6 203 0
 1528 075c 1092 0000 		sts ACKFrame_size+1,__zero_reg__
 1529 0760 1092 0000 		sts ACKFrame_size,__zero_reg__
 204:ServerLLDN.c  **** 		index_ConfRequest = 0;
 1530               		.loc 6 204 0
 1531 0764 1092 0000 		sts index_ConfRequest+1,__zero_reg__
 1532 0768 1092 0000 		sts index_ConfRequest,__zero_reg__
 205:ServerLLDN.c  **** 		counter_associados = 0;
 1533               		.loc 6 205 0
 1534 076c 1092 0000 		sts counter_associados+1,__zero_reg__
 1535 0770 1092 0000 		sts counter_associados,__zero_reg__
 206:ServerLLDN.c  **** 	}
 1536               		.loc 6 206 0
 1537 0774 0000      		nop
 1538               	/* epilogue start */
 1539 0776 DF91      		pop r29
 1540 0778 CF91      		pop r28
 1541 077a 0895      		ret
 1542               		.cfi_endproc
 1543               	.LFE140:
 1545               	.global	__floatsisf
 1546               	.global	__addsf3
 1547               	.global	__divsf3
 1548               	.global	__mulsf3
 1549               	.global	__fixunssfsi
 1551               	appPanDiscInit:
 1552               	.LFB141:
 207:ServerLLDN.c  **** 
 208:ServerLLDN.c  **** 	static void appPanDiscInit(void)
 209:ServerLLDN.c  **** 	{	
 1553               		.loc 6 209 0
 1554               		.cfi_startproc
 1555 077c CF93      		push r28
 1556               	.LCFI68:
 1557               		.cfi_def_cfa_offset 3
 1558               		.cfi_offset 28, -2
 1559 077e DF93      		push r29
 1560               	.LCFI69:
 1561               		.cfi_def_cfa_offset 4
 1562               		.cfi_offset 29, -3
 1563 0780 00D0      		rcall .
 1564               	.LCFI70:
 1565               		.cfi_def_cfa_offset 6
 1566 0782 CDB7      		in r28,__SP_L__
 1567 0784 DEB7      		in r29,__SP_H__
 1568               	.LCFI71:
 1569               		.cfi_def_cfa_register 28
 1570               	/* prologue: function */
 1571               	/* frame size = 2 */
 1572               	/* stack size = 4 */
 1573               	.L__stack_usage = 4
 1574               	.LBB4:
 210:ServerLLDN.c  **** 		for(int i = 0; i < 32; i++)
 1575               		.loc 6 210 0
 1576 0786 1A82      		std Y+2,__zero_reg__
 1577 0788 1982      		std Y+1,__zero_reg__
 1578 078a 00C0      		rjmp .L37
 1579               	.L38:
 211:ServerLLDN.c  **** 		{
 212:ServerLLDN.c  **** 			ACKFrame.ackFlags[i] = 0;
 1580               		.loc 6 212 0 discriminator 3
 1581 078c 8981      		ldd r24,Y+1
 1582 078e 9A81      		ldd r25,Y+2
 1583 0790 8050      		subi r24,lo8(-(ACKFrame+1))
 1584 0792 9040      		sbci r25,hi8(-(ACKFrame+1))
 1585 0794 FC01      		movw r30,r24
 1586 0796 1082      		st Z,__zero_reg__
 210:ServerLLDN.c  **** 		for(int i = 0; i < 32; i++)
 1587               		.loc 6 210 0 discriminator 3
 1588 0798 8981      		ldd r24,Y+1
 1589 079a 9A81      		ldd r25,Y+2
 1590 079c 0196      		adiw r24,1
 1591 079e 9A83      		std Y+2,r25
 1592 07a0 8983      		std Y+1,r24
 1593               	.L37:
 210:ServerLLDN.c  **** 		for(int i = 0; i < 32; i++)
 1594               		.loc 6 210 0 is_stmt 0 discriminator 1
 1595 07a2 8981      		ldd r24,Y+1
 1596 07a4 9A81      		ldd r25,Y+2
 1597 07a6 8097      		sbiw r24,32
 1598 07a8 04F0      		brlt .L38
 1599               	.LBE4:
 213:ServerLLDN.c  **** 		}
 214:ServerLLDN.c  **** 		
 215:ServerLLDN.c  **** 		/* Prepare Beacon Message as first beacon in discovery state */		
 216:ServerLLDN.c  **** 		msgReq.dstAddr				= 0;
 1600               		.loc 6 216 0 is_stmt 1
 1601 07aa 1092 0000 		sts msgReq+5+1,__zero_reg__
 1602 07ae 1092 0000 		sts msgReq+5,__zero_reg__
 217:ServerLLDN.c  **** 		msgReq.dstEndpoint			= APP_BEACON_ENDPOINT;
 1603               		.loc 6 217 0
 1604 07b2 1092 0000 		sts msgReq+7,__zero_reg__
 218:ServerLLDN.c  **** 		msgReq.srcEndpoint			= APP_BEACON_ENDPOINT;
 1605               		.loc 6 218 0
 1606 07b6 1092 0000 		sts msgReq+8,__zero_reg__
 219:ServerLLDN.c  **** 		msgReq.options				= NWK_OPT_LLDN_BEACON | NWK_OPT_DISCOVERY_STATE;
 1607               		.loc 6 219 0
 1608 07ba 80E4      		ldi r24,lo8(64)
 1609 07bc 91E0      		ldi r25,lo8(1)
 1610 07be 9093 0000 		sts msgReq+9+1,r25
 1611 07c2 8093 0000 		sts msgReq+9,r24
 220:ServerLLDN.c  **** 		msgReq.data					= NULL;
 1612               		.loc 6 220 0
 1613 07c6 1092 0000 		sts msgReq+13+1,__zero_reg__
 1614 07ca 1092 0000 		sts msgReq+13,__zero_reg__
 221:ServerLLDN.c  **** 		msgReq.size					= 0;
 1615               		.loc 6 221 0
 1616 07ce 1092 0000 		sts msgReq+15,__zero_reg__
 222:ServerLLDN.c  **** 		
 223:ServerLLDN.c  **** 		
 224:ServerLLDN.c  **** 		// esse if  para s inicializar os clocks se for o primeiro do ciclo
 225:ServerLLDN.c  **** 		// precisa ser mudado para quando for fazer em funo do nmero de nodos que 
 226:ServerLLDN.c  **** 		// quer que seja associado
 227:ServerLLDN.c  **** 		if(cycles_counter == 0 /*macLLDNdiscoveryModeTimeout*/) 
 1617               		.loc 6 227 0
 1618 07d2 8091 0000 		lds r24,cycles_counter
 1619 07d6 8823      		tst r24
 1620 07d8 01F0      		breq .+2
 1621 07da 00C0      		rjmp .L40
 228:ServerLLDN.c  **** 		{
 229:ServerLLDN.c  **** 			
 230:ServerLLDN.c  **** 		/* Calculates Beacon Intervals according to 802.15.4e - 2012 p. 70 */
 231:ServerLLDN.c  **** 		n = 127; // 180 -safe octets
 1622               		.loc 6 231 0
 1623 07dc 8FE7      		ldi r24,lo8(127)
 1624 07de 8093 0000 		sts n,r24
 232:ServerLLDN.c  **** 		tTS =  ((p_var*sp + (m+n)*sm + macMinLIFSPeriod)/v_var); // 0.009088 seconds with n = 255 
 1625               		.loc 6 232 0
 1626 07e2 8091 0000 		lds r24,n
 1627 07e6 882F      		mov r24,r24
 1628 07e8 90E0      		ldi r25,0
 1629 07ea 0396      		adiw r24,3
 1630 07ec 880F      		lsl r24
 1631 07ee 991F      		rol r25
 1632 07f0 092E      		mov __tmp_reg__,r25
 1633 07f2 000C      		lsl r0
 1634 07f4 AA0B      		sbc r26,r26
 1635 07f6 BB0B      		sbc r27,r27
 1636 07f8 BC01      		movw r22,r24
 1637 07fa CD01      		movw r24,r26
 1638 07fc 0E94 0000 		call __floatsisf
 1639 0800 DC01      		movw r26,r24
 1640 0802 CB01      		movw r24,r22
 1641 0804 20E0      		ldi r18,0
 1642 0806 30E0      		ldi r19,0
 1643 0808 40E4      		ldi r20,lo8(64)
 1644 080a 51E4      		ldi r21,lo8(65)
 1645 080c BC01      		movw r22,r24
 1646 080e CD01      		movw r24,r26
 1647 0810 0E94 0000 		call __addsf3
 1648 0814 DC01      		movw r26,r24
 1649 0816 CB01      		movw r24,r22
 1650 0818 20E0      		ldi r18,0
 1651 081a 30E0      		ldi r19,0
 1652 081c 40E2      		ldi r20,lo8(32)
 1653 081e 52E4      		ldi r21,lo8(66)
 1654 0820 BC01      		movw r22,r24
 1655 0822 CD01      		movw r24,r26
 1656 0824 0E94 0000 		call __addsf3
 1657 0828 DC01      		movw r26,r24
 1658 082a CB01      		movw r24,r22
 1659 082c 20E0      		ldi r18,0
 1660 082e 34E2      		ldi r19,lo8(36)
 1661 0830 44E7      		ldi r20,lo8(116)
 1662 0832 57E4      		ldi r21,lo8(71)
 1663 0834 BC01      		movw r22,r24
 1664 0836 CD01      		movw r24,r26
 1665 0838 0E94 0000 		call __divsf3
 1666 083c DC01      		movw r26,r24
 1667 083e CB01      		movw r24,r22
 1668 0840 8093 0000 		sts tTS,r24
 1669 0844 9093 0000 		sts tTS+1,r25
 1670 0848 A093 0000 		sts tTS+2,r26
 1671 084c B093 0000 		sts tTS+3,r27
 233:ServerLLDN.c  **** 		#if (MASTER_MACSC == 1)
 234:ServerLLDN.c  **** 		
 235:ServerLLDN.c  **** 			beaconInterval = 2 * numBaseTimeSlotperMgmt * (tTS) / (SYMBOL_TIME);
 1672               		.loc 6 235 0
 1673 0850 8091 0000 		lds r24,tTS
 1674 0854 9091 0000 		lds r25,tTS+1
 1675 0858 A091 0000 		lds r26,tTS+2
 1676 085c B091 0000 		lds r27,tTS+3
 1677 0860 20E0      		ldi r18,0
 1678 0862 30E0      		ldi r19,0
 1679 0864 40E0      		ldi r20,0
 1680 0866 51E4      		ldi r21,lo8(65)
 1681 0868 BC01      		movw r22,r24
 1682 086a CD01      		movw r24,r26
 1683 086c 0E94 0000 		call __mulsf3
 1684 0870 DC01      		movw r26,r24
 1685 0872 CB01      		movw r24,r22
 1686 0874 2DEB      		ldi r18,lo8(-67)
 1687 0876 37E3      		ldi r19,lo8(55)
 1688 0878 46E8      		ldi r20,lo8(-122)
 1689 087a 57E3      		ldi r21,lo8(55)
 1690 087c BC01      		movw r22,r24
 1691 087e CD01      		movw r24,r26
 1692 0880 0E94 0000 		call __divsf3
 1693 0884 DC01      		movw r26,r24
 1694 0886 CB01      		movw r24,r22
 1695 0888 8093 0000 		sts beaconInterval,r24
 1696 088c 9093 0000 		sts beaconInterval+1,r25
 1697 0890 A093 0000 		sts beaconInterval+2,r26
 1698 0894 B093 0000 		sts beaconInterval+3,r27
 236:ServerLLDN.c  **** 			/*
 237:ServerLLDN.c  **** 			* Configure interrupts callback functions
 238:ServerLLDN.c  **** 			* overflow interrupt, compare 1,2,3 interrupts
 239:ServerLLDN.c  **** 			*/
 240:ServerLLDN.c  **** 			macsc_set_cmp1_int_cb(lldn_server_beacon);
 1699               		.loc 6 240 0
 1700 0898 80E0      		ldi r24,lo8(gs(lldn_server_beacon))
 1701 089a 90E0      		ldi r25,hi8(gs(lldn_server_beacon))
 1702 089c 0E94 0000 		call macsc_set_cmp1_int_cb
 241:ServerLLDN.c  **** 			//macsc_set_cmp3_int_cb(downlink_delay_handler);
 242:ServerLLDN.c  **** 
 243:ServerLLDN.c  **** 			/*
 244:ServerLLDN.c  **** 			* Configure MACSC to generate compare interrupts from channels 1,2,3
 245:ServerLLDN.c  **** 			* Set compare mode to absolute, set compare value.
 246:ServerLLDN.c  **** 			*/
 247:ServerLLDN.c  **** 			macsc_enable_manual_bts();
 1703               		.loc 6 247 0
 1704 08a0 0E94 0000 		call macsc_enable_manual_bts
 248:ServerLLDN.c  **** 			macsc_enable_cmp_int(MACSC_CC1);
 1705               		.loc 6 248 0
 1706 08a4 81E0      		ldi r24,lo8(1)
 1707 08a6 0E94 0000 		call macsc_enable_cmp_int
 249:ServerLLDN.c  **** 			//macsc_enable_cmp_int(MACSC_CC3);
 250:ServerLLDN.c  **** 
 251:ServerLLDN.c  **** 			
 252:ServerLLDN.c  **** 			macsc_use_cmp(MACSC_RELATIVE_CMP, beaconInterval , MACSC_CC1);
 1708               		.loc 6 252 0
 1709 08aa 8091 0000 		lds r24,beaconInterval
 1710 08ae 9091 0000 		lds r25,beaconInterval+1
 1711 08b2 A091 0000 		lds r26,beaconInterval+2
 1712 08b6 B091 0000 		lds r27,beaconInterval+3
 1713 08ba BC01      		movw r22,r24
 1714 08bc CD01      		movw r24,r26
 1715 08be 0E94 0000 		call __fixunssfsi
 1716 08c2 DC01      		movw r26,r24
 1717 08c4 CB01      		movw r24,r22
 1718 08c6 21E0      		ldi r18,lo8(1)
 1719 08c8 AC01      		movw r20,r24
 1720 08ca BD01      		movw r22,r26
 1721 08cc 81E0      		ldi r24,lo8(1)
 1722 08ce 0E94 0000 		call macsc_use_cmp
 253:ServerLLDN.c  **** 			
 254:ServerLLDN.c  **** 			macsc_use_cmp(MACSC_RELATIVE_CMP,DELAY , MACSC_CC3);
 1723               		.loc 6 254 0
 1724 08d2 23E0      		ldi r18,lo8(3)
 1725 08d4 44E6      		ldi r20,lo8(100)
 1726 08d6 50E0      		ldi r21,0
 1727 08d8 60E0      		ldi r22,0
 1728 08da 70E0      		ldi r23,0
 1729 08dc 81E0      		ldi r24,lo8(1)
 1730 08de 0E94 0000 		call macsc_use_cmp
 1731               	.L40:
 255:ServerLLDN.c  **** 			
 256:ServerLLDN.c  **** 			#if TIMESLOT_TIMER
 257:ServerLLDN.c  **** 			macsc_set_cmp2_int_cb(teste_handler);	
 258:ServerLLDN.c  **** 			macsc_enable_cmp_int(MACSC_CC2);
 259:ServerLLDN.c  **** 			macsc_use_cmp(MACSC_RELATIVE_CMP, beaconInterval / 2, MACSC_CC2);
 260:ServerLLDN.c  **** 			#endif
 261:ServerLLDN.c  **** 			
 262:ServerLLDN.c  **** 		#endif
 263:ServerLLDN.c  **** 		}
 264:ServerLLDN.c  **** 	}
 1732               		.loc 6 264 0
 1733 08e2 0000      		nop
 1734               	/* epilogue start */
 1735 08e4 0F90      		pop __tmp_reg__
 1736 08e6 0F90      		pop __tmp_reg__
 1737 08e8 DF91      		pop r29
 1738 08ea CF91      		pop r28
 1739 08ec 0895      		ret
 1740               		.cfi_endproc
 1741               	.LFE141:
 1744               	appInit:
 1745               	.LFB142:
 265:ServerLLDN.c  **** 
 266:ServerLLDN.c  **** #else 
 267:ServerLLDN.c  **** 	static NwkFrameBeaconHeaderLLDN_t *rec_beacon;
 268:ServerLLDN.c  **** 	static NWK_ConfigStatus_t msgConfigStatus;
 269:ServerLLDN.c  **** 	static NWK_DiscoverResponse_t msgDiscResponse;
 270:ServerLLDN.c  **** 
 271:ServerLLDN.c  **** 	static uint8_t payloadSize = 0x01;
 272:ServerLLDN.c  **** 	static uint8_t assTimeSlot = 0xFF;
 273:ServerLLDN.c  **** 	static bool ack_received;
 274:ServerLLDN.c  **** 	bool associated = 0;
 275:ServerLLDN.c  **** 	
 276:ServerLLDN.c  **** 	static void send_message_timeHandler(void)
 277:ServerLLDN.c  **** 	{
 278:ServerLLDN.c  **** 		appState = APP_STATE_SEND;	
 279:ServerLLDN.c  **** 	}
 280:ServerLLDN.c  **** 	
 281:ServerLLDN.c  **** 	static void end_cap(void)
 282:ServerLLDN.c  **** 	{
 283:ServerLLDN.c  **** 		PHY_ResetRadio();
 284:ServerLLDN.c  **** 	}
 285:ServerLLDN.c  **** 	
 286:ServerLLDN.c  **** 	static bool appBeaconInd(NWK_DataInd_t *ind)
 287:ServerLLDN.c  **** 	{
 288:ServerLLDN.c  **** 		macsc_enable_manual_bts();	
 289:ServerLLDN.c  **** 		rec_beacon = (NwkFrameBeaconHeaderLLDN_t*)ind->data;
 290:ServerLLDN.c  **** 		PanId = rec_beacon->PanId; // s pode mudar se ele associar
 291:ServerLLDN.c  **** 			// mudar nome ack_Received
 292:ServerLLDN.c  **** 		if( (rec_beacon->Flags.txState == DISC_MODE && !ack_received) || 
 293:ServerLLDN.c  **** 			(rec_beacon->Flags.txState == CONFIG_MODE && ack_received))
 294:ServerLLDN.c  **** 		{
 295:ServerLLDN.c  **** 			int msg_wait_time = rec_beacon->Flags.numBaseMgmtTimeslots * rec_beacon->TimeSlotSize* 2 ; // sy
 296:ServerLLDN.c  **** 			macsc_set_cmp1_int_cb(send_message_timeHandler);
 297:ServerLLDN.c  **** 			
 298:ServerLLDN.c  **** 			macsc_enable_cmp_int(MACSC_CC1);	  
 299:ServerLLDN.c  **** 			macsc_use_cmp(MACSC_RELATIVE_CMP, msg_wait_time , MACSC_CC1);
 300:ServerLLDN.c  **** 			appState = (rec_beacon->Flags.txState == DISC_MODE) ? APP_STATE_PREP_DISC_REPONSE : APP_STATE_PR
 301:ServerLLDN.c  **** 			/*
 302:ServerLLDN.c  **** 			macsc_set_cmp2_int_cb(end_cap);	
 303:ServerLLDN.c  **** 			macsc_enable_cmp_int(MACSC_CC2);
 304:ServerLLDN.c  **** 			macsc_use_cmp(MACSC_RELATIVE_CMP, 2 * msg_wait_time, MACSC_CC2);
 305:ServerLLDN.c  **** 			*/
 306:ServerLLDN.c  **** 		}
 307:ServerLLDN.c  **** 		else if (rec_beacon->Flags.txState == RESET_MODE)
 308:ServerLLDN.c  **** 		{
 309:ServerLLDN.c  **** 			
 310:ServerLLDN.c  **** 			ack_received = 0;
 311:ServerLLDN.c  **** 			associated = 0;
 312:ServerLLDN.c  **** 			printf("ack = %d" ,ack_received);
 313:ServerLLDN.c  **** 		}
 314:ServerLLDN.c  **** 			
 315:ServerLLDN.c  **** 		return true;
 316:ServerLLDN.c  **** 	}
 317:ServerLLDN.c  **** 	
 318:ServerLLDN.c  **** 	static bool appAckInd(NWK_DataInd_t *ind)
 319:ServerLLDN.c  **** 	{
 320:ServerLLDN.c  **** 		NWK_ACKFormat_t *ackframe = (NWK_ACKFormat_t*)ind->data;
 321:ServerLLDN.c  **** 		if(PanId == ackframe->sourceId)
 322:ServerLLDN.c  **** 		{
 323:ServerLLDN.c  **** 			int pos = APP_ADDR / 8;
 324:ServerLLDN.c  **** 			int bit_shift = 8 - APP_ADDR % 8;
 325:ServerLLDN.c  **** 			if( ackframe->ackFlags[pos] & 1 << bit_shift)	
 326:ServerLLDN.c  **** 				{
 327:ServerLLDN.c  **** 				printf("\n ack true");
 328:ServerLLDN.c  **** 				ack_received = true;
 329:ServerLLDN.c  **** 				}
 330:ServerLLDN.c  **** 		}
 331:ServerLLDN.c  **** 		return true;
 332:ServerLLDN.c  **** 	}
 333:ServerLLDN.c  **** 	
 334:ServerLLDN.c  **** 	static bool appCommandInd(NWK_DataInd_t *ind)
 335:ServerLLDN.c  **** 	{
 336:ServerLLDN.c  **** 		if(ind->data[0] == LL_CONFIGURATION_REQUEST)
 337:ServerLLDN.c  **** 		{
 338:ServerLLDN.c  **** 			NWK_ConfigRequest_t *msg = (NWK_ConfigRequest_t*)ind->data;
 339:ServerLLDN.c  **** 			if(msg->macAddr == APP_ADDR)
 340:ServerLLDN.c  **** 			{
 341:ServerLLDN.c  **** 				associated = 1;
 342:ServerLLDN.c  **** 			}
 343:ServerLLDN.c  **** 		}
 344:ServerLLDN.c  **** 		return true;
 345:ServerLLDN.c  **** 	}
 346:ServerLLDN.c  **** 
 347:ServerLLDN.c  **** 	void appPrepareDiscoverResponse()
 348:ServerLLDN.c  **** 	{
 349:ServerLLDN.c  **** 		msgDiscResponse.id					= LL_DISCOVER_RESPONSE;
 350:ServerLLDN.c  **** 		msgDiscResponse.macAddr				= APP_ADDR;
 351:ServerLLDN.c  **** 		msgDiscResponse.ts_dir.tsDuration	= payloadSize;
 352:ServerLLDN.c  **** 		msgDiscResponse.ts_dir.dirIndicator = 1;
 353:ServerLLDN.c  **** 		
 354:ServerLLDN.c  **** 		msgReq.dstAddr				= 0;
 355:ServerLLDN.c  **** 		msgReq.dstEndpoint			= APP_COMMAND_ENDPOINT;
 356:ServerLLDN.c  **** 		msgReq.srcEndpoint			= APP_COMMAND_ENDPOINT;
 357:ServerLLDN.c  **** 		msgReq.options				= NWK_OPT_MAC_COMMAND;
 358:ServerLLDN.c  **** 		msgReq.data					= (uint8_t*)&msgDiscResponse;
 359:ServerLLDN.c  **** 		msgReq.size					= sizeof(msgDiscResponse);
 360:ServerLLDN.c  **** 	}
 361:ServerLLDN.c  **** 	
 362:ServerLLDN.c  **** 	void appPrepareConfigurationStatus()
 363:ServerLLDN.c  **** 	{
 364:ServerLLDN.c  **** 		msgConfigStatus.id					  = LL_CONFIGURATION_STATUS;
 365:ServerLLDN.c  **** 		msgConfigStatus.macAddr				  = APP_ADDR;
 366:ServerLLDN.c  **** 		msgConfigStatus.s_macAddr			  = APP_ADDR;
 367:ServerLLDN.c  **** 		msgConfigStatus.ts_dir.tsDuration	  = payloadSize;
 368:ServerLLDN.c  **** 		msgConfigStatus.ts_dir.dirIndicator   = 1;
 369:ServerLLDN.c  **** 		// assTimeSlot precisa ser variado quando for implementar
 370:ServerLLDN.c  **** 		// no caso inicial a rede no est em andamento ainda portanto faz
 371:ServerLLDN.c  **** 		// sentido nenhum nodo ter timeslot assigned
 372:ServerLLDN.c  **** 		msgConfigStatus.assTimeSlot = 0;
 373:ServerLLDN.c  **** 
 374:ServerLLDN.c  **** 		
 375:ServerLLDN.c  **** 		msgReq.dstAddr				= 0;
 376:ServerLLDN.c  **** 		msgReq.dstEndpoint			= APP_COMMAND_ENDPOINT;
 377:ServerLLDN.c  **** 		msgReq.srcEndpoint			= APP_COMMAND_ENDPOINT;
 378:ServerLLDN.c  **** 		msgReq.options				= NWK_OPT_MAC_COMMAND;
 379:ServerLLDN.c  **** 		msgReq.data					= (uint8_t*)&msgConfigStatus;
 380:ServerLLDN.c  **** 		msgReq.size					= sizeof(msgConfigStatus);
 381:ServerLLDN.c  **** 	}
 382:ServerLLDN.c  **** 	
 383:ServerLLDN.c  **** #endif // APP_COORDINATOR
 384:ServerLLDN.c  **** 
 385:ServerLLDN.c  **** static void appInit(void)
 386:ServerLLDN.c  **** {
 1746               		.loc 6 386 0
 1747               		.cfi_startproc
 1748 08ee CF93      		push r28
 1749               	.LCFI72:
 1750               		.cfi_def_cfa_offset 3
 1751               		.cfi_offset 28, -2
 1752 08f0 DF93      		push r29
 1753               	.LCFI73:
 1754               		.cfi_def_cfa_offset 4
 1755               		.cfi_offset 29, -3
 1756 08f2 CDB7      		in r28,__SP_L__
 1757 08f4 DEB7      		in r29,__SP_H__
 1758               	.LCFI74:
 1759               		.cfi_def_cfa_register 28
 1760               	/* prologue: function */
 1761               	/* frame size = 0 */
 1762               	/* stack size = 2 */
 1763               	.L__stack_usage = 2
 387:ServerLLDN.c  **** 	NWK_SetAddr(APP_ADDR);
 1764               		.loc 6 387 0
 1765 08f6 80E0      		ldi r24,0
 1766 08f8 90E0      		ldi r25,0
 1767 08fa 0E94 0000 		call NWK_SetAddr
 388:ServerLLDN.c  **** 	PHY_SetChannel(APP_CHANNEL);
 1768               		.loc 6 388 0
 1769 08fe 8FE0      		ldi r24,lo8(15)
 1770 0900 0E94 0000 		call PHY_SetChannel
 389:ServerLLDN.c  **** 	PHY_SetRxState(true);
 1771               		.loc 6 389 0
 1772 0904 81E0      		ldi r24,lo8(1)
 1773 0906 0E94 0000 		call PHY_SetRxState
 390:ServerLLDN.c  **** 		
 391:ServerLLDN.c  **** 	#if APP_COORDINATOR
 392:ServerLLDN.c  **** 	  tmrDiscoveryMode.interval = 2500;
 1774               		.loc 6 392 0
 1775 090a 84EC      		ldi r24,lo8(-60)
 1776 090c 99E0      		ldi r25,lo8(9)
 1777 090e A0E0      		ldi r26,0
 1778 0910 B0E0      		ldi r27,0
 1779 0912 8093 0000 		sts tmrDiscoveryMode+6,r24
 1780 0916 9093 0000 		sts tmrDiscoveryMode+6+1,r25
 1781 091a A093 0000 		sts tmrDiscoveryMode+6+2,r26
 1782 091e B093 0000 		sts tmrDiscoveryMode+6+3,r27
 393:ServerLLDN.c  **** 	  tmrDiscoveryMode.mode = SYS_TIMER_PERIODIC_MODE;
 1783               		.loc 6 393 0
 1784 0922 81E0      		ldi r24,lo8(1)
 1785 0924 8093 0000 		sts tmrDiscoveryMode+10,r24
 394:ServerLLDN.c  **** 	  tmrDiscoveryMode.handler = tmrDiscoveryModeHandler;
 1786               		.loc 6 394 0
 1787 0928 80E0      		ldi r24,lo8(gs(tmrDiscoveryModeHandler))
 1788 092a 90E0      		ldi r25,hi8(gs(tmrDiscoveryModeHandler))
 1789 092c 9093 0000 		sts tmrDiscoveryMode+11+1,r25
 1790 0930 8093 0000 		sts tmrDiscoveryMode+11,r24
 395:ServerLLDN.c  **** 	  //SYS_TimerStart(&tmrDiscoveryMode);
 396:ServerLLDN.c  **** 	  
 397:ServerLLDN.c  **** 	  tmrDelay_Discovery.interval = 2;
 1791               		.loc 6 397 0
 1792 0934 82E0      		ldi r24,lo8(2)
 1793 0936 90E0      		ldi r25,0
 1794 0938 A0E0      		ldi r26,0
 1795 093a B0E0      		ldi r27,0
 1796 093c 8093 0000 		sts tmrDelay_Discovery+6,r24
 1797 0940 9093 0000 		sts tmrDelay_Discovery+6+1,r25
 1798 0944 A093 0000 		sts tmrDelay_Discovery+6+2,r26
 1799 0948 B093 0000 		sts tmrDelay_Discovery+6+3,r27
 398:ServerLLDN.c  **** 	  tmrDelay_Discovery.mode = SYS_TIMER_INTERVAL_MODE;
 1800               		.loc 6 398 0
 1801 094c 1092 0000 		sts tmrDelay_Discovery+10,__zero_reg__
 399:ServerLLDN.c  **** 	  tmrDelay_Discovery.handler = tmrDelayHandler;
 1802               		.loc 6 399 0
 1803 0950 80E0      		ldi r24,lo8(gs(tmrDelayHandler))
 1804 0952 90E0      		ldi r25,hi8(gs(tmrDelayHandler))
 1805 0954 9093 0000 		sts tmrDelay_Discovery+11+1,r25
 1806 0958 8093 0000 		sts tmrDelay_Discovery+11,r24
 400:ServerLLDN.c  **** 	  //SYS_TimerStart(&tmrDelay);
 401:ServerLLDN.c  **** 	  
 402:ServerLLDN.c  **** 	  tmrDelay_Configuration.interval = 3;
 1807               		.loc 6 402 0
 1808 095c 83E0      		ldi r24,lo8(3)
 1809 095e 90E0      		ldi r25,0
 1810 0960 A0E0      		ldi r26,0
 1811 0962 B0E0      		ldi r27,0
 1812 0964 8093 0000 		sts tmrDelay_Configuration+6,r24
 1813 0968 9093 0000 		sts tmrDelay_Configuration+6+1,r25
 1814 096c A093 0000 		sts tmrDelay_Configuration+6+2,r26
 1815 0970 B093 0000 		sts tmrDelay_Configuration+6+3,r27
 403:ServerLLDN.c  **** 	  tmrDelay_Configuration.mode = SYS_TIMER_INTERVAL_MODE;
 1816               		.loc 6 403 0
 1817 0974 1092 0000 		sts tmrDelay_Configuration+10,__zero_reg__
 404:ServerLLDN.c  **** 	  tmrDelay_Configuration.handler = tmrDelayHandler;
 1818               		.loc 6 404 0
 1819 0978 80E0      		ldi r24,lo8(gs(tmrDelayHandler))
 1820 097a 90E0      		ldi r25,hi8(gs(tmrDelayHandler))
 1821 097c 9093 0000 		sts tmrDelay_Configuration+11+1,r25
 1822 0980 8093 0000 		sts tmrDelay_Configuration+11,r24
 405:ServerLLDN.c  **** 	  //SYS_TimerStart(&tmrDelay);
 406:ServerLLDN.c  **** 	  
 407:ServerLLDN.c  **** 		/* 
 408:ServerLLDN.c  **** 		* Disable CSMA/CA
 409:ServerLLDN.c  **** 		* Disable auto ACK
 410:ServerLLDN.c  **** 		*/
 411:ServerLLDN.c  **** 		NWK_SetPanId(APP_PANID);
 1823               		.loc 6 411 0
 1824 0984 8EEF      		ldi r24,lo8(-2)
 1825 0986 9AEC      		ldi r25,lo8(-54)
 1826 0988 0E94 0000 		call NWK_SetPanId
 412:ServerLLDN.c  **** 		PanId = APP_PANID;
 1827               		.loc 6 412 0
 1828 098c 8EEF      		ldi r24,lo8(-2)
 1829 098e 8093 0000 		sts PanId,r24
 413:ServerLLDN.c  **** 		ACKFrame.sourceId = APP_PANID;
 1830               		.loc 6 413 0
 1831 0992 8EEF      		ldi r24,lo8(-2)
 1832 0994 8093 0000 		sts ACKFrame,r24
 414:ServerLLDN.c  **** 		PHY_SetTdmaMode(true);
 1833               		.loc 6 414 0
 1834 0998 81E0      		ldi r24,lo8(1)
 1835 099a 0E94 0000 		call PHY_SetTdmaMode
 415:ServerLLDN.c  **** 		NWK_OpenEndpoint(APP_COMMAND_ENDPOINT, appCommandInd);
 1836               		.loc 6 415 0
 1837 099e 60E0      		ldi r22,lo8(gs(appCommandInd))
 1838 09a0 70E0      		ldi r23,hi8(gs(appCommandInd))
 1839 09a2 83E0      		ldi r24,lo8(3)
 1840 09a4 0E94 0000 		call NWK_OpenEndpoint
 416:ServerLLDN.c  **** 	#else
 417:ServerLLDN.c  **** 		printf("\nLIGOU");
 418:ServerLLDN.c  **** 		PHY_SetTdmaMode(false);
 419:ServerLLDN.c  **** 		PHY_SetOptimizedCSMAValues();
 420:ServerLLDN.c  **** 		
 421:ServerLLDN.c  **** 		payloadSize = 0x01;
 422:ServerLLDN.c  **** 		NWK_OpenEndpoint(APP_BEACON_ENDPOINT, appBeaconInd);
 423:ServerLLDN.c  **** 		NWK_OpenEndpoint(APP_ACK_ENDPOINT, appAckInd);
 424:ServerLLDN.c  **** 		NWK_OpenEndpoint(APP_COMMAND_ENDPOINT, appCommandInd);
 425:ServerLLDN.c  **** 		/*
 426:ServerLLDN.c  **** 		* Configure interrupts callback functions
 427:ServerLLDN.c  **** 		*/
 428:ServerLLDN.c  **** 		
 429:ServerLLDN.c  **** 	#endif // APP_COORDENATOR
 430:ServerLLDN.c  **** 	PHY_SetPromiscuousMode(true);
 1841               		.loc 6 430 0
 1842 09a8 81E0      		ldi r24,lo8(1)
 1843 09aa 0E94 0000 		call PHY_SetPromiscuousMode
 431:ServerLLDN.c  **** 
 432:ServerLLDN.c  **** }
 1844               		.loc 6 432 0
 1845 09ae 0000      		nop
 1846               	/* epilogue start */
 1847 09b0 DF91      		pop r29
 1848 09b2 CF91      		pop r28
 1849 09b4 0895      		ret
 1850               		.cfi_endproc
 1851               	.LFE142:
 1853               		.section	.rodata
 1854               	.LC7:
 1855 006d 0A00      		.string	"\n"
 1856               	.LC8:
 1857 006f 0A25 6400 		.string	"\n%d"
 1858               	.LC9:
 1859 0073 0A54 4849 		.string	"\nTHIRD BEACON"
 1859      5244 2042 
 1859      4541 434F 
 1859      4E00 
 1860               		.text
 1862               	APP_TaskHandler:
 1863               	.LFB143:
 433:ServerLLDN.c  **** 
 434:ServerLLDN.c  **** static void APP_TaskHandler(void)
 435:ServerLLDN.c  **** {
 1864               		.loc 6 435 0
 1865               		.cfi_startproc
 1866 09b6 CF93      		push r28
 1867               	.LCFI75:
 1868               		.cfi_def_cfa_offset 3
 1869               		.cfi_offset 28, -2
 1870 09b8 DF93      		push r29
 1871               	.LCFI76:
 1872               		.cfi_def_cfa_offset 4
 1873               		.cfi_offset 29, -3
 1874 09ba CDB7      		in r28,__SP_L__
 1875 09bc DEB7      		in r29,__SP_H__
 1876               	.LCFI77:
 1877               		.cfi_def_cfa_register 28
 1878               	/* prologue: function */
 1879               	/* frame size = 0 */
 1880               	/* stack size = 2 */
 1881               	.L__stack_usage = 2
 436:ServerLLDN.c  **** 	switch (appState){
 1882               		.loc 6 436 0
 1883 09be 8091 0000 		lds r24,appState
 1884 09c2 882F      		mov r24,r24
 1885 09c4 90E0      		ldi r25,0
 1886 09c6 8230      		cpi r24,2
 1887 09c8 9105      		cpc r25,__zero_reg__
 1888 09ca 01F0      		breq .L44
 1889 09cc 8330      		cpi r24,3
 1890 09ce 9105      		cpc r25,__zero_reg__
 1891 09d0 01F0      		breq .L45
 1892 09d2 892B      		or r24,r25
 1893 09d4 01F0      		breq .L46
 437:ServerLLDN.c  **** 		case APP_STATE_INITIAL:
 438:ServerLLDN.c  **** 		{
 439:ServerLLDN.c  **** 			appInit();
 440:ServerLLDN.c  **** 			#if APP_COORDINATOR
 441:ServerLLDN.c  **** 				appState = APP_STATE_ATT_PAN_STATE;
 442:ServerLLDN.c  **** 			#else
 443:ServerLLDN.c  **** 				appState = APP_STATE_IDLE;
 444:ServerLLDN.c  **** 			#endif
 445:ServerLLDN.c  **** 			break;
 446:ServerLLDN.c  **** 		}
 447:ServerLLDN.c  **** 		case APP_STATE_SEND:
 448:ServerLLDN.c  **** 		{
 449:ServerLLDN.c  **** 			appSendData();
 450:ServerLLDN.c  **** 			#if APP_COORDINATOR
 451:ServerLLDN.c  **** 				appState = APP_STATE_ATT_PAN_STATE;
 452:ServerLLDN.c  **** 			#else
 453:ServerLLDN.c  **** 				appState = APP_STATE_IDLE;
 454:ServerLLDN.c  **** 			#endif
 455:ServerLLDN.c  **** 			break;
 456:ServerLLDN.c  **** 		}
 457:ServerLLDN.c  **** 		#if APP_COORDINATOR // COORDINATOR SPECIFIC STATE MACHINE
 458:ServerLLDN.c  **** 		case APP_STATE_ATT_PAN_STATE:
 459:ServerLLDN.c  **** 		{
 460:ServerLLDN.c  **** 			switch(appPanState)
 461:ServerLLDN.c  **** 			{
 462:ServerLLDN.c  **** 				case APP_PAN_STATE_RESET:
 463:ServerLLDN.c  **** 				{
 464:ServerLLDN.c  **** 					appPanReset();
 465:ServerLLDN.c  **** 					appPanState = APP_PAN_STATE_DISC_INITIAL;
 466:ServerLLDN.c  **** 					appState	= APP_STATE_SEND;
 467:ServerLLDN.c  **** 					cycles_counter = 0;
 468:ServerLLDN.c  **** 					break;
 469:ServerLLDN.c  **** 				}
 470:ServerLLDN.c  **** 				case APP_PAN_STATE_DISC_INITIAL:
 471:ServerLLDN.c  **** 				{
 472:ServerLLDN.c  **** 					printf("\n\n");
 473:ServerLLDN.c  **** 					index_ConfRequest = 0;
 474:ServerLLDN.c  **** 					// cyclies counter precisa ser mudado para quando for fazer os testes
 475:ServerLLDN.c  **** 					// precisa ser em funo do nmero de nodos que queremos associar
 476:ServerLLDN.c  **** 					if(counter_associados == NODOS_ASSOCIADOS_ESPERADOS || cycles_counter > NODOS_ASSOCIADOS_ESPER
 477:ServerLLDN.c  **** 					{	
 478:ServerLLDN.c  **** 						// if(counter_associados >= NODOS_ASSOCIADOS_ESPERADOS)
 479:ServerLLDN.c  **** 							printf("\n%d", cycles_counter);
 480:ServerLLDN.c  **** 						counter_associados = 0;
 481:ServerLLDN.c  **** 						macsc_disable_cmp_int(MACSC_CC1);
 482:ServerLLDN.c  **** 						macsc_disable_cmp_int(MACSC_CC2);
 483:ServerLLDN.c  **** 						macsc_disable_cmp_int(MACSC_CC3);
 484:ServerLLDN.c  **** 						msgReq.options = 0;
 485:ServerLLDN.c  **** 						appState = APP_PAN_STATE_IDLE;
 486:ServerLLDN.c  **** 						appPanState = APP_PAN_STATE_IDLE;
 487:ServerLLDN.c  **** 						
 488:ServerLLDN.c  **** 					}
 489:ServerLLDN.c  **** 					else // este if  se no terminou todos os ciclos, ainda existem nodos a serem associados
 490:ServerLLDN.c  **** 					{
 491:ServerLLDN.c  **** 						appPanDiscInit();
 492:ServerLLDN.c  **** 						appState	= APP_STATE_IDLE;
 493:ServerLLDN.c  **** 						appPanState = APP_PAN_STATE_DISC_SECOND_BE;
 494:ServerLLDN.c  **** 					}
 495:ServerLLDN.c  **** 					break;
 496:ServerLLDN.c  **** 				}
 497:ServerLLDN.c  **** 				case APP_PAN_STATE_DISC_SECOND_BE:
 498:ServerLLDN.c  **** 				{
 499:ServerLLDN.c  **** 					// prepara mensagem como sendo: Beacon do Discovery e o Segundo Beacon
 500:ServerLLDN.c  **** 					msgReq.options = NWK_OPT_LLDN_BEACON | NWK_OPT_DISCOVERY_STATE | NWK_OPT_SECOND_BEACON ;
 501:ServerLLDN.c  **** 					appState	= APP_STATE_IDLE;
 502:ServerLLDN.c  **** 					appPanState = APP_PAN_STATE_DISC_PREPARE_ACK;
 503:ServerLLDN.c  **** 					break;
 504:ServerLLDN.c  **** 				}
 505:ServerLLDN.c  **** 				case APP_PAN_STATE_DISC_PREPARE_ACK:
 506:ServerLLDN.c  **** 				{
 507:ServerLLDN.c  **** 					SYS_TimerStart(&tmrDelay_Discovery);
 508:ServerLLDN.c  **** 					appPanPrepareACK();
 509:ServerLLDN.c  **** 					// precisa mudar para o novo estado, mas precisa esperar o beacon interval acabar
 510:ServerLLDN.c  **** 					// aqui ele vai mudar para preparar pro primeiro beacon do configuration
 511:ServerLLDN.c  **** 					appPanState = APP_PAN_STATE_CONFIG_INITIAL; 
 512:ServerLLDN.c  **** 					appState = APP_STATE_IDLE;
 513:ServerLLDN.c  **** 					break;
 514:ServerLLDN.c  **** 				}
 515:ServerLLDN.c  **** 				case APP_PAN_STATE_CONFIG_INITIAL:
 516:ServerLLDN.c  **** 				{
 517:ServerLLDN.c  **** 					// prepara a mensagem como esndo: Beacon do Configuration e o primeiro Beacon da etapa
 518:ServerLLDN.c  **** 					msgReq.options = NWK_OPT_LLDN_BEACON | NWK_OPT_CONFIG_STATE;
 519:ServerLLDN.c  **** 					appState	= APP_STATE_IDLE;
 520:ServerLLDN.c  **** 					appPanState = APP_PAN_STATE_CONFIG_SECOND_BEACON;
 521:ServerLLDN.c  **** 					break;
 522:ServerLLDN.c  **** 
 523:ServerLLDN.c  **** 				}
 524:ServerLLDN.c  **** 				case APP_PAN_STATE_CONFIG_SECOND_BEACON:
 525:ServerLLDN.c  **** 				{
 526:ServerLLDN.c  **** 					msgReq.options = NWK_OPT_LLDN_BEACON | NWK_OPT_CONFIG_STATE | NWK_OPT_SECOND_BEACON;
 527:ServerLLDN.c  **** 					appState	= APP_STATE_IDLE;
 528:ServerLLDN.c  **** 					appPanState = APP_PAN_STATE_SEND_CONF_REQUEST;
 529:ServerLLDN.c  **** 					break;
 530:ServerLLDN.c  **** 				}
 531:ServerLLDN.c  **** 				case APP_PAN_STATE_SEND_CONF_REQUEST:
 532:ServerLLDN.c  **** 				{
 533:ServerLLDN.c  **** 					//if(not_sent_yet = 1)
 534:ServerLLDN.c  **** 					//{
 535:ServerLLDN.c  **** 					if(index_ConfRequest > 0)
 536:ServerLLDN.c  **** 					{
 537:ServerLLDN.c  **** 						CopyToConfigRequest(index_ConfRequest);
 538:ServerLLDN.c  **** 						msgReq.options		= NWK_OPT_MAC_COMMAND;
 539:ServerLLDN.c  **** 						msgReq.data			= (uint8_t*)&ConfigRequest;
 540:ServerLLDN.c  **** 						msgReq.size			= sizeof(NWK_ConfigRequest_t);
 541:ServerLLDN.c  **** 						appState	= APP_STATE_IDLE;
 542:ServerLLDN.c  **** 						appPanState = APP_PAN_STATE_SEND_CONF_REQUEST;
 543:ServerLLDN.c  **** 						index_ConfRequest--;
 544:ServerLLDN.c  **** 						counter_associados++;
 545:ServerLLDN.c  **** 						SYS_TimerStart(&tmrDelay_Configuration);
 546:ServerLLDN.c  **** 					}
 547:ServerLLDN.c  **** 					else
 548:ServerLLDN.c  **** 					{
 549:ServerLLDN.c  **** 						appPanState = APP_PAN_STATE_CONFIG_THIRD_BEACON;
 550:ServerLLDN.c  **** 					}
 551:ServerLLDN.c  **** 					break;
 552:ServerLLDN.c  **** 				}
 553:ServerLLDN.c  **** 				case APP_PAN_STATE_CONFIG_THIRD_BEACON:
 554:ServerLLDN.c  **** 				{
 555:ServerLLDN.c  **** 					printf("\nTHIRD BEACON");
 556:ServerLLDN.c  **** 					msgReq.options = NWK_OPT_LLDN_BEACON | NWK_OPT_CONFIG_STATE | NWK_OPT_THIRD_BEACON;
 557:ServerLLDN.c  **** 					appState	= APP_STATE_IDLE;
 558:ServerLLDN.c  **** 					appPanState = APP_PAN_STATE_DISC_INITIAL;
 559:ServerLLDN.c  **** 					cycles_counter++;	
 560:ServerLLDN.c  **** 					
 561:ServerLLDN.c  **** 					break;
 562:ServerLLDN.c  **** 				}
 563:ServerLLDN.c  **** 				case APP_PAN_STATE_IDLE:
 564:ServerLLDN.c  **** 				{
 565:ServerLLDN.c  **** 					msgReq.options = 0;
 566:ServerLLDN.c  **** 					appState = APP_STATE_IDLE;
 567:ServerLLDN.c  **** 					break;
 568:ServerLLDN.c  **** 				}
 569:ServerLLDN.c  **** 			}
 570:ServerLLDN.c  **** 			break;	
 571:ServerLLDN.c  **** 		}
 572:ServerLLDN.c  **** 		#else // NODES SPECIFIC STATE MACHINE
 573:ServerLLDN.c  **** 		case APP_STATE_PREP_DISC_REPONSE:
 574:ServerLLDN.c  **** 		{
 575:ServerLLDN.c  **** 			// desativar timer espera timeslot
 576:ServerLLDN.c  **** 			if(rec_beacon->confSeqNumber == 0)
 577:ServerLLDN.c  **** 			{
 578:ServerLLDN.c  **** 				appPrepareDiscoverResponse();
 579:ServerLLDN.c  **** 			}
 580:ServerLLDN.c  **** 			else msgReq.options = 0;
 581:ServerLLDN.c  **** 			appState = APP_STATE_IDLE;	
 582:ServerLLDN.c  **** 			break;
 583:ServerLLDN.c  **** 		}
 584:ServerLLDN.c  **** 		
 585:ServerLLDN.c  **** 		case APP_STATE_PREP_CONFIG_STATUS:
 586:ServerLLDN.c  **** 		{
 587:ServerLLDN.c  **** 			// se o nodo recebeu ack na fase do discovery prepara a mensagem de configuration status
 588:ServerLLDN.c  **** 			if(ack_received && rec_beacon->confSeqNumber == 0 && associated == 0) {
 589:ServerLLDN.c  **** 				appPrepareConfigurationStatus();
 590:ServerLLDN.c  **** 			}
 591:ServerLLDN.c  **** 			// se o nodo no recebeu desativa o timer e fica em idle
 592:ServerLLDN.c  **** 			else {
 593:ServerLLDN.c  **** 				macsc_disable_cmp_int(MACSC_CC1);
 594:ServerLLDN.c  **** 			}
 595:ServerLLDN.c  **** 			appState = APP_STATE_IDLE;
 596:ServerLLDN.c  **** 			break;
 597:ServerLLDN.c  **** 		}
 598:ServerLLDN.c  **** 		#endif
 599:ServerLLDN.c  **** 		default:
 600:ServerLLDN.c  **** 		{
 601:ServerLLDN.c  **** 			break;
 1894               		.loc 6 601 0
 1895 09d6 00C0      		rjmp .L47
 1896               	.L46:
 439:ServerLLDN.c  **** 			#if APP_COORDINATOR
 1897               		.loc 6 439 0
 1898 09d8 0E94 0000 		call appInit
 441:ServerLLDN.c  **** 			#else
 1899               		.loc 6 441 0
 1900 09dc 83E0      		ldi r24,lo8(3)
 1901 09de 8093 0000 		sts appState,r24
 445:ServerLLDN.c  **** 		}
 1902               		.loc 6 445 0
 1903 09e2 00C0      		rjmp .L47
 1904               	.L44:
 449:ServerLLDN.c  **** 			#if APP_COORDINATOR
 1905               		.loc 6 449 0
 1906 09e4 0E94 0000 		call appSendData
 451:ServerLLDN.c  **** 			#else
 1907               		.loc 6 451 0
 1908 09e8 83E0      		ldi r24,lo8(3)
 1909 09ea 8093 0000 		sts appState,r24
 455:ServerLLDN.c  **** 		}
 1910               		.loc 6 455 0
 1911 09ee 00C0      		rjmp .L47
 1912               	.L45:
 460:ServerLLDN.c  **** 			{
 1913               		.loc 6 460 0
 1914 09f0 8091 0000 		lds r24,appPanState
 1915 09f4 882F      		mov r24,r24
 1916 09f6 90E0      		ldi r25,0
 1917 09f8 092E      		mov __tmp_reg__,r25
 1918 09fa 000C      		lsl r0
 1919 09fc AA0B      		sbc r26,r26
 1920 09fe BB0B      		sbc r27,r27
 1921 0a00 40E0      		ldi r20,0
 1922 0a02 50E0      		ldi r21,0
 1923 0a04 28E0      		ldi r18,lo8(8)
 1924 0a06 30E0      		ldi r19,0
 1925 0a08 841B      		sub r24,r20
 1926 0a0a 950B      		sbc r25,r21
 1927 0a0c 2817      		cp r18,r24
 1928 0a0e 3907      		cpc r19,r25
 1929 0a10 00F4      		brsh .+2
 1930 0a12 00C0      		rjmp .L64
 1931 0a14 8050      		subi r24,lo8(-(gs(.L50)))
 1932 0a16 9040      		sbci r25,hi8(-(gs(.L50)))
 1933 0a18 FC01      		movw r30,r24
 1934 0a1a 0C94 0000 		jmp __tablejump2__
 1935               		.section	.progmem.gcc_sw_table,"a",@progbits
 1936               		.p2align	1
 1937               	.L50:
 1938 0000 0000      		.word gs(.L49)
 1939 0002 0000      		.word gs(.L51)
 1940 0004 0000      		.word gs(.L52)
 1941 0006 0000      		.word gs(.L53)
 1942 0008 0000      		.word gs(.L54)
 1943 000a 0000      		.word gs(.L55)
 1944 000c 0000      		.word gs(.L56)
 1945 000e 0000      		.word gs(.L57)
 1946 0010 0000      		.word gs(.L58)
 1947               		.text
 1948               	.L51:
 464:ServerLLDN.c  **** 					appPanState = APP_PAN_STATE_DISC_INITIAL;
 1949               		.loc 6 464 0
 1950 0a1e 0E94 0000 		call appPanReset
 465:ServerLLDN.c  **** 					appState	= APP_STATE_SEND;
 1951               		.loc 6 465 0
 1952 0a22 82E0      		ldi r24,lo8(2)
 1953 0a24 8093 0000 		sts appPanState,r24
 466:ServerLLDN.c  **** 					cycles_counter = 0;
 1954               		.loc 6 466 0
 1955 0a28 82E0      		ldi r24,lo8(2)
 1956 0a2a 8093 0000 		sts appState,r24
 467:ServerLLDN.c  **** 					break;
 1957               		.loc 6 467 0
 1958 0a2e 1092 0000 		sts cycles_counter,__zero_reg__
 468:ServerLLDN.c  **** 				}
 1959               		.loc 6 468 0
 1960 0a32 00C0      		rjmp .L48
 1961               	.L52:
 472:ServerLLDN.c  **** 					index_ConfRequest = 0;
 1962               		.loc 6 472 0
 1963 0a34 80E0      		ldi r24,lo8(.LC7)
 1964 0a36 90E0      		ldi r25,hi8(.LC7)
 1965 0a38 0E94 0000 		call puts
 473:ServerLLDN.c  **** 					// cyclies counter precisa ser mudado para quando for fazer os testes
 1966               		.loc 6 473 0
 1967 0a3c 1092 0000 		sts index_ConfRequest+1,__zero_reg__
 1968 0a40 1092 0000 		sts index_ConfRequest,__zero_reg__
 476:ServerLLDN.c  **** 					{	
 1969               		.loc 6 476 0
 1970 0a44 8091 0000 		lds r24,counter_associados
 1971 0a48 9091 0000 		lds r25,counter_associados+1
 1972 0a4c 0397      		sbiw r24,3
 1973 0a4e 01F0      		breq .L59
 476:ServerLLDN.c  **** 					{	
 1974               		.loc 6 476 0 is_stmt 0 discriminator 1
 1975 0a50 8091 0000 		lds r24,cycles_counter
 1976 0a54 8430      		cpi r24,lo8(4)
 1977 0a56 00F0      		brlo .L60
 1978               	.L59:
 479:ServerLLDN.c  **** 						counter_associados = 0;
 1979               		.loc 6 479 0 is_stmt 1
 1980 0a58 8091 0000 		lds r24,cycles_counter
 1981 0a5c 882F      		mov r24,r24
 1982 0a5e 90E0      		ldi r25,0
 1983 0a60 292F      		mov r18,r25
 1984 0a62 2F93      		push r18
 1985 0a64 8F93      		push r24
 1986 0a66 80E0      		ldi r24,lo8(.LC8)
 1987 0a68 90E0      		ldi r25,hi8(.LC8)
 1988 0a6a 892F      		mov r24,r25
 1989 0a6c 8F93      		push r24
 1990 0a6e 80E0      		ldi r24,lo8(.LC8)
 1991 0a70 90E0      		ldi r25,hi8(.LC8)
 1992 0a72 8F93      		push r24
 1993 0a74 0E94 0000 		call printf
 1994 0a78 0F90      		pop __tmp_reg__
 1995 0a7a 0F90      		pop __tmp_reg__
 1996 0a7c 0F90      		pop __tmp_reg__
 1997 0a7e 0F90      		pop __tmp_reg__
 480:ServerLLDN.c  **** 						macsc_disable_cmp_int(MACSC_CC1);
 1998               		.loc 6 480 0
 1999 0a80 1092 0000 		sts counter_associados+1,__zero_reg__
 2000 0a84 1092 0000 		sts counter_associados,__zero_reg__
 481:ServerLLDN.c  **** 						macsc_disable_cmp_int(MACSC_CC2);
 2001               		.loc 6 481 0
 2002 0a88 81E0      		ldi r24,lo8(1)
 2003 0a8a 0E94 0000 		call macsc_disable_cmp_int
 482:ServerLLDN.c  **** 						macsc_disable_cmp_int(MACSC_CC3);
 2004               		.loc 6 482 0
 2005 0a8e 82E0      		ldi r24,lo8(2)
 2006 0a90 0E94 0000 		call macsc_disable_cmp_int
 483:ServerLLDN.c  **** 						msgReq.options = 0;
 2007               		.loc 6 483 0
 2008 0a94 83E0      		ldi r24,lo8(3)
 2009 0a96 0E94 0000 		call macsc_disable_cmp_int
 484:ServerLLDN.c  **** 						appState = APP_PAN_STATE_IDLE;
 2010               		.loc 6 484 0
 2011 0a9a 1092 0000 		sts msgReq+9+1,__zero_reg__
 2012 0a9e 1092 0000 		sts msgReq+9,__zero_reg__
 485:ServerLLDN.c  **** 						appPanState = APP_PAN_STATE_IDLE;
 2013               		.loc 6 485 0
 2014 0aa2 1092 0000 		sts appState,__zero_reg__
 486:ServerLLDN.c  **** 						
 2015               		.loc 6 486 0
 2016 0aa6 1092 0000 		sts appPanState,__zero_reg__
 495:ServerLLDN.c  **** 				}
 2017               		.loc 6 495 0
 2018 0aaa 00C0      		rjmp .L48
 2019               	.L60:
 491:ServerLLDN.c  **** 						appState	= APP_STATE_IDLE;
 2020               		.loc 6 491 0
 2021 0aac 0E94 0000 		call appPanDiscInit
 492:ServerLLDN.c  **** 						appPanState = APP_PAN_STATE_DISC_SECOND_BE;
 2022               		.loc 6 492 0
 2023 0ab0 81E0      		ldi r24,lo8(1)
 2024 0ab2 8093 0000 		sts appState,r24
 493:ServerLLDN.c  **** 					}
 2025               		.loc 6 493 0
 2026 0ab6 83E0      		ldi r24,lo8(3)
 2027 0ab8 8093 0000 		sts appPanState,r24
 495:ServerLLDN.c  **** 				}
 2028               		.loc 6 495 0
 2029 0abc 00C0      		rjmp .L48
 2030               	.L53:
 500:ServerLLDN.c  **** 					appState	= APP_STATE_IDLE;
 2031               		.loc 6 500 0
 2032 0abe 80E4      		ldi r24,lo8(64)
 2033 0ac0 99E0      		ldi r25,lo8(9)
 2034 0ac2 9093 0000 		sts msgReq+9+1,r25
 2035 0ac6 8093 0000 		sts msgReq+9,r24
 501:ServerLLDN.c  **** 					appPanState = APP_PAN_STATE_DISC_PREPARE_ACK;
 2036               		.loc 6 501 0
 2037 0aca 81E0      		ldi r24,lo8(1)
 2038 0acc 8093 0000 		sts appState,r24
 502:ServerLLDN.c  **** 					break;
 2039               		.loc 6 502 0
 2040 0ad0 84E0      		ldi r24,lo8(4)
 2041 0ad2 8093 0000 		sts appPanState,r24
 503:ServerLLDN.c  **** 				}
 2042               		.loc 6 503 0
 2043 0ad6 00C0      		rjmp .L48
 2044               	.L54:
 507:ServerLLDN.c  **** 					appPanPrepareACK();
 2045               		.loc 6 507 0
 2046 0ad8 80E0      		ldi r24,lo8(tmrDelay_Discovery)
 2047 0ada 90E0      		ldi r25,hi8(tmrDelay_Discovery)
 2048 0adc 0E94 0000 		call SYS_TimerStart
 508:ServerLLDN.c  **** 					// precisa mudar para o novo estado, mas precisa esperar o beacon interval acabar
 2049               		.loc 6 508 0
 2050 0ae0 0E94 0000 		call appPanPrepareACK
 511:ServerLLDN.c  **** 					appState = APP_STATE_IDLE;
 2051               		.loc 6 511 0
 2052 0ae4 85E0      		ldi r24,lo8(5)
 2053 0ae6 8093 0000 		sts appPanState,r24
 512:ServerLLDN.c  **** 					break;
 2054               		.loc 6 512 0
 2055 0aea 81E0      		ldi r24,lo8(1)
 2056 0aec 8093 0000 		sts appState,r24
 513:ServerLLDN.c  **** 				}
 2057               		.loc 6 513 0
 2058 0af0 00C0      		rjmp .L48
 2059               	.L55:
 518:ServerLLDN.c  **** 					appState	= APP_STATE_IDLE;
 2060               		.loc 6 518 0
 2061 0af2 80E4      		ldi r24,lo8(64)
 2062 0af4 92E0      		ldi r25,lo8(2)
 2063 0af6 9093 0000 		sts msgReq+9+1,r25
 2064 0afa 8093 0000 		sts msgReq+9,r24
 519:ServerLLDN.c  **** 					appPanState = APP_PAN_STATE_CONFIG_SECOND_BEACON;
 2065               		.loc 6 519 0
 2066 0afe 81E0      		ldi r24,lo8(1)
 2067 0b00 8093 0000 		sts appState,r24
 520:ServerLLDN.c  **** 					break;
 2068               		.loc 6 520 0
 2069 0b04 87E0      		ldi r24,lo8(7)
 2070 0b06 8093 0000 		sts appPanState,r24
 521:ServerLLDN.c  **** 
 2071               		.loc 6 521 0
 2072 0b0a 00C0      		rjmp .L48
 2073               	.L57:
 526:ServerLLDN.c  **** 					appState	= APP_STATE_IDLE;
 2074               		.loc 6 526 0
 2075 0b0c 80E4      		ldi r24,lo8(64)
 2076 0b0e 9AE0      		ldi r25,lo8(10)
 2077 0b10 9093 0000 		sts msgReq+9+1,r25
 2078 0b14 8093 0000 		sts msgReq+9,r24
 527:ServerLLDN.c  **** 					appPanState = APP_PAN_STATE_SEND_CONF_REQUEST;
 2079               		.loc 6 527 0
 2080 0b18 81E0      		ldi r24,lo8(1)
 2081 0b1a 8093 0000 		sts appState,r24
 528:ServerLLDN.c  **** 					break;
 2082               		.loc 6 528 0
 2083 0b1e 86E0      		ldi r24,lo8(6)
 2084 0b20 8093 0000 		sts appPanState,r24
 529:ServerLLDN.c  **** 				}
 2085               		.loc 6 529 0
 2086 0b24 00C0      		rjmp .L48
 2087               	.L56:
 535:ServerLLDN.c  **** 					{
 2088               		.loc 6 535 0
 2089 0b26 8091 0000 		lds r24,index_ConfRequest
 2090 0b2a 9091 0000 		lds r25,index_ConfRequest+1
 2091 0b2e 1816      		cp __zero_reg__,r24
 2092 0b30 1906      		cpc __zero_reg__,r25
 2093 0b32 04F4      		brge .L62
 537:ServerLLDN.c  **** 						msgReq.options		= NWK_OPT_MAC_COMMAND;
 2094               		.loc 6 537 0
 2095 0b34 8091 0000 		lds r24,index_ConfRequest
 2096 0b38 9091 0000 		lds r25,index_ConfRequest+1
 2097 0b3c 0E94 0000 		call CopyToConfigRequest
 538:ServerLLDN.c  **** 						msgReq.data			= (uint8_t*)&ConfigRequest;
 2098               		.loc 6 538 0
 2099 0b40 80E0      		ldi r24,0
 2100 0b42 90E8      		ldi r25,lo8(-128)
 2101 0b44 9093 0000 		sts msgReq+9+1,r25
 2102 0b48 8093 0000 		sts msgReq+9,r24
 539:ServerLLDN.c  **** 						msgReq.size			= sizeof(NWK_ConfigRequest_t);
 2103               		.loc 6 539 0
 2104 0b4c 80E0      		ldi r24,lo8(ConfigRequest)
 2105 0b4e 90E0      		ldi r25,hi8(ConfigRequest)
 2106 0b50 9093 0000 		sts msgReq+13+1,r25
 2107 0b54 8093 0000 		sts msgReq+13,r24
 540:ServerLLDN.c  **** 						appState	= APP_STATE_IDLE;
 2108               		.loc 6 540 0
 2109 0b58 87E0      		ldi r24,lo8(7)
 2110 0b5a 8093 0000 		sts msgReq+15,r24
 541:ServerLLDN.c  **** 						appPanState = APP_PAN_STATE_SEND_CONF_REQUEST;
 2111               		.loc 6 541 0
 2112 0b5e 81E0      		ldi r24,lo8(1)
 2113 0b60 8093 0000 		sts appState,r24
 542:ServerLLDN.c  **** 						index_ConfRequest--;
 2114               		.loc 6 542 0
 2115 0b64 86E0      		ldi r24,lo8(6)
 2116 0b66 8093 0000 		sts appPanState,r24
 543:ServerLLDN.c  **** 						counter_associados++;
 2117               		.loc 6 543 0
 2118 0b6a 8091 0000 		lds r24,index_ConfRequest
 2119 0b6e 9091 0000 		lds r25,index_ConfRequest+1
 2120 0b72 0197      		sbiw r24,1
 2121 0b74 9093 0000 		sts index_ConfRequest+1,r25
 2122 0b78 8093 0000 		sts index_ConfRequest,r24
 544:ServerLLDN.c  **** 						SYS_TimerStart(&tmrDelay_Configuration);
 2123               		.loc 6 544 0
 2124 0b7c 8091 0000 		lds r24,counter_associados
 2125 0b80 9091 0000 		lds r25,counter_associados+1
 2126 0b84 0196      		adiw r24,1
 2127 0b86 9093 0000 		sts counter_associados+1,r25
 2128 0b8a 8093 0000 		sts counter_associados,r24
 545:ServerLLDN.c  **** 					}
 2129               		.loc 6 545 0
 2130 0b8e 80E0      		ldi r24,lo8(tmrDelay_Configuration)
 2131 0b90 90E0      		ldi r25,hi8(tmrDelay_Configuration)
 2132 0b92 0E94 0000 		call SYS_TimerStart
 551:ServerLLDN.c  **** 				}
 2133               		.loc 6 551 0
 2134 0b96 00C0      		rjmp .L48
 2135               	.L62:
 549:ServerLLDN.c  **** 					}
 2136               		.loc 6 549 0
 2137 0b98 88E0      		ldi r24,lo8(8)
 2138 0b9a 8093 0000 		sts appPanState,r24
 551:ServerLLDN.c  **** 				}
 2139               		.loc 6 551 0
 2140 0b9e 00C0      		rjmp .L48
 2141               	.L58:
 555:ServerLLDN.c  **** 					msgReq.options = NWK_OPT_LLDN_BEACON | NWK_OPT_CONFIG_STATE | NWK_OPT_THIRD_BEACON;
 2142               		.loc 6 555 0
 2143 0ba0 80E0      		ldi r24,lo8(.LC9)
 2144 0ba2 90E0      		ldi r25,hi8(.LC9)
 2145 0ba4 892F      		mov r24,r25
 2146 0ba6 8F93      		push r24
 2147 0ba8 80E0      		ldi r24,lo8(.LC9)
 2148 0baa 90E0      		ldi r25,hi8(.LC9)
 2149 0bac 8F93      		push r24
 2150 0bae 0E94 0000 		call printf
 2151 0bb2 0F90      		pop __tmp_reg__
 2152 0bb4 0F90      		pop __tmp_reg__
 556:ServerLLDN.c  **** 					appState	= APP_STATE_IDLE;
 2153               		.loc 6 556 0
 2154 0bb6 80E4      		ldi r24,lo8(64)
 2155 0bb8 92E1      		ldi r25,lo8(18)
 2156 0bba 9093 0000 		sts msgReq+9+1,r25
 2157 0bbe 8093 0000 		sts msgReq+9,r24
 557:ServerLLDN.c  **** 					appPanState = APP_PAN_STATE_DISC_INITIAL;
 2158               		.loc 6 557 0
 2159 0bc2 81E0      		ldi r24,lo8(1)
 2160 0bc4 8093 0000 		sts appState,r24
 558:ServerLLDN.c  **** 					cycles_counter++;	
 2161               		.loc 6 558 0
 2162 0bc8 82E0      		ldi r24,lo8(2)
 2163 0bca 8093 0000 		sts appPanState,r24
 559:ServerLLDN.c  **** 					
 2164               		.loc 6 559 0
 2165 0bce 8091 0000 		lds r24,cycles_counter
 2166 0bd2 8F5F      		subi r24,lo8(-(1))
 2167 0bd4 8093 0000 		sts cycles_counter,r24
 561:ServerLLDN.c  **** 				}
 2168               		.loc 6 561 0
 2169 0bd8 00C0      		rjmp .L48
 2170               	.L49:
 565:ServerLLDN.c  **** 					appState = APP_STATE_IDLE;
 2171               		.loc 6 565 0
 2172 0bda 1092 0000 		sts msgReq+9+1,__zero_reg__
 2173 0bde 1092 0000 		sts msgReq+9,__zero_reg__
 566:ServerLLDN.c  **** 					break;
 2174               		.loc 6 566 0
 2175 0be2 81E0      		ldi r24,lo8(1)
 2176 0be4 8093 0000 		sts appState,r24
 567:ServerLLDN.c  **** 				}
 2177               		.loc 6 567 0
 2178 0be8 0000      		nop
 2179               	.L48:
 2180               	.L64:
 570:ServerLLDN.c  **** 		}
 2181               		.loc 6 570 0
 2182 0bea 0000      		nop
 2183               	.L47:
 602:ServerLLDN.c  **** 		}
 603:ServerLLDN.c  **** 	}
 604:ServerLLDN.c  **** }
 2184               		.loc 6 604 0
 2185 0bec 0000      		nop
 2186               	/* epilogue start */
 2187 0bee DF91      		pop r29
 2188 0bf0 CF91      		pop r28
 2189 0bf2 0895      		ret
 2190               		.cfi_endproc
 2191               	.LFE143:
 2193               		.section	.rodata
 2194               	.LC0:
 2195 0081 00        		.byte	0
 2196 0082 C2        		.byte	-62
 2197 0083 01        		.byte	1
 2198 0084 00        		.byte	0
 2199 0085 03        		.byte	3
 2200 0086 00        		.byte	0
 2201 0087 00        		.byte	0
 2202               		.text
 2203               	.global	main
 2205               	main:
 2206               	.LFB144:
 605:ServerLLDN.c  **** 
 606:ServerLLDN.c  **** 	/*****************************************************************************
 607:ServerLLDN.c  **** 	*****************************************************************************/
 608:ServerLLDN.c  **** 	int main(void)
 609:ServerLLDN.c  **** 	{
 2207               		.loc 6 609 0
 2208               		.cfi_startproc
 2209 0bf4 0F93      		push r16
 2210               	.LCFI78:
 2211               		.cfi_def_cfa_offset 3
 2212               		.cfi_offset 16, -2
 2213 0bf6 1F93      		push r17
 2214               	.LCFI79:
 2215               		.cfi_def_cfa_offset 4
 2216               		.cfi_offset 17, -3
 2217 0bf8 CF93      		push r28
 2218               	.LCFI80:
 2219               		.cfi_def_cfa_offset 5
 2220               		.cfi_offset 28, -4
 2221 0bfa DF93      		push r29
 2222               	.LCFI81:
 2223               		.cfi_def_cfa_offset 6
 2224               		.cfi_offset 29, -5
 2225 0bfc CDB7      		in r28,__SP_L__
 2226 0bfe DEB7      		in r29,__SP_H__
 2227               	.LCFI82:
 2228               		.cfi_def_cfa_register 28
 2229 0c00 2797      		sbiw r28,7
 2230               	.LCFI83:
 2231               		.cfi_def_cfa_offset 13
 2232 0c02 0FB6      		in __tmp_reg__,__SREG__
 2233 0c04 F894      		cli
 2234 0c06 DEBF      		out __SP_H__,r29
 2235 0c08 0FBE      		out __SREG__,__tmp_reg__
 2236 0c0a CDBF      		out __SP_L__,r28
 2237               	/* prologue: function */
 2238               	/* frame size = 7 */
 2239               	/* stack size = 11 */
 2240               	.L__stack_usage = 11
 610:ServerLLDN.c  **** 		sysclk_init();
 2241               		.loc 6 610 0
 2242 0c0c 0E94 0000 		call sysclk_init
 611:ServerLLDN.c  **** 		board_init();
 2243               		.loc 6 611 0
 2244 0c10 0E94 0000 		call board_init
 612:ServerLLDN.c  **** 
 613:ServerLLDN.c  **** 		SYS_Init();
 2245               		.loc 6 613 0
 2246 0c14 0E94 0000 		call SYS_Init
 614:ServerLLDN.c  **** 		/* Disable CSMA/CA
 615:ServerLLDN.c  **** 		 * Disable auto ACK
 616:ServerLLDN.c  **** 		 * Enable Rx of LLDN Frame Type as described in 802.15.4e - 2012 
 617:ServerLLDN.c  **** 		 */
 618:ServerLLDN.c  **** 
 619:ServerLLDN.c  **** 		sm_init();
 2247               		.loc 6 619 0
 2248 0c18 0E94 0000 		call sm_init
 620:ServerLLDN.c  **** 
 621:ServerLLDN.c  **** 		// Initialize interrupt vector table support.
 622:ServerLLDN.c  **** 	#if (SIO2HOST_CHANNEL == SIO_USB)
 623:ServerLLDN.c  **** 		irq_initialize_vectors();
 624:ServerLLDN.c  **** 	#endif
 625:ServerLLDN.c  **** 		cpu_irq_enable();
 2249               		.loc 6 625 0
 2250               	/* #APP */
 2251               	 ;  625 "ServerLLDN.c" 1
 2252 0c1c 7894      		sei
 2253               	 ;  0 "" 2
 626:ServerLLDN.c  **** 
 627:ServerLLDN.c  **** 	#if 1
 628:ServerLLDN.c  **** 	#if (SIO2HOST_CHANNEL == SIO_USB)
 629:ServerLLDN.c  **** 		stdio_usb_init();
 630:ServerLLDN.c  **** 	#else
 631:ServerLLDN.c  **** 		const usart_serial_options_t usart_serial_options =
 2254               		.loc 6 631 0
 2255               	/* #NOAPP */
 2256 0c1e 27E0      		ldi r18,lo8(7)
 2257 0c20 E0E0      		ldi r30,lo8(.LC0)
 2258 0c22 F0E0      		ldi r31,hi8(.LC0)
 2259 0c24 CE01      		movw r24,r28
 2260 0c26 0196      		adiw r24,1
 2261 0c28 DC01      		movw r26,r24
 2262               		0:
 2263 0c2a 0190      		ld r0,Z+
 2264 0c2c 0D92      		st X+,r0
 2265 0c2e 2A95      		dec r18
 2266 0c30 01F4      		brne 0b
 632:ServerLLDN.c  **** 		{
 633:ServerLLDN.c  **** 			.baudrate     = USART_HOST_BAUDRATE,
 634:ServerLLDN.c  **** 			.charlength   = USART_HOST_CHAR_LENGTH,
 635:ServerLLDN.c  **** 			.paritytype   = USART_HOST_PARITY,
 636:ServerLLDN.c  **** 			.stopbits     = USART_HOST_STOP_BITS
 637:ServerLLDN.c  **** 		};
 638:ServerLLDN.c  **** 
 639:ServerLLDN.c  **** 		stdio_serial_init(USART_HOST, &usart_serial_options);
 2267               		.loc 6 639 0
 2268 0c32 CE01      		movw r24,r28
 2269 0c34 0196      		adiw r24,1
 2270 0c36 BC01      		movw r22,r24
 2271 0c38 80EC      		ldi r24,lo8(-64)
 2272 0c3a 90E0      		ldi r25,0
 2273 0c3c 0E94 0000 		call stdio_serial_init
 640:ServerLLDN.c  **** 		usart_double_baud_enable(USART_HOST);
 2274               		.loc 6 640 0
 2275 0c40 80EC      		ldi r24,lo8(-64)
 2276 0c42 90E0      		ldi r25,0
 2277 0c44 0E94 0000 		call usart_double_baud_enable
 641:ServerLLDN.c  **** 		usart_set_baudrate_precalculated(USART_HOST, USART_HOST_BAUDRATE, sysclk_get_source_clock_hz());
 2278               		.loc 6 641 0
 2279 0c48 0E94 0000 		call sysclk_get_source_clock_hz
 2280 0c4c DC01      		movw r26,r24
 2281 0c4e CB01      		movw r24,r22
 2282 0c50 8C01      		movw r16,r24
 2283 0c52 9D01      		movw r18,r26
 2284 0c54 40E0      		ldi r20,0
 2285 0c56 52EC      		ldi r21,lo8(-62)
 2286 0c58 61E0      		ldi r22,lo8(1)
 2287 0c5a 70E0      		ldi r23,0
 2288 0c5c 80EC      		ldi r24,lo8(-64)
 2289 0c5e 90E0      		ldi r25,0
 2290 0c60 0E94 0000 		call usart_set_baudrate_precalculated
 2291               	.L66:
 642:ServerLLDN.c  **** 
 643:ServerLLDN.c  **** 	#endif
 644:ServerLLDN.c  **** 	#endif
 645:ServerLLDN.c  **** 		for(;;)
 646:ServerLLDN.c  **** 		{
 647:ServerLLDN.c  **** 			SYS_TaskHandler();
 2292               		.loc 6 647 0 discriminator 1
 2293 0c64 0E94 0000 		call SYS_TaskHandler
 648:ServerLLDN.c  **** 			APP_TaskHandler();
 2294               		.loc 6 648 0 discriminator 1
 2295 0c68 0E94 0000 		call APP_TaskHandler
 649:ServerLLDN.c  **** 		}
 2296               		.loc 6 649 0 discriminator 1
 2297 0c6c 00C0      		rjmp .L66
 2298               		.cfi_endproc
 2299               	.LFE144:
 2301               	.Letext0:
 2302               		.file 7 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\in
 2303               		.file 8 "../../../stack/LwMesh/TDMA/nwk/inc/nwkRx.h"
 2304               		.file 9 "../../../stack/LwMesh/TDMA/nwk/inc/nwkDataReq.h"
 2305               		.file 10 "../../../stack/LwMesh/TDMA/sys/inc/sysTimer.h"
 2306               		.file 11 "../../../platform/mega_rf/drivers/sleep/sleep.h"
 2307               		.file 12 "lldn.h"
 2308               		.file 13 "../../../platform/mega_rf/utils/status_codes.h"
 2309               		.file 14 "config/config.h"
 2310               		.file 15 "../../../platform/common/services/sleepmgr/mega_rf/sleepmgr.h"
DEFINED SYMBOLS
                            *ABS*:00000000 ServerLLDN.c
C:\Users\guilh\AppData\Local\Temp\ccflLi0M.s:2      *ABS*:0000003e __SP_H__
C:\Users\guilh\AppData\Local\Temp\ccflLi0M.s:3      *ABS*:0000003d __SP_L__
C:\Users\guilh\AppData\Local\Temp\ccflLi0M.s:4      *ABS*:0000003f __SREG__
C:\Users\guilh\AppData\Local\Temp\ccflLi0M.s:5      *ABS*:0000003b __RAMPZ__
C:\Users\guilh\AppData\Local\Temp\ccflLi0M.s:6      *ABS*:00000000 __tmp_reg__
C:\Users\guilh\AppData\Local\Temp\ccflLi0M.s:7      *ABS*:00000001 __zero_reg__
                            *COM*:00000001 n
C:\Users\guilh\AppData\Local\Temp\ccflLi0M.s:15     .bss.tTS:00000000 tTS
C:\Users\guilh\AppData\Local\Temp\ccflLi0M.s:19     .text:00000000 sysclk_get_main_hz
C:\Users\guilh\AppData\Local\Temp\ccflLi0M.s:56     .text:0000001a sysclk_get_source_clock_hz
C:\Users\guilh\AppData\Local\Temp\ccflLi0M.s:93     .progmem.data.baudctrl_1mhz:00000000 baudctrl_1mhz
C:\Users\guilh\AppData\Local\Temp\ccflLi0M.s:105    .progmem.data.baudctrl_8mhz:00000000 baudctrl_8mhz
C:\Users\guilh\AppData\Local\Temp\ccflLi0M.s:117    .progmem.data.baudctrl_16mhz:00000000 baudctrl_16mhz
C:\Users\guilh\AppData\Local\Temp\ccflLi0M.s:128    .text:00000034 usart_double_baud_enable
C:\Users\guilh\AppData\Local\Temp\ccflLi0M.s:177    .text:00000062 usart_serial_init
C:\Users\guilh\AppData\Local\Temp\ccflLi0M.s:272    .text:000000de usart_serial_putchar
C:\Users\guilh\AppData\Local\Temp\ccflLi0M.s:316    .text:00000106 usart_serial_getchar
C:\Users\guilh\AppData\Local\Temp\ccflLi0M.s:367    .text:0000013c stdio_serial_init
C:\Users\guilh\AppData\Local\Temp\ccflLi0M.s:438    .text:0000019e macsc_enable_manual_bts
C:\Users\guilh\AppData\Local\Temp\ccflLi0M.s:492    .bss.appState:00000000 appState
C:\Users\guilh\AppData\Local\Temp\ccflLi0M.s:497    .bss.msgReq:00000000 msgReq
C:\Users\guilh\AppData\Local\Temp\ccflLi0M.s:502    .bss.PanId:00000000 PanId
C:\Users\guilh\AppData\Local\Temp\ccflLi0M.s:509    .text:000001d2 appSendData
                            *COM*:00000004 beaconInterval
C:\Users\guilh\AppData\Local\Temp\ccflLi0M.s:572    .data.appPanState:00000000 appPanState
                            *COM*:00000021 ACKFrame
C:\Users\guilh\AppData\Local\Temp\ccflLi0M.s:579    .bss.ACKFrame_size:00000000 ACKFrame_size
C:\Users\guilh\AppData\Local\Temp\ccflLi0M.s:585    .data.cycles_counter:00000000 cycles_counter
C:\Users\guilh\AppData\Local\Temp\ccflLi0M.s:591    .bss.counter_associados:00000000 counter_associados
                            *COM*:000006f2 msgsConfRequest
                            *COM*:00000007 ConfigRequest
C:\Users\guilh\AppData\Local\Temp\ccflLi0M.s:599    .bss.macLLDNnumUplinkTS:00000000 macLLDNnumUplinkTS
C:\Users\guilh\AppData\Local\Temp\ccflLi0M.s:605    .bss.biggest_timeslot_duration:00000000 biggest_timeslot_duration
C:\Users\guilh\AppData\Local\Temp\ccflLi0M.s:611    .bss.index_ConfRequest:00000000 index_ConfRequest
                            *COM*:00000002 max_index
                            *COM*:0000000d tmrDiscoveryMode
                            *COM*:0000000d tmrDelay_Discovery
                            *COM*:0000000d tmrDelay_Configuration
C:\Users\guilh\AppData\Local\Temp\ccflLi0M.s:619    .text:0000021e tmrDiscoveryModeHandler
C:\Users\guilh\AppData\Local\Temp\ccflLi0M.s:665    .text:00000242 tmrDelayHandler
C:\Users\guilh\AppData\Local\Temp\ccflLi0M.s:720    .text:00000278 lldn_server_beacon
C:\Users\guilh\AppData\Local\Temp\ccflLi0M.s:770    .text:000002a8 downlink_delay_handler
C:\Users\guilh\AppData\Local\Temp\ccflLi0M.s:817    .text:000002da addToAckArray
C:\Users\guilh\AppData\Local\Temp\ccflLi0M.s:932    .text:00000386 addConfRequestArray
C:\Users\guilh\AppData\Local\Temp\ccflLi0M.s:1114   .text:000004e0 CopyToConfigRequest
C:\Users\guilh\AppData\Local\Temp\ccflLi0M.s:1292   .text:0000060e appCommandInd
C:\Users\guilh\AppData\Local\Temp\ccflLi0M.s:1438   .text:000006e6 appPanPrepareACK
C:\Users\guilh\AppData\Local\Temp\ccflLi0M.s:1490   .text:0000072c appPanReset
C:\Users\guilh\AppData\Local\Temp\ccflLi0M.s:1551   .text:0000077c appPanDiscInit
C:\Users\guilh\AppData\Local\Temp\ccflLi0M.s:1744   .text:000008ee appInit
C:\Users\guilh\AppData\Local\Temp\ccflLi0M.s:1862   .text:000009b6 APP_TaskHandler
C:\Users\guilh\AppData\Local\Temp\ccflLi0M.s:2205   .text:00000bf4 main

UNDEFINED SYMBOLS
usart_init_rs232
usart_putchar
usart_getchar
stdio_base
ptr_put
ptr_get
_read
_write
fdevopen
printf
NWK_DataReq
macsc_disable_cmp_int
__floatsisf
__addsf3
__divsf3
__mulsf3
__fixunssfsi
macsc_set_cmp1_int_cb
macsc_enable_cmp_int
macsc_use_cmp
NWK_SetAddr
PHY_SetChannel
PHY_SetRxState
NWK_SetPanId
PHY_SetTdmaMode
NWK_OpenEndpoint
PHY_SetPromiscuousMode
__tablejump2__
puts
SYS_TimerStart
sysclk_init
board_init
SYS_Init
sm_init
usart_set_baudrate_precalculated
SYS_TaskHandler
__do_copy_data
__do_clear_bss
