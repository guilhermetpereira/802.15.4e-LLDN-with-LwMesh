   1               		.file	"ServerLLDN.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__RAMPZ__ = 0x3b
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.text
   9               	.Ltext0:
  10               		.cfi_sections	.debug_frame
  11               	.global	n
  12               		.section	.bss.n,"aw",@nobits
  15               	n:
  16 0000 00        		.zero	1
  17               		.comm	tTS,4,1
  18               		.comm	macLLDNnumTimeSlots,2,1
  19               		.comm	macLLDNnumUplinkTS,2,1
  20               		.comm	macLLDNRetransmitTS,2,1
  21               		.text
  23               	sysclk_get_main_hz:
  24               	.LFB67:
  25               		.file 1 "../../../platform/common/services/clock/mega/sysclk.h"
   1:../../../platform/common/services/clock/mega/sysclk.h **** /**
   2:../../../platform/common/services/clock/mega/sysclk.h ****  * \file
   3:../../../platform/common/services/clock/mega/sysclk.h ****  *
   4:../../../platform/common/services/clock/mega/sysclk.h ****  * \brief Chip-specific system clock management functions
   5:../../../platform/common/services/clock/mega/sysclk.h ****  *
   6:../../../platform/common/services/clock/mega/sysclk.h ****  * Copyright (c) 2012 Atmel Corporation. All rights reserved.
   7:../../../platform/common/services/clock/mega/sysclk.h ****  *
   8:../../../platform/common/services/clock/mega/sysclk.h ****  * \asf_license_start
   9:../../../platform/common/services/clock/mega/sysclk.h ****  *
  10:../../../platform/common/services/clock/mega/sysclk.h ****  * \page License
  11:../../../platform/common/services/clock/mega/sysclk.h ****  *
  12:../../../platform/common/services/clock/mega/sysclk.h ****  * Redistribution and use in source and binary forms, with or without
  13:../../../platform/common/services/clock/mega/sysclk.h ****  * modification, are permitted provided that the following conditions are met:
  14:../../../platform/common/services/clock/mega/sysclk.h ****  *
  15:../../../platform/common/services/clock/mega/sysclk.h ****  * 1. Redistributions of source code must retain the above copyright notice,
  16:../../../platform/common/services/clock/mega/sysclk.h ****  *    this list of conditions and the following disclaimer.
  17:../../../platform/common/services/clock/mega/sysclk.h ****  *
  18:../../../platform/common/services/clock/mega/sysclk.h ****  * 2. Redistributions in binary form must reproduce the above copyright notice,
  19:../../../platform/common/services/clock/mega/sysclk.h ****  *    this list of conditions and the following disclaimer in the documentation
  20:../../../platform/common/services/clock/mega/sysclk.h ****  *    and/or other materials provided with the distribution.
  21:../../../platform/common/services/clock/mega/sysclk.h ****  *
  22:../../../platform/common/services/clock/mega/sysclk.h ****  * 3. The name of Atmel may not be used to endorse or promote products derived
  23:../../../platform/common/services/clock/mega/sysclk.h ****  *    from this software without specific prior written permission.
  24:../../../platform/common/services/clock/mega/sysclk.h ****  *
  25:../../../platform/common/services/clock/mega/sysclk.h ****  * 4. This software may only be redistributed and used in connection with an
  26:../../../platform/common/services/clock/mega/sysclk.h ****  *    Atmel microcontroller product.
  27:../../../platform/common/services/clock/mega/sysclk.h ****  *
  28:../../../platform/common/services/clock/mega/sysclk.h ****  * THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR IMPLIED
  29:../../../platform/common/services/clock/mega/sysclk.h ****  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
  30:../../../platform/common/services/clock/mega/sysclk.h ****  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
  31:../../../platform/common/services/clock/mega/sysclk.h ****  * EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR
  32:../../../platform/common/services/clock/mega/sysclk.h ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  33:../../../platform/common/services/clock/mega/sysclk.h ****  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
  34:../../../platform/common/services/clock/mega/sysclk.h ****  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  35:../../../platform/common/services/clock/mega/sysclk.h ****  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
  36:../../../platform/common/services/clock/mega/sysclk.h ****  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  37:../../../platform/common/services/clock/mega/sysclk.h ****  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  38:../../../platform/common/services/clock/mega/sysclk.h ****  * POSSIBILITY OF SUCH DAMAGE.
  39:../../../platform/common/services/clock/mega/sysclk.h ****  *
  40:../../../platform/common/services/clock/mega/sysclk.h ****  * \asf_license_stop
  41:../../../platform/common/services/clock/mega/sysclk.h ****  *
  42:../../../platform/common/services/clock/mega/sysclk.h ****  */
  43:../../../platform/common/services/clock/mega/sysclk.h **** #ifndef MEGA_SYSCLK_H_INCLUDED
  44:../../../platform/common/services/clock/mega/sysclk.h **** #define MEGA_SYSCLK_H_INCLUDED
  45:../../../platform/common/services/clock/mega/sysclk.h **** 
  46:../../../platform/common/services/clock/mega/sysclk.h **** #include <board.h>
  47:../../../platform/common/services/clock/mega/sysclk.h **** #include <compiler.h>
  48:../../../platform/common/services/clock/mega/sysclk.h **** #include <parts.h>
  49:../../../platform/common/services/clock/mega/sysclk.h **** 
  50:../../../platform/common/services/clock/mega/sysclk.h **** /* Include clock configuration for the project. */
  51:../../../platform/common/services/clock/mega/sysclk.h **** #include <conf_clock.h>
  52:../../../platform/common/services/clock/mega/sysclk.h **** 
  53:../../../platform/common/services/clock/mega/sysclk.h **** #ifdef __cplusplus
  54:../../../platform/common/services/clock/mega/sysclk.h **** extern "C" {
  55:../../../platform/common/services/clock/mega/sysclk.h **** #endif
  56:../../../platform/common/services/clock/mega/sysclk.h **** #define ASM __asm__
  57:../../../platform/common/services/clock/mega/sysclk.h **** 
  58:../../../platform/common/services/clock/mega/sysclk.h **** /* CONFIG_SYSCLK_PSDIV  to use default if not defined*/
  59:../../../platform/common/services/clock/mega/sysclk.h **** #ifndef CONFIG_SYSCLK_PSDIV
  60:../../../platform/common/services/clock/mega/sysclk.h **** # define CONFIG_SYSCLK_PSDIV    SYSCLK_PSDIV_8
  61:../../../platform/common/services/clock/mega/sysclk.h **** #endif
  62:../../../platform/common/services/clock/mega/sysclk.h **** 
  63:../../../platform/common/services/clock/mega/sysclk.h **** /* ! \name Prescaler Setting (relative to CLKsys) */
  64:../../../platform/common/services/clock/mega/sysclk.h **** /* @{ */
  65:../../../platform/common/services/clock/mega/sysclk.h **** #define SYSCLK_PSDIV_1      0   /* !< Do not prescale */
  66:../../../platform/common/services/clock/mega/sysclk.h **** #define SYSCLK_PSDIV_2      1   /* !< Prescale CLKper4 by 2 */
  67:../../../platform/common/services/clock/mega/sysclk.h **** #define SYSCLK_PSDIV_4      2   /* !< Prescale CLKper4 by 4 */
  68:../../../platform/common/services/clock/mega/sysclk.h **** #define SYSCLK_PSDIV_8      3   /* !< Prescale CLKper4 by 8 */
  69:../../../platform/common/services/clock/mega/sysclk.h **** #define SYSCLK_PSDIV_16     4   /* !< Prescale CLKper4 by 16 */
  70:../../../platform/common/services/clock/mega/sysclk.h **** #define SYSCLK_PSDIV_32     5   /* !< Prescale CLKper4 by 32 */
  71:../../../platform/common/services/clock/mega/sysclk.h **** #define SYSCLK_PSDIV_64     6   /* !< Prescale CLKper4 by 64 */
  72:../../../platform/common/services/clock/mega/sysclk.h **** #define SYSCLK_PSDIV_128    7   /* !< Prescale CLKper4 by 128 */
  73:../../../platform/common/services/clock/mega/sysclk.h **** #define SYSCLK_PSDIV_256    8   /* !< Prescale CLKper4 by 256 */
  74:../../../platform/common/services/clock/mega/sysclk.h **** 
  75:../../../platform/common/services/clock/mega/sysclk.h **** /* @} */
  76:../../../platform/common/services/clock/mega/sysclk.h **** 
  77:../../../platform/common/services/clock/mega/sysclk.h **** #if MEGA_RF || MEGA_XX0_1 || MEGA_XX4 || MEGA_XX4_A
  78:../../../platform/common/services/clock/mega/sysclk.h **** 
  79:../../../platform/common/services/clock/mega/sysclk.h **** #define NUMBER_OF_POWER_REG       2
  80:../../../platform/common/services/clock/mega/sysclk.h **** /*Starting Address for power reduction*/
  81:../../../platform/common/services/clock/mega/sysclk.h **** #define POWER_REG_ADD             PRR0
  82:../../../platform/common/services/clock/mega/sysclk.h **** 
  83:../../../platform/common/services/clock/mega/sysclk.h **** /* ! \name Power Reduction  Clock Port Numbers */
  84:../../../platform/common/services/clock/mega/sysclk.h **** enum power_red_id {
  85:../../../platform/common/services/clock/mega/sysclk.h **** 	POWER_RED_REG0,     /* !< Devices on PRR0 */
  86:../../../platform/common/services/clock/mega/sysclk.h **** #if !MEGA_XX4 || !MEGA_XX4_A || MEGA_XX0_1
  87:../../../platform/common/services/clock/mega/sysclk.h **** 	POWER_RED_REG1,     /* !< Devices on PRR1 */
  88:../../../platform/common/services/clock/mega/sysclk.h **** #endif
  89:../../../platform/common/services/clock/mega/sysclk.h **** };
  90:../../../platform/common/services/clock/mega/sysclk.h **** #endif
  91:../../../platform/common/services/clock/mega/sysclk.h **** 
  92:../../../platform/common/services/clock/mega/sysclk.h **** /****************************************************
  93:../../../platform/common/services/clock/mega/sysclk.h ****  * Given a dummy type but not used for these groups
  94:../../../platform/common/services/clock/mega/sysclk.h ****  * to support for otherthen megaRF device.
  95:../../../platform/common/services/clock/mega/sysclk.h ****  **************************************************/
  96:../../../platform/common/services/clock/mega/sysclk.h **** #if MEGA_XX8 || MEGA_XX8_A || MEGA_UNSPECIFIED
  97:../../../platform/common/services/clock/mega/sysclk.h **** #define NUMBER_OF_POWER_REG       1
  98:../../../platform/common/services/clock/mega/sysclk.h **** /*Starting Address for power reduction*/
  99:../../../platform/common/services/clock/mega/sysclk.h **** #define POWER_REG_ADD             PRR
 100:../../../platform/common/services/clock/mega/sysclk.h **** 
 101:../../../platform/common/services/clock/mega/sysclk.h **** /* ! \name Power Reduction  Clock Port Numbers */
 102:../../../platform/common/services/clock/mega/sysclk.h **** enum power_red_id {
 103:../../../platform/common/services/clock/mega/sysclk.h **** 	POWER_RED_REG0,     /* !< Devices on PRR */
 104:../../../platform/common/services/clock/mega/sysclk.h **** };
 105:../../../platform/common/services/clock/mega/sysclk.h **** #endif
 106:../../../platform/common/services/clock/mega/sysclk.h **** 
 107:../../../platform/common/services/clock/mega/sysclk.h **** /* Bit mask for the power reduction register based on */
 108:../../../platform/common/services/clock/mega/sysclk.h **** /*   MCU ARCH.                                        */
 109:../../../platform/common/services/clock/mega/sysclk.h **** #if MEGA_RF
 110:../../../platform/common/services/clock/mega/sysclk.h **** /*Bit mask for PRR2 */
 111:../../../platform/common/services/clock/mega/sysclk.h **** 
 112:../../../platform/common/services/clock/mega/sysclk.h **** #define PRRAM0_bm                       1 << PRRAM0
 113:../../../platform/common/services/clock/mega/sysclk.h **** #define PRRAM1_bm                       1 << PRRAM1
 114:../../../platform/common/services/clock/mega/sysclk.h **** #define PRRAM2_bm                       1 << PRRAM2
 115:../../../platform/common/services/clock/mega/sysclk.h **** #define PRRAM3_bm                       1 << PRRAM3
 116:../../../platform/common/services/clock/mega/sysclk.h **** #endif
 117:../../../platform/common/services/clock/mega/sysclk.h **** 
 118:../../../platform/common/services/clock/mega/sysclk.h **** /*Bit mask for the power reduction 0 or PRR*/
 119:../../../platform/common/services/clock/mega/sysclk.h **** #if !MEGA_XX_UN0 && !MEGA_XX_UN0
 120:../../../platform/common/services/clock/mega/sysclk.h **** #define PRADC_bm                        1 << PRADC
 121:../../../platform/common/services/clock/mega/sysclk.h **** #define PRUSART0_bm                     1 << PRUSART0
 122:../../../platform/common/services/clock/mega/sysclk.h **** #define PRSPI_bm                        1 << PRSPI
 123:../../../platform/common/services/clock/mega/sysclk.h **** #define PRTIM1_bm                       1 << PRTIM1
 124:../../../platform/common/services/clock/mega/sysclk.h **** #endif
 125:../../../platform/common/services/clock/mega/sysclk.h **** 
 126:../../../platform/common/services/clock/mega/sysclk.h **** #if MEGA_RF
 127:../../../platform/common/services/clock/mega/sysclk.h **** #define PRPGA_bm                        1 << PRPGA
 128:../../../platform/common/services/clock/mega/sysclk.h **** #endif
 129:../../../platform/common/services/clock/mega/sysclk.h **** 
 130:../../../platform/common/services/clock/mega/sysclk.h **** #if !MEGA_UNSPECIFIED
 131:../../../platform/common/services/clock/mega/sysclk.h **** #define PRTIM0_bm                       1 << PRTIM0
 132:../../../platform/common/services/clock/mega/sysclk.h **** #define PRTIM2_bm                       1 << PRTIM2
 133:../../../platform/common/services/clock/mega/sysclk.h **** #define PRTWI_bm                        1 << PRTWI
 134:../../../platform/common/services/clock/mega/sysclk.h **** #endif
 135:../../../platform/common/services/clock/mega/sysclk.h **** 
 136:../../../platform/common/services/clock/mega/sysclk.h **** #if MEGA_XX_UN2
 137:../../../platform/common/services/clock/mega/sysclk.h **** #define PRLCD_bm                        1 << PRLCD
 138:../../../platform/common/services/clock/mega/sysclk.h **** #endif
 139:../../../platform/common/services/clock/mega/sysclk.h **** 
 140:../../../platform/common/services/clock/mega/sysclk.h **** /*Bit mask for  PRR1  */
 141:../../../platform/common/services/clock/mega/sysclk.h **** #ifdef PRR1
 142:../../../platform/common/services/clock/mega/sysclk.h **** #if (MEGA_XX4 || MEGA_XX4_A)
 143:../../../platform/common/services/clock/mega/sysclk.h **** #define PRTIM3_bm                       1 << PRTIM3
 144:../../../platform/common/services/clock/mega/sysclk.h **** #endif
 145:../../../platform/common/services/clock/mega/sysclk.h **** #endif
 146:../../../platform/common/services/clock/mega/sysclk.h **** 
 147:../../../platform/common/services/clock/mega/sysclk.h **** #if MEGA_RF || MEGA_XX4 || MEGA_XX4_A
 148:../../../platform/common/services/clock/mega/sysclk.h **** #define PRUSART1_bm                     1 << PRUSART1
 149:../../../platform/common/services/clock/mega/sysclk.h **** #define PRUSART2_bm                     1 << PRUSART2
 150:../../../platform/common/services/clock/mega/sysclk.h **** #define PRUSART3_bm                     1 << PRUSART3
 151:../../../platform/common/services/clock/mega/sysclk.h **** #define PRTIM3_bm                       1 << PRTIM3
 152:../../../platform/common/services/clock/mega/sysclk.h **** #define PRTIM4_bm                       1 << PRTIM4
 153:../../../platform/common/services/clock/mega/sysclk.h **** #define PRTIM5_bm                       1 << PRTIM5
 154:../../../platform/common/services/clock/mega/sysclk.h **** #endif
 155:../../../platform/common/services/clock/mega/sysclk.h **** 
 156:../../../platform/common/services/clock/mega/sysclk.h **** #if MEGA_RF
 157:../../../platform/common/services/clock/mega/sysclk.h **** #define PRTRX24_bm                      1 << PRTRX24
 158:../../../platform/common/services/clock/mega/sysclk.h **** #endif
 159:../../../platform/common/services/clock/mega/sysclk.h **** 
 160:../../../platform/common/services/clock/mega/sysclk.h **** /**
 161:../../../platform/common/services/clock/mega/sysclk.h ****  * \name Querying the system clock and its derived clocks
 162:../../../platform/common/services/clock/mega/sysclk.h ****  */
 163:../../../platform/common/services/clock/mega/sysclk.h **** /* @{ */
 164:../../../platform/common/services/clock/mega/sysclk.h **** 
 165:../../../platform/common/services/clock/mega/sysclk.h **** /**
 166:../../../platform/common/services/clock/mega/sysclk.h ****  * \brief Return the current rate in Hz of the main system clock
 167:../../../platform/common/services/clock/mega/sysclk.h ****  * To know the clock value at what frequency the main clock is running
 168:../../../platform/common/services/clock/mega/sysclk.h ****  * \return Frequency of the main system clock, in Hz.
 169:../../../platform/common/services/clock/mega/sysclk.h ****  * \todo : please initialize the SYSCLK_SOURCE in conf_clock.h file for
 170:../../../platform/common/services/clock/mega/sysclk.h ****  * configured source clock using fuses.
 171:../../../platform/common/services/clock/mega/sysclk.h ****  * \eg. #define SYSCLK_SOURCE SYSCLK_SRC_RC16MHZ to use internal RC
 172:../../../platform/common/services/clock/mega/sysclk.h ****  * oscillator for clock source.
 173:../../../platform/common/services/clock/mega/sysclk.h ****  */
 174:../../../platform/common/services/clock/mega/sysclk.h **** static inline uint32_t sysclk_get_main_hz(void)
 175:../../../platform/common/services/clock/mega/sysclk.h **** {
  26               		.loc 1 175 0
  27               		.cfi_startproc
  28 0000 CF93      		push r28
  29               	.LCFI0:
  30               		.cfi_def_cfa_offset 3
  31               		.cfi_offset 28, -2
  32 0002 DF93      		push r29
  33               	.LCFI1:
  34               		.cfi_def_cfa_offset 4
  35               		.cfi_offset 29, -3
  36 0004 CDB7      		in r28,__SP_L__
  37 0006 DEB7      		in r29,__SP_H__
  38               	.LCFI2:
  39               		.cfi_def_cfa_register 28
  40               	/* prologue: function */
  41               	/* frame size = 0 */
  42               	/* stack size = 2 */
  43               	.L__stack_usage = 2
 176:../../../platform/common/services/clock/mega/sysclk.h **** 	switch (SYSCLK_SOURCE) {
 177:../../../platform/common/services/clock/mega/sysclk.h **** 	case SYSCLK_SRC_RC16MHZ:
 178:../../../platform/common/services/clock/mega/sysclk.h **** 		return 16000000UL;
 179:../../../platform/common/services/clock/mega/sysclk.h **** 
 180:../../../platform/common/services/clock/mega/sysclk.h **** 	case SYSCLK_SRC_RC128KHZ:
 181:../../../platform/common/services/clock/mega/sysclk.h **** 		return 128000UL;
 182:../../../platform/common/services/clock/mega/sysclk.h **** 
 183:../../../platform/common/services/clock/mega/sysclk.h **** #if MEGA_RF
 184:../../../platform/common/services/clock/mega/sysclk.h **** 	case SYSCLK_SRC_TRS16MHZ:
 185:../../../platform/common/services/clock/mega/sysclk.h **** 		return 16000000UL;
  44               		.loc 1 185 0
  45 0008 80E0      		ldi r24,0
  46 000a 94E2      		ldi r25,lo8(36)
  47 000c A4EF      		ldi r26,lo8(-12)
  48 000e B0E0      		ldi r27,0
 186:../../../platform/common/services/clock/mega/sysclk.h **** #endif
 187:../../../platform/common/services/clock/mega/sysclk.h **** #ifdef BOARD_EXTERNAL_CLK
 188:../../../platform/common/services/clock/mega/sysclk.h **** 	case SYSCLK_SRC_EXTERNAL:
 189:../../../platform/common/services/clock/mega/sysclk.h **** 		return BOARD_EXTERNAL_CLK;
 190:../../../platform/common/services/clock/mega/sysclk.h **** #endif
 191:../../../platform/common/services/clock/mega/sysclk.h **** 	default:
 192:../../../platform/common/services/clock/mega/sysclk.h **** 
 193:../../../platform/common/services/clock/mega/sysclk.h **** 		return 1000000UL;
 194:../../../platform/common/services/clock/mega/sysclk.h **** 	}
 195:../../../platform/common/services/clock/mega/sysclk.h **** }
  49               		.loc 1 195 0
  50 0010 BC01      		movw r22,r24
  51 0012 CD01      		movw r24,r26
  52               	/* epilogue start */
  53 0014 DF91      		pop r29
  54 0016 CF91      		pop r28
  55 0018 0895      		ret
  56               		.cfi_endproc
  57               	.LFE67:
  60               	sysclk_get_source_clock_hz:
  61               	.LFB68:
 196:../../../platform/common/services/clock/mega/sysclk.h **** 
 197:../../../platform/common/services/clock/mega/sysclk.h **** /**
 198:../../../platform/common/services/clock/mega/sysclk.h ****  * \brief Return the current rate in Hz of source clock in Hz.
 199:../../../platform/common/services/clock/mega/sysclk.h ****  *
 200:../../../platform/common/services/clock/mega/sysclk.h ****  * This clock always runs at the same rate as the CPU clock unless the divider
 201:../../../platform/common/services/clock/mega/sysclk.h ****  * is set.
 202:../../../platform/common/services/clock/mega/sysclk.h ****  *
 203:../../../platform/common/services/clock/mega/sysclk.h ****  * \return Frequency of the system clock, in Hz.
 204:../../../platform/common/services/clock/mega/sysclk.h ****  */
 205:../../../platform/common/services/clock/mega/sysclk.h **** static inline uint32_t sysclk_get_source_clock_hz(void)
 206:../../../platform/common/services/clock/mega/sysclk.h **** {
  62               		.loc 1 206 0
  63               		.cfi_startproc
  64 001a CF93      		push r28
  65               	.LCFI3:
  66               		.cfi_def_cfa_offset 3
  67               		.cfi_offset 28, -2
  68 001c DF93      		push r29
  69               	.LCFI4:
  70               		.cfi_def_cfa_offset 4
  71               		.cfi_offset 29, -3
  72 001e CDB7      		in r28,__SP_L__
  73 0020 DEB7      		in r29,__SP_H__
  74               	.LCFI5:
  75               		.cfi_def_cfa_register 28
  76               	/* prologue: function */
  77               	/* frame size = 0 */
  78               	/* stack size = 2 */
  79               	.L__stack_usage = 2
 207:../../../platform/common/services/clock/mega/sysclk.h **** 	switch (CONFIG_SYSCLK_PSDIV) {
 208:../../../platform/common/services/clock/mega/sysclk.h **** 	case SYSCLK_PSDIV_1: /* Fall through */
 209:../../../platform/common/services/clock/mega/sysclk.h **** 		if (SYSCLK_SOURCE == SYSCLK_SRC_RC16MHZ ||
 210:../../../platform/common/services/clock/mega/sysclk.h **** 				SYSCLK_SOURCE == SYSCLK_SRC_RC128KHZ) {
 211:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 2;
 212:../../../platform/common/services/clock/mega/sysclk.h **** 		} else {
 213:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz();
  80               		.loc 1 213 0
  81 0022 0E94 0000 		call sysclk_get_main_hz
  82 0026 DC01      		movw r26,r24
  83 0028 CB01      		movw r24,r22
 214:../../../platform/common/services/clock/mega/sysclk.h **** 		}
 215:../../../platform/common/services/clock/mega/sysclk.h **** 
 216:../../../platform/common/services/clock/mega/sysclk.h **** 	case SYSCLK_PSDIV_2:
 217:../../../platform/common/services/clock/mega/sysclk.h **** 		if (SYSCLK_SOURCE == SYSCLK_SRC_RC16MHZ ||
 218:../../../platform/common/services/clock/mega/sysclk.h **** 				SYSCLK_SOURCE == SYSCLK_SRC_RC128KHZ) {
 219:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 4;
 220:../../../platform/common/services/clock/mega/sysclk.h **** 		} else {
 221:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 2;
 222:../../../platform/common/services/clock/mega/sysclk.h **** 		}
 223:../../../platform/common/services/clock/mega/sysclk.h **** 
 224:../../../platform/common/services/clock/mega/sysclk.h **** 	case SYSCLK_PSDIV_4:
 225:../../../platform/common/services/clock/mega/sysclk.h **** 		if (SYSCLK_SOURCE == SYSCLK_SRC_RC16MHZ ||
 226:../../../platform/common/services/clock/mega/sysclk.h **** 				SYSCLK_SOURCE == SYSCLK_SRC_RC128KHZ) {
 227:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 8;
 228:../../../platform/common/services/clock/mega/sysclk.h **** 		} else {
 229:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 4;
 230:../../../platform/common/services/clock/mega/sysclk.h **** 		}
 231:../../../platform/common/services/clock/mega/sysclk.h **** 
 232:../../../platform/common/services/clock/mega/sysclk.h **** 	case SYSCLK_PSDIV_8:
 233:../../../platform/common/services/clock/mega/sysclk.h **** 		if (SYSCLK_SOURCE == SYSCLK_SRC_RC16MHZ ||
 234:../../../platform/common/services/clock/mega/sysclk.h **** 				SYSCLK_SOURCE == SYSCLK_SRC_RC128KHZ) {
 235:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 16;
 236:../../../platform/common/services/clock/mega/sysclk.h **** 		} else {
 237:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 8;
 238:../../../platform/common/services/clock/mega/sysclk.h **** 		}
 239:../../../platform/common/services/clock/mega/sysclk.h **** 
 240:../../../platform/common/services/clock/mega/sysclk.h **** 	case SYSCLK_PSDIV_16:
 241:../../../platform/common/services/clock/mega/sysclk.h **** 		if (SYSCLK_SOURCE == SYSCLK_SRC_RC16MHZ ||
 242:../../../platform/common/services/clock/mega/sysclk.h **** 				SYSCLK_SOURCE == SYSCLK_SRC_RC128KHZ) {
 243:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 32;
 244:../../../platform/common/services/clock/mega/sysclk.h **** 		} else {
 245:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 16;
 246:../../../platform/common/services/clock/mega/sysclk.h **** 		}
 247:../../../platform/common/services/clock/mega/sysclk.h **** 
 248:../../../platform/common/services/clock/mega/sysclk.h **** 	case SYSCLK_PSDIV_32:
 249:../../../platform/common/services/clock/mega/sysclk.h **** 		if (SYSCLK_SOURCE == SYSCLK_SRC_RC16MHZ ||
 250:../../../platform/common/services/clock/mega/sysclk.h **** 				SYSCLK_SOURCE == SYSCLK_SRC_RC128KHZ) {
 251:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 64;
 252:../../../platform/common/services/clock/mega/sysclk.h **** 		} else {
 253:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 32;
 254:../../../platform/common/services/clock/mega/sysclk.h **** 		}
 255:../../../platform/common/services/clock/mega/sysclk.h **** 
 256:../../../platform/common/services/clock/mega/sysclk.h **** 	case SYSCLK_PSDIV_64:
 257:../../../platform/common/services/clock/mega/sysclk.h **** 		if (SYSCLK_SOURCE == SYSCLK_SRC_RC16MHZ ||
 258:../../../platform/common/services/clock/mega/sysclk.h **** 				SYSCLK_SOURCE == SYSCLK_SRC_RC128KHZ) {
 259:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 128;
 260:../../../platform/common/services/clock/mega/sysclk.h **** 		} else {
 261:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 64;
 262:../../../platform/common/services/clock/mega/sysclk.h **** 		}
 263:../../../platform/common/services/clock/mega/sysclk.h **** 
 264:../../../platform/common/services/clock/mega/sysclk.h **** 	case SYSCLK_PSDIV_128:
 265:../../../platform/common/services/clock/mega/sysclk.h **** 		if (SYSCLK_SOURCE == SYSCLK_SRC_RC16MHZ ||
 266:../../../platform/common/services/clock/mega/sysclk.h **** 				SYSCLK_SOURCE == SYSCLK_SRC_RC128KHZ) {
 267:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 256;
 268:../../../platform/common/services/clock/mega/sysclk.h **** 		} else {
 269:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 128;
 270:../../../platform/common/services/clock/mega/sysclk.h **** 		}
 271:../../../platform/common/services/clock/mega/sysclk.h **** 
 272:../../../platform/common/services/clock/mega/sysclk.h **** 	case SYSCLK_PSDIV_256:
 273:../../../platform/common/services/clock/mega/sysclk.h **** 		if (SYSCLK_SOURCE == SYSCLK_SRC_RC16MHZ ||
 274:../../../platform/common/services/clock/mega/sysclk.h **** 				SYSCLK_SOURCE == SYSCLK_SRC_RC128KHZ) {
 275:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 512;
 276:../../../platform/common/services/clock/mega/sysclk.h **** 		} else {
 277:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 256;
 278:../../../platform/common/services/clock/mega/sysclk.h **** 		}
 279:../../../platform/common/services/clock/mega/sysclk.h **** 
 280:../../../platform/common/services/clock/mega/sysclk.h **** 	default:
 281:../../../platform/common/services/clock/mega/sysclk.h **** 		/*Invalide case*/
 282:../../../platform/common/services/clock/mega/sysclk.h **** 		return 0;
 283:../../../platform/common/services/clock/mega/sysclk.h **** 	}
 284:../../../platform/common/services/clock/mega/sysclk.h **** }
  84               		.loc 1 284 0
  85 002a BC01      		movw r22,r24
  86 002c CD01      		movw r24,r26
  87               	/* epilogue start */
  88 002e DF91      		pop r29
  89 0030 CF91      		pop r28
  90 0032 0895      		ret
  91               		.cfi_endproc
  92               	.LFE68:
  94               		.section	.progmem.data.baudctrl_1mhz,"a",@progbits
  97               	baudctrl_1mhz:
  98 0000 3300      		.word	51
  99 0002 1900      		.word	25
 100 0004 0C00      		.word	12
 101 0006 0600      		.word	6
 102 0008 0300      		.word	3
 103 000a 0200      		.word	2
 104 000c 0100      		.word	1
 105 000e FF00      		.word	255
 106               		.section	.progmem.data.baudctrl_8mhz,"a",@progbits
 109               	baudctrl_8mhz:
 110 0000 A001      		.word	416
 111 0002 CF00      		.word	207
 112 0004 6700      		.word	103
 113 0006 3300      		.word	51
 114 0008 1900      		.word	25
 115 000a 0C00      		.word	12
 116 000c 0700      		.word	7
 117 000e 0800      		.word	8
 118               		.section	.progmem.data.baudctrl_16mhz,"a",@progbits
 121               	baudctrl_16mhz:
 122 0000 4003      		.word	832
 123 0002 A001      		.word	416
 124 0004 CF00      		.word	207
 125 0006 6700      		.word	103
 126 0008 3300      		.word	51
 127 000a 1900      		.word	25
 128 000c 1000      		.word	16
 129 000e 1000      		.word	16
 130               		.text
 132               	usart_double_baud_enable:
 133               	.LFB101:
 134               		.file 2 "../../../platform/mega_rf/drivers/usart/usart_megarf.h"
   1:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
   2:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \file
   3:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
   4:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief USART driver for AVR MEGARF.
   5:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
   6:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * This file contains basic functions for the AVR MEGA USART, with support for
   7:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * all modes, settings and clock speeds.
   8:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
   9:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * Copyright (c) 2013-2015 Atmel Corporation. All rights reserved.
  10:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
  11:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \asf_license_start
  12:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
  13:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \page License
  14:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
  15:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * Redistribution and use in source and binary forms, with or without
  16:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * modification, are permitted provided that the following conditions are met:
  17:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
  18:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * 1. Redistributions of source code must retain the above copyright notice,
  19:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *    this list of conditions and the following disclaimer.
  20:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
  21:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * 2. Redistributions in binary form must reproduce the above copyright notice,
  22:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *    this list of conditions and the following disclaimer in the documentation
  23:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *    and/or other materials provided with the distribution.
  24:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
  25:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * 3. The name of Atmel may not be used to endorse or promote products derived
  26:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *    from this software without specific prior written permission.
  27:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
  28:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * 4. This software may only be redistributed and used in connection with an
  29:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *    Atmel microcontroller product.
  30:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
  31:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR IMPLIED
  32:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
  33:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
  34:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR
  35:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  36:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
  37:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  38:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
  39:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  40:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  41:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * POSSIBILITY OF SUCH DAMAGE.
  42:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
  43:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \asf_license_stop
  44:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
  45:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
  46:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #ifndef _USART_MEGARF_H_
  47:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define _USART_MEGARF_H_
  48:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
  49:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #ifdef __cplusplus
  50:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** extern "C" {
  51:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #endif
  52:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
  53:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #include "compiler.h"
  54:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #include "status_codes.h"
  55:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
  56:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
  57:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \defgroup megarf_usart_group USART module (USART)
  58:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
  59:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * See \ref megarf_usart_quickstart.
  60:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
  61:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * This is a driver for configuring, enabling, disabling and use of the on-chip
  62:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * USART.
  63:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
  64:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \section dependencies Dependencies
  65:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
  66:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * The USART module depends on the following modules:
  67:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *  - \ref sysclk_group for peripheral clock control.
  68:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *  - \ref port_driver_group for peripheral io port control.
  69:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
  70:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * @{
  71:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
  72:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
  73:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* ! Offset in lookup table for baudrate 1200 */
  74:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_BAUD_1200      0x00
  75:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* ! Offset in lookup table for baudrate 2400 */
  76:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_BAUD_2400      0x01
  77:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* ! Offset in lookup table for baudrate 4800 */
  78:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_BAUD_4800      0x02
  79:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* ! Offset in lookup table for baudrate 9600 */
  80:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_BAUD_9600      0x03
  81:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* ! Offset in lookup table for baudrate 19200 */
  82:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_BAUD_19200     0x04
  83:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* ! Offset in lookup table for baudrate 38400 */
  84:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_BAUD_38400     0x05
  85:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* ! Offset in lookup table for baudrate 57600 */
  86:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_BAUD_57600     0x06
  87:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* ! Offset in lookup table for baudrate 115200 */
  88:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_BAUD_115200    0x07
  89:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* ! Baudrate not in lookup table */
  90:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_BAUD_UNDEFINED 0xFF
  91:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
  92:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** typedef volatile uint8_t register8_t;
  93:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** typedef volatile uint16_t register16_t;
  94:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* Universal Synchronous/Asynchronous Receiver/Transmitter */
  95:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** typedef struct USART_struct {
  96:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	register8_t UCSRnA;  /* Control Register A */
  97:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	register8_t UCSRnB;  /* Control Register B */
  98:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	register8_t UCSRnC;  /* Control Register C */
  99:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	register8_t reserved;
 100:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	register16_t UBRR;  /* Baud Rate Register Value */
 101:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	register8_t UDR;  /* I/O Data Register */
 102:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** } USART_t;
 103:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 104:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USARTA0    (*(USART_t *)0xC0)   /* Universal Asynchronous
 105:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	                                 * Receiver-Transmitter A0 */
 106:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USARTA1    (*(USART_t *)0XC8)   /* Universal Asynchronous
 107:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	                                 * Receiver-Transmitter A1 */
 108:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 109:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* USART.UCSRxA  bit masks and bit positions */
 110:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_RXC_bm  0x80 /* RX complete bit mask.*/
 111:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_RXC_bp  7 /* RX complete bit position.*/
 112:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 113:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_TXC_bm  0x40 /* TX complete bit mask.*/
 114:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_TXC_bp  6 /* TX complete bit position.*/
 115:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 116:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_DRE_bm  0x20 /* DATA Register Empty Bit mask.*/
 117:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_DRE_bp  5 /*  DATA Register Empty bit position.*/
 118:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 119:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_FE_bm   0x10 /* Frame Error bit mask.*/
 120:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_FE_bp   4 /*Frame error bit position.*/
 121:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 122:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_DOR_bm  0x08 /* Data Over Run bit mask.*/
 123:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_DOR_bp  3 /* Data Over Run bit position.*/
 124:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 125:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_UPE_bm  0x04 /* Parity error bit mask.*/
 126:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_UPE_bp  2 /* Parity error bit position.*/
 127:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 128:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_U2X_bm  0x02 /* Double TX speed bit mask.*/
 129:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_U2X_bp  1 /* Double TX speed bit position.*/
 130:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 131:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_MPCM_bm  0x01 /* Multi Processor bit mask.*/
 132:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_MPMC_bp  0 /* Multi processor bit position.*/
 133:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 134:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* USART.UCSRxB  bit masks and bit positions */
 135:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_RXCIE_bm  0x80 /* RX complete interrupt Enable bit mask.*/
 136:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_RXCIE_bp  7 /* RX complete interrupt Enable bit position.*/
 137:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 138:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_TXCIE_bm  0x40 /* TX complete interrupt Enable bit mask.*/
 139:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_TXCIE_bp  6 /* TX complete interrupt Enable bit position.*/
 140:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 141:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_DRIE_bm  0x20 /* Data register empty interrupt Enable bit mask.*/
 142:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_DRIE_bp  5 /* Data register empty interrupt Enable bit position.*/
 143:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 144:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_RXEN_bm  0x10  /* Receiver Enable bit mask. */
 145:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_RXEN_bp  4  /* Receiver Enable bit position. */
 146:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 147:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_TXEN_bm  0x08  /* Transmitter Enable bit mask. */
 148:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_TXEN_bp  3  /* Transmitter Enable bit position. */
 149:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 150:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_CHSIZE2_bm  0x04  /* Character Size bit mask. */
 151:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_CHSIZE2_bp  2 /* Character Size bit position. */
 152:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 153:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_RXB8_bm  0x02  /* Transmit bit 8 bit mask. */
 154:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_RXB8_bp  1  /* Transmit bit 8 bit position. */
 155:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 156:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_TXB8_bm  0x01  /* Transmit bit 8 bit mask. */
 157:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_TXB8_bp  0  /* Transmit bit 8 bit position. */
 158:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 159:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* USART.UCSRxC  bit masks and bit positions */
 160:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_UMSEL01_gm  0xC0 /* USART Mode Select 01 grp mask.*/
 161:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_UMSEL01_gp  6 /* USART Mode Select 01 grp position.*/
 162:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 163:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_UMSEL01_bm  0x80 /* USART Mode Select 01 bit mask.*/
 164:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_UMSEL01_bp  7 /* USART Mode Select 01 bit position.*/
 165:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 166:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_UMSEL00_bm  0x40 /* USART Mode Select 00 bit mask.*/
 167:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_UMSEL00_bp  6 /* USART Mode Select 00 bit position.*/
 168:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 169:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_PMODE_gm  0x30 /* USART Parity Mode Select grp mask.*/
 170:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_PMODE_gp  4 /* USART Parity Mode Select grp position.*/
 171:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 172:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_PMODE01_bm  0x20 /* USART Parity Mode Select 01 bit mask.*/
 173:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_PMODE01_bp  5 /* USART Parity Mode Select 01 bit position.*/
 174:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 175:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_PMODE00_bm  0x10 /* USART Parity Mode Select 00 bit mask.*/
 176:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_PMODE00_bp  4 /* USART Parity Mode Select 00 bit position.*/
 177:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 178:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_STOPB_bm  0x08 /* USART stop bit mask.*/
 179:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_STOPB_bp  3 /* USART stop bit Position.*/
 180:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 181:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_CHSIZE01C_gm  0x06  /* Character Size 10 bit 1 mask. */
 182:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_CHSIZE01C_gp  1 /* Character Size 10 bit position. */
 183:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 184:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_CHSIZE01_bm  0x04  /* Character Size 10 bit 1 mask. */
 185:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_CHSIZE01_bp  2 /* Character Size 10 bit position. */
 186:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 187:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_CHSIZE00_bm  0x02  /* Character Size 00 bit 1 mask. */
 188:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_CHSIZE00_bp  1 /* Character Size bit 00 position. */
 189:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 190:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_UCPOL_bm  0x01  /* Sync mode Pol bit 1 mask. */
 191:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_UCPOL_bp  0 /*Sync mode Pol bit 0 position */
 192:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 193:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_UCPHA_bm 0x02 /* Clock Phase bit mask. */
 194:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_UCPHA_bp 1 /* Clock Phase bit position. */
 195:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 196:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_DORD_bm 0x04 /* Data order bit mask. */
 197:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_DORD_bp 2 /* Data order bit position. */
 198:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 199:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* Character Size */
 200:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** typedef enum USART_CHSIZE_enum {
 201:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	USART_CHSIZE_5BIT_gc = (0x00),  /* Character size: 5 bit */
 202:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	USART_CHSIZE_6BIT_gc = (0x01),  /* Character size: 6 bit */
 203:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	USART_CHSIZE_7BIT_gc = (0x02),  /* Character size: 7 bit */
 204:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	USART_CHSIZE_8BIT_gc = (0x03),  /* Character size: 8 bit */
 205:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	USART_CHSIZE_9BIT_gc = (0x07),  /* Character size: 9 bit */
 206:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** } USART_CHSIZE_t;
 207:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 208:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* Communication Mode */
 209:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** typedef enum USART_CMODE_enum {
 210:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	USART_CMODE_ASYNCHRONOUS_gc = (0x00 << USART_UMSEL01_gp),  /*
 211:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	                                                            *
 212:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	                                                            *
 213:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	                                                            *Asynchronous
 214:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	                                                            * Mode */
 215:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	USART_CMODE_SYNCHRONOUS_gc = (0x01 << USART_UMSEL01_gp),  /* Synchronous
 216:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	                                                           * Mode */
 217:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	USART_CMODE_IRDA_gc = (0x02 << USART_UMSEL01_gp),  /* IrDA Mode */
 218:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	USART_CMODE_MSPI_gc = (0x03 << USART_UMSEL01_gp),  /* Master SPI Mode */
 219:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** } USART_CMODE_t;
 220:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 221:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* Parity Mode */
 222:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** typedef enum USART_PMODE_enum {
 223:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	USART_PMODE_DISABLED_gc = (0x00 << USART_PMODE_gp),  /* No Parity */
 224:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	USART_PMODE_EVEN_gc = (0x02 << USART_PMODE_gp),  /* Even Parity */
 225:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	USART_PMODE_ODD_gc = (0x03 << USART_PMODE_gp),  /* Odd Parity */
 226:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** } USART_PMODE_t;
 227:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 228:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* ! Lookup table containing baudctrl values for CPU frequency 1 Mhz */
 229:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static PROGMEM_DECLARE(uint16_t, baudctrl_1mhz[]) = {
 230:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0033, /* Baud: 1200 */
 231:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0019, /* Baud: 2400 */
 232:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x000C, /* Baud: 4800 */
 233:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0006, /* Baud: 9600 */
 234:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0003, /* Baud: 19200 */
 235:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0002, /* Baud: 38400 */
 236:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0001, /* Baud: 57600 */
 237:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	USART_BAUD_UNDEFINED, /* Baud: 115200 */
 238:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** };
 239:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 240:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* ! Lookup table containing baudctrl values for CPU frequency 8 Mhz */
 241:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static PROGMEM_DECLARE(uint16_t, baudctrl_8mhz[]) = {
 242:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x01A0, /* Baud: 1200 */
 243:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x00CF, /* Baud: 2400 */
 244:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0067, /* Baud: 4800 */
 245:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0033, /* Baud: 9600 */
 246:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0019, /* Baud: 19200 */
 247:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x000C, /* Baud: 38400 */
 248:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0007, /* Baud: 57600 */
 249:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0008, /* Baud: 115200 */
 250:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** };
 251:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 252:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* ! Lookup table containing baudctrl values for CPU frequency 16 Mhz */
 253:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static PROGMEM_DECLARE(uint16_t, baudctrl_16mhz[]) = {
 254:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0340, /* Baud: 1200 */
 255:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x01A0, /* Baud: 2400 */
 256:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x00CF, /* Baud: 4800 */
 257:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0067, /* Baud: 9600 */
 258:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0033, /* Baud: 19200 */
 259:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0019, /* Baud: 38400 */
 260:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0010, /* Baud: 57600 */
 261:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0010, /* Baud: 115200 */
 262:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** };
 263:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 264:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 265:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* ! Input parameters when initializing RS232 and similar modes. */
 266:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** typedef struct usart_rs232_options {
 267:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	/* ! Set baud rate of the USART (unused in slave modes). */
 268:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	uint32_t baudrate;
 269:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 270:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	/* ! Number of bits to transmit as a character (5 to 9). */
 271:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	USART_CHSIZE_t charlength;
 272:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 273:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	/* ! Parity type: USART_PMODE_DISABLED_gc, USART_PMODE_EVEN_gc, */
 274:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	/* ! USART_PMODE_ODD_gc. */
 275:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	USART_PMODE_t paritytype;
 276:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 277:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	/* ! Number of stop bits between two characters: */
 278:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	/* ! true: 2 stop bits */
 279:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	/* ! false: 1 stop bit */
 280:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	bool stopbits;
 281:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** } usart_rs232_options_t;
 282:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 283:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* ! Input parameters when initializing SPI master mode. */
 284:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** typedef struct usart_spi_options {
 285:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	/* ! Set baud rate of the USART in SPI mode. */
 286:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	uint32_t baudrate;
 287:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 288:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	/* ! SPI transmission mode. */
 289:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	uint8_t spimode;
 290:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 291:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	uint8_t data_order;
 292:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** } usart_spi_options_t;
 293:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 294:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 295:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 296:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Enable USART receiver.
 297:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 298:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart Pointer to the USART module
 299:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 300:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline void usart_rx_enable(USART_t *usart)
 301:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 302:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	(usart)->UCSRnB |= USART_RXEN_bm;
 303:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 304:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 305:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 306:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Disable USART receiver.
 307:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 308:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart Pointer to the USART module.
 309:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 310:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline void usart_rx_disable(USART_t *usart)
 311:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 312:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	(usart)->UCSRnB &= ~USART_RXEN_bm;
 313:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 314:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 315:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 316:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief  Configure the USART frame format.
 317:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 318:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *  Sets the frame format, Frame Size, parity mode and number of stop bits.
 319:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 320:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *  \param usart Pointer to the USART module
 321:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *  \param charSize The character size. Use USART_CHSIZE_t type.
 322:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *  \param parityMode The parity Mode. Use USART_PMODE_t type.
 323:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *  \param twoStopBits Enable two stop bit mode. Use bool type.
 324:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 325:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline void usart_format_set(USART_t *usart, USART_CHSIZE_t charSize,
 326:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 		USART_PMODE_t parityMode, bool twoStopBits)
 327:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 328:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	(usart)->UCSRnC
 329:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 		= ((usart)->UCSRnC &
 330:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 			(~USART_CHSIZE01C_gm)) | ((charSize & 0x03)
 331:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 			<< USART_CHSIZE01C_gp);
 332:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	(usart)->UCSRnB
 333:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 		= ((usart)->UCSRnB &
 334:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 			(~USART_CHSIZE2_bm)) | ((charSize & 0x04)
 335:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 			<< USART_CHSIZE2_bp);
 336:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 337:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	(usart)->UCSRnC = ((usart)->UCSRnC & (~USART_PMODE_gm)) | parityMode;
 338:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 339:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	(usart)->UCSRnC = ((usart)->UCSRnC & (~USART_STOPB_bm)) | (twoStopBits
 340:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 			<< USART_STOPB_bp);
 341:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 342:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 343:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 344:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Enable USART transmitter.
 345:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 346:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart Pointer to the USART module.
 347:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 348:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline void usart_tx_enable(USART_t *usart)
 349:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 350:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	(usart)->UCSRnB |= USART_TXEN_bm;
 351:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 352:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 353:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 354:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Disable USART transmitter.
 355:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 356:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart Pointer to the USART module.
 357:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 358:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline void usart_tx_disable(USART_t *usart)
 359:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 360:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	(usart)->UCSRnB &= ~USART_TXEN_bm;
 361:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 362:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 363:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 364:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Enable USART transmit complete interrupt.
 365:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 366:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart Pointer to the USART module.
 367:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 368:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline void usart_tx_complete_interrupt_enable(USART_t *usart)
 369:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 370:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	(usart)->UCSRnB |= USART_TXC_bm;
 371:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 372:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 373:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 374:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Enable USART receive complete interrupt.
 375:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 376:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart Pointer to the USART module.
 377:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 378:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline void usart_rx_complete_interrupt_enable(USART_t *usart)
 379:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 380:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	(usart)->UCSRnB |= USART_RXC_bm;
 381:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 382:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 383:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 384:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Enable USART data register empty interrupt.
 385:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 386:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart Pointer to the USART module.
 387:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 388:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline void usart_data_empty_interrupt_enable(USART_t *usart)
 389:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 390:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	(usart)->UCSRnB |= USART_DRIE_bm;
 391:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 392:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 393:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 394:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Disable USART transmit complete interrupt.
 395:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 396:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart Pointer to the USART module.
 397:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 398:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline void usart_tx_complete_interrupt_disable(USART_t *usart)
 399:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 400:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	(usart)->UCSRnB &= ~USART_TXC_bm;
 401:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 402:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 403:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 404:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Disable USART receive complete interrupt.
 405:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 406:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart Pointer to the USART module.
 407:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 408:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline void usart_rx_complete_interrupt_disable(USART_t *usart)
 409:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 410:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	(usart)->UCSRnB &= ~USART_RXC_bm;
 411:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 412:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 413:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 414:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Disable USART data register empty interrupt.
 415:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 416:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart Pointer to the USART module.
 417:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 418:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline void usart_data_empty_interrupt_disable(USART_t *usart)
 419:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 420:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	(usart)->UCSRnB &= ~USART_DRIE_bm;
 421:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 422:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 423:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 424:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Set the mode the USART run in.
 425:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 426:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * Set the mode the USART run in. The default mode is asynchronous mode.
 427:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 428:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart Pointer to the USART module register section.
 429:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usartmode Selects the USART mode. Use USART_CMODE_t type.
 430:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 431:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * USART modes:
 432:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * - 0x0        : Asynchronous mode.
 433:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * - 0x1        : Synchronous mode.
 434:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * - 0x2        : IrDA mode.
 435:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * - 0x3        : Master SPI mode.
 436:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 437:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline void usart_set_mode(USART_t *usart, USART_CMODE_t usartmode)
 438:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 439:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	(usart)->UCSRnC = ((usart)->UCSRnC & (~USART_UMSEL01_gm)) | usartmode;
 440:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 441:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 442:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 443:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Check if data register empty flag is set.
 444:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 445:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart The USART module.
 446:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 447:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline bool usart_data_register_is_empty(USART_t *usart)
 448:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 449:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	return (usart)->UCSRnA & USART_DRE_bm;
 450:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 451:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 452:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 453:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Checks if the RX complete interrupt flag is set.
 454:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 455:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * Checks if the RX complete interrupt flag is set.
 456:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 457:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart The USART module.
 458:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 459:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline bool usart_rx_is_complete(USART_t *usart)
 460:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 461:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	return (usart)->UCSRnA & USART_RXC_bm;
 462:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 463:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 464:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 465:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Checks if the TX complete interrupt flag is set.
 466:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 467:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * Checks if the TX complete interrupt flag is set.
 468:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 469:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart The USART module.
 470:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 471:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline bool usart_tx_is_complete(USART_t *usart)
 472:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 473:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	return (usart)->UCSRnA & USART_TXC_bm;
 474:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 475:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 476:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 477:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Clear TX complete interrupt flag.
 478:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * TX flag is clear after complete transmission, automatically.
 479:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart The USART module.
 480:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 481:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline void usart_clear_tx_complete(USART_t *usart)
 482:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 483:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****          usart->UCSRnA |=  USART_TXC_bm;
 484:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 485:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 486:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 487:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Write a data to the USART data register.
 488:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 489:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart The USART module.
 490:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param txdata The data to be transmitted.
 491:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 492:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline void usart_put(USART_t *usart, uint8_t txdata)
 493:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 494:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	(usart)->UDR = txdata;
 495:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 496:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 497:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 498:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief  Read a data to the USART data register.
 499:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 500:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart The USART module.
 501:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 502:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \return The received data
 503:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 504:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline uint8_t usart_get(USART_t *usart)
 505:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 506:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	return (usart)->UDR;
 507:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 508:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 509:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 510:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Double the USART transmission speed.
 511:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 512:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart The USART module.
 513:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 514:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline void usart_double_baud_enable(USART_t *usart)
 515:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 135               		.loc 2 515 0
 136               		.cfi_startproc
 137 0034 CF93      		push r28
 138               	.LCFI6:
 139               		.cfi_def_cfa_offset 3
 140               		.cfi_offset 28, -2
 141 0036 DF93      		push r29
 142               	.LCFI7:
 143               		.cfi_def_cfa_offset 4
 144               		.cfi_offset 29, -3
 145 0038 00D0      		rcall .
 146               	.LCFI8:
 147               		.cfi_def_cfa_offset 6
 148 003a CDB7      		in r28,__SP_L__
 149 003c DEB7      		in r29,__SP_H__
 150               	.LCFI9:
 151               		.cfi_def_cfa_register 28
 152               	/* prologue: function */
 153               	/* frame size = 2 */
 154               	/* stack size = 4 */
 155               	.L__stack_usage = 4
 156 003e 9A83      		std Y+2,r25
 157 0040 8983      		std Y+1,r24
 516:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	usart->UCSRnA |=  USART_U2X_bm;
 158               		.loc 2 516 0
 159 0042 8981      		ldd r24,Y+1
 160 0044 9A81      		ldd r25,Y+2
 161 0046 FC01      		movw r30,r24
 162 0048 8081      		ld r24,Z
 163 004a 282F      		mov r18,r24
 164 004c 2260      		ori r18,lo8(2)
 165 004e 8981      		ldd r24,Y+1
 166 0050 9A81      		ldd r25,Y+2
 167 0052 FC01      		movw r30,r24
 168 0054 2083      		st Z,r18
 517:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 169               		.loc 2 517 0
 170 0056 0000      		nop
 171               	/* epilogue start */
 172 0058 0F90      		pop __tmp_reg__
 173 005a 0F90      		pop __tmp_reg__
 174 005c DF91      		pop r29
 175 005e CF91      		pop r28
 176 0060 0895      		ret
 177               		.cfi_endproc
 178               	.LFE101:
 181               	usart_serial_init:
 182               	.LFB104:
 183               		.file 3 "../../../platform/common/services/serial/megarf_usart/usart_serial.h"
   1:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** /**
   2:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * \file
   3:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
   4:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * \brief This file defines a useful set of functions for the Serial interface on 
   5:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * AVR MEGARF devices.
   6:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
   7:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * Copyright (c) 2013 Atmel Corporation. All rights reserved.
   8:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
   9:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * \asf_license_start
  10:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
  11:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * \page License
  12:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
  13:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * Redistribution and use in source and binary forms, with or without
  14:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * modification, are permitted provided that the following conditions are met:
  15:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
  16:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * 1. Redistributions of source code must retain the above copyright notice,
  17:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *    this list of conditions and the following disclaimer.
  18:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
  19:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * 2. Redistributions in binary form must reproduce the above copyright notice,
  20:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *    this list of conditions and the following disclaimer in the documentation
  21:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *    and/or other materials provided with the distribution.
  22:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
  23:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * 3. The name of Atmel may not be used to endorse or promote products derived
  24:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *    from this software without specific prior written permission.
  25:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
  26:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * 4. This software may only be redistributed and used in connection with an
  27:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *    Atmel microcontroller product.
  28:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
  29:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR IMPLIED
  30:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
  31:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
  32:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR
  33:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  34:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
  35:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  36:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
  37:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  38:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  39:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * POSSIBILITY OF SUCH DAMAGE.
  40:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
  41:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * \asf_license_stop
  42:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
  43:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  */
  44:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** #ifndef _USART_SERIAL_H_
  45:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** #define _USART_SERIAL_H_
  46:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 
  47:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** #ifdef __cplusplus
  48:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** extern "C" {
  49:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** #endif
  50:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 
  51:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** #include "compiler.h"
  52:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** #include "sysclk.h"
  53:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** #include "status_codes.h"
  54:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** #include "usart_megarf.h"
  55:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 
  56:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** /*! \name Serial Management Configuration
  57:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  */
  58:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** /* ! @{ */
  59:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** #include "conf_usart_serial.h"
  60:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** /* ! @} */
  61:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 
  62:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** typedef usart_rs232_options_t usart_serial_options_t;
  63:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 
  64:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** typedef USART_t *usart_if;
  65:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 
  66:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** /*! \brief Initializes the Usart in master mode.
  67:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
  68:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * \param usart       Base address of the USART instance.
  69:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * \param options     Options needed to set up RS232 communication (see \ref
  70:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * usart_serial_options_t).
  71:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
  72:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * \retval true if the initialization was successful
  73:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * \retval false if initialization failed (error in baud rate calculation)
  74:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  */
  75:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** static inline bool usart_serial_init(usart_if usart, const
  76:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 		usart_serial_options_t *options)
  77:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** {
 184               		.loc 3 77 0
 185               		.cfi_startproc
 186 0062 CF93      		push r28
 187               	.LCFI10:
 188               		.cfi_def_cfa_offset 3
 189               		.cfi_offset 28, -2
 190 0064 DF93      		push r29
 191               	.LCFI11:
 192               		.cfi_def_cfa_offset 4
 193               		.cfi_offset 29, -3
 194 0066 CDB7      		in r28,__SP_L__
 195 0068 DEB7      		in r29,__SP_H__
 196               	.LCFI12:
 197               		.cfi_def_cfa_register 28
 198 006a 2B97      		sbiw r28,11
 199               	.LCFI13:
 200               		.cfi_def_cfa_offset 15
 201 006c 0FB6      		in __tmp_reg__,__SREG__
 202 006e F894      		cli
 203 0070 DEBF      		out __SP_H__,r29
 204 0072 0FBE      		out __SREG__,__tmp_reg__
 205 0074 CDBF      		out __SP_L__,r28
 206               	/* prologue: function */
 207               	/* frame size = 11 */
 208               	/* stack size = 13 */
 209               	.L__stack_usage = 13
 210 0076 9987      		std Y+9,r25
 211 0078 8887      		std Y+8,r24
 212 007a 7B87      		std Y+11,r23
 213 007c 6A87      		std Y+10,r22
  78:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 	/* USART options. */
  79:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 	usart_rs232_options_t usart_rs232_options;
  80:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 	usart_rs232_options.charlength   = options->charlength;
 214               		.loc 3 80 0
 215 007e 8A85      		ldd r24,Y+10
 216 0080 9B85      		ldd r25,Y+11
 217 0082 FC01      		movw r30,r24
 218 0084 8481      		ldd r24,Z+4
 219 0086 8D83      		std Y+5,r24
  81:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 	usart_rs232_options.paritytype   = options->paritytype;
 220               		.loc 3 81 0
 221 0088 8A85      		ldd r24,Y+10
 222 008a 9B85      		ldd r25,Y+11
 223 008c FC01      		movw r30,r24
 224 008e 8581      		ldd r24,Z+5
 225 0090 8E83      		std Y+6,r24
  82:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 	usart_rs232_options.stopbits     = options->stopbits;
 226               		.loc 3 82 0
 227 0092 8A85      		ldd r24,Y+10
 228 0094 9B85      		ldd r25,Y+11
 229 0096 FC01      		movw r30,r24
 230 0098 8681      		ldd r24,Z+6
 231 009a 8F83      		std Y+7,r24
  83:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 	usart_rs232_options.baudrate     = options->baudrate;
 232               		.loc 3 83 0
 233 009c 8A85      		ldd r24,Y+10
 234 009e 9B85      		ldd r25,Y+11
 235 00a0 FC01      		movw r30,r24
 236 00a2 8081      		ld r24,Z
 237 00a4 9181      		ldd r25,Z+1
 238 00a6 A281      		ldd r26,Z+2
 239 00a8 B381      		ldd r27,Z+3
 240 00aa 8983      		std Y+1,r24
 241 00ac 9A83      		std Y+2,r25
 242 00ae AB83      		std Y+3,r26
 243 00b0 BC83      		std Y+4,r27
  84:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 
  85:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 	if (usart_init_rs232(usart, &usart_rs232_options)) {
 244               		.loc 3 85 0
 245 00b2 8885      		ldd r24,Y+8
 246 00b4 9985      		ldd r25,Y+9
 247 00b6 9E01      		movw r18,r28
 248 00b8 2F5F      		subi r18,-1
 249 00ba 3F4F      		sbci r19,-1
 250 00bc B901      		movw r22,r18
 251 00be 0E94 0000 		call usart_init_rs232
 252 00c2 8823      		tst r24
 253 00c4 01F0      		breq .L7
  86:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 		return true;
 254               		.loc 3 86 0
 255 00c6 81E0      		ldi r24,lo8(1)
 256 00c8 00C0      		rjmp .L9
 257               	.L7:
  87:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 	} else {
  88:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 		return false;
 258               		.loc 3 88 0
 259 00ca 80E0      		ldi r24,0
 260               	.L9:
 261               	/* epilogue start */
  89:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 	}
  90:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** }
 262               		.loc 3 90 0 discriminator 1
 263 00cc 2B96      		adiw r28,11
 264 00ce 0FB6      		in __tmp_reg__,__SREG__
 265 00d0 F894      		cli
 266 00d2 DEBF      		out __SP_H__,r29
 267 00d4 0FBE      		out __SREG__,__tmp_reg__
 268 00d6 CDBF      		out __SP_L__,r28
 269 00d8 DF91      		pop r29
 270 00da CF91      		pop r28
 271 00dc 0895      		ret
 272               		.cfi_endproc
 273               	.LFE104:
 276               	usart_serial_putchar:
 277               	.LFB105:
  91:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 
  92:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** /*! \brief Sends a character with the USART.
  93:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
  94:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * \param usart   Base address of the USART instance.
  95:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * \param c       Character to write.
  96:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
  97:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * \return Status code
  98:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  */
  99:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** static inline status_code_t usart_serial_putchar(usart_if usart, uint8_t c)
 100:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** {
 278               		.loc 3 100 0
 279               		.cfi_startproc
 280 00de CF93      		push r28
 281               	.LCFI14:
 282               		.cfi_def_cfa_offset 3
 283               		.cfi_offset 28, -2
 284 00e0 DF93      		push r29
 285               	.LCFI15:
 286               		.cfi_def_cfa_offset 4
 287               		.cfi_offset 29, -3
 288 00e2 00D0      		rcall .
 289 00e4 1F92      		push __zero_reg__
 290               	.LCFI16:
 291               		.cfi_def_cfa_offset 7
 292 00e6 CDB7      		in r28,__SP_L__
 293 00e8 DEB7      		in r29,__SP_H__
 294               	.LCFI17:
 295               		.cfi_def_cfa_register 28
 296               	/* prologue: function */
 297               	/* frame size = 3 */
 298               	/* stack size = 5 */
 299               	.L__stack_usage = 5
 300 00ea 9A83      		std Y+2,r25
 301 00ec 8983      		std Y+1,r24
 302 00ee 6B83      		std Y+3,r22
 101:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 	return usart_putchar(usart, c);
 303               		.loc 3 101 0
 304 00f0 8981      		ldd r24,Y+1
 305 00f2 9A81      		ldd r25,Y+2
 306 00f4 6B81      		ldd r22,Y+3
 307 00f6 0E94 0000 		call usart_putchar
 308               	/* epilogue start */
 102:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** }
 309               		.loc 3 102 0
 310 00fa 0F90      		pop __tmp_reg__
 311 00fc 0F90      		pop __tmp_reg__
 312 00fe 0F90      		pop __tmp_reg__
 313 0100 DF91      		pop r29
 314 0102 CF91      		pop r28
 315 0104 0895      		ret
 316               		.cfi_endproc
 317               	.LFE105:
 320               	usart_serial_getchar:
 321               	.LFB106:
 103:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 
 104:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** /*! \brief Waits until a character is received, and returns it.
 105:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
 106:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * \param usart   Base address of the USART instance.
 107:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * \param data   Data to read
 108:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
 109:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  */
 110:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** static inline void usart_serial_getchar(usart_if usart, uint8_t *data)
 111:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** {
 322               		.loc 3 111 0
 323               		.cfi_startproc
 324 0106 CF93      		push r28
 325               	.LCFI18:
 326               		.cfi_def_cfa_offset 3
 327               		.cfi_offset 28, -2
 328 0108 DF93      		push r29
 329               	.LCFI19:
 330               		.cfi_def_cfa_offset 4
 331               		.cfi_offset 29, -3
 332 010a 00D0      		rcall .
 333 010c 00D0      		rcall .
 334               	.LCFI20:
 335               		.cfi_def_cfa_offset 8
 336 010e CDB7      		in r28,__SP_L__
 337 0110 DEB7      		in r29,__SP_H__
 338               	.LCFI21:
 339               		.cfi_def_cfa_register 28
 340               	/* prologue: function */
 341               	/* frame size = 4 */
 342               	/* stack size = 6 */
 343               	.L__stack_usage = 6
 344 0112 9A83      		std Y+2,r25
 345 0114 8983      		std Y+1,r24
 346 0116 7C83      		std Y+4,r23
 347 0118 6B83      		std Y+3,r22
 112:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 	*data = usart_getchar(usart);
 348               		.loc 3 112 0
 349 011a 8981      		ldd r24,Y+1
 350 011c 9A81      		ldd r25,Y+2
 351 011e 0E94 0000 		call usart_getchar
 352 0122 282F      		mov r18,r24
 353 0124 8B81      		ldd r24,Y+3
 354 0126 9C81      		ldd r25,Y+4
 355 0128 FC01      		movw r30,r24
 356 012a 2083      		st Z,r18
 113:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** }
 357               		.loc 3 113 0
 358 012c 0000      		nop
 359               	/* epilogue start */
 360 012e 0F90      		pop __tmp_reg__
 361 0130 0F90      		pop __tmp_reg__
 362 0132 0F90      		pop __tmp_reg__
 363 0134 0F90      		pop __tmp_reg__
 364 0136 DF91      		pop r29
 365 0138 CF91      		pop r28
 366 013a 0895      		ret
 367               		.cfi_endproc
 368               	.LFE106:
 371               	stdio_serial_init:
 372               	.LFB107:
 373               		.file 4 "../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h"
   1:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** /**
   2:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
   3:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * \file
   4:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
   5:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * \brief Common Standard I/O Serial Management.
   6:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
   7:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * This file defines a useful set of functions for the Stdio Serial interface on AVR
   8:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * and SAM devices.
   9:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
  10:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * Copyright (c) 2009-2013 Atmel Corporation. All rights reserved.
  11:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
  12:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * \asf_license_start
  13:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
  14:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * \page License
  15:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
  16:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * Redistribution and use in source and binary forms, with or without
  17:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * modification, are permitted provided that the following conditions are met:
  18:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
  19:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * 1. Redistributions of source code must retain the above copyright notice,
  20:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *    this list of conditions and the following disclaimer.
  21:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
  22:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * 2. Redistributions in binary form must reproduce the above copyright notice,
  23:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *    this list of conditions and the following disclaimer in the documentation
  24:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *    and/or other materials provided with the distribution.
  25:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
  26:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * 3. The name of Atmel may not be used to endorse or promote products derived
  27:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *    from this software without specific prior written permission.
  28:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
  29:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * 4. This software may only be redistributed and used in connection with an
  30:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *    Atmel microcontroller product.
  31:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
  32:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR IMPLIED
  33:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
  34:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
  35:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR
  36:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  37:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
  38:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  39:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
  40:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  41:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  42:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * POSSIBILITY OF SUCH DAMAGE.
  43:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
  44:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * \asf_license_stop
  45:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
  46:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  ******************************************************************************/
  47:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 
  48:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 
  49:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** #ifndef _STDIO_SERIAL_H_
  50:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** #define _STDIO_SERIAL_H_
  51:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 
  52:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** /**
  53:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * \defgroup group_common_utils_stdio_stdio_serial Standard serial I/O (stdio)
  54:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * \ingroup group_common_utils_stdio
  55:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
  56:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * Common standard serial I/O management driver that
  57:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * implements a stdio serial interface on AVR and SAM devices.
  58:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
  59:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * \{
  60:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  */
  61:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 
  62:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** #include <stdio.h>
  63:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** #include "compiler.h"
  64:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** #ifndef SAMD20
  65:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** # include "sysclk.h"
  66:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** #endif
  67:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** #include "serial.h"
  68:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 
  69:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** #if (XMEGA || MEGA_RF) && defined(__GNUC__)
  70:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	extern int _write (char c, int *f);
  71:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	extern int _read (int *f);
  72:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** #endif
  73:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 
  74:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 
  75:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** //! Pointer to the base of the USART module instance to use for stdio.
  76:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** extern volatile void *volatile stdio_base;
  77:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** //! Pointer to the external low level write function.
  78:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** extern int (*ptr_put)(void volatile*, char);
  79:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 
  80:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** //! Pointer to the external low level read function.
  81:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** extern void (*ptr_get)(void volatile*, char*);
  82:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 
  83:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** /*! \brief Initializes the stdio in Serial Mode.
  84:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
  85:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * \param usart       Base address of the USART instance.
  86:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * \param opt         Options needed to set up RS232 communication (see \ref usart_options_t).
  87:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
  88:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  */
  89:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** static inline void stdio_serial_init(volatile void *usart, const usart_serial_options_t *opt)
  90:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** {
 374               		.loc 4 90 0
 375               		.cfi_startproc
 376 013c CF93      		push r28
 377               	.LCFI22:
 378               		.cfi_def_cfa_offset 3
 379               		.cfi_offset 28, -2
 380 013e DF93      		push r29
 381               	.LCFI23:
 382               		.cfi_def_cfa_offset 4
 383               		.cfi_offset 29, -3
 384 0140 00D0      		rcall .
 385 0142 00D0      		rcall .
 386               	.LCFI24:
 387               		.cfi_def_cfa_offset 8
 388 0144 CDB7      		in r28,__SP_L__
 389 0146 DEB7      		in r29,__SP_H__
 390               	.LCFI25:
 391               		.cfi_def_cfa_register 28
 392               	/* prologue: function */
 393               	/* frame size = 4 */
 394               	/* stack size = 6 */
 395               	.L__stack_usage = 6
 396 0148 9A83      		std Y+2,r25
 397 014a 8983      		std Y+1,r24
 398 014c 7C83      		std Y+4,r23
 399 014e 6B83      		std Y+3,r22
  91:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	stdio_base = (void *)usart;
 400               		.loc 4 91 0
 401 0150 8981      		ldd r24,Y+1
 402 0152 9A81      		ldd r25,Y+2
 403 0154 9093 0000 		sts stdio_base+1,r25
 404 0158 8093 0000 		sts stdio_base,r24
  92:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	ptr_put = (int (*)(void volatile*,char))&usart_serial_putchar;
 405               		.loc 4 92 0
 406 015c 80E0      		ldi r24,lo8(gs(usart_serial_putchar))
 407 015e 90E0      		ldi r25,hi8(gs(usart_serial_putchar))
 408 0160 9093 0000 		sts ptr_put+1,r25
 409 0164 8093 0000 		sts ptr_put,r24
  93:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	ptr_get = (void (*)(void volatile*,char*))&usart_serial_getchar;
 410               		.loc 4 93 0
 411 0168 80E0      		ldi r24,lo8(gs(usart_serial_getchar))
 412 016a 90E0      		ldi r25,hi8(gs(usart_serial_getchar))
 413 016c 9093 0000 		sts ptr_get+1,r25
 414 0170 8093 0000 		sts ptr_get,r24
  94:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** # if (XMEGA || MEGA_RF)
  95:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	usart_serial_init((USART_t *)usart,opt);
 415               		.loc 4 95 0
 416 0174 2B81      		ldd r18,Y+3
 417 0176 3C81      		ldd r19,Y+4
 418 0178 8981      		ldd r24,Y+1
 419 017a 9A81      		ldd r25,Y+2
 420 017c B901      		movw r22,r18
 421 017e 0E94 0000 		call usart_serial_init
  96:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** # elif UC3
  97:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	usart_serial_init(usart,(usart_serial_options_t *)opt);
  98:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** # elif SAM
  99:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	usart_serial_init((Usart *)usart,(usart_serial_options_t *)opt);
 100:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** # else
 101:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** #  error Unsupported chip type
 102:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** # endif
 103:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 
 104:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** # if defined(__GNUC__)
 105:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** #  if (XMEGA || MEGA_RF)
 106:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	// For AVR GCC libc print redirection uses fdevopen.
 107:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	fdevopen((int (*)(char, FILE*))(_write),(int (*)(FILE*))(_read));
 422               		.loc 4 107 0
 423 0182 60E0      		ldi r22,lo8(gs(_read))
 424 0184 70E0      		ldi r23,hi8(gs(_read))
 425 0186 80E0      		ldi r24,lo8(gs(_write))
 426 0188 90E0      		ldi r25,hi8(gs(_write))
 427 018a 0E94 0000 		call fdevopen
 108:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** #  endif
 109:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** #  if UC3 || SAM
 110:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	// For AVR32 and SAM GCC
 111:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	// Specify that stdout and stdin should not be buffered.
 112:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	setbuf(stdout, NULL);
 113:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	setbuf(stdin, NULL);
 114:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	// Note: Already the case in IAR's Normal DLIB default configuration
 115:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	// and AVR GCC library:
 116:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	// - printf() emits one character at a time.
 117:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	// - getchar() requests only 1 byte to exit.
 118:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** #  endif
 119:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** # endif
 120:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** }
 428               		.loc 4 120 0
 429 018e 0000      		nop
 430               	/* epilogue start */
 431 0190 0F90      		pop __tmp_reg__
 432 0192 0F90      		pop __tmp_reg__
 433 0194 0F90      		pop __tmp_reg__
 434 0196 0F90      		pop __tmp_reg__
 435 0198 DF91      		pop r29
 436 019a CF91      		pop r28
 437 019c 0895      		ret
 438               		.cfi_endproc
 439               	.LFE107:
 442               	macsc_read32:
 443               	.LFB108:
 444               		.file 5 "../../../platform/mega_rf/drivers/macsc/macsc_megarf.h"
   1:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
   2:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \file
   3:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
   4:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief AVR MEGARF MAC Symbol Counter Driver Definitions
   5:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
   6:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * Copyright (c) 2013 Atmel Corporation. All rights reserved.
   7:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
   8:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \asf_license_start
   9:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  10:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \page License
  11:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  12:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * Redistribution and use in source and binary forms, with or without
  13:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * modification, are permitted provided that the following conditions are met:
  14:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  15:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * 1. Redistributions of source code must retain the above copyright notice,
  16:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *    this list of conditions and the following disclaimer.
  17:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  18:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * 2. Redistributions in binary form must reproduce the above copyright notice,
  19:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *    this list of conditions and the following disclaimer in the documentation
  20:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *    and/or other materials provided with the distribution.
  21:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  22:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * 3. The name of Atmel may not be used to endorse or promote products derived
  23:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *    from this software without specific prior written permission.
  24:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  25:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * 4. This software may only be redistributed and used in connection with an
  26:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *    Atmel microcontroller product.
  27:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  28:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR IMPLIED
  29:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
  30:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
  31:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR
  32:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  33:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
  34:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  35:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
  36:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  37:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  38:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * POSSIBILITY OF SUCH DAMAGE.
  39:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  40:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \asf_license_stop
  41:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  42:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
  43:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** #ifndef MACSC_MEGARF_H
  44:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** #define MACSC_MEGARF_H
  45:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
  46:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** #include <compiler.h>
  47:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** #include <parts.h>
  48:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** #include "status_codes.h"
  49:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
  50:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** #ifdef __cplusplus
  51:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** extern "C" {
  52:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** #endif
  53:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
  54:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
  55:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \defgroup macsc_group MAC Symbol Counter Driver(MACSC)
  56:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  57:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * See \ref megarf_macsc_quickstart
  58:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  59:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * This is a driver for the AVR MEGARF MAC Symbol Counter Driver(MACSC).
  60:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * It provides functions for enabling, disabling and configuring the module.
  61:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  62:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \section dependencies Dependencies
  63:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * This driver depends on the following modules:
  64:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * - \ref interrupt_group for ISR definition and disabling interrupts during
  65:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * critical code sections.
  66:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * @{
  67:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
  68:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
  69:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
  70:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Interrupt event callback function type
  71:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  72:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * The interrupt handler can be configured to do a function callback,
  73:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * the callback function must match the macsc_callback_t type.
  74:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  75:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
  76:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** typedef void (*macsc_callback_t)(void);
  77:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
  78:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /* ! MAC symbol counter compare Channel index */
  79:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** enum macsc_cc_channel {
  80:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	/* ! Channel 1 */
  81:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	MACSC_CC1 = 1,
  82:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	/* ! Channel 2 */
  83:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	MACSC_CC2 = 2,
  84:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	/* ! Channel 3 */
  85:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	MACSC_CC3 = 3,
  86:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** };
  87:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
  88:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief MAC SC clock source select
  89:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  90:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * uses the SCCKSEL bit in SSCR register to select macsc clk src
  91:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  92:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * If the bit is one,the RTC clock from TOSC1 is selected, otherwise the symbol
  93:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * counter operates with the clock from XTAL1.
  94:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * During transceiver sleep modes the clock falls back to the RTC clock source,
  95:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * regardless of the selected clock. After wakeup, it switches back to the
  96:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * previosly
  97:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * selected clock source.
  98:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
  99:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 100:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** enum macsc_xtal {
 101:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	/* ! 16MHz as macsc clock */
 102:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	MACSC_16MHz = 0,
 103:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	MACSC_32KHz = 1,
 104:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** };
 105:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 106:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 107:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * @brief Reads the 32-bit timer register in the required order of bytes
 108:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 109:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * @param hh hh octet of 32-bit register
 110:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * @param hl hl octet of 32-bit register
 111:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * @param lh lh octet of 32-bit register
 112:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * @param ll ll octet of 32-bit register
 113:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 114:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * @returns uint32_t Value of timer register
 115:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 116:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** static inline uint32_t macsc_read32(volatile uint8_t *hh,
 117:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		volatile uint8_t *hl,
 118:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		volatile uint8_t *lh,
 119:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		volatile uint8_t *ll)
 120:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** {
 445               		.loc 5 120 0
 446               		.cfi_startproc
 447 019e CF93      		push r28
 448               	.LCFI26:
 449               		.cfi_def_cfa_offset 3
 450               		.cfi_offset 28, -2
 451 01a0 DF93      		push r29
 452               	.LCFI27:
 453               		.cfi_def_cfa_offset 4
 454               		.cfi_offset 29, -3
 455 01a2 CDB7      		in r28,__SP_L__
 456 01a4 DEB7      		in r29,__SP_H__
 457               	.LCFI28:
 458               		.cfi_def_cfa_register 28
 459 01a6 2C97      		sbiw r28,12
 460               	.LCFI29:
 461               		.cfi_def_cfa_offset 16
 462 01a8 0FB6      		in __tmp_reg__,__SREG__
 463 01aa F894      		cli
 464 01ac DEBF      		out __SP_H__,r29
 465 01ae 0FBE      		out __SREG__,__tmp_reg__
 466 01b0 CDBF      		out __SP_L__,r28
 467               	/* prologue: function */
 468               	/* frame size = 12 */
 469               	/* stack size = 14 */
 470               	.L__stack_usage = 14
 471 01b2 9E83      		std Y+6,r25
 472 01b4 8D83      		std Y+5,r24
 473 01b6 7887      		std Y+8,r23
 474 01b8 6F83      		std Y+7,r22
 475 01ba 5A87      		std Y+10,r21
 476 01bc 4987      		std Y+9,r20
 477 01be 3C87      		std Y+12,r19
 478 01c0 2B87      		std Y+11,r18
 121:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	union {
 122:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		uint8_t a[4];
 123:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		uint32_t rv;
 124:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	}
 125:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	x;
 126:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 127:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	x.a[0] = *ll;
 479               		.loc 5 127 0
 480 01c2 8B85      		ldd r24,Y+11
 481 01c4 9C85      		ldd r25,Y+12
 482 01c6 FC01      		movw r30,r24
 483 01c8 8081      		ld r24,Z
 484 01ca 8983      		std Y+1,r24
 128:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	x.a[1] = *lh;
 485               		.loc 5 128 0
 486 01cc 8985      		ldd r24,Y+9
 487 01ce 9A85      		ldd r25,Y+10
 488 01d0 FC01      		movw r30,r24
 489 01d2 8081      		ld r24,Z
 490 01d4 8A83      		std Y+2,r24
 129:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	x.a[2] = *hl;
 491               		.loc 5 129 0
 492 01d6 8F81      		ldd r24,Y+7
 493 01d8 9885      		ldd r25,Y+8
 494 01da FC01      		movw r30,r24
 495 01dc 8081      		ld r24,Z
 496 01de 8B83      		std Y+3,r24
 130:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	x.a[3] = *hh;
 497               		.loc 5 130 0
 498 01e0 8D81      		ldd r24,Y+5
 499 01e2 9E81      		ldd r25,Y+6
 500 01e4 FC01      		movw r30,r24
 501 01e6 8081      		ld r24,Z
 502 01e8 8C83      		std Y+4,r24
 131:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 132:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	return x.rv;
 503               		.loc 5 132 0
 504 01ea 8981      		ldd r24,Y+1
 505 01ec 9A81      		ldd r25,Y+2
 506 01ee AB81      		ldd r26,Y+3
 507 01f0 BC81      		ldd r27,Y+4
 133:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** }
 508               		.loc 5 133 0
 509 01f2 BC01      		movw r22,r24
 510 01f4 CD01      		movw r24,r26
 511               	/* epilogue start */
 512 01f6 2C96      		adiw r28,12
 513 01f8 0FB6      		in __tmp_reg__,__SREG__
 514 01fa F894      		cli
 515 01fc DEBF      		out __SP_H__,r29
 516 01fe 0FBE      		out __SREG__,__tmp_reg__
 517 0200 CDBF      		out __SP_L__,r28
 518 0202 DF91      		pop r29
 519 0204 CF91      		pop r28
 520 0206 0895      		ret
 521               		.cfi_endproc
 522               	.LFE108:
 525               	macsc_read_count:
 526               	.LFB114:
 134:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 135:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /* ! compare modes */
 136:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** #define MACSC_ABSOLUTE_CMP 0
 137:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** #define MACSC_RELATIVE_CMP 1
 138:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 139:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /** String concatenation by preprocessor used to create proper register names.
 140:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  **/
 141:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** #define CONCAT(a, b) a ## b
 142:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 143:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /** Creates proper subregister names and reads the corresponding values. */
 144:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** #define MACSC_READ32(reg)                  macsc_read32(&CONCAT(reg, HH), \
 145:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		&CONCAT(reg, HL), \
 146:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		&CONCAT(reg, LH), \
 147:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		&CONCAT(reg, LL))
 148:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 149:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** #define MACSC_WRITE32(reg, val)	\
 150:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	do { \
 151:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		union { uint8_t a[4]; uint32_t v; } \
 152:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		x; \
 153:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		x.v = val; \
 154:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		CONCAT(reg, HH) = x.a[3]; \
 155:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		CONCAT(reg, HL) = x.a[2]; \
 156:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		CONCAT(reg, LH) = x.a[1]; \
 157:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		CONCAT(reg, LL) = x.a[0]; \
 158:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	} \
 159:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	while (0)
 160:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 161:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 162:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Enable MAC SC
 163:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 164:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * Enables the SC
 165:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 166:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param clk_src selection of clk source,avalable options in macsc_xtal,fixed
 167:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *  prescalar
 168:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param sleep_enable enable RTC as clock source during sleep
 169:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param auto_ts enable automatic timestamping
 170:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 171:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 172:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** void macsc_enable(void);
 173:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 174:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 175:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Check if MACSC is enabled
 176:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 177:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * check if the MACSC is enabled.
 178:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 179:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param none
 180:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 181:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 182:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** bool is_macsc_enable(void);
 183:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 184:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 185:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Disable MAC SC
 186:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 187:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * Disables the MAC SC
 188:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 189:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param none
 190:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 191:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 192:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** void macsc_disable(void);
 193:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 194:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 195:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Check if back-off slot counter is enabled
 196:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 197:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * check if the back-off slot counter is enabled.
 198:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 199:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param none
 200:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 201:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 202:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** bool is_macsc_backoff_enable(void);
 203:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 204:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 205:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Enables compare interrupts of the MACSC
 206:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 207:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param channel Compare channel
 208:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 209:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** void macsc_enable_cmp_int(enum macsc_cc_channel channel);
 210:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 211:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 212:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Disables compare interrupts of the MACSC
 213:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 214:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param channel Compare channel
 215:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */void macsc_disable_cmp_int(enum macsc_cc_channel channel);
 216:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 217:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 218:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Usage of Absolute compare mode of the MACSC
 219:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 220:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param abs_rel  0 for absoulte cmp;1 for relative cmp
 221:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param cmp compare value for SCOCRx register
 222:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param channel Compare channel
 223:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 224:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** void macsc_use_cmp(bool abs_rel, uint32_t cmp,enum macsc_cc_channel channel);
 225:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 226:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 227:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \ingroup macsc_group
 228:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \defgroup macsc_interrupt_group MAC Symbol Counter (MACSC) interrupt
 229:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * management
 230:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * This group provides functions to configure MACSC module interrupts
 231:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 232:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * @{
 233:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 234:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 235:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 236:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Set MACSC overflow interrupt callback function
 237:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 238:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * This function allows the caller to set and change the interrupt callback
 239:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * function. Without setting a callback function the interrupt handler in the
 240:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * driver will only clear the interrupt flags.
 241:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 242:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param callback Reference to a callback function
 243:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 244:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** void macsc_set_ovf_int_cb(macsc_callback_t callback);
 245:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 246:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 247:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Set MACSC Compare Channel 1 interrupt callback function
 248:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 249:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * This function allows the caller to set and change the interrupt callback
 250:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * function. Without setting a callback function the interrupt handler in the
 251:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * driver will only clear the interrupt flags.
 252:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 253:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param callback Reference to a callback function
 254:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 255:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** void macsc_set_cmp1_int_cb(macsc_callback_t callback);
 256:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 257:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 258:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Set MACSC Compare Channel 2 interrupt callback function
 259:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 260:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * This function allows the caller to set and change the interrupt callback
 261:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * function. Without setting a callback function the interrupt handler in the
 262:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * driver will only clear the interrupt flags.
 263:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 264:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param callback Reference to a callback function
 265:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 266:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** void macsc_set_cmp2_int_cb(macsc_callback_t callback);
 267:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 268:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 269:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Set MACSC Compare Channel 3 interrupt callback function
 270:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 271:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * This function allows the caller to set and change the interrupt callback
 272:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * function. Without setting a callback function the interrupt handler in the
 273:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * driver will only clear the interrupt flags.
 274:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 275:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param callback Reference to a callback function
 276:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 277:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** void macsc_set_cmp3_int_cb(macsc_callback_t callback);
 278:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 279:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 280:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Set MACSC backoff slot counter interrupt callback function
 281:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 282:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * This function allows the caller to set and change the interrupt callback
 283:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * function. Without setting a callback function the interrupt handler in the
 284:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * driver will only clear the interrupt flags.
 285:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 286:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param callback Reference to a callback function
 287:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 288:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** void macsc_set_backoff_slot_cntr_int_cb(macsc_callback_t callback);
 289:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** //@}
 290:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 291:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 292:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Enable 32.768KHz clk using timer 2 async register
 293:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 294:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param none
 295:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 296:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 297:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** static inline void macsc_sleep_clk_enable(void)
 298:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** {
 299:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	ASSR |= (1 << AS2);
 300:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** }
 301:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 302:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 303:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Disable 32.768KHz clk using timer 2 async register
 304:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 305:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param none
 306:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 307:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** static inline void macsc_sleep_clk_disable(void)
 308:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** {
 309:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	ASSR &= ~(1 << AS2);
 310:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** }
 311:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 312:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /* @} */
 313:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 314:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 315:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Configure MAC Symbol Counter Clock Source
 316:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 317:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param macsc macsc clk src
 318:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 319:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** static inline void macsc_write_clock_source(enum macsc_xtal source)
 320:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** {
 321:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	if (source == MACSC_16MHz) {
 322:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		SCCR0 |= (source << SCCKSEL);
 323:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	} else if (source == MACSC_32KHz) {
 324:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		SCCR0 &= ~(1 << SCCKSEL);
 325:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	}
 326:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** }
 327:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 328:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 329:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Read MAC SC Clock Source
 330:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 331:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param none
 332:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \return macsc_xtal enum Clock source selection
 333:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 334:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** static inline enum macsc_xtal macsc_read_clock_source(void)
 335:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** {
 336:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	return (enum macsc_xtal)(SCCR0 & (1 << SCCKSEL));
 337:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** }
 338:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 339:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 340:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Write the Counter value of the MAC Symbol counter
 341:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 342:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param cnt_value Counter value
 343:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 344:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** static inline void macsc_write_count(uint32_t cnt_value)
 345:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** {
 346:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	MACSC_WRITE32(SCCNT, cnt_value);
 347:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** }
 348:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 349:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 350:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Reads the Counter value of the MAC Symbol counter
 351:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 352:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \note Output the Counter value
 353:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 354:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** static inline uint32_t macsc_read_count(void)
 355:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** {
 527               		.loc 5 355 0
 528               		.cfi_startproc
 529 0208 CF93      		push r28
 530               	.LCFI30:
 531               		.cfi_def_cfa_offset 3
 532               		.cfi_offset 28, -2
 533 020a DF93      		push r29
 534               	.LCFI31:
 535               		.cfi_def_cfa_offset 4
 536               		.cfi_offset 29, -3
 537 020c CDB7      		in r28,__SP_L__
 538 020e DEB7      		in r29,__SP_H__
 539               	.LCFI32:
 540               		.cfi_def_cfa_register 28
 541               	/* prologue: function */
 542               	/* frame size = 0 */
 543               	/* stack size = 2 */
 544               	.L__stack_usage = 2
 356:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	return (MACSC_READ32(SCCNT));
 545               		.loc 5 356 0
 546 0210 21EE      		ldi r18,lo8(-31)
 547 0212 30E0      		ldi r19,0
 548 0214 42EE      		ldi r20,lo8(-30)
 549 0216 50E0      		ldi r21,0
 550 0218 63EE      		ldi r22,lo8(-29)
 551 021a 70E0      		ldi r23,0
 552 021c 84EE      		ldi r24,lo8(-28)
 553 021e 90E0      		ldi r25,0
 554 0220 0E94 0000 		call macsc_read32
 555 0224 DC01      		movw r26,r24
 556 0226 CB01      		movw r24,r22
 357:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** }
 557               		.loc 5 357 0
 558 0228 BC01      		movw r22,r24
 559 022a CD01      		movw r24,r26
 560               	/* epilogue start */
 561 022c DF91      		pop r29
 562 022e CF91      		pop r28
 563 0230 0895      		ret
 564               		.cfi_endproc
 565               	.LFE114:
 568               	macsc_enable_manual_bts:
 569               	.LFB121:
 358:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 359:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 360:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief enable back-off slot counter
 361:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 362:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param none
 363:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \note  Enables interrupt as well	.
 364:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \note This counter works only if transceiver clock is running.So check Trx
 365:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * state in app before using this function in IEEE802.15.4 applications.
 366:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 367:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** static inline bool macsc_backoff_slot_cnt_enable(void)
 368:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** {
 369:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	if (!(PRR1 & (1 << PRTRX24))) {
 370:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		SCCR1 = (1 << SCENBO);
 371:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		SCIRQS |= (1 << IRQSBO);
 372:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		SCIRQM |= (1 << IRQMBO);
 373:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		return true;
 374:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	}
 375:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	else return false;
 376:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** }
 377:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 378:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 379:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Disable back-off slot counter
 380:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 381:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param none
 382:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \note    Disables interrupt as well	.
 383:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \note This counter works only if transceiver clock is running.So check Trx
 384:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * state in app before using this function in IEEE802.15.4 applications.
 385:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 386:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** static inline void macsc_backoff_slot_cnt_disable(void)
 387:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** {
 388:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	SCCR1 &= ~(1 << SCENBO);
 389:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	SCIRQM &= ~(1 << IRQMBO);
 390:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** }
 391:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 392:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 393:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Tests if the Backoff slot cntr interrupt flag is set
 394:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 395:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \return  backoff slot cntr interrupt has occurred or not : IRQSBO
 396:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 397:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** static inline bool macsc_is_slot_cntr_interrupt_flag_set(void)
 398:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** {
 399:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	return (SCIRQS & (1 << IRQSBO));
 400:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** }
 401:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 402:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 403:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Clears the Backoff Slot cntr interrupt flag
 404:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 405:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \note  IRQSBO is cleared
 406:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 407:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** static inline void macsc_clear_slot_cntr_interrupt_flag(void)
 408:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** {
 409:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	SCIRQS |= (1 << IRQSBO);
 410:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** }
 411:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 412:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 413:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Reads the SFD Timestamp register
 414:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 415:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \return Timestamp of last received frame :SCTSR(read-only register)
 416:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 417:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** static inline uint32_t macsc_read_ts(void)
 418:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** {
 419:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	return (MACSC_READ32(SCTSR));
 420:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** }
 421:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 422:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 423:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Reads the Beacon Timestamp register
 424:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 425:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \return Timestamp of last received beacon frame :SCBTSR
 426:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 427:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** static inline uint32_t macsc_read_bts(void)
 428:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** {
 429:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	return (MACSC_READ32(SCBTSR));
 430:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** }
 431:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 432:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 433:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Write the Beacon Timestamp register of the MAC Symbol counter
 434:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * The manual beacon timestamping can be used in conjunction with the
 435:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * relative compare mode of the three compare units to generate compare match
 436:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * interrupts without having a beacon frame received
 437:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 438:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * If set to 1, the current symbol counter value is stored into the beacon
 439:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * timestamp register.
 440:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * The bit is cleared afterwards.
 441:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 442:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 443:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** static inline void macsc_enable_manual_bts(void)
 444:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** {
 570               		.loc 5 444 0
 571               		.cfi_startproc
 572 0232 CF93      		push r28
 573               	.LCFI33:
 574               		.cfi_def_cfa_offset 3
 575               		.cfi_offset 28, -2
 576 0234 DF93      		push r29
 577               	.LCFI34:
 578               		.cfi_def_cfa_offset 4
 579               		.cfi_offset 29, -3
 580 0236 CDB7      		in r28,__SP_L__
 581 0238 DEB7      		in r29,__SP_H__
 582               	.LCFI35:
 583               		.cfi_def_cfa_register 28
 584               	/* prologue: function */
 585               	/* frame size = 0 */
 586               	/* stack size = 2 */
 587               	.L__stack_usage = 2
 445:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	SCCR0 |= (1 << SCMBTS);
 588               		.loc 5 445 0
 589 023a 8CED      		ldi r24,lo8(-36)
 590 023c 90E0      		ldi r25,0
 591 023e 2CED      		ldi r18,lo8(-36)
 592 0240 30E0      		ldi r19,0
 593 0242 F901      		movw r30,r18
 594 0244 2081      		ld r18,Z
 595 0246 2064      		ori r18,lo8(64)
 596 0248 FC01      		movw r30,r24
 597 024a 2083      		st Z,r18
 446:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	SCCR0 &= ~(1 << SCTSE);
 598               		.loc 5 446 0
 599 024c 8CED      		ldi r24,lo8(-36)
 600 024e 90E0      		ldi r25,0
 601 0250 2CED      		ldi r18,lo8(-36)
 602 0252 30E0      		ldi r19,0
 603 0254 F901      		movw r30,r18
 604 0256 2081      		ld r18,Z
 605 0258 277F      		andi r18,lo8(-9)
 606 025a FC01      		movw r30,r24
 607 025c 2083      		st Z,r18
 447:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** }
 608               		.loc 5 447 0
 609 025e 0000      		nop
 610               	/* epilogue start */
 611 0260 DF91      		pop r29
 612 0262 CF91      		pop r28
 613 0264 0895      		ret
 614               		.cfi_endproc
 615               	.LFE121:
 617               	.global	appState
 618               		.section	.bss.appState,"aw",@nobits
 621               	appState:
 622 0000 00        		.zero	1
 623               		.section	.bss.msgReq,"aw",@nobits
 626               	msgReq:
 627 0000 0000 0000 		.zero	20
 627      0000 0000 
 627      0000 0000 
 627      0000 0000 
 627      0000 0000 
 628               		.section	.bss.PanId,"aw",@nobits
 631               	PanId:
 632 0000 00        		.zero	1
 633               		.text
 634               	.global	appSendData
 636               	appSendData:
 637               	.LFB130:
 638               		.file 6 "ServerLLDN.c"
   1:ServerLLDN.c  **** /*
   2:ServerLLDN.c  **** 	* ServerLLDN.c
   3:ServerLLDN.c  **** 	*
   4:ServerLLDN.c  **** 	* Created: 10/18/2019 5:15:37 PM
   5:ServerLLDN.c  **** 	*  Author: guilherme
   6:ServerLLDN.c  **** 	*/ 
   7:ServerLLDN.c  **** 
   8:ServerLLDN.c  **** #include <stdlib.h>
   9:ServerLLDN.c  **** #include <stdio.h>
  10:ServerLLDN.c  **** #include <string.h>
  11:ServerLLDN.c  **** #include <inttypes.h>
  12:ServerLLDN.c  **** #include "config.h"
  13:ServerLLDN.c  **** #include "sys.h"
  14:ServerLLDN.c  **** #include "phy.h"
  15:ServerLLDN.c  **** #include "sys.h"
  16:ServerLLDN.c  **** #include "nwk.h"
  17:ServerLLDN.c  **** #include "sysclk.h"
  18:ServerLLDN.c  **** #include "sysTimer.h"
  19:ServerLLDN.c  **** #include "sleep_mgr.h"
  20:ServerLLDN.c  **** #include "sleepmgr.h"
  21:ServerLLDN.c  **** #include "led.h"
  22:ServerLLDN.c  **** #include "ioport.h"
  23:ServerLLDN.c  **** #include "conf_sleepmgr.h"
  24:ServerLLDN.c  **** #include "board.h"
  25:ServerLLDN.c  **** #include "platform.h"
  26:ServerLLDN.c  **** 
  27:ServerLLDN.c  **** #include "lldn.h"
  28:ServerLLDN.c  **** 
  29:ServerLLDN.c  **** #if 1
  30:ServerLLDN.c  **** #if (SIO2HOST_CHANNEL == SIO_USB)
  31:ServerLLDN.c  **** /* Only ARM */
  32:ServerLLDN.c  **** #include "hw_timer_lldn.h"
  33:ServerLLDN.c  **** #include "stdio_usb.h"
  34:ServerLLDN.c  **** #define MASTER_MACSC	0
  35:ServerLLDN.c  **** #else
  36:ServerLLDN.c  **** /* Only megarf series */
  37:ServerLLDN.c  **** #include "conf_sio2host.h"
  38:ServerLLDN.c  **** #define MASTER_MACSC	1
  39:ServerLLDN.c  **** #endif
  40:ServerLLDN.c  **** #else
  41:ServerLLDN.c  **** /* Only megarf series */
  42:ServerLLDN.c  **** #define MASTER_MACSC		1
  43:ServerLLDN.c  **** #endif
  44:ServerLLDN.c  **** 
  45:ServerLLDN.c  **** #define HUMAM_READABLE			1
  46:ServerLLDN.c  **** 
  47:ServerLLDN.c  **** #if (MASTER_MACSC == 1)
  48:ServerLLDN.c  **** #include "macsc_megarf.h"
  49:ServerLLDN.c  **** #define TIMESLOT_TIMER 0
  50:ServerLLDN.c  **** #else
  51:ServerLLDN.c  **** static SYS_Timer_t				tmrBeaconInterval;			// Beacon
  52:ServerLLDN.c  **** static SYS_Timer_t				tmrComputeData;				// Compute data
  53:ServerLLDN.c  **** #endif
  54:ServerLLDN.c  **** 
  55:ServerLLDN.c  **** #define PRINT 1
  56:ServerLLDN.c  **** 
  57:ServerLLDN.c  **** 	
  58:ServerLLDN.c  **** // equation for tTS gives time in seconds, the division by SYMBOL_TIME changes to symbols for count
  59:ServerLLDN.c  **** AppState_t	appState = APP_STATE_INITIAL;
  60:ServerLLDN.c  **** static NWK_DataReq_t msgReq;
  61:ServerLLDN.c  **** static uint8_t PanId;
  62:ServerLLDN.c  **** 
  63:ServerLLDN.c  ****  void appSendData(void)
  64:ServerLLDN.c  **** {
 639               		.loc 6 64 0
 640               		.cfi_startproc
 641 0266 CF93      		push r28
 642               	.LCFI36:
 643               		.cfi_def_cfa_offset 3
 644               		.cfi_offset 28, -2
 645 0268 DF93      		push r29
 646               	.LCFI37:
 647               		.cfi_def_cfa_offset 4
 648               		.cfi_offset 29, -3
 649 026a CDB7      		in r28,__SP_L__
 650 026c DEB7      		in r29,__SP_H__
 651               	.LCFI38:
 652               		.cfi_def_cfa_register 28
 653               	/* prologue: function */
 654               	/* frame size = 0 */
 655               	/* stack size = 2 */
 656               	.L__stack_usage = 2
  65:ServerLLDN.c  **** 	if(msgReq.options != 0)
 657               		.loc 6 65 0
 658 026e 8091 0000 		lds r24,msgReq+9
 659 0272 9091 0000 		lds r25,msgReq+9+1
 660 0276 892B      		or r24,r25
 661 0278 01F0      		breq .L21
  66:ServerLLDN.c  **** 	{
  67:ServerLLDN.c  **** 		NWK_DataReq(&msgReq);
 662               		.loc 6 67 0
 663 027a 80E0      		ldi r24,lo8(msgReq)
 664 027c 90E0      		ldi r25,hi8(msgReq)
 665 027e 0E94 0000 		call NWK_DataReq
  68:ServerLLDN.c  **** 		#if PRINT
  69:ServerLLDN.c  **** 		//printf("\nREQ %d",msgReq.options);
  70:ServerLLDN.c  **** 		#endif
  71:ServerLLDN.c  **** 	#if !APP_COORDINATOR
  72:ServerLLDN.c  **** 			macsc_set_cmp2_int_cb(0);
 666               		.loc 6 72 0
 667 0282 80E0      		ldi r24,0
 668 0284 90E0      		ldi r25,0
 669 0286 0E94 0000 		call macsc_set_cmp2_int_cb
 670               	.L21:
  73:ServerLLDN.c  **** 	#endif
  74:ServerLLDN.c  **** 	}
  75:ServerLLDN.c  **** }
 671               		.loc 6 75 0
 672 028a 0000      		nop
 673               	/* epilogue start */
 674 028c DF91      		pop r29
 675 028e CF91      		pop r28
 676 0290 0895      		ret
 677               		.cfi_endproc
 678               	.LFE130:
 680               	.global	payloadSize
 681               		.section	.data.payloadSize,"aw",@progbits
 684               	payloadSize:
 685 0000 32        		.byte	50
 686               	.global	assTimeSlot
 687               		.section	.data.assTimeSlot,"aw",@progbits
 690               	assTimeSlot:
 691 0000 FF        		.byte	-1
 692               	.global	data_payload
 693               		.section	.data.data_payload,"aw",@progbits
 696               	data_payload:
 697 0000 03        		.byte	3
 698               		.comm	rec_beacon,8,1
 699               		.comm	ackframe,2,1
 700               		.section	.data.msgDiscResponse,"aw",@progbits
 703               	msgDiscResponse:
 704 0000 0D        		.byte	13
 705 0001 03        		.byte	3
 706 0002 B2        		.byte	178
 707               		.section	.data.msgConfigStatus,"aw",@progbits
 710               	msgConfigStatus:
 711 0000 0E        		.byte	14
 712 0001 03        		.byte	3
 713 0002 FF        		.byte	-1
 714 0003 03        		.byte	3
 715 0004 B2        		.byte	178
 716               		.section	.data.msgReqDiscResponse,"aw",@progbits
 719               	msgReqDiscResponse:
 720 0000 0000 0000 		.zero	5
 720      00
 721 0005 0000      		.word	0
 722 0007 03        		.byte	3
 723 0008 03        		.byte	3
 724 0009 0080      		.word	-32768
 725 000b 0000      		.zero	2
 726 000d 0000      		.word	msgDiscResponse
 727 000f 03        		.byte	3
 728 0010 0000 0000 		.zero	4
 729               		.section	.data.msgReqConfigStatus,"aw",@progbits
 732               	msgReqConfigStatus:
 733 0000 0000 0000 		.zero	5
 733      00
 734 0005 0000      		.word	0
 735 0007 03        		.byte	3
 736 0008 03        		.byte	3
 737 0009 0080      		.word	-32768
 738 000b 0000      		.zero	2
 739 000d 0000      		.word	msgConfigStatus
 740 000f 05        		.byte	5
 741 0010 0000 0000 		.zero	4
 742               		.section	.data.msgReqData,"aw",@progbits
 745               	msgReqData:
 746 0000 0000 0000 		.zero	5
 746      00
 747 0005 0000      		.word	0
 748 0007 03        		.byte	3
 749 0008 03        		.byte	3
 750 0009 0020      		.word	8192
 751 000b 0000      		.zero	2
 752 000d 0000      		.word	data_payload
 753 000f 01        		.byte	1
 754 0010 0000 0000 		.zero	4
 755               		.section	.bss.ack_received,"aw",@nobits
 758               	ack_received:
 759 0000 00        		.zero	1
 760               	.global	MacLLDNMgmtTS
 761               		.section	.bss.MacLLDNMgmtTS,"aw",@nobits
 764               	MacLLDNMgmtTS:
 765 0000 00        		.zero	1
 766               	.global	associated
 767               		.section	.bss.associated,"aw",@nobits
 770               	associated:
 771 0000 00        		.zero	1
 772               		.comm	ts_time,2,1
 773               	.global	STATE
 774               		.section	.data.STATE,"aw",@progbits
 777               	STATE:
 778 0000 04        		.byte	4
 779               	.global	tmr_error
 780               		.section	.bss.tmr_error,"aw",@nobits
 783               	tmr_error:
 784 0000 0000      		.zero	2
 785               	.global	delta_error
 786               		.section	.bss.delta_error,"aw",@nobits
 789               	delta_error:
 790 0000 0000 0000 		.zero	4
 791               	.global	beacon_tmr
 792               		.section	.bss.beacon_tmr,"aw",@nobits
 795               	beacon_tmr:
 796 0000 00        		.zero	1
 797               	.global	be_read
 798               		.section	.bss.be_read,"aw",@nobits
 801               	be_read:
 802 0000 0000 0000 		.zero	4
 803               	.global	tmr_read
 804               		.section	.bss.tmr_read,"aw",@nobits
 807               	tmr_read:
 808 0000 0000 0000 		.zero	4
 809               		.comm	msg_wait_time,2,1
 810               	.global	ok_seq
 811               		.section	.data.ok_seq,"aw",@progbits
 814               	ok_seq:
 815 0000 FFFF      		.word	-1
 816               		.text
 818               	send_message_timeHandler:
 819               	.LFB131:
  76:ServerLLDN.c  **** 
  77:ServerLLDN.c  **** #if APP_COORDINATOR
  78:ServerLLDN.c  **** 
  79:ServerLLDN.c  **** 	#define NODOS_ASSOCIADOS_ESPERADOS 12
  80:ServerLLDN.c  **** 	int accepting_requests = 1;
  81:ServerLLDN.c  **** 	AppPanState_t appPanState = APP_PAN_STATE_RESET; // Initial state of PAN node
  82:ServerLLDN.c  **** 	
  83:ServerLLDN.c  **** 	/* Configuration Request Frames */
  84:ServerLLDN.c  **** 	/* Da pra mudar o envio do confrequest pra ja usar essa array com as informas dos nodos */	
  85:ServerLLDN.c  **** 	nodes_info_t nodes_info_arr[50]; // Array for Configure Request messages, one position per node, 2
  86:ServerLLDN.c  **** 	NWK_ConfigRequest_t config_request_frame = { .id = LL_CONFIGURATION_REQUEST,
  87:ServerLLDN.c  **** 												 .s_macAddr = APP_ADDR,
  88:ServerLLDN.c  **** 												 .tx_channel = APP_CHANNEL,
  89:ServerLLDN.c  **** 												 .conf.macLLDNmgmtTS = MacLLDNMgmtTS };
  90:ServerLLDN.c  **** 
  91:ServerLLDN.c  **** 
  92:ServerLLDN.c  **** 
  93:ServerLLDN.c  **** 	nodes_info_list_t *conf_req_list = NULL;
  94:ServerLLDN.c  **** 	uint8_t stack_conf_req[20];
  95:ServerLLDN.c  **** 	
  96:ServerLLDN.c  **** 	/* Acknowledge Frame and Array */
  97:ServerLLDN.c  **** 	NWK_ACKFormat_t ACKFrame;	
  98:ServerLLDN.c  **** 	NWK_ACKFormat_t ACKFrame_aux;
  99:ServerLLDN.c  **** 	
 100:ServerLLDN.c  **** 	int ACKFrame_size = 0;
 101:ServerLLDN.c  **** 	
 102:ServerLLDN.c  **** 
 103:ServerLLDN.c  **** 	float beaconInterval = 0; // no precisa ser global
 104:ServerLLDN.c  **** 	float beaconInterval_association = 0;
 105:ServerLLDN.c  **** 	
 106:ServerLLDN.c  **** 	/* This timer implements a delay between messages, 
 107:ServerLLDN.c  **** 	 * if not used the nodes are not able to receive the message
 108:ServerLLDN.c  **** 	 */
 109:ServerLLDN.c  **** 	static SYS_Timer_t tmrDelay;	
 110:ServerLLDN.c  **** 	
 111:ServerLLDN.c  **** 	/*  Control variables for testing */	
 112:ServerLLDN.c  **** 	int assTimeSlot = 0;
 113:ServerLLDN.c  **** 
 114:ServerLLDN.c  **** 	int counter_associados = 0;		// Associated nodes counter
 115:ServerLLDN.c  **** 	uint8_t cycles_counter = macLLDNdiscoveryModeTimeout;
 116:ServerLLDN.c  **** 
 117:ServerLLDN.c  **** 	bool association_request = false;
 118:ServerLLDN.c  **** 
 119:ServerLLDN.c  **** 	/* data related variables */
 120:ServerLLDN.c  **** 	msg_info_t msg_info_array[50]; // size of array limited by hardware
 121:ServerLLDN.c  **** 	unsigned int size_msg_info = 0;
 122:ServerLLDN.c  **** 	bool data_received = false;	
 123:ServerLLDN.c  **** 	float PLR = 0;
 124:ServerLLDN.c  **** 	float PER = 0;
 125:ServerLLDN.c  **** 	uint8_t retransmit_ts_array[32];
 126:ServerLLDN.c  **** 	int retransmit_ts_array_counter = 0;
 127:ServerLLDN.c  **** 	
 128:ServerLLDN.c  **** 	int counter_delay_msg = 0;
 129:ServerLLDN.c  **** 	uint32_t cmp_value_start_superframe = 0;
 130:ServerLLDN.c  **** 	
 131:ServerLLDN.c  **** 	static NWK_DataReq_t msgReqGACK = { .dstAddr = 0,
 132:ServerLLDN.c  **** 										.dstEndpoint = APP_BEACON_ENDPOINT,
 133:ServerLLDN.c  **** 										.srcEndpoint = APP_BEACON_ENDPOINT,
 134:ServerLLDN.c  **** 										.options = NWK_OPT_LLDN_ACK,
 135:ServerLLDN.c  **** 										.data = (uint8_t*)&ACKFrame};
 136:ServerLLDN.c  **** 
 137:ServerLLDN.c  **** 	
 138:ServerLLDN.c  **** 	static void tmrDelayHandler(SYS_Timer_t *timer)
 139:ServerLLDN.c  **** 	{
 140:ServerLLDN.c  **** 		#if PRINT
 141:ServerLLDN.c  **** 		// printf("\ndelay handler");
 142:ServerLLDN.c  **** 		#endif
 143:ServerLLDN.c  **** 		appState = APP_STATE_SEND;
 144:ServerLLDN.c  **** 	}
 145:ServerLLDN.c  **** 	
 146:ServerLLDN.c  **** 	static void lldn_server_beacon(void)
 147:ServerLLDN.c  **** 	{
 148:ServerLLDN.c  **** 		macsc_enable_manual_bts();
 149:ServerLLDN.c  **** 		appState = APP_STATE_SEND;
 150:ServerLLDN.c  **** 	}
 151:ServerLLDN.c  **** 	
 152:ServerLLDN.c  **** 
 153:ServerLLDN.c  **** 	static void downlink_delay_handler(void)
 154:ServerLLDN.c  **** 	{
 155:ServerLLDN.c  **** 		if(msgReq.options == NWK_OPT_MAC_COMMAND)
 156:ServerLLDN.c  **** 		{
 157:ServerLLDN.c  **** 			counter_delay_msg++;
 158:ServerLLDN.c  **** 			appState = APP_STATE_SEND;
 159:ServerLLDN.c  **** 		}
 160:ServerLLDN.c  **** 	}
 161:ServerLLDN.c  **** 
 162:ServerLLDN.c  **** 	static void end_of_association_delay_handler(void)
 163:ServerLLDN.c  **** 	{
 164:ServerLLDN.c  **** 		appState = APP_STATE_ATT_PAN_STATE;
 165:ServerLLDN.c  **** 		appPanState = APP_PAN_STATE_ONLINE_INITIAL;
 166:ServerLLDN.c  **** 	}
 167:ServerLLDN.c  **** 	
 168:ServerLLDN.c  **** 	#if TIMESLOT_TIMER
 169:ServerLLDN.c  **** 	static void teste_handler(void)
 170:ServerLLDN.c  **** 	{
 171:ServerLLDN.c  **** 		if(msgReq.options)
 172:ServerLLDN.c  **** 			// printf("\n***TIMESLOT****");
 173:ServerLLDN.c  **** 		macsc_disable_cmp_int(MACSC_CC3);
 174:ServerLLDN.c  **** 	}
 175:ServerLLDN.c  **** 	#endif
 176:ServerLLDN.c  **** 	
 177:ServerLLDN.c  **** 	static bool addToAckArray(uint8_t addres)
 178:ServerLLDN.c  **** 	{	
 179:ServerLLDN.c  **** 		int pos =(int) addres / 8;
 180:ServerLLDN.c  **** 		int bit_shift = 8 - (addres % 8);
 181:ServerLLDN.c  **** // 		if(addres == 8)
 182:ServerLLDN.c  **** // 		{
 183:ServerLLDN.c  **** // 			pos = 0;
 184:ServerLLDN.c  **** // 			bit_shift = 0;
 185:ServerLLDN.c  **** // 			printf("\nadddr=8");
 186:ServerLLDN.c  **** // 		}
 187:ServerLLDN.c  **** 		if(ACKFrame.ackFlags[pos] & 1 << bit_shift)
 188:ServerLLDN.c  **** 		{
 189:ServerLLDN.c  **** 			// printf("\nAddr rep %d", addres);
 190:ServerLLDN.c  **** 			return false;
 191:ServerLLDN.c  **** 		}
 192:ServerLLDN.c  **** 		ACKFrame.ackFlags[pos] |= 1 << bit_shift;
 193:ServerLLDN.c  **** 		if (pos + 1 > ACKFrame_size)
 194:ServerLLDN.c  **** 			ACKFrame_size = pos + 1;
 195:ServerLLDN.c  **** 		// printf("ACK, %hhx", ACKFrame.ackFlags[pos]);
 196:ServerLLDN.c  **** 		return true;
 197:ServerLLDN.c  **** 	}
 198:ServerLLDN.c  **** 
 199:ServerLLDN.c  **** 	static void addConfRequestArray(NWK_ConfigStatus_t *node)
 200:ServerLLDN.c  **** 	{
 201:ServerLLDN.c  **** 
 202:ServerLLDN.c  **** 		uint8_t i;
 203:ServerLLDN.c  **** 		for (i= 0;i < 256 && nodes_info_arr[i].mac_addr != 0; i++);
 204:ServerLLDN.c  **** 		
 205:ServerLLDN.c  **** 		assTimeSlot++;
 206:ServerLLDN.c  **** 	
 207:ServerLLDN.c  **** 		if(node->ts_dir.tsDuration > config_request_frame.conf.tsDuration)
 208:ServerLLDN.c  **** 			config_request_frame.conf.tsDuration =  node->ts_dir.tsDuration;
 209:ServerLLDN.c  **** 		
 210:ServerLLDN.c  **** 		nodes_info_arr[i].req_timeslot_duration = node->ts_dir.tsDuration;
 211:ServerLLDN.c  **** 		nodes_info_arr[i].mac_addr = node->macAddr;
 212:ServerLLDN.c  **** 		nodes_info_arr[i].assigned_time_slot = (uint8_t)i;
 213:ServerLLDN.c  **** // 		stack_conf_req
 214:ServerLLDN.c  **** 		if(conf_req_list != NULL)
 215:ServerLLDN.c  **** 		{
 216:ServerLLDN.c  **** 			nodes_info_list_t *tmp = (nodes_info_list_t*)malloc(sizeof(nodes_info_list_t));
 217:ServerLLDN.c  **** 			tmp->node = &nodes_info_arr[i];
 218:ServerLLDN.c  **** 			tmp->next = conf_req_list;
 219:ServerLLDN.c  **** 			conf_req_list = tmp;
 220:ServerLLDN.c  **** 		}
 221:ServerLLDN.c  **** 		else
 222:ServerLLDN.c  **** 		{
 223:ServerLLDN.c  **** 			conf_req_list = (nodes_info_list_t*)malloc(sizeof(nodes_info_list_t));
 224:ServerLLDN.c  **** 			conf_req_list->node = &nodes_info_arr[i];
 225:ServerLLDN.c  **** 			conf_req_list->next = NULL;
 226:ServerLLDN.c  **** 		}
 227:ServerLLDN.c  **** 	}
 228:ServerLLDN.c  **** 
 229:ServerLLDN.c  **** 	static bool CopyToConfigRequest()
 230:ServerLLDN.c  **** 	{
 231:ServerLLDN.c  **** 		if(conf_req_list->node == NULL)
 232:ServerLLDN.c  **** 			return false;
 233:ServerLLDN.c  **** 		config_request_frame.assTimeSlot = conf_req_list->node->assigned_time_slot;
 234:ServerLLDN.c  **** 		config_request_frame.macAddr = conf_req_list->node->mac_addr;
 235:ServerLLDN.c  **** 		nodes_info_list_t *tmp = conf_req_list;
 236:ServerLLDN.c  **** 		conf_req_list = conf_req_list->next;
 237:ServerLLDN.c  **** 		tmp->node = NULL;
 238:ServerLLDN.c  **** 		tmp->next = NULL;
 239:ServerLLDN.c  **** 		free(tmp);
 240:ServerLLDN.c  **** 		return true;
 241:ServerLLDN.c  **** 	}
 242:ServerLLDN.c  **** 
 243:ServerLLDN.c  **** 
 244:ServerLLDN.c  **** 	static bool appCommandInd(NWK_DataInd_t *ind)
 245:ServerLLDN.c  **** 	{
 246:ServerLLDN.c  **** 		if(!accepting_requests) return false;
 247:ServerLLDN.c  **** 		// if(n <127) return false;
 248:ServerLLDN.c  **** 		if(ind->data[0] == LL_DISCOVER_RESPONSE)
 249:ServerLLDN.c  **** 		{
 250:ServerLLDN.c  **** 			NWK_DiscoverResponse_t *msg = (NWK_DiscoverResponse_t*)ind->data;
 251:ServerLLDN.c  **** 			addToAckArray(msg->macAddr);	
 252:ServerLLDN.c  **** 					
 253:ServerLLDN.c  **** 			#if PRINT
 254:ServerLLDN.c  **** 			uint32_t tmp = macsc_read_count();
 255:ServerLLDN.c  **** // 			printf("\n%" PRIu32 " ", tmp);			
 256:ServerLLDN.c  ****  			// printf(" DISC %hhx", msg->macAddr);	
 257:ServerLLDN.c  **** 			#endif
 258:ServerLLDN.c  **** 		}
 259:ServerLLDN.c  **** 		else if(ind->data[0] == LL_CONFIGURATION_STATUS)
 260:ServerLLDN.c  **** 		{
 261:ServerLLDN.c  **** 			NWK_ConfigStatus_t *msg = (NWK_ConfigStatus_t*)ind->data;
 262:ServerLLDN.c  **** 			addConfRequestArray(msg);
 263:ServerLLDN.c  **** 			#if PRINT
 264:ServerLLDN.c  **** 			// printf("\nCONF %d", msg->macAddr);	
 265:ServerLLDN.c  **** 			#endif
 266:ServerLLDN.c  **** 		}
 267:ServerLLDN.c  **** 		else return false;			
 268:ServerLLDN.c  **** 		return true;
 269:ServerLLDN.c  **** 	}
 270:ServerLLDN.c  **** 	
 271:ServerLLDN.c  **** 	bool check_ack_pan(int addr)
 272:ServerLLDN.c  **** 	{
 273:ServerLLDN.c  **** 		int pos =  addr / 8;
 274:ServerLLDN.c  **** 		int bit_shift = 8 - addr % 8;
 275:ServerLLDN.c  **** 		
 276:ServerLLDN.c  **** 		if( ACKFrame.ackFlags[pos] & 1 << bit_shift)
 277:ServerLLDN.c  **** 		{
 278:ServerLLDN.c  **** 			return true;
 279:ServerLLDN.c  **** 		}
 280:ServerLLDN.c  **** 		else
 281:ServerLLDN.c  **** 			return false;
 282:ServerLLDN.c  **** 	}
 283:ServerLLDN.c  **** 	
 284:ServerLLDN.c  **** 	bool check_ack_aux(int addr)
 285:ServerLLDN.c  **** 	{
 286:ServerLLDN.c  **** 		int pos =  addr / 8;
 287:ServerLLDN.c  **** 		int bit_shift = 8 - addr % 8;
 288:ServerLLDN.c  **** 		
 289:ServerLLDN.c  **** 		if( ACKFrame_aux.ackFlags[pos] & 1 << bit_shift)
 290:ServerLLDN.c  **** 		{
 291:ServerLLDN.c  **** 			return true;
 292:ServerLLDN.c  **** 		}
 293:ServerLLDN.c  **** 		else
 294:ServerLLDN.c  **** 		return false;
 295:ServerLLDN.c  **** 	}
 296:ServerLLDN.c  **** 	
 297:ServerLLDN.c  **** 	static bool appDataInd(NWK_DataInd_t *ind)
 298:ServerLLDN.c  **** 	{
 299:ServerLLDN.c  **** 		uint32_t cmp_value = macsc_read_count();
 300:ServerLLDN.c  **** 		int relative_cmp =  cmp_value - cmp_value_start_superframe - 40;
 301:ServerLLDN.c  **** 		
 302:ServerLLDN.c  **** 
 303:ServerLLDN.c  **** 		int curr_up_ts = (relative_cmp)/(tTS / (SYMBOL_TIME)) - 2*MacLLDNMgmtTS*numBaseTimeSlotperMgmt_on
 304:ServerLLDN.c  **** 		if(curr_up_ts > assTimeSlot)
 305:ServerLLDN.c  **** 		{
 306:ServerLLDN.c  **** 			
 307:ServerLLDN.c  **** 			int i;
 308:ServerLLDN.c  **** 			curr_up_ts -= assTimeSlot+1;
 309:ServerLLDN.c  **** 			for (i = 0; i < assTimeSlot && curr_up_ts > 0; ++i)
 310:ServerLLDN.c  **** 			{
 311:ServerLLDN.c  **** 				if(!check_ack_aux(i+1))
 312:ServerLLDN.c  **** 				{
 313:ServerLLDN.c  **** 					curr_up_ts--;
 314:ServerLLDN.c  **** 				}
 315:ServerLLDN.c  **** 			}
 316:ServerLLDN.c  **** 			curr_up_ts = i-1*(i!=0);
 317:ServerLLDN.c  **** 		}
 318:ServerLLDN.c  **** // 		if(nodes_info_arr[curr_up_ts].mac_addr != ind->data[0])
 319:ServerLLDN.c  **** // 			return false;	
 320:ServerLLDN.c  **** 		nodes_info_arr[curr_up_ts].rssi = ind->rssi;
 321:ServerLLDN.c  **** 		nodes_info_arr[curr_up_ts].average_rssi = (nodes_info_arr[curr_up_ts].rssi + nodes_info_arr[curr_
 322:ServerLLDN.c  **** 																				/(nodes_info_arr[curr_up_ts].msg_rec + 1);
 323:ServerLLDN.c  **** 		nodes_info_arr[curr_up_ts].msg_rec++;
 324:ServerLLDN.c  **** 
 325:ServerLLDN.c  **** 		addToAckArray(curr_up_ts+1);
 326:ServerLLDN.c  **** 		#if PRINT
 327:ServerLLDN.c  ****  		//printf("\n[%d] Data: ", curr_up_ts);
 328:ServerLLDN.c  **** 		#endif
 329:ServerLLDN.c  **** 		for (int i = 0; i < ind->size; i++)
 330:ServerLLDN.c  **** 		{
 331:ServerLLDN.c  **** 			msg_info_array[curr_up_ts].data_payload[i] = ind->data[i];
 332:ServerLLDN.c  **** 			#if PRINT
 333:ServerLLDN.c  ****  			//printf("%hhx", msg_info_array[curr_up_ts].data_payload[i]);
 334:ServerLLDN.c  **** 			#endif
 335:ServerLLDN.c  **** 		}		
 336:ServerLLDN.c  **** // 		printf(" cmp %d", relative_cmp);
 337:ServerLLDN.c  **** 	}
 338:ServerLLDN.c  **** 	
 339:ServerLLDN.c  **** 	static void appPanPrepareACK(void)
 340:ServerLLDN.c  **** 	{
 341:ServerLLDN.c  **** 		msgReq.dstAddr		= 0;
 342:ServerLLDN.c  **** 		msgReq.dstEndpoint	= APP_BEACON_ENDPOINT;
 343:ServerLLDN.c  **** 		msgReq.srcEndpoint	= APP_BEACON_ENDPOINT;
 344:ServerLLDN.c  **** 		msgReq.options		= NWK_OPT_LLDN_ACK;
 345:ServerLLDN.c  **** 		msgReq.data	= (uint8_t *)&ACKFrame;
 346:ServerLLDN.c  **** 		msgReq.size	= sizeof(uint8_t)*(ACKFrame_size + 1);
 347:ServerLLDN.c  **** 
 348:ServerLLDN.c  **** 	}
 349:ServerLLDN.c  **** 
 350:ServerLLDN.c  **** 	static void appPanReset(void)
 351:ServerLLDN.c  **** 	{
 352:ServerLLDN.c  **** 		// prepare beacon reset message
 353:ServerLLDN.c  **** 		msgReq.dstAddr		= 0;
 354:ServerLLDN.c  **** 		msgReq.dstEndpoint	= APP_BEACON_ENDPOINT;
 355:ServerLLDN.c  **** 		msgReq.srcEndpoint	= APP_BEACON_ENDPOINT;
 356:ServerLLDN.c  **** 		msgReq.options		= NWK_OPT_LLDN_BEACON | NWK_OPT_RESET_STATE;
 357:ServerLLDN.c  **** 		msgReq.data			= NULL;
 358:ServerLLDN.c  **** 		msgReq.size			= 0;
 359:ServerLLDN.c  **** 
 360:ServerLLDN.c  **** 		for(int i = 0; i < 32; i++)
 361:ServerLLDN.c  **** 			ACKFrame.ackFlags[i] = 0;
 362:ServerLLDN.c  **** 			
 363:ServerLLDN.c  **** 		for (int i = 0; i < 50; i++)
 364:ServerLLDN.c  **** 		{
 365:ServerLLDN.c  **** 			nodes_info_arr[i].mac_addr = 0;
 366:ServerLLDN.c  **** 			nodes_info_arr[i].msg_rec = 0;
 367:ServerLLDN.c  **** 
 368:ServerLLDN.c  **** 			
 369:ServerLLDN.c  **** 			msg_info_array[i].mac_addr = 0;
 370:ServerLLDN.c  **** 			msg_info_array[i].coop_addr = 0;
 371:ServerLLDN.c  **** 			for (int j = 0; j < 50; j++)
 372:ServerLLDN.c  **** 				nodes_info_arr[i].neighbors[j] = 0;
 373:ServerLLDN.c  **** 		}
 374:ServerLLDN.c  **** 		ACKFrame_size = 0;
 375:ServerLLDN.c  **** 		counter_associados = 0;
 376:ServerLLDN.c  **** 		macLLDNnumUplinkTS = 0;
 377:ServerLLDN.c  **** 		n = 0;
 378:ServerLLDN.c  **** 	}
 379:ServerLLDN.c  **** 
 380:ServerLLDN.c  **** 	static void appPanDiscInit(void)
 381:ServerLLDN.c  **** 	{	
 382:ServerLLDN.c  **** 		/* clearray of previous discovery state */
 383:ServerLLDN.c  **** 		for(int i = 0; i < 32; i++)
 384:ServerLLDN.c  **** 			ACKFrame.ackFlags[i] = 0;
 385:ServerLLDN.c  **** 		ACKFrame_size = 0;
 386:ServerLLDN.c  **** 
 387:ServerLLDN.c  **** 
 388:ServerLLDN.c  **** 		/* Prepare Beacon Message as first beacon in discovery state */		
 389:ServerLLDN.c  **** 		msgReq.dstAddr				= 0;
 390:ServerLLDN.c  **** 		msgReq.dstEndpoint			= APP_BEACON_ENDPOINT;
 391:ServerLLDN.c  **** 		msgReq.srcEndpoint			= APP_BEACON_ENDPOINT;
 392:ServerLLDN.c  **** 		msgReq.options				= NWK_OPT_LLDN_BEACON | NWK_OPT_DISCOVERY_STATE;
 393:ServerLLDN.c  **** 		msgReq.data					= NULL;
 394:ServerLLDN.c  **** 		msgReq.size					= 0;
 395:ServerLLDN.c  **** 		
 396:ServerLLDN.c  **** 		macLLDNnumTimeSlots = 2;
 397:ServerLLDN.c  **** 		accepting_requests = 1;
 398:ServerLLDN.c  **** 		/* Only start timers if it is the first association process */
 399:ServerLLDN.c  **** 		if(cycles_counter == 0) 
 400:ServerLLDN.c  **** 		{
 401:ServerLLDN.c  **** 
 402:ServerLLDN.c  **** 
 403:ServerLLDN.c  **** 			
 404:ServerLLDN.c  **** 		/* Calculates Beacon Intervals according to 802.15.4e - 2012 p. 70 */
 405:ServerLLDN.c  **** 		n = 127; 
 406:ServerLLDN.c  **** 		tTS =  ((p_var*sp + (m+n)*sm + macMinLIFSPeriod)/v_var);
 407:ServerLLDN.c  **** 		#if (MASTER_MACSC == 1)
 408:ServerLLDN.c  **** 		
 409:ServerLLDN.c  **** 
 410:ServerLLDN.c  **** 			beaconInterval_association = 2 * numBaseTimeSlotperMgmt_association * (tTS) / (SYMBOL_TIME);
 411:ServerLLDN.c  **** 			#if PRINT
 412:ServerLLDN.c  **** // 			printf("\n Beacon interval %f", beaconInterval_association);
 413:ServerLLDN.c  **** 			#endif
 414:ServerLLDN.c  **** 			/*
 415:ServerLLDN.c  **** 			* Configure interrupts callback functions
 416:ServerLLDN.c  **** 			* overflow interrupt, compare 1,2,3 interrupts
 417:ServerLLDN.c  **** 			*/
 418:ServerLLDN.c  **** 			macsc_set_cmp1_int_cb(lldn_server_beacon);
 419:ServerLLDN.c  **** 			/*
 420:ServerLLDN.c  **** 			* Configure MACSC to generate compare interrupts from channels 1,2,3
 421:ServerLLDN.c  **** 			* Set compare mode to absolute, set compare value.
 422:ServerLLDN.c  **** 			*/
 423:ServerLLDN.c  **** 			macsc_enable_manual_bts();
 424:ServerLLDN.c  **** 			macsc_enable_cmp_int(MACSC_CC1);
 425:ServerLLDN.c  **** 
 426:ServerLLDN.c  **** 			macsc_use_cmp(MACSC_RELATIVE_CMP, beaconInterval_association , MACSC_CC1);
 427:ServerLLDN.c  **** 			
 428:ServerLLDN.c  **** 			/* Timer used in testing */
 429:ServerLLDN.c  **** 			#if TIMESLOT_TIMER
 430:ServerLLDN.c  **** 			macsc_set_cmp2_int_cb(teste_handler);	
 431:ServerLLDN.c  **** 			macsc_enable_cmp_int(MACSC_CC2);
 432:ServerLLDN.c  **** 			macsc_use_cmp(MACSC_RELATIVE_CMP, beaconInterval_association / 2, MACSC_CC2);
 433:ServerLLDN.c  **** 			#endif
 434:ServerLLDN.c  **** 			
 435:ServerLLDN.c  **** 		#endif
 436:ServerLLDN.c  **** 		}
 437:ServerLLDN.c  **** 	}
 438:ServerLLDN.c  **** 	
 439:ServerLLDN.c  **** 	static void end_of_superframe_Online(void)
 440:ServerLLDN.c  **** 	{
 441:ServerLLDN.c  **** 		appPanState = APP_PAN_STATE_ONLINE_INITIAL;
 442:ServerLLDN.c  **** 		if(cycles_counter>0)
 443:ServerLLDN.c  **** 			appState = APP_STATE_SEND;
 444:ServerLLDN.c  **** 		else
 445:ServerLLDN.c  **** 		appState = APP_STATE_ATT_PAN_STATE;
 446:ServerLLDN.c  **** 
 447:ServerLLDN.c  **** 	}
 448:ServerLLDN.c  **** 	
 449:ServerLLDN.c  **** 	static void send_gack(void)
 450:ServerLLDN.c  **** 	{
 451:ServerLLDN.c  **** 		msgReqGACK.size = sizeof(uint8_t)*(macLLDNRetransmitTS + 1);
 452:ServerLLDN.c  **** 		NWK_DataReq(&msgReqGACK);
 453:ServerLLDN.c  **** 		ACKFrame_aux = ACKFrame;
 454:ServerLLDN.c  **** 		#if PRINT
 455:ServerLLDN.c  **** // 		printf("\n%hhx ", ACKFrame.ackFlags[0]);
 456:ServerLLDN.c  **** 		#endif
 457:ServerLLDN.c  **** 		if(cycles_counter<NUMERO_CICLOS_ONLINE-1)
 458:ServerLLDN.c  **** 		{
 459:ServerLLDN.c  **** 			for (int i  = 0; i < assTimeSlot;i++)
 460:ServerLLDN.c  **** 				if(!check_ack_pan(i+1))
 461:ServerLLDN.c  **** 				{
 462:ServerLLDN.c  **** 					nodes_info_arr[i].msg_not_rec++;
 463:ServerLLDN.c  **** 			}
 464:ServerLLDN.c  **** 		}
 465:ServerLLDN.c  **** 	}
 466:ServerLLDN.c  **** 
 467:ServerLLDN.c  **** 	static void appPanOnlineInit()
 468:ServerLLDN.c  **** 	{
 469:ServerLLDN.c  **** 			
 470:ServerLLDN.c  **** 			macLLDNnumUplinkTS = (assTimeSlot) * 2 + 1;
 471:ServerLLDN.c  **** 			macLLDNRetransmitTS = assTimeSlot;
 472:ServerLLDN.c  **** 			macLLDNnumTimeSlots = macLLDNnumUplinkTS + 2 *MacLLDNMgmtTS;			
 473:ServerLLDN.c  **** 			
 474:ServerLLDN.c  **** // 			printf("\nmacLLDNnumUplinkTS : %d\nmacLLDNRetransmitTS : %d\nmacLLDNnumTimeSlots : %d",macLLD
 475:ServerLLDN.c  **** 			
 476:ServerLLDN.c  **** 			config_request_frame.conf.tsDuration = 75;
 477:ServerLLDN.c  **** 			
 478:ServerLLDN.c  **** 			tTS =  ((p_var*sp + (m+ config_request_frame.conf.tsDuration )*sm + macMinLIFSPeriod)/v_var);
 479:ServerLLDN.c  **** 				
 480:ServerLLDN.c  **** 			n = config_request_frame.conf.tsDuration;
 481:ServerLLDN.c  **** 			
 482:ServerLLDN.c  **** 
 483:ServerLLDN.c  **** 			msgReq.dstAddr				= 0;
 484:ServerLLDN.c  **** 			msgReq.dstEndpoint			= APP_BEACON_ENDPOINT;
 485:ServerLLDN.c  **** 			msgReq.srcEndpoint			= APP_BEACON_ENDPOINT;
 486:ServerLLDN.c  **** 			msgReq.options				= NWK_OPT_LLDN_BEACON | NWK_OPT_ONLINE_STATE;
 487:ServerLLDN.c  **** 			msgReq.data					= NULL;
 488:ServerLLDN.c  **** 			msgReq.size					= 0;
 489:ServerLLDN.c  **** 			
 490:ServerLLDN.c  **** 			beaconInterval= (macLLDNnumUplinkTS + 2*MacLLDNMgmtTS*numBaseTimeSlotperMgmt_online) * tTS / (SY
 491:ServerLLDN.c  **** 			float GACK_tTS = (assTimeSlot + 0.2 + 2*MacLLDNMgmtTS*numBaseTimeSlotperMgmt_online) * tTS / (SY
 492:ServerLLDN.c  **** 			macsc_write_count(0);
 493:ServerLLDN.c  **** 			macsc_set_cmp1_int_cb(end_of_superframe_Online);
 494:ServerLLDN.c  **** 			macsc_enable_cmp_int(MACSC_CC1);
 495:ServerLLDN.c  **** 
 496:ServerLLDN.c  **** 			macsc_set_cmp2_int_cb(send_gack);
 497:ServerLLDN.c  **** 			if(cycles_counter != NUMERO_CICLOS_ONLINE)
 498:ServerLLDN.c  **** 				macsc_enable_cmp_int(MACSC_CC2);
 499:ServerLLDN.c  **** 
 500:ServerLLDN.c  **** 			macsc_use_cmp(MACSC_RELATIVE_CMP, beaconInterval, MACSC_CC1);
 501:ServerLLDN.c  **** 			macsc_use_cmp(MACSC_RELATIVE_CMP, GACK_tTS, MACSC_CC2);
 502:ServerLLDN.c  **** 			macsc_enable_manual_bts();
 503:ServerLLDN.c  **** 			
 504:ServerLLDN.c  **** 			cmp_value_start_superframe = macsc_read_count();
 505:ServerLLDN.c  **** 
 506:ServerLLDN.c  **** 
 507:ServerLLDN.c  **** 			for(int i = 0; i < 32; i++)
 508:ServerLLDN.c  **** 			{
 509:ServerLLDN.c  **** 				ACKFrame.ackFlags[i] = 0;
 510:ServerLLDN.c  **** 				retransmit_ts_array[i] = 0;
 511:ServerLLDN.c  **** 			}
 512:ServerLLDN.c  **** 			retransmit_ts_array_counter = 0;
 513:ServerLLDN.c  **** 			ACKFrame_size = 0;
 514:ServerLLDN.c  **** 			
 515:ServerLLDN.c  **** 			NWK_OpenEndpoint(APP_DATA_ENDPOINT, appDataInd);
 516:ServerLLDN.c  **** 	}
 517:ServerLLDN.c  **** 
 518:ServerLLDN.c  **** #else 
 519:ServerLLDN.c  **** 	uint8_t payloadSize = 50;
 520:ServerLLDN.c  **** 	uint8_t assTimeSlot = 0xFF;
 521:ServerLLDN.c  **** 	uint8_t n = 0;
 522:ServerLLDN.c  **** 	uint8_t data_payload = APP_ADDR;
 523:ServerLLDN.c  **** 
 524:ServerLLDN.c  **** 
 525:ServerLLDN.c  **** 	
 526:ServerLLDN.c  **** 	NwkFrameBeaconHeaderLLDN_t rec_beacon;
 527:ServerLLDN.c  **** 	NWK_ACKFormat_t *ackframe;
 528:ServerLLDN.c  **** 	static NWK_DiscoverResponse_t msgDiscResponse = { .id = LL_DISCOVER_RESPONSE,
 529:ServerLLDN.c  **** 													 .macAddr = APP_ADDR,
 530:ServerLLDN.c  **** 													 .ts_dir.tsDuration = 50,
 531:ServerLLDN.c  **** 													 .ts_dir.dirIndicator = 0b1 };
 532:ServerLLDN.c  **** 	static NWK_ConfigStatus_t msgConfigStatus = { .id = LL_CONFIGURATION_STATUS,
 533:ServerLLDN.c  **** 												 .macAddr = APP_ADDR,
 534:ServerLLDN.c  **** 												 .s_macAddr = APP_ADDR,
 535:ServerLLDN.c  **** 												 .ts_dir.tsDuration = 50,
 536:ServerLLDN.c  **** 												 .ts_dir.dirIndicator = 1,
 537:ServerLLDN.c  **** 												 .assTimeSlot = 0xff };
 538:ServerLLDN.c  **** 												 
 539:ServerLLDN.c  **** 	static NWK_DataReq_t msgReqDiscResponse = { .dstAddr = 0,
 540:ServerLLDN.c  **** 									.dstEndpoint = APP_COMMAND_ENDPOINT,
 541:ServerLLDN.c  **** 									.srcEndpoint = APP_COMMAND_ENDPOINT,
 542:ServerLLDN.c  **** 									.options = NWK_OPT_MAC_COMMAND,
 543:ServerLLDN.c  **** 									.data = (uint8_t*)&msgDiscResponse,
 544:ServerLLDN.c  **** 									.size = sizeof(msgDiscResponse)};
 545:ServerLLDN.c  **** 	
 546:ServerLLDN.c  **** 	static NWK_DataReq_t msgReqConfigStatus = { .dstAddr =0,
 547:ServerLLDN.c  **** 									.dstEndpoint = APP_COMMAND_ENDPOINT,
 548:ServerLLDN.c  **** 									.srcEndpoint = APP_COMMAND_ENDPOINT,
 549:ServerLLDN.c  **** 									.options = NWK_OPT_MAC_COMMAND,
 550:ServerLLDN.c  **** 									.data = (uint8_t*)&msgConfigStatus,
 551:ServerLLDN.c  **** 									.size = sizeof(msgConfigStatus)};
 552:ServerLLDN.c  **** 		
 553:ServerLLDN.c  **** 	static NWK_DataReq_t msgReqData = { .dstAddr =0,
 554:ServerLLDN.c  **** 									.dstEndpoint = APP_COMMAND_ENDPOINT,
 555:ServerLLDN.c  **** 									.srcEndpoint = APP_COMMAND_ENDPOINT,
 556:ServerLLDN.c  **** 									.options = NWK_OPT_LLDN_DATA,
 557:ServerLLDN.c  **** 									.data = (uint8_t*)&data_payload,
 558:ServerLLDN.c  **** 									.size = sizeof(data_payload)};
 559:ServerLLDN.c  **** 
 560:ServerLLDN.c  **** 	static bool ack_received = false;
 561:ServerLLDN.c  **** 	bool MacLLDNMgmtTS = 0; 
 562:ServerLLDN.c  **** 	bool associated = 0;
 563:ServerLLDN.c  **** 	int ts_time;
 564:ServerLLDN.c  **** 	uint8_t STATE = DISC_MODE;
 565:ServerLLDN.c  **** 	int tmr_error = 0;
 566:ServerLLDN.c  **** 	float delta_error = 0;
 567:ServerLLDN.c  **** 	bool beacon_tmr = false;
 568:ServerLLDN.c  **** 	uint32_t be_read = 0;
 569:ServerLLDN.c  **** 	uint32_t tmr_read= 0;
 570:ServerLLDN.c  **** 	int msg_wait_time;
 571:ServerLLDN.c  **** 	int ok_seq = -1;
 572:ServerLLDN.c  **** 	static void send_message_timeHandler(void)
 573:ServerLLDN.c  **** 	{
 820               		.loc 6 573 0
 821               		.cfi_startproc
 822 0292 CF93      		push r28
 823               	.LCFI39:
 824               		.cfi_def_cfa_offset 3
 825               		.cfi_offset 28, -2
 826 0294 DF93      		push r29
 827               	.LCFI40:
 828               		.cfi_def_cfa_offset 4
 829               		.cfi_offset 29, -3
 830 0296 CDB7      		in r28,__SP_L__
 831 0298 DEB7      		in r29,__SP_H__
 832               	.LCFI41:
 833               		.cfi_def_cfa_register 28
 834               	/* prologue: function */
 835               	/* frame size = 0 */
 836               	/* stack size = 2 */
 837               	.L__stack_usage = 2
 574:ServerLLDN.c  **** 		appSendData();
 838               		.loc 6 574 0
 839 029a 0E94 0000 		call appSendData
 575:ServerLLDN.c  **** 		#if MASTER_MACSC == 0
 576:ServerLLDN.c  **** 			timer_stop();
 577:ServerLLDN.c  **** 		#else 
 578:ServerLLDN.c  **** 		macsc_disable_cmp_int(MACSC_CC1);
 840               		.loc 6 578 0
 841 029e 81E0      		ldi r24,lo8(1)
 842 02a0 0E94 0000 		call macsc_disable_cmp_int
 579:ServerLLDN.c  **** 		#endif
 580:ServerLLDN.c  **** 	
 581:ServerLLDN.c  **** 	}
 843               		.loc 6 581 0
 844 02a4 0000      		nop
 845               	/* epilogue start */
 846 02a6 DF91      		pop r29
 847 02a8 CF91      		pop r28
 848 02aa 0895      		ret
 849               		.cfi_endproc
 850               	.LFE131:
 853               	node_time_handler:
 854               	.LFB132:
 582:ServerLLDN.c  **** 
 583:ServerLLDN.c  **** 	static void node_time_handler(void)
 584:ServerLLDN.c  **** 	{
 855               		.loc 6 584 0
 856               		.cfi_startproc
 857 02ac CF93      		push r28
 858               	.LCFI42:
 859               		.cfi_def_cfa_offset 3
 860               		.cfi_offset 28, -2
 861 02ae DF93      		push r29
 862               	.LCFI43:
 863               		.cfi_def_cfa_offset 4
 864               		.cfi_offset 29, -3
 865 02b0 CDB7      		in r28,__SP_L__
 866 02b2 DEB7      		in r29,__SP_H__
 867               	.LCFI44:
 868               		.cfi_def_cfa_register 28
 869               	/* prologue: function */
 870               	/* frame size = 0 */
 871               	/* stack size = 2 */
 872               	.L__stack_usage = 2
 585:ServerLLDN.c  **** 		beacon_tmr = true;
 873               		.loc 6 585 0
 874 02b4 81E0      		ldi r24,lo8(1)
 875 02b6 8093 0000 		sts beacon_tmr,r24
 586:ServerLLDN.c  **** 		tmr_read = macsc_read_count();
 876               		.loc 6 586 0
 877 02ba 0E94 0000 		call macsc_read_count
 878 02be DC01      		movw r26,r24
 879 02c0 CB01      		movw r24,r22
 880 02c2 8093 0000 		sts tmr_read,r24
 881 02c6 9093 0000 		sts tmr_read+1,r25
 882 02ca A093 0000 		sts tmr_read+2,r26
 883 02ce B093 0000 		sts tmr_read+3,r27
 587:ServerLLDN.c  **** 		return;
 884               		.loc 6 587 0
 885 02d2 0000      		nop
 886               	/* epilogue start */
 588:ServerLLDN.c  **** 	}
 887               		.loc 6 588 0
 888 02d4 DF91      		pop r29
 889 02d6 CF91      		pop r28
 890 02d8 0895      		ret
 891               		.cfi_endproc
 892               	.LFE132:
 894               		.section	.rodata
 895               	.LC1:
 896 0000 0A44 6973 		.string	"\nDisc"
 896      6300 
 897               		.text
 899               	disc_time_hndlr:
 900               	.LFB133:
 589:ServerLLDN.c  **** 	
 590:ServerLLDN.c  **** 	
 591:ServerLLDN.c  **** 	static void disc_time_hndlr(void)
 592:ServerLLDN.c  **** 	{
 901               		.loc 6 592 0
 902               		.cfi_startproc
 903 02da CF93      		push r28
 904               	.LCFI45:
 905               		.cfi_def_cfa_offset 3
 906               		.cfi_offset 28, -2
 907 02dc DF93      		push r29
 908               	.LCFI46:
 909               		.cfi_def_cfa_offset 4
 910               		.cfi_offset 29, -3
 911 02de CDB7      		in r28,__SP_L__
 912 02e0 DEB7      		in r29,__SP_H__
 913               	.LCFI47:
 914               		.cfi_def_cfa_register 28
 915               	/* prologue: function */
 916               	/* frame size = 0 */
 917               	/* stack size = 2 */
 918               	.L__stack_usage = 2
 593:ServerLLDN.c  **** 		printf("\nDisc");
 919               		.loc 6 593 0
 920 02e2 80E0      		ldi r24,lo8(.LC1)
 921 02e4 90E0      		ldi r25,hi8(.LC1)
 922 02e6 892F      		mov r24,r25
 923 02e8 8F93      		push r24
 924 02ea 80E0      		ldi r24,lo8(.LC1)
 925 02ec 90E0      		ldi r25,hi8(.LC1)
 926 02ee 8F93      		push r24
 927 02f0 0E94 0000 		call printf
 928 02f4 0F90      		pop __tmp_reg__
 929 02f6 0F90      		pop __tmp_reg__
 594:ServerLLDN.c  **** 			NWK_DataReq(&msgReqDiscResponse);
 930               		.loc 6 594 0
 931 02f8 80E0      		ldi r24,lo8(msgReqDiscResponse)
 932 02fa 90E0      		ldi r25,hi8(msgReqDiscResponse)
 933 02fc 0E94 0000 		call NWK_DataReq
 595:ServerLLDN.c  **** 		macsc_set_cmp1_int_cb(0);
 934               		.loc 6 595 0
 935 0300 80E0      		ldi r24,0
 936 0302 90E0      		ldi r25,0
 937 0304 0E94 0000 		call macsc_set_cmp1_int_cb
 596:ServerLLDN.c  **** 		
 597:ServerLLDN.c  **** 	}
 938               		.loc 6 597 0
 939 0308 0000      		nop
 940               	/* epilogue start */
 941 030a DF91      		pop r29
 942 030c CF91      		pop r28
 943 030e 0895      		ret
 944               		.cfi_endproc
 945               	.LFE133:
 948               	config_time_hndlr:
 949               	.LFB134:
 598:ServerLLDN.c  **** 	
 599:ServerLLDN.c  **** 	static void config_time_hndlr(void)
 600:ServerLLDN.c  **** 	{
 950               		.loc 6 600 0
 951               		.cfi_startproc
 952 0310 CF93      		push r28
 953               	.LCFI48:
 954               		.cfi_def_cfa_offset 3
 955               		.cfi_offset 28, -2
 956 0312 DF93      		push r29
 957               	.LCFI49:
 958               		.cfi_def_cfa_offset 4
 959               		.cfi_offset 29, -3
 960 0314 CDB7      		in r28,__SP_L__
 961 0316 DEB7      		in r29,__SP_H__
 962               	.LCFI50:
 963               		.cfi_def_cfa_register 28
 964               	/* prologue: function */
 965               	/* frame size = 0 */
 966               	/* stack size = 2 */
 967               	.L__stack_usage = 2
 601:ServerLLDN.c  **** 		if(ack_received)
 968               		.loc 6 601 0
 969 0318 8091 0000 		lds r24,ack_received
 970 031c 8823      		tst r24
 971 031e 01F0      		breq .L27
 602:ServerLLDN.c  **** 		{
 603:ServerLLDN.c  **** 			NWK_DataReq(&msgReqConfigStatus);
 972               		.loc 6 603 0
 973 0320 80E0      		ldi r24,lo8(msgReqConfigStatus)
 974 0322 90E0      		ldi r25,hi8(msgReqConfigStatus)
 975 0324 0E94 0000 		call NWK_DataReq
 604:ServerLLDN.c  **** 			ack_received = false;
 976               		.loc 6 604 0
 977 0328 1092 0000 		sts ack_received,__zero_reg__
 978               	.L27:
 605:ServerLLDN.c  **** 		}
 606:ServerLLDN.c  **** 		macsc_set_cmp1_int_cb(0);
 979               		.loc 6 606 0
 980 032c 80E0      		ldi r24,0
 981 032e 90E0      		ldi r25,0
 982 0330 0E94 0000 		call macsc_set_cmp1_int_cb
 607:ServerLLDN.c  **** 		
 608:ServerLLDN.c  **** 	}
 983               		.loc 6 608 0
 984 0334 0000      		nop
 985               	/* epilogue start */
 986 0336 DF91      		pop r29
 987 0338 CF91      		pop r28
 988 033a 0895      		ret
 989               		.cfi_endproc
 990               	.LFE134:
 992               		.section	.rodata
 993               	.LC2:
 994 0006 0A64 6174 		.string	"\ndata_msg"
 994      615F 6D73 
 994      6700 
 995               		.text
 997               	online_time_hndlr:
 998               	.LFB135:
 609:ServerLLDN.c  **** 	
 610:ServerLLDN.c  **** 		
 611:ServerLLDN.c  **** 	static void online_time_hndlr(void)
 612:ServerLLDN.c  **** 	{
 999               		.loc 6 612 0
 1000               		.cfi_startproc
 1001 033c CF93      		push r28
 1002               	.LCFI51:
 1003               		.cfi_def_cfa_offset 3
 1004               		.cfi_offset 28, -2
 1005 033e DF93      		push r29
 1006               	.LCFI52:
 1007               		.cfi_def_cfa_offset 4
 1008               		.cfi_offset 29, -3
 1009 0340 CDB7      		in r28,__SP_L__
 1010 0342 DEB7      		in r29,__SP_H__
 1011               	.LCFI53:
 1012               		.cfi_def_cfa_register 28
 1013               	/* prologue: function */
 1014               	/* frame size = 0 */
 1015               	/* stack size = 2 */
 1016               	.L__stack_usage = 2
 613:ServerLLDN.c  **** 		printf("\ndata_msg");
 1017               		.loc 6 613 0
 1018 0344 80E0      		ldi r24,lo8(.LC2)
 1019 0346 90E0      		ldi r25,hi8(.LC2)
 1020 0348 892F      		mov r24,r25
 1021 034a 8F93      		push r24
 1022 034c 80E0      		ldi r24,lo8(.LC2)
 1023 034e 90E0      		ldi r25,hi8(.LC2)
 1024 0350 8F93      		push r24
 1025 0352 0E94 0000 		call printf
 1026 0356 0F90      		pop __tmp_reg__
 1027 0358 0F90      		pop __tmp_reg__
 614:ServerLLDN.c  **** 		NWK_DataReq(&msgReqData);
 1028               		.loc 6 614 0
 1029 035a 80E0      		ldi r24,lo8(msgReqData)
 1030 035c 90E0      		ldi r25,hi8(msgReqData)
 1031 035e 0E94 0000 		call NWK_DataReq
 615:ServerLLDN.c  **** 		macsc_set_cmp1_int_cb(0);		
 1032               		.loc 6 615 0
 1033 0362 80E0      		ldi r24,0
 1034 0364 90E0      		ldi r25,0
 1035 0366 0E94 0000 		call macsc_set_cmp1_int_cb
 616:ServerLLDN.c  **** 	}
 1036               		.loc 6 616 0
 1037 036a 0000      		nop
 1038               	/* epilogue start */
 1039 036c DF91      		pop r29
 1040 036e CF91      		pop r28
 1041 0370 0895      		ret
 1042               		.cfi_endproc
 1043               	.LFE135:
 1045               	.global	__floatsisf
 1046               	.global	__addsf3
 1047               	.global	__divsf3
 1048               		.section	.rodata
 1049               	.LC3:
 1050 0010 0A42 4520 		.string	"\nBE %f"
 1050      2566 00
 1051               	.global	__mulsf3
 1052               	.global	__fixsfsi
 1053               	.LC4:
 1054 0017 6D73 675F 		.string	"msg_wait %d"
 1054      7761 6974 
 1054      2025 6400 
 1055               		.text
 1057               	appBeaconInd:
 1058               	.LFB136:
 617:ServerLLDN.c  **** 	
 618:ServerLLDN.c  **** 	static bool appBeaconInd(NWK_DataInd_t *ind)
 619:ServerLLDN.c  **** 	{
 1059               		.loc 6 619 0
 1060               		.cfi_startproc
 1061 0372 EF92      		push r14
 1062               	.LCFI54:
 1063               		.cfi_def_cfa_offset 3
 1064               		.cfi_offset 14, -2
 1065 0374 FF92      		push r15
 1066               	.LCFI55:
 1067               		.cfi_def_cfa_offset 4
 1068               		.cfi_offset 15, -3
 1069 0376 0F93      		push r16
 1070               	.LCFI56:
 1071               		.cfi_def_cfa_offset 5
 1072               		.cfi_offset 16, -4
 1073 0378 1F93      		push r17
 1074               	.LCFI57:
 1075               		.cfi_def_cfa_offset 6
 1076               		.cfi_offset 17, -5
 1077 037a CF93      		push r28
 1078               	.LCFI58:
 1079               		.cfi_def_cfa_offset 7
 1080               		.cfi_offset 28, -6
 1081 037c DF93      		push r29
 1082               	.LCFI59:
 1083               		.cfi_def_cfa_offset 8
 1084               		.cfi_offset 29, -7
 1085 037e 00D0      		rcall .
 1086 0380 00D0      		rcall .
 1087               	.LCFI60:
 1088               		.cfi_def_cfa_offset 12
 1089 0382 CDB7      		in r28,__SP_L__
 1090 0384 DEB7      		in r29,__SP_H__
 1091               	.LCFI61:
 1092               		.cfi_def_cfa_register 28
 1093               	/* prologue: function */
 1094               	/* frame size = 4 */
 1095               	/* stack size = 10 */
 1096               	.L__stack_usage = 10
 1097 0386 9C83      		std Y+4,r25
 1098 0388 8B83      		std Y+3,r24
 620:ServerLLDN.c  **** 		NwkFrameBeaconHeaderLLDN_t *tmp_beacon = (NwkFrameBeaconHeaderLLDN_t*)ind->data;
 1099               		.loc 6 620 0
 1100 038a 8B81      		ldd r24,Y+3
 1101 038c 9C81      		ldd r25,Y+4
 1102 038e FC01      		movw r30,r24
 1103 0390 8085      		ldd r24,Z+8
 1104 0392 9185      		ldd r25,Z+9
 1105 0394 9A83      		std Y+2,r25
 1106 0396 8983      		std Y+1,r24
 621:ServerLLDN.c  **** 		rec_beacon = *tmp_beacon;
 1107               		.loc 6 621 0
 1108 0398 8981      		ldd r24,Y+1
 1109 039a 9A81      		ldd r25,Y+2
 1110 039c 28E0      		ldi r18,lo8(8)
 1111 039e FC01      		movw r30,r24
 1112 03a0 A0E0      		ldi r26,lo8(rec_beacon)
 1113 03a2 B0E0      		ldi r27,hi8(rec_beacon)
 1114               		0:
 1115 03a4 0190      		ld r0,Z+
 1116 03a6 0D92      		st X+,r0
 1117 03a8 2A95      		dec r18
 1118 03aa 01F4      		brne 0b
 622:ServerLLDN.c  **** 		PanId = tmp_beacon->PanId;
 1119               		.loc 6 622 0
 1120 03ac 8981      		ldd r24,Y+1
 1121 03ae 9A81      		ldd r25,Y+2
 1122 03b0 FC01      		movw r30,r24
 1123 03b2 8481      		ldd r24,Z+4
 1124 03b4 8093 0000 		sts PanId,r24
 623:ServerLLDN.c  **** 		tTS =  ((p_var*sp + (m+ tmp_beacon->TimeSlotSize )*sm + macMinLIFSPeriod)/v_var)  / (SYMBOL_TIME)
 1125               		.loc 6 623 0
 1126 03b8 8981      		ldd r24,Y+1
 1127 03ba 9A81      		ldd r25,Y+2
 1128 03bc FC01      		movw r30,r24
 1129 03be 8681      		ldd r24,Z+6
 1130 03c0 882F      		mov r24,r24
 1131 03c2 90E0      		ldi r25,0
 1132 03c4 0396      		adiw r24,3
 1133 03c6 880F      		lsl r24
 1134 03c8 991F      		rol r25
 1135 03ca 092E      		mov __tmp_reg__,r25
 1136 03cc 000C      		lsl r0
 1137 03ce AA0B      		sbc r26,r26
 1138 03d0 BB0B      		sbc r27,r27
 1139 03d2 BC01      		movw r22,r24
 1140 03d4 CD01      		movw r24,r26
 1141 03d6 0E94 0000 		call __floatsisf
 1142 03da DC01      		movw r26,r24
 1143 03dc CB01      		movw r24,r22
 1144 03de 20E0      		ldi r18,0
 1145 03e0 30E0      		ldi r19,0
 1146 03e2 40E4      		ldi r20,lo8(64)
 1147 03e4 51E4      		ldi r21,lo8(65)
 1148 03e6 BC01      		movw r22,r24
 1149 03e8 CD01      		movw r24,r26
 1150 03ea 0E94 0000 		call __addsf3
 1151 03ee DC01      		movw r26,r24
 1152 03f0 CB01      		movw r24,r22
 1153 03f2 20E0      		ldi r18,0
 1154 03f4 30E0      		ldi r19,0
 1155 03f6 40E2      		ldi r20,lo8(32)
 1156 03f8 52E4      		ldi r21,lo8(66)
 1157 03fa BC01      		movw r22,r24
 1158 03fc CD01      		movw r24,r26
 1159 03fe 0E94 0000 		call __addsf3
 1160 0402 DC01      		movw r26,r24
 1161 0404 CB01      		movw r24,r22
 1162 0406 20E0      		ldi r18,0
 1163 0408 34E2      		ldi r19,lo8(36)
 1164 040a 44E7      		ldi r20,lo8(116)
 1165 040c 57E4      		ldi r21,lo8(71)
 1166 040e BC01      		movw r22,r24
 1167 0410 CD01      		movw r24,r26
 1168 0412 0E94 0000 		call __divsf3
 1169 0416 DC01      		movw r26,r24
 1170 0418 CB01      		movw r24,r22
 1171 041a 2DEB      		ldi r18,lo8(-67)
 1172 041c 37E3      		ldi r19,lo8(55)
 1173 041e 46E8      		ldi r20,lo8(-122)
 1174 0420 57E3      		ldi r21,lo8(55)
 1175 0422 BC01      		movw r22,r24
 1176 0424 CD01      		movw r24,r26
 1177 0426 0E94 0000 		call __divsf3
 1178 042a DC01      		movw r26,r24
 1179 042c CB01      		movw r24,r22
 1180 042e 8093 0000 		sts tTS,r24
 1181 0432 9093 0000 		sts tTS+1,r25
 1182 0436 A093 0000 		sts tTS+2,r26
 1183 043a B093 0000 		sts tTS+3,r27
 624:ServerLLDN.c  **** 		printf("\nBE %f", tTS);
 1184               		.loc 6 624 0
 1185 043e 8091 0000 		lds r24,tTS
 1186 0442 9091 0000 		lds r25,tTS+1
 1187 0446 A091 0000 		lds r26,tTS+2
 1188 044a B091 0000 		lds r27,tTS+3
 1189 044e 2B2F      		mov r18,r27
 1190 0450 2F93      		push r18
 1191 0452 2A2F      		mov r18,r26
 1192 0454 2F93      		push r18
 1193 0456 292F      		mov r18,r25
 1194 0458 2F93      		push r18
 1195 045a 8F93      		push r24
 1196 045c 80E0      		ldi r24,lo8(.LC3)
 1197 045e 90E0      		ldi r25,hi8(.LC3)
 1198 0460 892F      		mov r24,r25
 1199 0462 8F93      		push r24
 1200 0464 80E0      		ldi r24,lo8(.LC3)
 1201 0466 90E0      		ldi r25,hi8(.LC3)
 1202 0468 8F93      		push r24
 1203 046a 0E94 0000 		call printf
 1204 046e 0F90      		pop __tmp_reg__
 1205 0470 0F90      		pop __tmp_reg__
 1206 0472 0F90      		pop __tmp_reg__
 1207 0474 0F90      		pop __tmp_reg__
 1208 0476 0F90      		pop __tmp_reg__
 1209 0478 0F90      		pop __tmp_reg__
 625:ServerLLDN.c  **** 		if(rec_beacon.Flags.txState == STATE && rec_beacon.confSeqNumber == 0)
 1210               		.loc 6 625 0
 1211 047a 8091 0000 		lds r24,rec_beacon+3
 1212 047e 8770      		andi r24,lo8(7)
 1213 0480 282F      		mov r18,r24
 1214 0482 30E0      		ldi r19,0
 1215 0484 8091 0000 		lds r24,STATE
 1216 0488 882F      		mov r24,r24
 1217 048a 90E0      		ldi r25,0
 1218 048c 2817      		cp r18,r24
 1219 048e 3907      		cpc r19,r25
 1220 0490 01F0      		breq .+2
 1221 0492 00C0      		rjmp .L30
 1222               		.loc 6 625 0 is_stmt 0 discriminator 1
 1223 0494 8091 0000 		lds r24,rec_beacon+5
 1224 0498 8823      		tst r24
 1225 049a 01F0      		breq .+2
 1226 049c 00C0      		rjmp .L30
 626:ServerLLDN.c  **** 		{
 627:ServerLLDN.c  **** 			if(STATE == DISC_MODE) 
 1227               		.loc 6 627 0 is_stmt 1
 1228 049e 8091 0000 		lds r24,STATE
 1229 04a2 8430      		cpi r24,lo8(4)
 1230 04a4 01F4      		brne .L31
 628:ServerLLDN.c  **** 				macsc_set_cmp1_int_cb(disc_time_hndlr);
 1231               		.loc 6 628 0
 1232 04a6 80E0      		ldi r24,lo8(gs(disc_time_hndlr))
 1233 04a8 90E0      		ldi r25,hi8(gs(disc_time_hndlr))
 1234 04aa 0E94 0000 		call macsc_set_cmp1_int_cb
 1235 04ae 00C0      		rjmp .L32
 1236               	.L31:
 629:ServerLLDN.c  **** 			else if(STATE == CONFIG_MODE)
 1237               		.loc 6 629 0
 1238 04b0 8091 0000 		lds r24,STATE
 1239 04b4 8630      		cpi r24,lo8(6)
 1240 04b6 01F4      		brne .L33
 630:ServerLLDN.c  **** 				macsc_set_cmp1_int_cb(config_time_hndlr);
 1241               		.loc 6 630 0
 1242 04b8 80E0      		ldi r24,lo8(gs(config_time_hndlr))
 1243 04ba 90E0      		ldi r25,hi8(gs(config_time_hndlr))
 1244 04bc 0E94 0000 		call macsc_set_cmp1_int_cb
 1245 04c0 00C0      		rjmp .L32
 1246               	.L33:
 631:ServerLLDN.c  **** 			else if(STATE == ONLINE_MODE)
 1247               		.loc 6 631 0
 1248 04c2 8091 0000 		lds r24,STATE
 1249 04c6 8823      		tst r24
 1250 04c8 01F4      		brne .L32
 632:ServerLLDN.c  **** 				macsc_set_cmp1_int_cb(online_time_hndlr);
 1251               		.loc 6 632 0
 1252 04ca 80E0      		ldi r24,lo8(gs(online_time_hndlr))
 1253 04cc 90E0      		ldi r25,hi8(gs(online_time_hndlr))
 1254 04ce 0E94 0000 		call macsc_set_cmp1_int_cb
 1255               	.L32:
 633:ServerLLDN.c  **** 					
 634:ServerLLDN.c  **** 			
 635:ServerLLDN.c  **** 			
 636:ServerLLDN.c  **** 			if(STATE == ONLINE_MODE)
 1256               		.loc 6 636 0
 1257 04d2 8091 0000 		lds r24,STATE
 1258 04d6 8823      		tst r24
 1259 04d8 01F0      		breq .+2
 1260 04da 00C0      		rjmp .L34
 637:ServerLLDN.c  **** 			{
 638:ServerLLDN.c  **** 				msg_wait_time = (2*rec_beacon.Flags.numBaseMgmtTimeslots + assTimeSlot) * tTS /*+ 80 + 45*assTi
 1261               		.loc 6 638 0
 1262 04dc 8091 0000 		lds r24,rec_beacon+3
 1263 04e0 8295      		swap r24
 1264 04e2 8695      		lsr r24
 1265 04e4 8770      		andi r24,lo8(7)
 1266 04e6 882F      		mov r24,r24
 1267 04e8 90E0      		ldi r25,0
 1268 04ea 9C01      		movw r18,r24
 1269 04ec 220F      		lsl r18
 1270 04ee 331F      		rol r19
 1271 04f0 8091 0000 		lds r24,assTimeSlot
 1272 04f4 882F      		mov r24,r24
 1273 04f6 90E0      		ldi r25,0
 1274 04f8 820F      		add r24,r18
 1275 04fa 931F      		adc r25,r19
 1276 04fc 092E      		mov __tmp_reg__,r25
 1277 04fe 000C      		lsl r0
 1278 0500 AA0B      		sbc r26,r26
 1279 0502 BB0B      		sbc r27,r27
 1280 0504 BC01      		movw r22,r24
 1281 0506 CD01      		movw r24,r26
 1282 0508 0E94 0000 		call __floatsisf
 1283 050c 7B01      		movw r14,r22
 1284 050e 8C01      		movw r16,r24
 1285 0510 8091 0000 		lds r24,tTS
 1286 0514 9091 0000 		lds r25,tTS+1
 1287 0518 A091 0000 		lds r26,tTS+2
 1288 051c B091 0000 		lds r27,tTS+3
 1289 0520 9C01      		movw r18,r24
 1290 0522 AD01      		movw r20,r26
 1291 0524 C801      		movw r24,r16
 1292 0526 B701      		movw r22,r14
 1293 0528 0E94 0000 		call __mulsf3
 1294 052c DC01      		movw r26,r24
 1295 052e CB01      		movw r24,r22
 1296 0530 BC01      		movw r22,r24
 1297 0532 CD01      		movw r24,r26
 1298 0534 0E94 0000 		call __fixsfsi
 1299 0538 DC01      		movw r26,r24
 1300 053a CB01      		movw r24,r22
 1301 053c 9093 0000 		sts msg_wait_time+1,r25
 1302 0540 8093 0000 		sts msg_wait_time,r24
 639:ServerLLDN.c  **** 				printf("msg_wait %d", msg_wait_time);
 1303               		.loc 6 639 0
 1304 0544 8091 0000 		lds r24,msg_wait_time
 1305 0548 9091 0000 		lds r25,msg_wait_time+1
 1306 054c 292F      		mov r18,r25
 1307 054e 2F93      		push r18
 1308 0550 8F93      		push r24
 1309 0552 80E0      		ldi r24,lo8(.LC4)
 1310 0554 90E0      		ldi r25,hi8(.LC4)
 1311 0556 892F      		mov r24,r25
 1312 0558 8F93      		push r24
 1313 055a 80E0      		ldi r24,lo8(.LC4)
 1314 055c 90E0      		ldi r25,hi8(.LC4)
 1315 055e 8F93      		push r24
 1316 0560 0E94 0000 		call printf
 1317 0564 0F90      		pop __tmp_reg__
 1318 0566 0F90      		pop __tmp_reg__
 1319 0568 0F90      		pop __tmp_reg__
 1320 056a 0F90      		pop __tmp_reg__
 1321 056c 00C0      		rjmp .L35
 1322               	.L34:
 640:ServerLLDN.c  **** 			}
 641:ServerLLDN.c  **** 			else	
 642:ServerLLDN.c  **** 				msg_wait_time = tTS * rec_beacon.Flags.numBaseMgmtTimeslots; 
 1323               		.loc 6 642 0
 1324 056e 8091 0000 		lds r24,rec_beacon+3
 1325 0572 8295      		swap r24
 1326 0574 8695      		lsr r24
 1327 0576 8770      		andi r24,lo8(7)
 1328 0578 882F      		mov r24,r24
 1329 057a 90E0      		ldi r25,0
 1330 057c 092E      		mov __tmp_reg__,r25
 1331 057e 000C      		lsl r0
 1332 0580 AA0B      		sbc r26,r26
 1333 0582 BB0B      		sbc r27,r27
 1334 0584 BC01      		movw r22,r24
 1335 0586 CD01      		movw r24,r26
 1336 0588 0E94 0000 		call __floatsisf
 1337 058c 7B01      		movw r14,r22
 1338 058e 8C01      		movw r16,r24
 1339 0590 8091 0000 		lds r24,tTS
 1340 0594 9091 0000 		lds r25,tTS+1
 1341 0598 A091 0000 		lds r26,tTS+2
 1342 059c B091 0000 		lds r27,tTS+3
 1343 05a0 9C01      		movw r18,r24
 1344 05a2 AD01      		movw r20,r26
 1345 05a4 C801      		movw r24,r16
 1346 05a6 B701      		movw r22,r14
 1347 05a8 0E94 0000 		call __mulsf3
 1348 05ac DC01      		movw r26,r24
 1349 05ae CB01      		movw r24,r22
 1350 05b0 BC01      		movw r22,r24
 1351 05b2 CD01      		movw r24,r26
 1352 05b4 0E94 0000 		call __fixsfsi
 1353 05b8 DC01      		movw r26,r24
 1354 05ba CB01      		movw r24,r22
 1355 05bc 9093 0000 		sts msg_wait_time+1,r25
 1356 05c0 8093 0000 		sts msg_wait_time,r24
 1357               	.L35:
 643:ServerLLDN.c  **** 			macsc_enable_cmp_int(MACSC_CC1);
 1358               		.loc 6 643 0
 1359 05c4 81E0      		ldi r24,lo8(1)
 1360 05c6 0E94 0000 		call macsc_enable_cmp_int
 644:ServerLLDN.c  **** 			macsc_use_cmp(MACSC_RELATIVE_CMP, msg_wait_time - 150, MACSC_CC1);
 1361               		.loc 6 644 0
 1362 05ca 8091 0000 		lds r24,msg_wait_time
 1363 05ce 9091 0000 		lds r25,msg_wait_time+1
 1364 05d2 8659      		subi r24,-106
 1365 05d4 9109      		sbc r25,__zero_reg__
 1366 05d6 092E      		mov __tmp_reg__,r25
 1367 05d8 000C      		lsl r0
 1368 05da AA0B      		sbc r26,r26
 1369 05dc BB0B      		sbc r27,r27
 1370 05de 21E0      		ldi r18,lo8(1)
 1371 05e0 AC01      		movw r20,r24
 1372 05e2 BD01      		movw r22,r26
 1373 05e4 81E0      		ldi r24,lo8(1)
 1374 05e6 0E94 0000 		call macsc_use_cmp
 645:ServerLLDN.c  ****  			macsc_enable_manual_bts();
 1375               		.loc 6 645 0
 1376 05ea 0E94 0000 		call macsc_enable_manual_bts
 1377 05ee 00C0      		rjmp .L36
 1378               	.L30:
 646:ServerLLDN.c  **** 			
 647:ServerLLDN.c  **** 		}
 648:ServerLLDN.c  **** 
 649:ServerLLDN.c  **** 		else if (rec_beacon.Flags.txState == RESET_MODE)
 1379               		.loc 6 649 0
 1380 05f0 8091 0000 		lds r24,rec_beacon+3
 1381 05f4 8770      		andi r24,lo8(7)
 1382 05f6 8730      		cpi r24,lo8(7)
 1383 05f8 01F4      		brne .L36
 650:ServerLLDN.c  **** 		{
 651:ServerLLDN.c  **** 			PHY_SetTdmaMode(false);
 1384               		.loc 6 651 0
 1385 05fa 80E0      		ldi r24,0
 1386 05fc 0E94 0000 		call PHY_SetTdmaMode
 652:ServerLLDN.c  **** 			ack_received = 0;
 1387               		.loc 6 652 0
 1388 0600 1092 0000 		sts ack_received,__zero_reg__
 653:ServerLLDN.c  **** 			STATE = DISC_MODE;
 1389               		.loc 6 653 0
 1390 0604 84E0      		ldi r24,lo8(4)
 1391 0606 8093 0000 		sts STATE,r24
 1392               	.L36:
 654:ServerLLDN.c  **** 		}
 655:ServerLLDN.c  **** 		return true;
 1393               		.loc 6 655 0
 1394 060a 81E0      		ldi r24,lo8(1)
 1395               	/* epilogue start */
 656:ServerLLDN.c  **** 	}
 1396               		.loc 6 656 0
 1397 060c 0F90      		pop __tmp_reg__
 1398 060e 0F90      		pop __tmp_reg__
 1399 0610 0F90      		pop __tmp_reg__
 1400 0612 0F90      		pop __tmp_reg__
 1401 0614 DF91      		pop r29
 1402 0616 CF91      		pop r28
 1403 0618 1F91      		pop r17
 1404 061a 0F91      		pop r16
 1405 061c FF90      		pop r15
 1406 061e EF90      		pop r14
 1407 0620 0895      		ret
 1408               		.cfi_endproc
 1409               	.LFE136:
 1411               		.section	.rodata
 1412               	.LC5:
 1413 0023 0A20 6163 		.string	"\n ack rec %hhx "
 1413      6B20 7265 
 1413      6320 2568 
 1413      6878 2000 
 1414               		.text
 1415               	.global	check_ack
 1417               	check_ack:
 1418               	.LFB137:
 657:ServerLLDN.c  **** 	
 658:ServerLLDN.c  **** 	bool check_ack(int addr)
 659:ServerLLDN.c  **** 	{
 1419               		.loc 6 659 0
 1420               		.cfi_startproc
 1421 0622 CF93      		push r28
 1422               	.LCFI62:
 1423               		.cfi_def_cfa_offset 3
 1424               		.cfi_offset 28, -2
 1425 0624 DF93      		push r29
 1426               	.LCFI63:
 1427               		.cfi_def_cfa_offset 4
 1428               		.cfi_offset 29, -3
 1429 0626 00D0      		rcall .
 1430 0628 00D0      		rcall .
 1431 062a 00D0      		rcall .
 1432               	.LCFI64:
 1433               		.cfi_def_cfa_offset 10
 1434 062c CDB7      		in r28,__SP_L__
 1435 062e DEB7      		in r29,__SP_H__
 1436               	.LCFI65:
 1437               		.cfi_def_cfa_register 28
 1438               	/* prologue: function */
 1439               	/* frame size = 6 */
 1440               	/* stack size = 8 */
 1441               	.L__stack_usage = 8
 1442 0630 9E83      		std Y+6,r25
 1443 0632 8D83      		std Y+5,r24
 660:ServerLLDN.c  **** 		int pos =  addr / 8;
 1444               		.loc 6 660 0
 1445 0634 8D81      		ldd r24,Y+5
 1446 0636 9E81      		ldd r25,Y+6
 1447 0638 9923      		tst r25
 1448 063a 04F4      		brge .L39
 1449 063c 0796      		adiw r24,7
 1450               	.L39:
 1451 063e 9595      		asr r25
 1452 0640 8795      		ror r24
 1453 0642 9595      		asr r25
 1454 0644 8795      		ror r24
 1455 0646 9595      		asr r25
 1456 0648 8795      		ror r24
 1457 064a 9A83      		std Y+2,r25
 1458 064c 8983      		std Y+1,r24
 661:ServerLLDN.c  **** 		int bit_shift = 8 - addr % 8;
 1459               		.loc 6 661 0
 1460 064e 8D81      		ldd r24,Y+5
 1461 0650 9E81      		ldd r25,Y+6
 1462 0652 8770      		andi r24,7
 1463 0654 9078      		andi r25,128
 1464 0656 9923      		tst r25
 1465 0658 04F4      		brge .L40
 1466 065a 0197      		sbiw r24,1
 1467 065c 886F      		ori r24,248
 1468 065e 9F6F      		ori r25,255
 1469 0660 0196      		adiw r24,1
 1470               	.L40:
 1471 0662 9C01      		movw r18,r24
 1472 0664 88E0      		ldi r24,lo8(8)
 1473 0666 90E0      		ldi r25,0
 1474 0668 821B      		sub r24,r18
 1475 066a 930B      		sbc r25,r19
 1476 066c 9C83      		std Y+4,r25
 1477 066e 8B83      		std Y+3,r24
 662:ServerLLDN.c  **** // 		if(addr == 8)
 663:ServerLLDN.c  **** // 		{
 664:ServerLLDN.c  **** // 			pos = 0;
 665:ServerLLDN.c  **** // 			bit_shift = 0;
 666:ServerLLDN.c  **** // 		}
 667:ServerLLDN.c  **** 		printf("\n ack rec %hhx ", ackframe->ackFlags[pos]);
 1478               		.loc 6 667 0
 1479 0670 2091 0000 		lds r18,ackframe
 1480 0674 3091 0000 		lds r19,ackframe+1
 1481 0678 8981      		ldd r24,Y+1
 1482 067a 9A81      		ldd r25,Y+2
 1483 067c 820F      		add r24,r18
 1484 067e 931F      		adc r25,r19
 1485 0680 0196      		adiw r24,1
 1486 0682 FC01      		movw r30,r24
 1487 0684 8081      		ld r24,Z
 1488 0686 882F      		mov r24,r24
 1489 0688 90E0      		ldi r25,0
 1490 068a 292F      		mov r18,r25
 1491 068c 2F93      		push r18
 1492 068e 8F93      		push r24
 1493 0690 80E0      		ldi r24,lo8(.LC5)
 1494 0692 90E0      		ldi r25,hi8(.LC5)
 1495 0694 892F      		mov r24,r25
 1496 0696 8F93      		push r24
 1497 0698 80E0      		ldi r24,lo8(.LC5)
 1498 069a 90E0      		ldi r25,hi8(.LC5)
 1499 069c 8F93      		push r24
 1500 069e 0E94 0000 		call printf
 1501 06a2 0F90      		pop __tmp_reg__
 1502 06a4 0F90      		pop __tmp_reg__
 1503 06a6 0F90      		pop __tmp_reg__
 1504 06a8 0F90      		pop __tmp_reg__
 668:ServerLLDN.c  **** 		if( ackframe->ackFlags[pos] & 1 << bit_shift)
 1505               		.loc 6 668 0
 1506 06aa 2091 0000 		lds r18,ackframe
 1507 06ae 3091 0000 		lds r19,ackframe+1
 1508 06b2 8981      		ldd r24,Y+1
 1509 06b4 9A81      		ldd r25,Y+2
 1510 06b6 820F      		add r24,r18
 1511 06b8 931F      		adc r25,r19
 1512 06ba 0196      		adiw r24,1
 1513 06bc FC01      		movw r30,r24
 1514 06be 8081      		ld r24,Z
 1515 06c0 882F      		mov r24,r24
 1516 06c2 90E0      		ldi r25,0
 1517 06c4 0B80      		ldd r0,Y+3
 1518 06c6 00C0      		rjmp 2f
 1519               		1:
 1520 06c8 9595      		asr r25
 1521 06ca 8795      		ror r24
 1522               		2:
 1523 06cc 0A94      		dec r0
 1524 06ce 02F4      		brpl 1b
 1525 06d0 8170      		andi r24,1
 1526 06d2 9927      		clr r25
 1527 06d4 892B      		or r24,r25
 1528 06d6 01F0      		breq .L41
 669:ServerLLDN.c  **** 		{
 670:ServerLLDN.c  **** 			return true;
 1529               		.loc 6 670 0
 1530 06d8 81E0      		ldi r24,lo8(1)
 1531 06da 00C0      		rjmp .L42
 1532               	.L41:
 671:ServerLLDN.c  **** 		}
 672:ServerLLDN.c  **** 		else
 673:ServerLLDN.c  **** 			return false;
 1533               		.loc 6 673 0
 1534 06dc 80E0      		ldi r24,0
 1535               	.L42:
 1536               	/* epilogue start */
 674:ServerLLDN.c  **** 	}
 1537               		.loc 6 674 0
 1538 06de 2696      		adiw r28,6
 1539 06e0 0FB6      		in __tmp_reg__,__SREG__
 1540 06e2 F894      		cli
 1541 06e4 DEBF      		out __SP_H__,r29
 1542 06e6 0FBE      		out __SREG__,__tmp_reg__
 1543 06e8 CDBF      		out __SP_L__,r28
 1544 06ea DF91      		pop r29
 1545 06ec CF91      		pop r28
 1546 06ee 0895      		ret
 1547               		.cfi_endproc
 1548               	.LFE137:
 1550               	.global	__subsf3
 1551               	.global	__fixunssfsi
 1552               		.section	.rodata
 1553               	.LC6:
 1554 0033 0A72 6574 		.string	"\nretransmition_slot %d , %f"
 1554      7261 6E73 
 1554      6D69 7469 
 1554      6F6E 5F73 
 1554      6C6F 7420 
 1555               	.LC7:
 1556 004f 0A4F 4B20 		.string	"\nOK on conf"
 1556      6F6E 2063 
 1556      6F6E 6600 
 1557               		.text
 1559               	appAckInd:
 1560               	.LFB138:
 675:ServerLLDN.c  **** 	
 676:ServerLLDN.c  **** 	static bool appAckInd(NWK_DataInd_t *ind)
 677:ServerLLDN.c  **** 	{
 1561               		.loc 6 677 0
 1562               		.cfi_startproc
 1563 06f0 EF92      		push r14
 1564               	.LCFI66:
 1565               		.cfi_def_cfa_offset 3
 1566               		.cfi_offset 14, -2
 1567 06f2 FF92      		push r15
 1568               	.LCFI67:
 1569               		.cfi_def_cfa_offset 4
 1570               		.cfi_offset 15, -3
 1571 06f4 0F93      		push r16
 1572               	.LCFI68:
 1573               		.cfi_def_cfa_offset 5
 1574               		.cfi_offset 16, -4
 1575 06f6 1F93      		push r17
 1576               	.LCFI69:
 1577               		.cfi_def_cfa_offset 6
 1578               		.cfi_offset 17, -5
 1579 06f8 CF93      		push r28
 1580               	.LCFI70:
 1581               		.cfi_def_cfa_offset 7
 1582               		.cfi_offset 28, -6
 1583 06fa DF93      		push r29
 1584               	.LCFI71:
 1585               		.cfi_def_cfa_offset 8
 1586               		.cfi_offset 29, -7
 1587 06fc 00D0      		rcall .
 1588 06fe 00D0      		rcall .
 1589 0700 00D0      		rcall .
 1590               	.LCFI72:
 1591               		.cfi_def_cfa_offset 14
 1592 0702 CDB7      		in r28,__SP_L__
 1593 0704 DEB7      		in r29,__SP_H__
 1594               	.LCFI73:
 1595               		.cfi_def_cfa_register 28
 1596               	/* prologue: function */
 1597               	/* frame size = 6 */
 1598               	/* stack size = 12 */
 1599               	.L__stack_usage = 12
 1600 0706 9E83      		std Y+6,r25
 1601 0708 8D83      		std Y+5,r24
 678:ServerLLDN.c  **** 		#if !MASTER_MACSC
 679:ServerLLDN.c  **** 		ind->data = ind->data - (uint8_t) 1;
 680:ServerLLDN.c  **** 		#endif
 681:ServerLLDN.c  **** 		ackframe = (NWK_ACKFormat_t*)ind->data;
 1602               		.loc 6 681 0
 1603 070a 8D81      		ldd r24,Y+5
 1604 070c 9E81      		ldd r25,Y+6
 1605 070e FC01      		movw r30,r24
 1606 0710 8085      		ldd r24,Z+8
 1607 0712 9185      		ldd r25,Z+9
 1608 0714 9093 0000 		sts ackframe+1,r25
 1609 0718 8093 0000 		sts ackframe,r24
 682:ServerLLDN.c  **** 
 683:ServerLLDN.c  **** 		if(PanId == ackframe->sourceId)
 1610               		.loc 6 683 0
 1611 071c 8091 0000 		lds r24,ackframe
 1612 0720 9091 0000 		lds r25,ackframe+1
 1613 0724 FC01      		movw r30,r24
 1614 0726 9081      		ld r25,Z
 1615 0728 8091 0000 		lds r24,PanId
 1616 072c 9817      		cp r25,r24
 1617 072e 01F0      		breq .+2
 1618 0730 00C0      		rjmp .L44
 684:ServerLLDN.c  **** 		{
 685:ServerLLDN.c  **** 			if(STATE == ONLINE_MODE /*&& rec_beacon.Flags.txState == ONLINE_MODE*/)
 1619               		.loc 6 685 0
 1620 0732 8091 0000 		lds r24,STATE
 1621 0736 8823      		tst r24
 1622 0738 01F0      		breq .+2
 1623 073a 00C0      		rjmp .L45
 686:ServerLLDN.c  **** 			{
 687:ServerLLDN.c  **** 				ack_received = check_ack(assTimeSlot + 1);
 1624               		.loc 6 687 0
 1625 073c 8091 0000 		lds r24,assTimeSlot
 1626 0740 882F      		mov r24,r24
 1627 0742 90E0      		ldi r25,0
 1628 0744 0196      		adiw r24,1
 1629 0746 0E94 0000 		call check_ack
 1630 074a 8093 0000 		sts ack_received,r24
 688:ServerLLDN.c  **** 				if(!ack_received)
 1631               		.loc 6 688 0
 1632 074e 9091 0000 		lds r25,ack_received
 1633 0752 81E0      		ldi r24,lo8(1)
 1634 0754 8927      		eor r24,r25
 1635 0756 8823      		tst r24
 1636 0758 01F4      		brne .+2
 1637 075a 00C0      		rjmp .L44
 1638               	.LBB2:
 689:ServerLLDN.c  **** 				{
 690:ServerLLDN.c  **** 				
 691:ServerLLDN.c  **** 					int retransmition_slot = 0;
 1639               		.loc 6 691 0
 1640 075c 1A82      		std Y+2,__zero_reg__
 1641 075e 1982      		std Y+1,__zero_reg__
 1642               	.LBB3:
 692:ServerLLDN.c  **** 					
 693:ServerLLDN.c  **** 
 694:ServerLLDN.c  **** 					for(int i = 0; i < assTimeSlot && i < (rec_beacon.NumberOfBaseTimeslotsinSuperframe - 3)/2; i+
 1643               		.loc 6 694 0
 1644 0760 1C82      		std Y+4,__zero_reg__
 1645 0762 1B82      		std Y+3,__zero_reg__
 1646 0764 00C0      		rjmp .L47
 1647               	.L51:
 695:ServerLLDN.c  **** 						if( !check_ack(i+1) )
 1648               		.loc 6 695 0
 1649 0766 8B81      		ldd r24,Y+3
 1650 0768 9C81      		ldd r25,Y+4
 1651 076a 0196      		adiw r24,1
 1652 076c 0E94 0000 		call check_ack
 1653 0770 982F      		mov r25,r24
 1654 0772 81E0      		ldi r24,lo8(1)
 1655 0774 8927      		eor r24,r25
 1656 0776 8823      		tst r24
 1657 0778 01F0      		breq .L48
 696:ServerLLDN.c  **** 							retransmition_slot++;
 1658               		.loc 6 696 0
 1659 077a 8981      		ldd r24,Y+1
 1660 077c 9A81      		ldd r25,Y+2
 1661 077e 0196      		adiw r24,1
 1662 0780 9A83      		std Y+2,r25
 1663 0782 8983      		std Y+1,r24
 1664               	.L48:
 694:ServerLLDN.c  **** 						if( !check_ack(i+1) )
 1665               		.loc 6 694 0 discriminator 2
 1666 0784 8B81      		ldd r24,Y+3
 1667 0786 9C81      		ldd r25,Y+4
 1668 0788 0196      		adiw r24,1
 1669 078a 9C83      		std Y+4,r25
 1670 078c 8B83      		std Y+3,r24
 1671               	.L47:
 694:ServerLLDN.c  **** 						if( !check_ack(i+1) )
 1672               		.loc 6 694 0 is_stmt 0 discriminator 1
 1673 078e 8091 0000 		lds r24,assTimeSlot
 1674 0792 282F      		mov r18,r24
 1675 0794 30E0      		ldi r19,0
 1676 0796 8B81      		ldd r24,Y+3
 1677 0798 9C81      		ldd r25,Y+4
 1678 079a 8217      		cp r24,r18
 1679 079c 9307      		cpc r25,r19
 1680 079e 04F4      		brge .L49
 694:ServerLLDN.c  **** 						if( !check_ack(i+1) )
 1681               		.loc 6 694 0 discriminator 3
 1682 07a0 8091 0000 		lds r24,rec_beacon+7
 1683 07a4 882F      		mov r24,r24
 1684 07a6 90E0      		ldi r25,0
 1685 07a8 0397      		sbiw r24,3
 1686 07aa 9923      		tst r25
 1687 07ac 04F4      		brge .L50
 1688 07ae 0196      		adiw r24,1
 1689               	.L50:
 1690 07b0 9595      		asr r25
 1691 07b2 8795      		ror r24
 1692 07b4 9C01      		movw r18,r24
 1693 07b6 8B81      		ldd r24,Y+3
 1694 07b8 9C81      		ldd r25,Y+4
 1695 07ba 8217      		cp r24,r18
 1696 07bc 9307      		cpc r25,r19
 1697 07be 04F0      		brlt .L51
 1698               	.L49:
 1699               	.LBE3:
 697:ServerLLDN.c  **** 					
 698:ServerLLDN.c  **** 					
 699:ServerLLDN.c  **** // 					if( retransmition_slot > (rec_beacon.NumberOfBaseTimeslotsinSuperframe - 3)/2 - 1)
 700:ServerLLDN.c  **** // 						return false;
 701:ServerLLDN.c  **** 										
 702:ServerLLDN.c  **** 					
 703:ServerLLDN.c  **** 					if(retransmition_slot == 0)
 1700               		.loc 6 703 0 is_stmt 1
 1701 07c0 8981      		ldd r24,Y+1
 1702 07c2 9A81      		ldd r25,Y+2
 1703 07c4 892B      		or r24,r25
 1704 07c6 01F4      		brne .L52
 704:ServerLLDN.c  **** 					{
 705:ServerLLDN.c  **** 						NWK_DataReq(&msgReqData);
 1705               		.loc 6 705 0
 1706 07c8 80E0      		ldi r24,lo8(msgReqData)
 1707 07ca 90E0      		ldi r25,hi8(msgReqData)
 1708 07cc 0E94 0000 		call NWK_DataReq
 1709 07d0 00C0      		rjmp .L53
 1710               	.L52:
 706:ServerLLDN.c  **** 					}
 707:ServerLLDN.c  **** 					else
 708:ServerLLDN.c  **** 					{
 709:ServerLLDN.c  **** 						#if MASTER_MACSC
 710:ServerLLDN.c  **** 						macsc_enable_manual_bts();
 1711               		.loc 6 710 0
 1712 07d2 0E94 0000 		call macsc_enable_manual_bts
 711:ServerLLDN.c  **** 						macsc_set_cmp1_int_cb(online_time_hndlr);
 1713               		.loc 6 711 0
 1714 07d6 80E0      		ldi r24,lo8(gs(online_time_hndlr))
 1715 07d8 90E0      		ldi r25,hi8(gs(online_time_hndlr))
 1716 07da 0E94 0000 		call macsc_set_cmp1_int_cb
 712:ServerLLDN.c  **** 						macsc_enable_cmp_int(MACSC_CC1);
 1717               		.loc 6 712 0
 1718 07de 81E0      		ldi r24,lo8(1)
 1719 07e0 0E94 0000 		call macsc_enable_cmp_int
 713:ServerLLDN.c  **** 						macsc_use_cmp(MACSC_RELATIVE_CMP, tTS * retransmition_slot - 40, MACSC_CC1);
 1720               		.loc 6 713 0
 1721 07e4 8981      		ldd r24,Y+1
 1722 07e6 9A81      		ldd r25,Y+2
 1723 07e8 092E      		mov __tmp_reg__,r25
 1724 07ea 000C      		lsl r0
 1725 07ec AA0B      		sbc r26,r26
 1726 07ee BB0B      		sbc r27,r27
 1727 07f0 BC01      		movw r22,r24
 1728 07f2 CD01      		movw r24,r26
 1729 07f4 0E94 0000 		call __floatsisf
 1730 07f8 7B01      		movw r14,r22
 1731 07fa 8C01      		movw r16,r24
 1732 07fc 8091 0000 		lds r24,tTS
 1733 0800 9091 0000 		lds r25,tTS+1
 1734 0804 A091 0000 		lds r26,tTS+2
 1735 0808 B091 0000 		lds r27,tTS+3
 1736 080c 9C01      		movw r18,r24
 1737 080e AD01      		movw r20,r26
 1738 0810 C801      		movw r24,r16
 1739 0812 B701      		movw r22,r14
 1740 0814 0E94 0000 		call __mulsf3
 1741 0818 DC01      		movw r26,r24
 1742 081a CB01      		movw r24,r22
 1743 081c 20E0      		ldi r18,0
 1744 081e 30E0      		ldi r19,0
 1745 0820 40E2      		ldi r20,lo8(32)
 1746 0822 52E4      		ldi r21,lo8(66)
 1747 0824 BC01      		movw r22,r24
 1748 0826 CD01      		movw r24,r26
 1749 0828 0E94 0000 		call __subsf3
 1750 082c DC01      		movw r26,r24
 1751 082e CB01      		movw r24,r22
 1752 0830 BC01      		movw r22,r24
 1753 0832 CD01      		movw r24,r26
 1754 0834 0E94 0000 		call __fixunssfsi
 1755 0838 DC01      		movw r26,r24
 1756 083a CB01      		movw r24,r22
 1757 083c 21E0      		ldi r18,lo8(1)
 1758 083e AC01      		movw r20,r24
 1759 0840 BD01      		movw r22,r26
 1760 0842 81E0      		ldi r24,lo8(1)
 1761 0844 0E94 0000 		call macsc_use_cmp
 1762               	.L53:
 714:ServerLLDN.c  **** 						#endif
 715:ServerLLDN.c  **** 					}					
 716:ServerLLDN.c  **** 					printf("\nretransmition_slot %d , %f", retransmition_slot, tTS);
 1763               		.loc 6 716 0
 1764 0848 8091 0000 		lds r24,tTS
 1765 084c 9091 0000 		lds r25,tTS+1
 1766 0850 A091 0000 		lds r26,tTS+2
 1767 0854 B091 0000 		lds r27,tTS+3
 1768 0858 2B2F      		mov r18,r27
 1769 085a 2F93      		push r18
 1770 085c 2A2F      		mov r18,r26
 1771 085e 2F93      		push r18
 1772 0860 292F      		mov r18,r25
 1773 0862 2F93      		push r18
 1774 0864 8F93      		push r24
 1775 0866 8A81      		ldd r24,Y+2
 1776 0868 8F93      		push r24
 1777 086a 8981      		ldd r24,Y+1
 1778 086c 8F93      		push r24
 1779 086e 80E0      		ldi r24,lo8(.LC6)
 1780 0870 90E0      		ldi r25,hi8(.LC6)
 1781 0872 892F      		mov r24,r25
 1782 0874 8F93      		push r24
 1783 0876 80E0      		ldi r24,lo8(.LC6)
 1784 0878 90E0      		ldi r25,hi8(.LC6)
 1785 087a 8F93      		push r24
 1786 087c 0E94 0000 		call printf
 1787 0880 8DB7      		in r24,__SP_L__
 1788 0882 9EB7      		in r25,__SP_H__
 1789 0884 0896      		adiw r24,8
 1790 0886 0FB6      		in __tmp_reg__,__SREG__
 1791 0888 F894      		cli
 1792 088a DEBF      		out __SP_H__,r29
 1793 088c 0FBE      		out __SREG__,__tmp_reg__
 1794 088e CDBF      		out __SP_L__,r28
 1795 0890 00C0      		rjmp .L44
 1796               	.L45:
 1797               	.LBE2:
 717:ServerLLDN.c  **** 
 718:ServerLLDN.c  **** 				}				
 719:ServerLLDN.c  **** 			}
 720:ServerLLDN.c  **** 			else
 721:ServerLLDN.c  **** 			{
 722:ServerLLDN.c  **** 				ack_received = check_ack(APP_ADDR);								
 1798               		.loc 6 722 0
 1799 0892 83E0      		ldi r24,lo8(3)
 1800 0894 90E0      		ldi r25,0
 1801 0896 0E94 0000 		call check_ack
 1802 089a 8093 0000 		sts ack_received,r24
 723:ServerLLDN.c  **** 				if(STATE == DISC_MODE && ack_received)
 1803               		.loc 6 723 0
 1804 089e 8091 0000 		lds r24,STATE
 1805 08a2 8430      		cpi r24,lo8(4)
 1806 08a4 01F4      		brne .L44
 1807               		.loc 6 723 0 is_stmt 0 discriminator 1
 1808 08a6 8091 0000 		lds r24,ack_received
 1809 08aa 8823      		tst r24
 1810 08ac 01F0      		breq .L44
 724:ServerLLDN.c  **** 				{
 725:ServerLLDN.c  **** 					printf("\nOK on conf");
 1811               		.loc 6 725 0 is_stmt 1
 1812 08ae 80E0      		ldi r24,lo8(.LC7)
 1813 08b0 90E0      		ldi r25,hi8(.LC7)
 1814 08b2 892F      		mov r24,r25
 1815 08b4 8F93      		push r24
 1816 08b6 80E0      		ldi r24,lo8(.LC7)
 1817 08b8 90E0      		ldi r25,hi8(.LC7)
 1818 08ba 8F93      		push r24
 1819 08bc 0E94 0000 		call printf
 1820 08c0 0F90      		pop __tmp_reg__
 1821 08c2 0F90      		pop __tmp_reg__
 726:ServerLLDN.c  **** 					STATE = CONFIG_MODE;
 1822               		.loc 6 726 0
 1823 08c4 86E0      		ldi r24,lo8(6)
 1824 08c6 8093 0000 		sts STATE,r24
 1825               	.L44:
 727:ServerLLDN.c  **** 				}
 728:ServerLLDN.c  **** 			}
 729:ServerLLDN.c  **** 		}
 730:ServerLLDN.c  **** 		return true;
 1826               		.loc 6 730 0
 1827 08ca 81E0      		ldi r24,lo8(1)
 1828               	/* epilogue start */
 731:ServerLLDN.c  **** 	}
 1829               		.loc 6 731 0
 1830 08cc 2696      		adiw r28,6
 1831 08ce 0FB6      		in __tmp_reg__,__SREG__
 1832 08d0 F894      		cli
 1833 08d2 DEBF      		out __SP_H__,r29
 1834 08d4 0FBE      		out __SREG__,__tmp_reg__
 1835 08d6 CDBF      		out __SP_L__,r28
 1836 08d8 DF91      		pop r29
 1837 08da CF91      		pop r28
 1838 08dc 1F91      		pop r17
 1839 08de 0F91      		pop r16
 1840 08e0 FF90      		pop r15
 1841 08e2 EF90      		pop r14
 1842 08e4 0895      		ret
 1843               		.cfi_endproc
 1844               	.LFE138:
 1846               		.section	.rodata
 1847               	.LC8:
 1848 005b 0A20 436F 		.string	"\n Command ind"
 1848      6D6D 616E 
 1848      6420 696E 
 1848      6400 
 1849               	.LC9:
 1850 0069 0A20 6173 		.string	"\n asstimeslot %d, tsDuration %hhx"
 1850      7374 696D 
 1850      6573 6C6F 
 1850      7420 2564 
 1850      2C20 7473 
 1851               		.text
 1853               	appCommandInd:
 1854               	.LFB139:
 732:ServerLLDN.c  **** 	
 733:ServerLLDN.c  **** 	static bool appCommandInd(NWK_DataInd_t *ind)
 734:ServerLLDN.c  **** 	{
 1855               		.loc 6 734 0
 1856               		.cfi_startproc
 1857 08e6 CF93      		push r28
 1858               	.LCFI74:
 1859               		.cfi_def_cfa_offset 3
 1860               		.cfi_offset 28, -2
 1861 08e8 DF93      		push r29
 1862               	.LCFI75:
 1863               		.cfi_def_cfa_offset 4
 1864               		.cfi_offset 29, -3
 1865 08ea 00D0      		rcall .
 1866 08ec 00D0      		rcall .
 1867               	.LCFI76:
 1868               		.cfi_def_cfa_offset 8
 1869 08ee CDB7      		in r28,__SP_L__
 1870 08f0 DEB7      		in r29,__SP_H__
 1871               	.LCFI77:
 1872               		.cfi_def_cfa_register 28
 1873               	/* prologue: function */
 1874               	/* frame size = 4 */
 1875               	/* stack size = 6 */
 1876               	.L__stack_usage = 6
 1877 08f2 9C83      		std Y+4,r25
 1878 08f4 8B83      		std Y+3,r24
 735:ServerLLDN.c  **** 		printf("\n Command ind");
 1879               		.loc 6 735 0
 1880 08f6 80E0      		ldi r24,lo8(.LC8)
 1881 08f8 90E0      		ldi r25,hi8(.LC8)
 1882 08fa 892F      		mov r24,r25
 1883 08fc 8F93      		push r24
 1884 08fe 80E0      		ldi r24,lo8(.LC8)
 1885 0900 90E0      		ldi r25,hi8(.LC8)
 1886 0902 8F93      		push r24
 1887 0904 0E94 0000 		call printf
 1888 0908 0F90      		pop __tmp_reg__
 1889 090a 0F90      		pop __tmp_reg__
 736:ServerLLDN.c  **** 		if(ind->data[0] == LL_CONFIGURATION_REQUEST)
 1890               		.loc 6 736 0
 1891 090c 8B81      		ldd r24,Y+3
 1892 090e 9C81      		ldd r25,Y+4
 1893 0910 FC01      		movw r30,r24
 1894 0912 8085      		ldd r24,Z+8
 1895 0914 9185      		ldd r25,Z+9
 1896 0916 FC01      		movw r30,r24
 1897 0918 8081      		ld r24,Z
 1898 091a 8F30      		cpi r24,lo8(15)
 1899 091c 01F0      		breq .+2
 1900 091e 00C0      		rjmp .L56
 1901               	.LBB4:
 737:ServerLLDN.c  **** 		{
 738:ServerLLDN.c  **** 			NWK_ConfigRequest_t *msg = (NWK_ConfigRequest_t*)ind->data;
 1902               		.loc 6 738 0
 1903 0920 8B81      		ldd r24,Y+3
 1904 0922 9C81      		ldd r25,Y+4
 1905 0924 FC01      		movw r30,r24
 1906 0926 8085      		ldd r24,Z+8
 1907 0928 9185      		ldd r25,Z+9
 1908 092a 9A83      		std Y+2,r25
 1909 092c 8983      		std Y+1,r24
 739:ServerLLDN.c  **** 			if(msg->macAddr == APP_ADDR)
 1910               		.loc 6 739 0
 1911 092e 8981      		ldd r24,Y+1
 1912 0930 9A81      		ldd r25,Y+2
 1913 0932 FC01      		movw r30,r24
 1914 0934 8481      		ldd r24,Z+4
 1915 0936 8330      		cpi r24,lo8(3)
 1916 0938 01F0      		breq .+2
 1917 093a 00C0      		rjmp .L56
 740:ServerLLDN.c  **** 			{
 741:ServerLLDN.c  **** 				PHY_SetChannel(msg->tx_channel);
 1918               		.loc 6 741 0
 1919 093c 8981      		ldd r24,Y+1
 1920 093e 9A81      		ldd r25,Y+2
 1921 0940 FC01      		movw r30,r24
 1922 0942 8281      		ldd r24,Z+2
 1923 0944 0E94 0000 		call PHY_SetChannel
 742:ServerLLDN.c  **** 				NWK_SetPanId(msg->s_macAddr);
 1924               		.loc 6 742 0
 1925 0948 8981      		ldd r24,Y+1
 1926 094a 9A81      		ldd r25,Y+2
 1927 094c FC01      		movw r30,r24
 1928 094e 8181      		ldd r24,Z+1
 1929 0950 882F      		mov r24,r24
 1930 0952 90E0      		ldi r25,0
 1931 0954 0E94 0000 		call NWK_SetPanId
 743:ServerLLDN.c  **** 				PanId = msg->s_macAddr;
 1932               		.loc 6 743 0
 1933 0958 8981      		ldd r24,Y+1
 1934 095a 9A81      		ldd r25,Y+2
 1935 095c FC01      		movw r30,r24
 1936 095e 8181      		ldd r24,Z+1
 1937 0960 8093 0000 		sts PanId,r24
 744:ServerLLDN.c  **** 				assTimeSlot = msg->assTimeSlot;
 1938               		.loc 6 744 0
 1939 0964 8981      		ldd r24,Y+1
 1940 0966 9A81      		ldd r25,Y+2
 1941 0968 FC01      		movw r30,r24
 1942 096a 8381      		ldd r24,Z+3
 1943 096c 8093 0000 		sts assTimeSlot,r24
 745:ServerLLDN.c  **** 				n = msg->conf.tsDuration;
 1944               		.loc 6 745 0
 1945 0970 8981      		ldd r24,Y+1
 1946 0972 9A81      		ldd r25,Y+2
 1947 0974 FC01      		movw r30,r24
 1948 0976 8581      		ldd r24,Z+5
 1949 0978 8F77      		andi r24,lo8(127)
 1950 097a 8093 0000 		sts n,r24
 746:ServerLLDN.c  **** 				associated = 1;
 1951               		.loc 6 746 0
 1952 097e 81E0      		ldi r24,lo8(1)
 1953 0980 8093 0000 		sts associated,r24
 747:ServerLLDN.c  **** 				STATE = ONLINE_MODE;
 1954               		.loc 6 747 0
 1955 0984 1092 0000 		sts STATE,__zero_reg__
 748:ServerLLDN.c  **** 				PHY_SetTdmaMode(true);
 1956               		.loc 6 748 0
 1957 0988 81E0      		ldi r24,lo8(1)
 1958 098a 0E94 0000 		call PHY_SetTdmaMode
 749:ServerLLDN.c  **** 				printf("\n asstimeslot %d, tsDuration %hhx", assTimeSlot, n);
 1959               		.loc 6 749 0
 1960 098e 8091 0000 		lds r24,n
 1961 0992 282F      		mov r18,r24
 1962 0994 30E0      		ldi r19,0
 1963 0996 8091 0000 		lds r24,assTimeSlot
 1964 099a 882F      		mov r24,r24
 1965 099c 90E0      		ldi r25,0
 1966 099e 432F      		mov r20,r19
 1967 09a0 4F93      		push r20
 1968 09a2 2F93      		push r18
 1969 09a4 292F      		mov r18,r25
 1970 09a6 2F93      		push r18
 1971 09a8 8F93      		push r24
 1972 09aa 80E0      		ldi r24,lo8(.LC9)
 1973 09ac 90E0      		ldi r25,hi8(.LC9)
 1974 09ae 892F      		mov r24,r25
 1975 09b0 8F93      		push r24
 1976 09b2 80E0      		ldi r24,lo8(.LC9)
 1977 09b4 90E0      		ldi r25,hi8(.LC9)
 1978 09b6 8F93      		push r24
 1979 09b8 0E94 0000 		call printf
 1980 09bc 0F90      		pop __tmp_reg__
 1981 09be 0F90      		pop __tmp_reg__
 1982 09c0 0F90      		pop __tmp_reg__
 1983 09c2 0F90      		pop __tmp_reg__
 1984 09c4 0F90      		pop __tmp_reg__
 1985 09c6 0F90      		pop __tmp_reg__
 1986               	.L56:
 1987               	.LBE4:
 750:ServerLLDN.c  **** 			}
 751:ServerLLDN.c  **** 		}
 752:ServerLLDN.c  **** 		return true;
 1988               		.loc 6 752 0
 1989 09c8 81E0      		ldi r24,lo8(1)
 1990               	/* epilogue start */
 753:ServerLLDN.c  **** 	}
 1991               		.loc 6 753 0
 1992 09ca 0F90      		pop __tmp_reg__
 1993 09cc 0F90      		pop __tmp_reg__
 1994 09ce 0F90      		pop __tmp_reg__
 1995 09d0 0F90      		pop __tmp_reg__
 1996 09d2 DF91      		pop r29
 1997 09d4 CF91      		pop r28
 1998 09d6 0895      		ret
 1999               		.cfi_endproc
 2000               	.LFE139:
 2002               	.global	appPrepareDiscoverResponse
 2004               	appPrepareDiscoverResponse:
 2005               	.LFB140:
 754:ServerLLDN.c  **** 
 755:ServerLLDN.c  **** 	void appPrepareDiscoverResponse()
 756:ServerLLDN.c  **** 	{
 2006               		.loc 6 756 0
 2007               		.cfi_startproc
 2008 09d8 CF93      		push r28
 2009               	.LCFI78:
 2010               		.cfi_def_cfa_offset 3
 2011               		.cfi_offset 28, -2
 2012 09da DF93      		push r29
 2013               	.LCFI79:
 2014               		.cfi_def_cfa_offset 4
 2015               		.cfi_offset 29, -3
 2016 09dc CDB7      		in r28,__SP_L__
 2017 09de DEB7      		in r29,__SP_H__
 2018               	.LCFI80:
 2019               		.cfi_def_cfa_register 28
 2020               	/* prologue: function */
 2021               	/* frame size = 0 */
 2022               	/* stack size = 2 */
 2023               	.L__stack_usage = 2
 757:ServerLLDN.c  **** 		msgReq.dstAddr				= 0;
 2024               		.loc 6 757 0
 2025 09e0 1092 0000 		sts msgReq+5+1,__zero_reg__
 2026 09e4 1092 0000 		sts msgReq+5,__zero_reg__
 758:ServerLLDN.c  **** 		msgReq.dstEndpoint			= APP_COMMAND_ENDPOINT;
 2027               		.loc 6 758 0
 2028 09e8 83E0      		ldi r24,lo8(3)
 2029 09ea 8093 0000 		sts msgReq+7,r24
 759:ServerLLDN.c  **** 		msgReq.srcEndpoint			= APP_COMMAND_ENDPOINT;
 2030               		.loc 6 759 0
 2031 09ee 83E0      		ldi r24,lo8(3)
 2032 09f0 8093 0000 		sts msgReq+8,r24
 760:ServerLLDN.c  **** 		msgReq.options				= NWK_OPT_MAC_COMMAND;
 2033               		.loc 6 760 0
 2034 09f4 80E0      		ldi r24,0
 2035 09f6 90E8      		ldi r25,lo8(-128)
 2036 09f8 9093 0000 		sts msgReq+9+1,r25
 2037 09fc 8093 0000 		sts msgReq+9,r24
 761:ServerLLDN.c  **** 		msgReq.data					= (uint8_t*)&msgDiscResponse;
 2038               		.loc 6 761 0
 2039 0a00 80E0      		ldi r24,lo8(msgDiscResponse)
 2040 0a02 90E0      		ldi r25,hi8(msgDiscResponse)
 2041 0a04 9093 0000 		sts msgReq+13+1,r25
 2042 0a08 8093 0000 		sts msgReq+13,r24
 762:ServerLLDN.c  **** 		msgReq.size					= sizeof(msgDiscResponse);
 2043               		.loc 6 762 0
 2044 0a0c 83E0      		ldi r24,lo8(3)
 2045 0a0e 8093 0000 		sts msgReq+15,r24
 763:ServerLLDN.c  **** 	}
 2046               		.loc 6 763 0
 2047 0a12 0000      		nop
 2048               	/* epilogue start */
 2049 0a14 DF91      		pop r29
 2050 0a16 CF91      		pop r28
 2051 0a18 0895      		ret
 2052               		.cfi_endproc
 2053               	.LFE140:
 2055               	.global	appPrepareConfigurationStatus
 2057               	appPrepareConfigurationStatus:
 2058               	.LFB141:
 764:ServerLLDN.c  **** 	
 765:ServerLLDN.c  **** 	void appPrepareConfigurationStatus()
 766:ServerLLDN.c  **** 	{		
 2059               		.loc 6 766 0
 2060               		.cfi_startproc
 2061 0a1a CF93      		push r28
 2062               	.LCFI81:
 2063               		.cfi_def_cfa_offset 3
 2064               		.cfi_offset 28, -2
 2065 0a1c DF93      		push r29
 2066               	.LCFI82:
 2067               		.cfi_def_cfa_offset 4
 2068               		.cfi_offset 29, -3
 2069 0a1e CDB7      		in r28,__SP_L__
 2070 0a20 DEB7      		in r29,__SP_H__
 2071               	.LCFI83:
 2072               		.cfi_def_cfa_register 28
 2073               	/* prologue: function */
 2074               	/* frame size = 0 */
 2075               	/* stack size = 2 */
 2076               	.L__stack_usage = 2
 767:ServerLLDN.c  **** 		msgReq.dstAddr				= 0;
 2077               		.loc 6 767 0
 2078 0a22 1092 0000 		sts msgReq+5+1,__zero_reg__
 2079 0a26 1092 0000 		sts msgReq+5,__zero_reg__
 768:ServerLLDN.c  **** 		msgReq.dstEndpoint			= APP_COMMAND_ENDPOINT;
 2080               		.loc 6 768 0
 2081 0a2a 83E0      		ldi r24,lo8(3)
 2082 0a2c 8093 0000 		sts msgReq+7,r24
 769:ServerLLDN.c  **** 		msgReq.srcEndpoint			= APP_COMMAND_ENDPOINT;
 2083               		.loc 6 769 0
 2084 0a30 83E0      		ldi r24,lo8(3)
 2085 0a32 8093 0000 		sts msgReq+8,r24
 770:ServerLLDN.c  **** 		msgReq.options				= NWK_OPT_MAC_COMMAND;
 2086               		.loc 6 770 0
 2087 0a36 80E0      		ldi r24,0
 2088 0a38 90E8      		ldi r25,lo8(-128)
 2089 0a3a 9093 0000 		sts msgReq+9+1,r25
 2090 0a3e 8093 0000 		sts msgReq+9,r24
 771:ServerLLDN.c  **** 		msgReq.data					= (uint8_t*)&msgConfigStatus;
 2091               		.loc 6 771 0
 2092 0a42 80E0      		ldi r24,lo8(msgConfigStatus)
 2093 0a44 90E0      		ldi r25,hi8(msgConfigStatus)
 2094 0a46 9093 0000 		sts msgReq+13+1,r25
 2095 0a4a 8093 0000 		sts msgReq+13,r24
 772:ServerLLDN.c  **** 		msgReq.size					= sizeof(msgConfigStatus);
 2096               		.loc 6 772 0
 2097 0a4e 85E0      		ldi r24,lo8(5)
 2098 0a50 8093 0000 		sts msgReq+15,r24
 773:ServerLLDN.c  **** 	}
 2099               		.loc 6 773 0
 2100 0a54 0000      		nop
 2101               	/* epilogue start */
 2102 0a56 DF91      		pop r29
 2103 0a58 CF91      		pop r28
 2104 0a5a 0895      		ret
 2105               		.cfi_endproc
 2106               	.LFE141:
 2108               	.global	appPrepareDataFrame
 2110               	appPrepareDataFrame:
 2111               	.LFB142:
 774:ServerLLDN.c  **** 	
 775:ServerLLDN.c  **** 	void appPrepareDataFrame(void)
 776:ServerLLDN.c  **** 	{
 2112               		.loc 6 776 0
 2113               		.cfi_startproc
 2114 0a5c CF93      		push r28
 2115               	.LCFI84:
 2116               		.cfi_def_cfa_offset 3
 2117               		.cfi_offset 28, -2
 2118 0a5e DF93      		push r29
 2119               	.LCFI85:
 2120               		.cfi_def_cfa_offset 4
 2121               		.cfi_offset 29, -3
 2122 0a60 CDB7      		in r28,__SP_L__
 2123 0a62 DEB7      		in r29,__SP_H__
 2124               	.LCFI86:
 2125               		.cfi_def_cfa_register 28
 2126               	/* prologue: function */
 2127               	/* frame size = 0 */
 2128               	/* stack size = 2 */
 2129               	.L__stack_usage = 2
 777:ServerLLDN.c  **** 		
 778:ServerLLDN.c  **** 		PHY_SetTdmaMode(true);
 2130               		.loc 6 778 0
 2131 0a64 81E0      		ldi r24,lo8(1)
 2132 0a66 0E94 0000 		call PHY_SetTdmaMode
 779:ServerLLDN.c  **** 
 780:ServerLLDN.c  **** 	
 781:ServerLLDN.c  **** 		msgReq.dstAddr				= 0;
 2133               		.loc 6 781 0
 2134 0a6a 1092 0000 		sts msgReq+5+1,__zero_reg__
 2135 0a6e 1092 0000 		sts msgReq+5,__zero_reg__
 782:ServerLLDN.c  **** 		msgReq.dstEndpoint			= APP_COMMAND_ENDPOINT;
 2136               		.loc 6 782 0
 2137 0a72 83E0      		ldi r24,lo8(3)
 2138 0a74 8093 0000 		sts msgReq+7,r24
 783:ServerLLDN.c  **** 		msgReq.srcEndpoint			= APP_COMMAND_ENDPOINT;
 2139               		.loc 6 783 0
 2140 0a78 83E0      		ldi r24,lo8(3)
 2141 0a7a 8093 0000 		sts msgReq+8,r24
 784:ServerLLDN.c  **** 		msgReq.options				= NWK_OPT_LLDN_DATA;
 2142               		.loc 6 784 0
 2143 0a7e 80E0      		ldi r24,0
 2144 0a80 90E2      		ldi r25,lo8(32)
 2145 0a82 9093 0000 		sts msgReq+9+1,r25
 2146 0a86 8093 0000 		sts msgReq+9,r24
 785:ServerLLDN.c  **** 		msgReq.data					= (uint8_t *)&data_payload;
 2147               		.loc 6 785 0
 2148 0a8a 80E0      		ldi r24,lo8(data_payload)
 2149 0a8c 90E0      		ldi r25,hi8(data_payload)
 2150 0a8e 9093 0000 		sts msgReq+13+1,r25
 2151 0a92 8093 0000 		sts msgReq+13,r24
 786:ServerLLDN.c  **** 		msgReq.size					= sizeof(data_payload);
 2152               		.loc 6 786 0
 2153 0a96 81E0      		ldi r24,lo8(1)
 2154 0a98 8093 0000 		sts msgReq+15,r24
 787:ServerLLDN.c  **** 	}
 2155               		.loc 6 787 0
 2156 0a9c 0000      		nop
 2157               	/* epilogue start */
 2158 0a9e DF91      		pop r29
 2159 0aa0 CF91      		pop r28
 2160 0aa2 0895      		ret
 2161               		.cfi_endproc
 2162               	.LFE142:
 2165               	appInit:
 2166               	.LFB143:
 788:ServerLLDN.c  **** 	
 789:ServerLLDN.c  **** 	
 790:ServerLLDN.c  **** #endif // APP_COORDINATOR
 791:ServerLLDN.c  **** 
 792:ServerLLDN.c  **** static void appInit(void)
 793:ServerLLDN.c  **** {
 2167               		.loc 6 793 0
 2168               		.cfi_startproc
 2169 0aa4 CF93      		push r28
 2170               	.LCFI87:
 2171               		.cfi_def_cfa_offset 3
 2172               		.cfi_offset 28, -2
 2173 0aa6 DF93      		push r29
 2174               	.LCFI88:
 2175               		.cfi_def_cfa_offset 4
 2176               		.cfi_offset 29, -3
 2177 0aa8 CDB7      		in r28,__SP_L__
 2178 0aaa DEB7      		in r29,__SP_H__
 2179               	.LCFI89:
 2180               		.cfi_def_cfa_register 28
 2181               	/* prologue: function */
 2182               	/* frame size = 0 */
 2183               	/* stack size = 2 */
 2184               	.L__stack_usage = 2
 794:ServerLLDN.c  **** 	NWK_SetAddr(APP_ADDR);
 2185               		.loc 6 794 0
 2186 0aac 83E0      		ldi r24,lo8(3)
 2187 0aae 90E0      		ldi r25,0
 2188 0ab0 0E94 0000 		call NWK_SetAddr
 795:ServerLLDN.c  **** 	PHY_SetChannel(APP_CHANNEL);
 2189               		.loc 6 795 0
 2190 0ab4 8FE0      		ldi r24,lo8(15)
 2191 0ab6 0E94 0000 		call PHY_SetChannel
 796:ServerLLDN.c  **** 	PHY_SetRxState(true);
 2192               		.loc 6 796 0
 2193 0aba 81E0      		ldi r24,lo8(1)
 2194 0abc 0E94 0000 		call PHY_SetRxState
 797:ServerLLDN.c  **** 		
 798:ServerLLDN.c  **** 	#if APP_COORDINATOR	 
 799:ServerLLDN.c  **** 		/* Timer used for delay between messages */
 800:ServerLLDN.c  **** 		tmrDelay.interval = 1;
 801:ServerLLDN.c  **** 		tmrDelay.mode = SYS_TIMER_INTERVAL_MODE;
 802:ServerLLDN.c  **** 		tmrDelay.handler = tmrDelayHandler;
 803:ServerLLDN.c  **** 	  
 804:ServerLLDN.c  **** 		/* 
 805:ServerLLDN.c  **** 		* Disable CSMA/CA
 806:ServerLLDN.c  **** 		* Disable auto ACK
 807:ServerLLDN.c  **** 		*/
 808:ServerLLDN.c  **** 		NWK_SetPanId(APP_PANID);
 809:ServerLLDN.c  **** 		PanId = APP_PANID;
 810:ServerLLDN.c  **** 		ACKFrame.sourceId = APP_PANID;
 811:ServerLLDN.c  **** 		PHY_SetTdmaMode(true);
 812:ServerLLDN.c  **** 	NWK_OpenEndpoint(APP_COMMAND_ENDPOINT, appCommandInd);
 813:ServerLLDN.c  **** 	#else
 814:ServerLLDN.c  **** 		appPrepareDiscoverResponse();	
 2195               		.loc 6 814 0
 2196 0ac0 0E94 0000 		call appPrepareDiscoverResponse
 815:ServerLLDN.c  **** 		/*
 816:ServerLLDN.c  **** 		 * Enable CSMA/CA
 817:ServerLLDN.c  **** 		 * Enable Random CSMA seed generator
 818:ServerLLDN.c  **** 		 */
 819:ServerLLDN.c  **** 		PHY_SetTdmaMode(false);
 2197               		.loc 6 819 0
 2198 0ac4 80E0      		ldi r24,0
 2199 0ac6 0E94 0000 		call PHY_SetTdmaMode
 820:ServerLLDN.c  **** 		PHY_SetOptimizedCSMAValues();
 2200               		.loc 6 820 0
 2201 0aca 0E94 0000 		call PHY_SetOptimizedCSMAValues
 821:ServerLLDN.c  **** 		
 822:ServerLLDN.c  **** 		
 823:ServerLLDN.c  **** 		
 824:ServerLLDN.c  **** 		payloadSize = 127;
 2202               		.loc 6 824 0
 2203 0ace 8FE7      		ldi r24,lo8(127)
 2204 0ad0 8093 0000 		sts payloadSize,r24
 825:ServerLLDN.c  **** 		NWK_OpenEndpoint(APP_BEACON_ENDPOINT, appBeaconInd);
 2205               		.loc 6 825 0
 2206 0ad4 60E0      		ldi r22,lo8(gs(appBeaconInd))
 2207 0ad6 70E0      		ldi r23,hi8(gs(appBeaconInd))
 2208 0ad8 80E0      		ldi r24,0
 2209 0ada 0E94 0000 		call NWK_OpenEndpoint
 826:ServerLLDN.c  **** 		NWK_OpenEndpoint(APP_ACK_ENDPOINT, appAckInd);
 2210               		.loc 6 826 0
 2211 0ade 60E0      		ldi r22,lo8(gs(appAckInd))
 2212 0ae0 70E0      		ldi r23,hi8(gs(appAckInd))
 2213 0ae2 84E0      		ldi r24,lo8(4)
 2214 0ae4 0E94 0000 		call NWK_OpenEndpoint
 827:ServerLLDN.c  **** 		NWK_OpenEndpoint(APP_COMMAND_ENDPOINT, appCommandInd);
 2215               		.loc 6 827 0
 2216 0ae8 60E0      		ldi r22,lo8(gs(appCommandInd))
 2217 0aea 70E0      		ldi r23,hi8(gs(appCommandInd))
 2218 0aec 83E0      		ldi r24,lo8(3)
 2219 0aee 0E94 0000 		call NWK_OpenEndpoint
 828:ServerLLDN.c  **** 		/*
 829:ServerLLDN.c  **** 		* Configure interrupts callback functions
 830:ServerLLDN.c  **** 		*/
 831:ServerLLDN.c  **** 		
 832:ServerLLDN.c  **** 	#endif // APP_COORDENATOR
 833:ServerLLDN.c  **** 	PHY_SetPromiscuousMode(true);
 2220               		.loc 6 833 0
 2221 0af2 81E0      		ldi r24,lo8(1)
 2222 0af4 0E94 0000 		call PHY_SetPromiscuousMode
 834:ServerLLDN.c  **** 
 835:ServerLLDN.c  **** }
 2223               		.loc 6 835 0
 2224 0af8 0000      		nop
 2225               	/* epilogue start */
 2226 0afa DF91      		pop r29
 2227 0afc CF91      		pop r28
 2228 0afe 0895      		ret
 2229               		.cfi_endproc
 2230               	.LFE143:
 2232               		.section	.rodata
 2233               	.LC10:
 2234 008b 0A72 6574 		.string	"\nretransmition_slot %d"
 2234      7261 6E73 
 2234      6D69 7469 
 2234      6F6E 5F73 
 2234      6C6F 7420 
 2235               		.text
 2237               	APP_TaskHandler:
 2238               	.LFB144:
 836:ServerLLDN.c  **** 
 837:ServerLLDN.c  **** static void APP_TaskHandler(void)
 838:ServerLLDN.c  **** {
 2239               		.loc 6 838 0
 2240               		.cfi_startproc
 2241 0b00 CF93      		push r28
 2242               	.LCFI90:
 2243               		.cfi_def_cfa_offset 3
 2244               		.cfi_offset 28, -2
 2245 0b02 DF93      		push r29
 2246               	.LCFI91:
 2247               		.cfi_def_cfa_offset 4
 2248               		.cfi_offset 29, -3
 2249 0b04 00D0      		rcall .
 2250 0b06 00D0      		rcall .
 2251               	.LCFI92:
 2252               		.cfi_def_cfa_offset 8
 2253 0b08 CDB7      		in r28,__SP_L__
 2254 0b0a DEB7      		in r29,__SP_H__
 2255               	.LCFI93:
 2256               		.cfi_def_cfa_register 28
 2257               	/* prologue: function */
 2258               	/* frame size = 4 */
 2259               	/* stack size = 6 */
 2260               	.L__stack_usage = 6
 839:ServerLLDN.c  **** 	switch (appState){
 2261               		.loc 6 839 0
 2262 0b0c 8091 0000 		lds r24,appState
 2263 0b10 882F      		mov r24,r24
 2264 0b12 90E0      		ldi r25,0
 2265 0b14 8430      		cpi r24,4
 2266 0b16 9105      		cpc r25,__zero_reg__
 2267 0b18 01F0      		breq .L64
 2268 0b1a 8530      		cpi r24,5
 2269 0b1c 9105      		cpc r25,__zero_reg__
 2270 0b1e 04F4      		brge .L65
 2271 0b20 0097      		sbiw r24,0
 2272 0b22 01F0      		breq .L66
 2273 0b24 0297      		sbiw r24,2
 2274 0b26 01F0      		breq .L67
 840:ServerLLDN.c  **** 		case APP_STATE_INITIAL:
 841:ServerLLDN.c  **** 		{
 842:ServerLLDN.c  **** 			appInit();
 843:ServerLLDN.c  **** 			#if APP_COORDINATOR
 844:ServerLLDN.c  **** 				appState = APP_STATE_ATT_PAN_STATE;
 845:ServerLLDN.c  **** 			#else
 846:ServerLLDN.c  **** 				appState = APP_STATE_IDLE;
 847:ServerLLDN.c  **** 			#endif
 848:ServerLLDN.c  **** 			break;
 849:ServerLLDN.c  **** 		}
 850:ServerLLDN.c  **** 		case APP_STATE_SEND:
 851:ServerLLDN.c  **** 		{
 852:ServerLLDN.c  **** 			appSendData();
 853:ServerLLDN.c  **** 			#if APP_COORDINATOR
 854:ServerLLDN.c  **** 				/* Every time a message is send updates coordinator to prepare next message */
 855:ServerLLDN.c  **** 				appState = APP_STATE_ATT_PAN_STATE;
 856:ServerLLDN.c  **** 			#else
 857:ServerLLDN.c  **** 				appState = APP_STATE_IDLE;
 858:ServerLLDN.c  **** 			#endif
 859:ServerLLDN.c  **** 			break;
 860:ServerLLDN.c  **** 		}
 861:ServerLLDN.c  **** 		#if APP_COORDINATOR // COORDINATOR SPECIFIC STATE MACHINE
 862:ServerLLDN.c  **** 		case APP_STATE_ATT_PAN_STATE:
 863:ServerLLDN.c  **** 		{
 864:ServerLLDN.c  **** 			switch(appPanState)
 865:ServerLLDN.c  **** 			{
 866:ServerLLDN.c  **** 				/* Prepare beacon to desassociate all nodes */
 867:ServerLLDN.c  **** 				case APP_PAN_STATE_RESET:
 868:ServerLLDN.c  **** 				{
 869:ServerLLDN.c  **** 					appPanReset();
 870:ServerLLDN.c  **** 					appPanState = APP_PAN_STATE_DISC_INITIAL;
 871:ServerLLDN.c  **** 					appState	= APP_STATE_SEND;
 872:ServerLLDN.c  **** 					cycles_counter = 0;
 873:ServerLLDN.c  **** 					break;
 874:ServerLLDN.c  **** 				}
 875:ServerLLDN.c  **** 				/* Prepare first Beacon of Discovery */
 876:ServerLLDN.c  **** 				case APP_PAN_STATE_DISC_INITIAL:
 877:ServerLLDN.c  **** 				{
 878:ServerLLDN.c  **** 					/* if nodes associated is equal to expected number of associated nodes stop association proces
 879:ServerLLDN.c  **** 					 * this implementation was done as is to be used in tests, for real network functionality 
 880:ServerLLDN.c  **** 					 * the number of max association processes must be done through macLLDNdiscoveryModeTimeout
 881:ServerLLDN.c  **** 					 */
 882:ServerLLDN.c  **** 					if(counter_associados == NODOS_ASSOCIADOS_ESPERADOS || cycles_counter >= 4)
 883:ServerLLDN.c  **** 					{	
 884:ServerLLDN.c  **** 						printf("\n%d, %d", cycles_counter, counter_associados);
 885:ServerLLDN.c  **** 						counter_associados = 0;
 886:ServerLLDN.c  **** 						/* if all nodes expected where associated stop beacon generation interruptions */
 887:ServerLLDN.c  **** 						macsc_disable_cmp_int(MACSC_CC1);
 888:ServerLLDN.c  **** 						macsc_disable_cmp_int(MACSC_CC2);
 889:ServerLLDN.c  **** 						msgReq.options = 0;
 890:ServerLLDN.c  **** 						
 891:ServerLLDN.c  **** 						/* reseting ack bitmap */
 892:ServerLLDN.c  **** 						for(int i = 0; i < 32; i++)
 893:ServerLLDN.c  **** 						ACKFrame.ackFlags[i] = 0;
 894:ServerLLDN.c  **** 						ACKFrame_size = 0;
 895:ServerLLDN.c  **** 						accepting_requests = 0;
 896:ServerLLDN.c  **** 						appState = APP_STATE_ATT_PAN_STATE;
 897:ServerLLDN.c  **** 						appPanState = APP_PAN_STATE_ONLINE_INITIAL; // APP_PAN_STATE_ONLINE_INIT
 898:ServerLLDN.c  **** 						cycles_counter = NUMERO_CICLOS_ONLINE;
 899:ServerLLDN.c  **** 					}
 900:ServerLLDN.c  **** 					/* if not all nodes expected where associated run through association process again */
 901:ServerLLDN.c  **** 					else 
 902:ServerLLDN.c  **** 					{
 903:ServerLLDN.c  **** 						/* prepare beacon message and start timers for beacon */
 904:ServerLLDN.c  **** 						appPanDiscInit();
 905:ServerLLDN.c  **** 						appState	= APP_STATE_IDLE;
 906:ServerLLDN.c  **** 						appPanState = APP_PAN_STATE_DISC_SECOND_BE;
 907:ServerLLDN.c  **** 					}
 908:ServerLLDN.c  **** 					break;
 909:ServerLLDN.c  **** 				}
 910:ServerLLDN.c  **** 				case APP_PAN_STATE_DISC_SECOND_BE:
 911:ServerLLDN.c  **** 				{
 912:ServerLLDN.c  **** 					/* Prepares message as: Discovery Beacon and Second Beacon */
 913:ServerLLDN.c  **** 					msgReq.options = NWK_OPT_LLDN_BEACON | NWK_OPT_DISCOVERY_STATE | NWK_OPT_SECOND_BEACON ;
 914:ServerLLDN.c  **** 					msgReq.data = NULL;
 915:ServerLLDN.c  **** 					msgReq.size = 0;
 916:ServerLLDN.c  **** 					
 917:ServerLLDN.c  **** 					appState	= APP_STATE_IDLE;
 918:ServerLLDN.c  **** 					appPanState = APP_PAN_STATE_DISC_PREPARE_ACK;
 919:ServerLLDN.c  **** 					break;
 920:ServerLLDN.c  **** 				}
 921:ServerLLDN.c  **** 				case APP_PAN_STATE_DISC_PREPARE_ACK:
 922:ServerLLDN.c  **** 				{
 923:ServerLLDN.c  **** 					/* This timer implements a delay between messages, 
 924:ServerLLDN.c  **** 					 * if not used the nodes are not able to receive the message
 925:ServerLLDN.c  **** 					 */
 926:ServerLLDN.c  **** 					appPanPrepareACK();
 927:ServerLLDN.c  **** 					appState = APP_STATE_SEND;
 928:ServerLLDN.c  **** 					// SYS_TimerStart(&tmrDelay);
 929:ServerLLDN.c  **** 					
 930:ServerLLDN.c  **** 					appPanState = APP_PAN_STATE_CONFIG_INITIAL;
 931:ServerLLDN.c  **** 					appState = APP_STATE_IDLE;
 932:ServerLLDN.c  **** 					break;
 933:ServerLLDN.c  **** 				}
 934:ServerLLDN.c  **** 				case APP_PAN_STATE_CONFIG_INITIAL:
 935:ServerLLDN.c  **** 				{
 936:ServerLLDN.c  **** 					/* Prepares the message as: Configuration Beacon and First State Beacon */
 937:ServerLLDN.c  **** 					msgReq.options = NWK_OPT_LLDN_BEACON | NWK_OPT_CONFIG_STATE;
 938:ServerLLDN.c  **** 					msgReq.data = NULL;
 939:ServerLLDN.c  **** 					msgReq.size = 0;
 940:ServerLLDN.c  **** 					
 941:ServerLLDN.c  **** 					appState	= APP_STATE_IDLE;
 942:ServerLLDN.c  **** 					appPanState = APP_PAN_STATE_CONFIG_SECOND_BEACON;
 943:ServerLLDN.c  **** 					break;
 944:ServerLLDN.c  **** 
 945:ServerLLDN.c  **** 				}
 946:ServerLLDN.c  **** 				case APP_PAN_STATE_CONFIG_SECOND_BEACON:
 947:ServerLLDN.c  **** 				{
 948:ServerLLDN.c  **** 					/* Prepares the message as: Configuration Beacon and Second State Beacon */
 949:ServerLLDN.c  **** 					msgReq.options = NWK_OPT_LLDN_BEACON | NWK_OPT_CONFIG_STATE | NWK_OPT_SECOND_BEACON;
 950:ServerLLDN.c  **** 					msgReq.data = NULL;
 951:ServerLLDN.c  **** 					msgReq.size = 0;
 952:ServerLLDN.c  **** 					
 953:ServerLLDN.c  **** 					counter_delay_msg = 0;
 954:ServerLLDN.c  **** 					
 955:ServerLLDN.c  **** 					appState	= APP_STATE_IDLE;
 956:ServerLLDN.c  **** 					appPanState = APP_PAN_STATE_SEND_CONF_REQUEST;
 957:ServerLLDN.c  **** 					
 958:ServerLLDN.c  **** 					break;
 959:ServerLLDN.c  **** 				}
 960:ServerLLDN.c  **** 				case APP_PAN_STATE_SEND_CONF_REQUEST:
 961:ServerLLDN.c  **** 				{
 962:ServerLLDN.c  **** 					if(conf_req_list != NULL)
 963:ServerLLDN.c  **** 					{
 964:ServerLLDN.c  **** 						if(CopyToConfigRequest())
 965:ServerLLDN.c  **** 						{
 966:ServerLLDN.c  **** 						msgReq.options		= NWK_OPT_MAC_COMMAND;
 967:ServerLLDN.c  **** 						msgReq.data			= (uint8_t*)&config_request_frame;
 968:ServerLLDN.c  **** 						msgReq.size			= sizeof(NWK_ConfigRequest_t);
 969:ServerLLDN.c  **** 						appState	= APP_STATE_IDLE;
 970:ServerLLDN.c  **** 						appPanState = APP_PAN_STATE_SEND_CONF_REQUEST;
 971:ServerLLDN.c  **** // 						printf("  assts %d %hhx",config_request_frame.assTimeSlot,  config_request_frame.macAddr);
 972:ServerLLDN.c  **** 						// Delay between messages
 973:ServerLLDN.c  **** 						}
 974:ServerLLDN.c  **** 						else
 975:ServerLLDN.c  **** 						{
 976:ServerLLDN.c  **** 							msgReq.options = 0;
 977:ServerLLDN.c  **** 						}
 978:ServerLLDN.c  **** 						macsc_set_cmp1_int_cb(downlink_delay_handler);
 979:ServerLLDN.c  **** 						macsc_disable_cmp_int(MACSC_CC1);
 980:ServerLLDN.c  **** 						macsc_enable_manual_bts();
 981:ServerLLDN.c  **** 						macsc_enable_cmp_int(MACSC_CC1);
 982:ServerLLDN.c  **** 						macsc_use_cmp(MACSC_RELATIVE_CMP, DELAY, MACSC_CC1);
 983:ServerLLDN.c  **** 						
 984:ServerLLDN.c  **** 						counter_associados++;
 985:ServerLLDN.c  **** 					}
 986:ServerLLDN.c  **** 					else
 987:ServerLLDN.c  **** 					{
 988:ServerLLDN.c  **** 						msgReq.options = 0;
 989:ServerLLDN.c  **** 
 990:ServerLLDN.c  **** 						if(counter_delay_msg > 0)
 991:ServerLLDN.c  **** 						{
 992:ServerLLDN.c  **** 							macsc_set_cmp1_int_cb(lldn_server_beacon);
 993:ServerLLDN.c  **** 							macsc_disable_cmp_int(MACSC_CC1);
 994:ServerLLDN.c  **** 							macsc_enable_manual_bts();
 995:ServerLLDN.c  **** 							macsc_enable_cmp_int(MACSC_CC1);
 996:ServerLLDN.c  **** 							macsc_use_cmp(MACSC_RELATIVE_CMP,beaconInterval_association - counter_delay_msg * DELAY, MAC
 997:ServerLLDN.c  **** 						}
 998:ServerLLDN.c  **** 						
 999:ServerLLDN.c  **** 						appState	= APP_STATE_ATT_PAN_STATE;
1000:ServerLLDN.c  **** 						appPanState = APP_PAN_STATE_CONFIG_THIRD_BEACON;
1001:ServerLLDN.c  **** 					}
1002:ServerLLDN.c  **** 					break;
1003:ServerLLDN.c  **** 				}
1004:ServerLLDN.c  **** 				case APP_PAN_STATE_CONFIG_THIRD_BEACON:
1005:ServerLLDN.c  **** 				{
1006:ServerLLDN.c  **** 					msgReq.options = NWK_OPT_LLDN_BEACON | NWK_OPT_CONFIG_STATE | NWK_OPT_THIRD_BEACON;
1007:ServerLLDN.c  **** 					msgReq.data = NULL;
1008:ServerLLDN.c  **** 					msgReq.size = 0;
1009:ServerLLDN.c  **** 					
1010:ServerLLDN.c  **** 					appState	= APP_STATE_IDLE;
1011:ServerLLDN.c  **** 					appPanState = APP_PAN_STATE_DISC_INITIAL;
1012:ServerLLDN.c  **** 					cycles_counter++;	
1013:ServerLLDN.c  **** 					
1014:ServerLLDN.c  **** 					break;
1015:ServerLLDN.c  **** 				}
1016:ServerLLDN.c  **** 				case APP_PAN_STATE_ONLINE_INITIAL:
1017:ServerLLDN.c  **** 				{
1018:ServerLLDN.c  **** 
1019:ServerLLDN.c  **** 					if(cycles_counter != 0)
1020:ServerLLDN.c  **** 					{
1021:ServerLLDN.c  **** 						appPanOnlineInit();
1022:ServerLLDN.c  **** 						
1023:ServerLLDN.c  **** 						appState = APP_STATE_IDLE;
1024:ServerLLDN.c  **** 						appPanState = APP_PAN_STATE_IDLE;
1025:ServerLLDN.c  **** 						
1026:ServerLLDN.c  **** 						cycles_counter--;
1027:ServerLLDN.c  **** 					}
1028:ServerLLDN.c  **** 					else
1029:ServerLLDN.c  **** 					{
1030:ServerLLDN.c  **** 						appState = APP_STATE_IDLE;
1031:ServerLLDN.c  **** 						appPanState = APP_PAN_STATE_IDLE;
1032:ServerLLDN.c  **** 						macsc_disable_cmp_int(MACSC_CC1);
1033:ServerLLDN.c  **** 						
1034:ServerLLDN.c  **** 						printf("\n\n Mtricas (%d Ciclos):\n", NUMERO_CICLOS_ONLINE -1);
1035:ServerLLDN.c  **** 						int total_msg = 0;
1036:ServerLLDN.c  **** 						float uplink_lost_packets = 0;
1037:ServerLLDN.c  **** 						float expected_messages = assTimeSlot * (float)(NUMERO_CICLOS_ONLINE - 1);
1038:ServerLLDN.c  **** 						for(int i = 0; nodes_info_arr[i].mac_addr != 0 && assTimeSlot > i; i++)
1039:ServerLLDN.c  **** 						{
1040:ServerLLDN.c  **** 							printf("\nAddrs , %hhx", nodes_info_arr[i].mac_addr);
1041:ServerLLDN.c  **** 							printf("\nPLR ,  %.3f", 1 - nodes_info_arr[i].msg_rec / (float)(NUMERO_CICLOS_ONLINE - 1));
1042:ServerLLDN.c  **** 							printf("\nPER ,  %.3f", nodes_info_arr[i].msg_not_rec / (float)(NUMERO_CICLOS_ONLINE - 1));
1043:ServerLLDN.c  **** 							printf("\nRssi Mdio , %f\n", nodes_info_arr[i].average_rssi);
1044:ServerLLDN.c  **** 							
1045:ServerLLDN.c  **** 							total_msg = total_msg + nodes_info_arr[i].msg_rec;
1046:ServerLLDN.c  **** 							uplink_lost_packets += nodes_info_arr[i].msg_not_rec;
1047:ServerLLDN.c  **** 						}
1048:ServerLLDN.c  **** 						if(assTimeSlot > 0 && total_msg > 0)
1049:ServerLLDN.c  **** 						{
1050:ServerLLDN.c  **** 							PLR = 1 - total_msg / expected_messages;
1051:ServerLLDN.c  **** 							PER = uplink_lost_packets / expected_messages;
1052:ServerLLDN.c  **** 							printf("\nPLR , %.3f\nPER , %.3f, total_de_mensagens %d", PLR, PER, total_msg);
1053:ServerLLDN.c  **** 							
1054:ServerLLDN.c  **** 						}
1055:ServerLLDN.c  **** 					}
1056:ServerLLDN.c  **** 					break;
1057:ServerLLDN.c  **** 				}
1058:ServerLLDN.c  **** 				case APP_PAN_STATE_ONLINE_PREPARE_ACK_GROUP:
1059:ServerLLDN.c  **** 				{
1060:ServerLLDN.c  **** 					for(int i = 0; i < 32; i++)
1061:ServerLLDN.c  **** 					{
1062:ServerLLDN.c  **** 						ACKFrame.ackFlags[i] = 0;
1063:ServerLLDN.c  **** 						retransmit_ts_array[i] = 0;
1064:ServerLLDN.c  **** 					}
1065:ServerLLDN.c  **** 					retransmit_ts_array_counter = 0;
1066:ServerLLDN.c  **** 					ACKFrame_size = 0;
1067:ServerLLDN.c  **** 					
1068:ServerLLDN.c  **** 					msgReq.dstAddr		= 0;
1069:ServerLLDN.c  **** 					msgReq.dstEndpoint	= APP_BEACON_ENDPOINT;
1070:ServerLLDN.c  **** 					msgReq.srcEndpoint	= APP_BEACON_ENDPOINT;
1071:ServerLLDN.c  **** 					msgReq.options		= NWK_OPT_LLDN_ACK;
1072:ServerLLDN.c  **** 					msgReq.data	= (uint8_t *)&ACKFrame;
1073:ServerLLDN.c  **** 					msgReq.size	= sizeof(uint8_t)*(macLLDNRetransmitTS + 1);
1074:ServerLLDN.c  **** 
1075:ServerLLDN.c  **** 					appState = APP_STATE_IDLE;
1076:ServerLLDN.c  **** 					appPanState = APP_PAN_STATE_IDLE;
1077:ServerLLDN.c  **** 					break;
1078:ServerLLDN.c  **** 				}				
1079:ServerLLDN.c  **** 				case APP_PAN_STATE_IDLE:
1080:ServerLLDN.c  **** 				{
1081:ServerLLDN.c  **** 
1082:ServerLLDN.c  **** 					msgReq.options = 0;
1083:ServerLLDN.c  **** 					appState = APP_STATE_IDLE;
1084:ServerLLDN.c  **** 					break;
1085:ServerLLDN.c  **** 				}
1086:ServerLLDN.c  **** 			}
1087:ServerLLDN.c  **** 			break;	
1088:ServerLLDN.c  **** 		}
1089:ServerLLDN.c  **** 		#else // NODES SPECIFIC STATE MACHINE
1090:ServerLLDN.c  **** 		case APP_STATE_PREP_DISC_REPONSE:
1091:ServerLLDN.c  **** 		{
1092:ServerLLDN.c  **** 			appPrepareDiscoverResponse();
1093:ServerLLDN.c  **** 			appState = APP_STATE_IDLE;	
1094:ServerLLDN.c  **** 			break;
1095:ServerLLDN.c  **** 		}
1096:ServerLLDN.c  **** 		
1097:ServerLLDN.c  **** 		case APP_STATE_PREP_CONFIG_STATUS:
1098:ServerLLDN.c  **** 		{
1099:ServerLLDN.c  **** 			// se o nodo recebeu ack na fase do discovery prepara a mensagem de configuration status
1100:ServerLLDN.c  **** 			if(ack_received && rec_beacon.confSeqNumber == 0 && associated == 0 && STATE != ONLINE_MODE) {
1101:ServerLLDN.c  **** 				appPrepareConfigurationStatus();
1102:ServerLLDN.c  **** 			}
1103:ServerLLDN.c  **** 			// se o nodo no recebeu desativa o timer e fica em idle
1104:ServerLLDN.c  **** 			else {
1105:ServerLLDN.c  **** 				#if MASTER_MACSC
1106:ServerLLDN.c  **** 				macsc_disable_cmp_int(MACSC_CC1);
1107:ServerLLDN.c  **** 				#else
1108:ServerLLDN.c  **** 				timer_stop();
1109:ServerLLDN.c  **** 				#endif
1110:ServerLLDN.c  **** 			}
1111:ServerLLDN.c  **** 			ack_received = 0;
1112:ServerLLDN.c  **** 			appState = APP_STATE_IDLE;
1113:ServerLLDN.c  **** 			break;
1114:ServerLLDN.c  **** 		}
1115:ServerLLDN.c  **** 		case APP_STATE_PREP_DATA_FRAME:
1116:ServerLLDN.c  **** 		{
1117:ServerLLDN.c  **** 			appPrepareDataFrame();
1118:ServerLLDN.c  **** 			appState = APP_STATE_IDLE;
1119:ServerLLDN.c  **** 			break;
1120:ServerLLDN.c  **** 		}
1121:ServerLLDN.c  **** 		case APP_STATE_RETRANSMIT_DATA:
1122:ServerLLDN.c  **** 		{
1123:ServerLLDN.c  **** 			if(!ack_received)
1124:ServerLLDN.c  **** 			{
1125:ServerLLDN.c  **** 				appState = APP_STATE_IDLE;
1126:ServerLLDN.c  **** 				
1127:ServerLLDN.c  **** 				int retransmition_slot = 0;
1128:ServerLLDN.c  **** 				
1129:ServerLLDN.c  **** 				
1130:ServerLLDN.c  **** 				for(int i = 0; i < assTimeSlot - 1 && i < (rec_beacon.NumberOfBaseTimeslotsinSuperframe - 3)/2;
1131:ServerLLDN.c  **** 					if( !check_ack(i) )
1132:ServerLLDN.c  **** 						retransmition_slot++;
1133:ServerLLDN.c  **** 					
1134:ServerLLDN.c  **** 				printf("\nretransmition_slot %d", retransmition_slot);
1135:ServerLLDN.c  **** 				
1136:ServerLLDN.c  **** 				if(retransmition_slot == 0)
1137:ServerLLDN.c  **** 				{
1138:ServerLLDN.c  **** 					appSendData();
1139:ServerLLDN.c  **** 					// appState = APP_STATE_SEND;			
1140:ServerLLDN.c  **** 				}
1141:ServerLLDN.c  **** 				else
1142:ServerLLDN.c  **** 				{
1143:ServerLLDN.c  **** 					#if MASTER_MACSC
1144:ServerLLDN.c  **** 					macsc_enable_manual_bts();
1145:ServerLLDN.c  **** 					macsc_set_cmp1_int_cb(send_message_timeHandler);
1146:ServerLLDN.c  **** 					macsc_enable_cmp_int(MACSC_CC1);
1147:ServerLLDN.c  **** 					macsc_use_cmp(MACSC_RELATIVE_CMP, ts_time * retransmition_slot, MACSC_CC1);
1148:ServerLLDN.c  **** 					#endif
1149:ServerLLDN.c  **** 				}
1150:ServerLLDN.c  **** 				
1151:ServerLLDN.c  **** 			}
1152:ServerLLDN.c  **** 			else
1153:ServerLLDN.c  **** 			{
1154:ServerLLDN.c  **** 				appState = APP_STATE_IDLE;
1155:ServerLLDN.c  **** 			}
1156:ServerLLDN.c  **** 			
1157:ServerLLDN.c  **** 			break;
1158:ServerLLDN.c  **** 		}
1159:ServerLLDN.c  **** 		#endif
1160:ServerLLDN.c  **** 		default:
1161:ServerLLDN.c  **** 		{
1162:ServerLLDN.c  **** 			break;
 2275               		.loc 6 1162 0
 2276 0b28 00C0      		rjmp .L71
 2277               	.L65:
 839:ServerLLDN.c  **** 	switch (appState){
 2278               		.loc 6 839 0
 2279 0b2a 8630      		cpi r24,6
 2280 0b2c 9105      		cpc r25,__zero_reg__
 2281 0b2e 01F0      		breq .L68
 2282 0b30 8630      		cpi r24,6
 2283 0b32 9105      		cpc r25,__zero_reg__
 2284 0b34 04F0      		brlt .L69
 2285 0b36 0797      		sbiw r24,7
 2286 0b38 01F0      		breq .L70
 2287               		.loc 6 1162 0
 2288 0b3a 00C0      		rjmp .L71
 2289               	.L66:
 842:ServerLLDN.c  **** 			#if APP_COORDINATOR
 2290               		.loc 6 842 0
 2291 0b3c 0E94 0000 		call appInit
 846:ServerLLDN.c  **** 			#endif
 2292               		.loc 6 846 0
 2293 0b40 81E0      		ldi r24,lo8(1)
 2294 0b42 8093 0000 		sts appState,r24
 848:ServerLLDN.c  **** 		}
 2295               		.loc 6 848 0
 2296 0b46 00C0      		rjmp .L71
 2297               	.L67:
 852:ServerLLDN.c  **** 			#if APP_COORDINATOR
 2298               		.loc 6 852 0
 2299 0b48 0E94 0000 		call appSendData
 857:ServerLLDN.c  **** 			#endif
 2300               		.loc 6 857 0
 2301 0b4c 81E0      		ldi r24,lo8(1)
 2302 0b4e 8093 0000 		sts appState,r24
 859:ServerLLDN.c  **** 		}
 2303               		.loc 6 859 0
 2304 0b52 00C0      		rjmp .L71
 2305               	.L64:
1092:ServerLLDN.c  **** 			appState = APP_STATE_IDLE;	
 2306               		.loc 6 1092 0
 2307 0b54 0E94 0000 		call appPrepareDiscoverResponse
1093:ServerLLDN.c  **** 			break;
 2308               		.loc 6 1093 0
 2309 0b58 81E0      		ldi r24,lo8(1)
 2310 0b5a 8093 0000 		sts appState,r24
1094:ServerLLDN.c  **** 		}
 2311               		.loc 6 1094 0
 2312 0b5e 00C0      		rjmp .L71
 2313               	.L69:
1100:ServerLLDN.c  **** 				appPrepareConfigurationStatus();
 2314               		.loc 6 1100 0
 2315 0b60 8091 0000 		lds r24,ack_received
 2316 0b64 8823      		tst r24
 2317 0b66 01F0      		breq .L72
1100:ServerLLDN.c  **** 				appPrepareConfigurationStatus();
 2318               		.loc 6 1100 0 is_stmt 0 discriminator 1
 2319 0b68 8091 0000 		lds r24,rec_beacon+5
 2320 0b6c 8823      		tst r24
 2321 0b6e 01F4      		brne .L72
1100:ServerLLDN.c  **** 				appPrepareConfigurationStatus();
 2322               		.loc 6 1100 0 discriminator 2
 2323 0b70 9091 0000 		lds r25,associated
 2324 0b74 81E0      		ldi r24,lo8(1)
 2325 0b76 8927      		eor r24,r25
 2326 0b78 8823      		tst r24
 2327 0b7a 01F0      		breq .L72
1100:ServerLLDN.c  **** 				appPrepareConfigurationStatus();
 2328               		.loc 6 1100 0 discriminator 3
 2329 0b7c 8091 0000 		lds r24,STATE
 2330 0b80 8823      		tst r24
 2331 0b82 01F0      		breq .L72
1101:ServerLLDN.c  **** 			}
 2332               		.loc 6 1101 0 is_stmt 1
 2333 0b84 0E94 0000 		call appPrepareConfigurationStatus
 2334 0b88 00C0      		rjmp .L73
 2335               	.L72:
1106:ServerLLDN.c  **** 				#else
 2336               		.loc 6 1106 0
 2337 0b8a 81E0      		ldi r24,lo8(1)
 2338 0b8c 0E94 0000 		call macsc_disable_cmp_int
 2339               	.L73:
1111:ServerLLDN.c  **** 			appState = APP_STATE_IDLE;
 2340               		.loc 6 1111 0
 2341 0b90 1092 0000 		sts ack_received,__zero_reg__
1112:ServerLLDN.c  **** 			break;
 2342               		.loc 6 1112 0
 2343 0b94 81E0      		ldi r24,lo8(1)
 2344 0b96 8093 0000 		sts appState,r24
1113:ServerLLDN.c  **** 		}
 2345               		.loc 6 1113 0
 2346 0b9a 00C0      		rjmp .L71
 2347               	.L68:
1117:ServerLLDN.c  **** 			appState = APP_STATE_IDLE;
 2348               		.loc 6 1117 0
 2349 0b9c 0E94 0000 		call appPrepareDataFrame
1118:ServerLLDN.c  **** 			break;
 2350               		.loc 6 1118 0
 2351 0ba0 81E0      		ldi r24,lo8(1)
 2352 0ba2 8093 0000 		sts appState,r24
1119:ServerLLDN.c  **** 		}
 2353               		.loc 6 1119 0
 2354 0ba6 00C0      		rjmp .L71
 2355               	.L70:
1123:ServerLLDN.c  **** 			{
 2356               		.loc 6 1123 0
 2357 0ba8 9091 0000 		lds r25,ack_received
 2358 0bac 81E0      		ldi r24,lo8(1)
 2359 0bae 8927      		eor r24,r25
 2360 0bb0 8823      		tst r24
 2361 0bb2 01F4      		brne .+2
 2362 0bb4 00C0      		rjmp .L74
 2363               	.LBB5:
1125:ServerLLDN.c  **** 				
 2364               		.loc 6 1125 0
 2365 0bb6 81E0      		ldi r24,lo8(1)
 2366 0bb8 8093 0000 		sts appState,r24
1127:ServerLLDN.c  **** 				
 2367               		.loc 6 1127 0
 2368 0bbc 1A82      		std Y+2,__zero_reg__
 2369 0bbe 1982      		std Y+1,__zero_reg__
 2370               	.LBB6:
1130:ServerLLDN.c  **** 					if( !check_ack(i) )
 2371               		.loc 6 1130 0
 2372 0bc0 1C82      		std Y+4,__zero_reg__
 2373 0bc2 1B82      		std Y+3,__zero_reg__
 2374 0bc4 00C0      		rjmp .L75
 2375               	.L79:
1131:ServerLLDN.c  **** 						retransmition_slot++;
 2376               		.loc 6 1131 0
 2377 0bc6 8B81      		ldd r24,Y+3
 2378 0bc8 9C81      		ldd r25,Y+4
 2379 0bca 0E94 0000 		call check_ack
 2380 0bce 982F      		mov r25,r24
 2381 0bd0 81E0      		ldi r24,lo8(1)
 2382 0bd2 8927      		eor r24,r25
 2383 0bd4 8823      		tst r24
 2384 0bd6 01F0      		breq .L76
1132:ServerLLDN.c  **** 					
 2385               		.loc 6 1132 0
 2386 0bd8 8981      		ldd r24,Y+1
 2387 0bda 9A81      		ldd r25,Y+2
 2388 0bdc 0196      		adiw r24,1
 2389 0bde 9A83      		std Y+2,r25
 2390 0be0 8983      		std Y+1,r24
 2391               	.L76:
1130:ServerLLDN.c  **** 					if( !check_ack(i) )
 2392               		.loc 6 1130 0 discriminator 2
 2393 0be2 8B81      		ldd r24,Y+3
 2394 0be4 9C81      		ldd r25,Y+4
 2395 0be6 0196      		adiw r24,1
 2396 0be8 9C83      		std Y+4,r25
 2397 0bea 8B83      		std Y+3,r24
 2398               	.L75:
1130:ServerLLDN.c  **** 					if( !check_ack(i) )
 2399               		.loc 6 1130 0 is_stmt 0 discriminator 1
 2400 0bec 8091 0000 		lds r24,assTimeSlot
 2401 0bf0 882F      		mov r24,r24
 2402 0bf2 90E0      		ldi r25,0
 2403 0bf4 9C01      		movw r18,r24
 2404 0bf6 2150      		subi r18,1
 2405 0bf8 3109      		sbc r19,__zero_reg__
 2406 0bfa 8B81      		ldd r24,Y+3
 2407 0bfc 9C81      		ldd r25,Y+4
 2408 0bfe 8217      		cp r24,r18
 2409 0c00 9307      		cpc r25,r19
 2410 0c02 04F4      		brge .L77
1130:ServerLLDN.c  **** 					if( !check_ack(i) )
 2411               		.loc 6 1130 0 discriminator 3
 2412 0c04 8091 0000 		lds r24,rec_beacon+7
 2413 0c08 882F      		mov r24,r24
 2414 0c0a 90E0      		ldi r25,0
 2415 0c0c 0397      		sbiw r24,3
 2416 0c0e 9923      		tst r25
 2417 0c10 04F4      		brge .L78
 2418 0c12 0196      		adiw r24,1
 2419               	.L78:
 2420 0c14 9595      		asr r25
 2421 0c16 8795      		ror r24
 2422 0c18 9C01      		movw r18,r24
 2423 0c1a 8B81      		ldd r24,Y+3
 2424 0c1c 9C81      		ldd r25,Y+4
 2425 0c1e 8217      		cp r24,r18
 2426 0c20 9307      		cpc r25,r19
 2427 0c22 04F0      		brlt .L79
 2428               	.L77:
 2429               	.LBE6:
1134:ServerLLDN.c  **** 				
 2430               		.loc 6 1134 0 is_stmt 1
 2431 0c24 8A81      		ldd r24,Y+2
 2432 0c26 8F93      		push r24
 2433 0c28 8981      		ldd r24,Y+1
 2434 0c2a 8F93      		push r24
 2435 0c2c 80E0      		ldi r24,lo8(.LC10)
 2436 0c2e 90E0      		ldi r25,hi8(.LC10)
 2437 0c30 892F      		mov r24,r25
 2438 0c32 8F93      		push r24
 2439 0c34 80E0      		ldi r24,lo8(.LC10)
 2440 0c36 90E0      		ldi r25,hi8(.LC10)
 2441 0c38 8F93      		push r24
 2442 0c3a 0E94 0000 		call printf
 2443 0c3e 0F90      		pop __tmp_reg__
 2444 0c40 0F90      		pop __tmp_reg__
 2445 0c42 0F90      		pop __tmp_reg__
 2446 0c44 0F90      		pop __tmp_reg__
1136:ServerLLDN.c  **** 				{
 2447               		.loc 6 1136 0
 2448 0c46 8981      		ldd r24,Y+1
 2449 0c48 9A81      		ldd r25,Y+2
 2450 0c4a 892B      		or r24,r25
 2451 0c4c 01F4      		brne .L80
1138:ServerLLDN.c  **** 					// appState = APP_STATE_SEND;			
 2452               		.loc 6 1138 0
 2453 0c4e 0E94 0000 		call appSendData
 2454               	.LBE5:
1157:ServerLLDN.c  **** 		}
 2455               		.loc 6 1157 0
 2456 0c52 00C0      		rjmp .L83
 2457               	.L80:
 2458               	.LBB7:
1144:ServerLLDN.c  **** 					macsc_set_cmp1_int_cb(send_message_timeHandler);
 2459               		.loc 6 1144 0
 2460 0c54 0E94 0000 		call macsc_enable_manual_bts
1145:ServerLLDN.c  **** 					macsc_enable_cmp_int(MACSC_CC1);
 2461               		.loc 6 1145 0
 2462 0c58 80E0      		ldi r24,lo8(gs(send_message_timeHandler))
 2463 0c5a 90E0      		ldi r25,hi8(gs(send_message_timeHandler))
 2464 0c5c 0E94 0000 		call macsc_set_cmp1_int_cb
1146:ServerLLDN.c  **** 					macsc_use_cmp(MACSC_RELATIVE_CMP, ts_time * retransmition_slot, MACSC_CC1);
 2465               		.loc 6 1146 0
 2466 0c60 81E0      		ldi r24,lo8(1)
 2467 0c62 0E94 0000 		call macsc_enable_cmp_int
1147:ServerLLDN.c  **** 					#endif
 2468               		.loc 6 1147 0
 2469 0c66 4091 0000 		lds r20,ts_time
 2470 0c6a 5091 0000 		lds r21,ts_time+1
 2471 0c6e 2981      		ldd r18,Y+1
 2472 0c70 3A81      		ldd r19,Y+2
 2473 0c72 429F      		mul r20,r18
 2474 0c74 C001      		movw r24,r0
 2475 0c76 439F      		mul r20,r19
 2476 0c78 900D      		add r25,r0
 2477 0c7a 529F      		mul r21,r18
 2478 0c7c 900D      		add r25,r0
 2479 0c7e 1124      		clr r1
 2480 0c80 092E      		mov __tmp_reg__,r25
 2481 0c82 000C      		lsl r0
 2482 0c84 AA0B      		sbc r26,r26
 2483 0c86 BB0B      		sbc r27,r27
 2484 0c88 21E0      		ldi r18,lo8(1)
 2485 0c8a AC01      		movw r20,r24
 2486 0c8c BD01      		movw r22,r26
 2487 0c8e 81E0      		ldi r24,lo8(1)
 2488 0c90 0E94 0000 		call macsc_use_cmp
 2489               	.LBE7:
1157:ServerLLDN.c  **** 		}
 2490               		.loc 6 1157 0
 2491 0c94 00C0      		rjmp .L83
 2492               	.L74:
1154:ServerLLDN.c  **** 			}
 2493               		.loc 6 1154 0
 2494 0c96 81E0      		ldi r24,lo8(1)
 2495 0c98 8093 0000 		sts appState,r24
 2496               	.L83:
1157:ServerLLDN.c  **** 		}
 2497               		.loc 6 1157 0
 2498 0c9c 0000      		nop
 2499               	.L71:
1163:ServerLLDN.c  **** 		}
1164:ServerLLDN.c  **** 	}
1165:ServerLLDN.c  **** }
 2500               		.loc 6 1165 0
 2501 0c9e 0000      		nop
 2502               	/* epilogue start */
 2503 0ca0 0F90      		pop __tmp_reg__
 2504 0ca2 0F90      		pop __tmp_reg__
 2505 0ca4 0F90      		pop __tmp_reg__
 2506 0ca6 0F90      		pop __tmp_reg__
 2507 0ca8 DF91      		pop r29
 2508 0caa CF91      		pop r28
 2509 0cac 0895      		ret
 2510               		.cfi_endproc
 2511               	.LFE144:
 2513               		.section	.rodata
 2514               	.LC0:
 2515 00a2 00        		.byte	0
 2516 00a3 C2        		.byte	-62
 2517 00a4 01        		.byte	1
 2518 00a5 00        		.byte	0
 2519 00a6 03        		.byte	3
 2520 00a7 00        		.byte	0
 2521 00a8 00        		.byte	0
 2522               		.text
 2523               	.global	main
 2525               	main:
 2526               	.LFB145:
1166:ServerLLDN.c  **** 
1167:ServerLLDN.c  **** 	/*****************************************************************************
1168:ServerLLDN.c  **** 	*****************************************************************************/
1169:ServerLLDN.c  **** 	int main(void)
1170:ServerLLDN.c  **** 	{
 2527               		.loc 6 1170 0
 2528               		.cfi_startproc
 2529 0cae 0F93      		push r16
 2530               	.LCFI94:
 2531               		.cfi_def_cfa_offset 3
 2532               		.cfi_offset 16, -2
 2533 0cb0 1F93      		push r17
 2534               	.LCFI95:
 2535               		.cfi_def_cfa_offset 4
 2536               		.cfi_offset 17, -3
 2537 0cb2 CF93      		push r28
 2538               	.LCFI96:
 2539               		.cfi_def_cfa_offset 5
 2540               		.cfi_offset 28, -4
 2541 0cb4 DF93      		push r29
 2542               	.LCFI97:
 2543               		.cfi_def_cfa_offset 6
 2544               		.cfi_offset 29, -5
 2545 0cb6 CDB7      		in r28,__SP_L__
 2546 0cb8 DEB7      		in r29,__SP_H__
 2547               	.LCFI98:
 2548               		.cfi_def_cfa_register 28
 2549 0cba 2797      		sbiw r28,7
 2550               	.LCFI99:
 2551               		.cfi_def_cfa_offset 13
 2552 0cbc 0FB6      		in __tmp_reg__,__SREG__
 2553 0cbe F894      		cli
 2554 0cc0 DEBF      		out __SP_H__,r29
 2555 0cc2 0FBE      		out __SREG__,__tmp_reg__
 2556 0cc4 CDBF      		out __SP_L__,r28
 2557               	/* prologue: function */
 2558               	/* frame size = 7 */
 2559               	/* stack size = 11 */
 2560               	.L__stack_usage = 11
1171:ServerLLDN.c  **** 		sysclk_init();
 2561               		.loc 6 1171 0
 2562 0cc6 0E94 0000 		call sysclk_init
1172:ServerLLDN.c  **** 		board_init();
 2563               		.loc 6 1172 0
 2564 0cca 0E94 0000 		call board_init
1173:ServerLLDN.c  **** 
1174:ServerLLDN.c  **** 		SYS_Init();
 2565               		.loc 6 1174 0
 2566 0cce 0E94 0000 		call SYS_Init
1175:ServerLLDN.c  **** 		/* Disable CSMA/CA
1176:ServerLLDN.c  **** 		 * Disable auto ACK
1177:ServerLLDN.c  **** 		 * Enable Rx of LLDN Frame Type as described in 802.15.4e - 2012 
1178:ServerLLDN.c  **** 		 */
1179:ServerLLDN.c  **** 
1180:ServerLLDN.c  **** 		sm_init();
 2567               		.loc 6 1180 0
 2568 0cd2 0E94 0000 		call sm_init
1181:ServerLLDN.c  **** 
1182:ServerLLDN.c  **** 		// Initialize interrupt vector table support.
1183:ServerLLDN.c  **** 	#if (SIO2HOST_CHANNEL == SIO_USB)
1184:ServerLLDN.c  **** 		irq_initialize_vectors();
1185:ServerLLDN.c  **** 	#endif
1186:ServerLLDN.c  **** 		cpu_irq_enable();
 2569               		.loc 6 1186 0
 2570               	/* #APP */
 2571               	 ;  1186 "ServerLLDN.c" 1
 2572 0cd6 7894      		sei
 2573               	 ;  0 "" 2
1187:ServerLLDN.c  **** 
1188:ServerLLDN.c  **** 	#if 1
1189:ServerLLDN.c  **** 	#if (SIO2HOST_CHANNEL == SIO_USB)
1190:ServerLLDN.c  **** 		stdio_usb_init();
1191:ServerLLDN.c  **** 	#else
1192:ServerLLDN.c  **** 		const usart_serial_options_t usart_serial_options =
 2574               		.loc 6 1192 0
 2575               	/* #NOAPP */
 2576 0cd8 27E0      		ldi r18,lo8(7)
 2577 0cda E0E0      		ldi r30,lo8(.LC0)
 2578 0cdc F0E0      		ldi r31,hi8(.LC0)
 2579 0cde CE01      		movw r24,r28
 2580 0ce0 0196      		adiw r24,1
 2581 0ce2 DC01      		movw r26,r24
 2582               		0:
 2583 0ce4 0190      		ld r0,Z+
 2584 0ce6 0D92      		st X+,r0
 2585 0ce8 2A95      		dec r18
 2586 0cea 01F4      		brne 0b
1193:ServerLLDN.c  **** 		{
1194:ServerLLDN.c  **** 			.baudrate     = USART_HOST_BAUDRATE,
1195:ServerLLDN.c  **** 			.charlength   = USART_HOST_CHAR_LENGTH,
1196:ServerLLDN.c  **** 			.paritytype   = USART_HOST_PARITY,
1197:ServerLLDN.c  **** 			.stopbits     = USART_HOST_STOP_BITS
1198:ServerLLDN.c  **** 		};
1199:ServerLLDN.c  **** 
1200:ServerLLDN.c  **** 		stdio_serial_init(USART_HOST, &usart_serial_options);
 2587               		.loc 6 1200 0
 2588 0cec CE01      		movw r24,r28
 2589 0cee 0196      		adiw r24,1
 2590 0cf0 BC01      		movw r22,r24
 2591 0cf2 80EC      		ldi r24,lo8(-64)
 2592 0cf4 90E0      		ldi r25,0
 2593 0cf6 0E94 0000 		call stdio_serial_init
1201:ServerLLDN.c  **** 		usart_double_baud_enable(USART_HOST);
 2594               		.loc 6 1201 0
 2595 0cfa 80EC      		ldi r24,lo8(-64)
 2596 0cfc 90E0      		ldi r25,0
 2597 0cfe 0E94 0000 		call usart_double_baud_enable
1202:ServerLLDN.c  **** 		usart_set_baudrate_precalculated(USART_HOST, USART_HOST_BAUDRATE, sysclk_get_source_clock_hz());
 2598               		.loc 6 1202 0
 2599 0d02 0E94 0000 		call sysclk_get_source_clock_hz
 2600 0d06 DC01      		movw r26,r24
 2601 0d08 CB01      		movw r24,r22
 2602 0d0a 8C01      		movw r16,r24
 2603 0d0c 9D01      		movw r18,r26
 2604 0d0e 40E0      		ldi r20,0
 2605 0d10 52EC      		ldi r21,lo8(-62)
 2606 0d12 61E0      		ldi r22,lo8(1)
 2607 0d14 70E0      		ldi r23,0
 2608 0d16 80EC      		ldi r24,lo8(-64)
 2609 0d18 90E0      		ldi r25,0
 2610 0d1a 0E94 0000 		call usart_set_baudrate_precalculated
 2611               	.L85:
1203:ServerLLDN.c  **** 
1204:ServerLLDN.c  **** 	#endif
1205:ServerLLDN.c  **** 	#endif
1206:ServerLLDN.c  **** 		for(;;)
1207:ServerLLDN.c  **** 		{
1208:ServerLLDN.c  **** 			SYS_TaskHandler();
 2612               		.loc 6 1208 0 discriminator 1
 2613 0d1e 0E94 0000 		call SYS_TaskHandler
1209:ServerLLDN.c  **** 			APP_TaskHandler();
 2614               		.loc 6 1209 0 discriminator 1
 2615 0d22 0E94 0000 		call APP_TaskHandler
1210:ServerLLDN.c  **** 		}
 2616               		.loc 6 1210 0 discriminator 1
 2617 0d26 00C0      		rjmp .L85
 2618               		.cfi_endproc
 2619               	.LFE145:
 2621               	.Letext0:
 2622               		.file 7 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\in
 2623               		.file 8 "../../../stack/LwMesh/TDMA/nwk/inc/nwkFrame.h"
 2624               		.file 9 "../../../stack/LwMesh/TDMA/nwk/inc/nwkRx.h"
 2625               		.file 10 "../../../stack/LwMesh/TDMA/nwk/inc/nwkDataReq.h"
 2626               		.file 11 "lldn.h"
 2627               		.file 12 "../../../platform/mega_rf/drivers/sleep/sleep.h"
 2628               		.file 13 "../../../platform/mega_rf/utils/status_codes.h"
 2629               		.file 14 "config/config.h"
 2630               		.file 15 "../../../platform/common/services/sleepmgr/mega_rf/sleepmgr.h"
DEFINED SYMBOLS
                            *ABS*:00000000 ServerLLDN.c
C:\Users\GUILHE~1\AppData\Local\Temp\cckHYjLd.s:2      *ABS*:0000003e __SP_H__
C:\Users\GUILHE~1\AppData\Local\Temp\cckHYjLd.s:3      *ABS*:0000003d __SP_L__
C:\Users\GUILHE~1\AppData\Local\Temp\cckHYjLd.s:4      *ABS*:0000003f __SREG__
C:\Users\GUILHE~1\AppData\Local\Temp\cckHYjLd.s:5      *ABS*:0000003b __RAMPZ__
C:\Users\GUILHE~1\AppData\Local\Temp\cckHYjLd.s:6      *ABS*:00000000 __tmp_reg__
C:\Users\GUILHE~1\AppData\Local\Temp\cckHYjLd.s:7      *ABS*:00000001 __zero_reg__
C:\Users\GUILHE~1\AppData\Local\Temp\cckHYjLd.s:15     .bss.n:00000000 n
                            *COM*:00000004 tTS
                            *COM*:00000002 macLLDNnumTimeSlots
                            *COM*:00000002 macLLDNnumUplinkTS
                            *COM*:00000002 macLLDNRetransmitTS
C:\Users\GUILHE~1\AppData\Local\Temp\cckHYjLd.s:23     .text:00000000 sysclk_get_main_hz
C:\Users\GUILHE~1\AppData\Local\Temp\cckHYjLd.s:60     .text:0000001a sysclk_get_source_clock_hz
C:\Users\GUILHE~1\AppData\Local\Temp\cckHYjLd.s:97     .progmem.data.baudctrl_1mhz:00000000 baudctrl_1mhz
C:\Users\GUILHE~1\AppData\Local\Temp\cckHYjLd.s:109    .progmem.data.baudctrl_8mhz:00000000 baudctrl_8mhz
C:\Users\GUILHE~1\AppData\Local\Temp\cckHYjLd.s:121    .progmem.data.baudctrl_16mhz:00000000 baudctrl_16mhz
C:\Users\GUILHE~1\AppData\Local\Temp\cckHYjLd.s:132    .text:00000034 usart_double_baud_enable
C:\Users\GUILHE~1\AppData\Local\Temp\cckHYjLd.s:181    .text:00000062 usart_serial_init
C:\Users\GUILHE~1\AppData\Local\Temp\cckHYjLd.s:276    .text:000000de usart_serial_putchar
C:\Users\GUILHE~1\AppData\Local\Temp\cckHYjLd.s:320    .text:00000106 usart_serial_getchar
C:\Users\GUILHE~1\AppData\Local\Temp\cckHYjLd.s:371    .text:0000013c stdio_serial_init
C:\Users\GUILHE~1\AppData\Local\Temp\cckHYjLd.s:442    .text:0000019e macsc_read32
C:\Users\GUILHE~1\AppData\Local\Temp\cckHYjLd.s:525    .text:00000208 macsc_read_count
C:\Users\GUILHE~1\AppData\Local\Temp\cckHYjLd.s:568    .text:00000232 macsc_enable_manual_bts
C:\Users\GUILHE~1\AppData\Local\Temp\cckHYjLd.s:621    .bss.appState:00000000 appState
C:\Users\GUILHE~1\AppData\Local\Temp\cckHYjLd.s:626    .bss.msgReq:00000000 msgReq
C:\Users\GUILHE~1\AppData\Local\Temp\cckHYjLd.s:631    .bss.PanId:00000000 PanId
C:\Users\GUILHE~1\AppData\Local\Temp\cckHYjLd.s:636    .text:00000266 appSendData
C:\Users\GUILHE~1\AppData\Local\Temp\cckHYjLd.s:684    .data.payloadSize:00000000 payloadSize
C:\Users\GUILHE~1\AppData\Local\Temp\cckHYjLd.s:690    .data.assTimeSlot:00000000 assTimeSlot
C:\Users\GUILHE~1\AppData\Local\Temp\cckHYjLd.s:696    .data.data_payload:00000000 data_payload
                            *COM*:00000008 rec_beacon
                            *COM*:00000002 ackframe
C:\Users\GUILHE~1\AppData\Local\Temp\cckHYjLd.s:703    .data.msgDiscResponse:00000000 msgDiscResponse
C:\Users\GUILHE~1\AppData\Local\Temp\cckHYjLd.s:710    .data.msgConfigStatus:00000000 msgConfigStatus
C:\Users\GUILHE~1\AppData\Local\Temp\cckHYjLd.s:719    .data.msgReqDiscResponse:00000000 msgReqDiscResponse
C:\Users\GUILHE~1\AppData\Local\Temp\cckHYjLd.s:732    .data.msgReqConfigStatus:00000000 msgReqConfigStatus
C:\Users\GUILHE~1\AppData\Local\Temp\cckHYjLd.s:745    .data.msgReqData:00000000 msgReqData
C:\Users\GUILHE~1\AppData\Local\Temp\cckHYjLd.s:758    .bss.ack_received:00000000 ack_received
C:\Users\GUILHE~1\AppData\Local\Temp\cckHYjLd.s:764    .bss.MacLLDNMgmtTS:00000000 MacLLDNMgmtTS
C:\Users\GUILHE~1\AppData\Local\Temp\cckHYjLd.s:770    .bss.associated:00000000 associated
                            *COM*:00000002 ts_time
C:\Users\GUILHE~1\AppData\Local\Temp\cckHYjLd.s:777    .data.STATE:00000000 STATE
C:\Users\GUILHE~1\AppData\Local\Temp\cckHYjLd.s:783    .bss.tmr_error:00000000 tmr_error
C:\Users\GUILHE~1\AppData\Local\Temp\cckHYjLd.s:789    .bss.delta_error:00000000 delta_error
C:\Users\GUILHE~1\AppData\Local\Temp\cckHYjLd.s:795    .bss.beacon_tmr:00000000 beacon_tmr
C:\Users\GUILHE~1\AppData\Local\Temp\cckHYjLd.s:801    .bss.be_read:00000000 be_read
C:\Users\GUILHE~1\AppData\Local\Temp\cckHYjLd.s:807    .bss.tmr_read:00000000 tmr_read
                            *COM*:00000002 msg_wait_time
C:\Users\GUILHE~1\AppData\Local\Temp\cckHYjLd.s:814    .data.ok_seq:00000000 ok_seq
C:\Users\GUILHE~1\AppData\Local\Temp\cckHYjLd.s:818    .text:00000292 send_message_timeHandler
C:\Users\GUILHE~1\AppData\Local\Temp\cckHYjLd.s:853    .text:000002ac node_time_handler
C:\Users\GUILHE~1\AppData\Local\Temp\cckHYjLd.s:899    .text:000002da disc_time_hndlr
C:\Users\GUILHE~1\AppData\Local\Temp\cckHYjLd.s:948    .text:00000310 config_time_hndlr
C:\Users\GUILHE~1\AppData\Local\Temp\cckHYjLd.s:997    .text:0000033c online_time_hndlr
C:\Users\GUILHE~1\AppData\Local\Temp\cckHYjLd.s:1057   .text:00000372 appBeaconInd
C:\Users\GUILHE~1\AppData\Local\Temp\cckHYjLd.s:1417   .text:00000622 check_ack
C:\Users\GUILHE~1\AppData\Local\Temp\cckHYjLd.s:1559   .text:000006f0 appAckInd
C:\Users\GUILHE~1\AppData\Local\Temp\cckHYjLd.s:1853   .text:000008e6 appCommandInd
C:\Users\GUILHE~1\AppData\Local\Temp\cckHYjLd.s:2004   .text:000009d8 appPrepareDiscoverResponse
C:\Users\GUILHE~1\AppData\Local\Temp\cckHYjLd.s:2057   .text:00000a1a appPrepareConfigurationStatus
C:\Users\GUILHE~1\AppData\Local\Temp\cckHYjLd.s:2110   .text:00000a5c appPrepareDataFrame
C:\Users\GUILHE~1\AppData\Local\Temp\cckHYjLd.s:2165   .text:00000aa4 appInit
C:\Users\GUILHE~1\AppData\Local\Temp\cckHYjLd.s:2237   .text:00000b00 APP_TaskHandler
C:\Users\GUILHE~1\AppData\Local\Temp\cckHYjLd.s:2525   .text:00000cae main

UNDEFINED SYMBOLS
usart_init_rs232
usart_putchar
usart_getchar
stdio_base
ptr_put
ptr_get
_read
_write
fdevopen
NWK_DataReq
macsc_set_cmp2_int_cb
macsc_disable_cmp_int
printf
macsc_set_cmp1_int_cb
__floatsisf
__addsf3
__divsf3
__mulsf3
__fixsfsi
macsc_enable_cmp_int
macsc_use_cmp
PHY_SetTdmaMode
__subsf3
__fixunssfsi
PHY_SetChannel
NWK_SetPanId
NWK_SetAddr
PHY_SetRxState
PHY_SetOptimizedCSMAValues
NWK_OpenEndpoint
PHY_SetPromiscuousMode
sysclk_init
board_init
SYS_Init
sm_init
usart_set_baudrate_precalculated
SYS_TaskHandler
__do_copy_data
__do_clear_bss
