   1               		.file	"ServerLLDN.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__RAMPZ__ = 0x3b
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.text
   9               	.Ltext0:
  10               		.cfi_sections	.debug_frame
  11               		.section	.bss.n,"aw",@nobits
  14               	n:
  15 0000 00        		.zero	1
  16               		.section	.bss.tTS,"aw",@nobits
  19               	tTS:
  20 0000 0000 0000 		.zero	4
  21               		.text
  23               	macsc_enable_manual_bts:
  24               	.LFB96:
  25               		.file 1 "../../../platform/mega_rf/drivers/macsc/macsc_megarf.h"
   1:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
   2:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \file
   3:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
   4:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief AVR MEGARF MAC Symbol Counter Driver Definitions
   5:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
   6:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * Copyright (c) 2013 Atmel Corporation. All rights reserved.
   7:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
   8:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \asf_license_start
   9:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  10:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \page License
  11:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  12:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * Redistribution and use in source and binary forms, with or without
  13:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * modification, are permitted provided that the following conditions are met:
  14:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  15:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * 1. Redistributions of source code must retain the above copyright notice,
  16:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *    this list of conditions and the following disclaimer.
  17:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  18:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * 2. Redistributions in binary form must reproduce the above copyright notice,
  19:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *    this list of conditions and the following disclaimer in the documentation
  20:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *    and/or other materials provided with the distribution.
  21:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  22:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * 3. The name of Atmel may not be used to endorse or promote products derived
  23:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *    from this software without specific prior written permission.
  24:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  25:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * 4. This software may only be redistributed and used in connection with an
  26:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *    Atmel microcontroller product.
  27:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  28:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR IMPLIED
  29:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
  30:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
  31:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR
  32:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  33:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
  34:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  35:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
  36:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  37:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  38:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * POSSIBILITY OF SUCH DAMAGE.
  39:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  40:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \asf_license_stop
  41:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  42:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
  43:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** #ifndef MACSC_MEGARF_H
  44:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** #define MACSC_MEGARF_H
  45:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
  46:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** #include <compiler.h>
  47:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** #include <parts.h>
  48:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** #include "status_codes.h"
  49:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
  50:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** #ifdef __cplusplus
  51:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** extern "C" {
  52:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** #endif
  53:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
  54:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
  55:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \defgroup macsc_group MAC Symbol Counter Driver(MACSC)
  56:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  57:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * See \ref megarf_macsc_quickstart
  58:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  59:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * This is a driver for the AVR MEGARF MAC Symbol Counter Driver(MACSC).
  60:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * It provides functions for enabling, disabling and configuring the module.
  61:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  62:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \section dependencies Dependencies
  63:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * This driver depends on the following modules:
  64:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * - \ref interrupt_group for ISR definition and disabling interrupts during
  65:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * critical code sections.
  66:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * @{
  67:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
  68:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
  69:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
  70:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Interrupt event callback function type
  71:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  72:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * The interrupt handler can be configured to do a function callback,
  73:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * the callback function must match the macsc_callback_t type.
  74:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  75:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
  76:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** typedef void (*macsc_callback_t)(void);
  77:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
  78:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /* ! MAC symbol counter compare Channel index */
  79:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** enum macsc_cc_channel {
  80:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	/* ! Channel 1 */
  81:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	MACSC_CC1 = 1,
  82:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	/* ! Channel 2 */
  83:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	MACSC_CC2 = 2,
  84:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	/* ! Channel 3 */
  85:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	MACSC_CC3 = 3,
  86:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** };
  87:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
  88:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief MAC SC clock source select
  89:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  90:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * uses the SCCKSEL bit in SSCR register to select macsc clk src
  91:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  92:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * If the bit is one,the RTC clock from TOSC1 is selected, otherwise the symbol
  93:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * counter operates with the clock from XTAL1.
  94:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * During transceiver sleep modes the clock falls back to the RTC clock source,
  95:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * regardless of the selected clock. After wakeup, it switches back to the
  96:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * previosly
  97:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * selected clock source.
  98:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
  99:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 100:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** enum macsc_xtal {
 101:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	/* ! 16MHz as macsc clock */
 102:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	MACSC_16MHz = 0,
 103:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	MACSC_32KHz = 1,
 104:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** };
 105:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 106:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 107:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * @brief Reads the 32-bit timer register in the required order of bytes
 108:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 109:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * @param hh hh octet of 32-bit register
 110:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * @param hl hl octet of 32-bit register
 111:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * @param lh lh octet of 32-bit register
 112:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * @param ll ll octet of 32-bit register
 113:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 114:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * @returns uint32_t Value of timer register
 115:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 116:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** static inline uint32_t macsc_read32(volatile uint8_t *hh,
 117:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		volatile uint8_t *hl,
 118:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		volatile uint8_t *lh,
 119:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		volatile uint8_t *ll)
 120:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** {
 121:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	union {
 122:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		uint8_t a[4];
 123:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		uint32_t rv;
 124:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	}
 125:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	x;
 126:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 127:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	x.a[0] = *ll;
 128:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	x.a[1] = *lh;
 129:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	x.a[2] = *hl;
 130:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	x.a[3] = *hh;
 131:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 132:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	return x.rv;
 133:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** }
 134:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 135:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /* ! compare modes */
 136:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** #define MACSC_ABSOLUTE_CMP 0
 137:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** #define MACSC_RELATIVE_CMP 1
 138:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 139:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /** String concatenation by preprocessor used to create proper register names.
 140:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  **/
 141:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** #define CONCAT(a, b) a ## b
 142:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 143:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /** Creates proper subregister names and reads the corresponding values. */
 144:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** #define MACSC_READ32(reg)                  macsc_read32(&CONCAT(reg, HH), \
 145:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		&CONCAT(reg, HL), \
 146:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		&CONCAT(reg, LH), \
 147:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		&CONCAT(reg, LL))
 148:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 149:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** #define MACSC_WRITE32(reg, val)	\
 150:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	do { \
 151:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		union { uint8_t a[4]; uint32_t v; } \
 152:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		x; \
 153:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		x.v = val; \
 154:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		CONCAT(reg, HH) = x.a[3]; \
 155:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		CONCAT(reg, HL) = x.a[2]; \
 156:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		CONCAT(reg, LH) = x.a[1]; \
 157:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		CONCAT(reg, LL) = x.a[0]; \
 158:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	} \
 159:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	while (0)
 160:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 161:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 162:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Enable MAC SC
 163:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 164:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * Enables the SC
 165:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 166:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param clk_src selection of clk source,avalable options in macsc_xtal,fixed
 167:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *  prescalar
 168:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param sleep_enable enable RTC as clock source during sleep
 169:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param auto_ts enable automatic timestamping
 170:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 171:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 172:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** void macsc_enable(void);
 173:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 174:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 175:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Check if MACSC is enabled
 176:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 177:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * check if the MACSC is enabled.
 178:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 179:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param none
 180:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 181:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 182:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** bool is_macsc_enable(void);
 183:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 184:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 185:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Disable MAC SC
 186:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 187:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * Disables the MAC SC
 188:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 189:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param none
 190:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 191:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 192:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** void macsc_disable(void);
 193:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 194:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 195:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Check if back-off slot counter is enabled
 196:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 197:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * check if the back-off slot counter is enabled.
 198:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 199:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param none
 200:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 201:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 202:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** bool is_macsc_backoff_enable(void);
 203:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 204:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 205:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Enables compare interrupts of the MACSC
 206:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 207:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param channel Compare channel
 208:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 209:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** void macsc_enable_cmp_int(enum macsc_cc_channel channel);
 210:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 211:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 212:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Disables compare interrupts of the MACSC
 213:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 214:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param channel Compare channel
 215:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */void macsc_disable_cmp_int(enum macsc_cc_channel channel);
 216:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 217:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 218:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Usage of Absolute compare mode of the MACSC
 219:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 220:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param abs_rel  0 for absoulte cmp;1 for relative cmp
 221:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param cmp compare value for SCOCRx register
 222:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param channel Compare channel
 223:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 224:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** void macsc_use_cmp(bool abs_rel, uint32_t cmp,enum macsc_cc_channel channel);
 225:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 226:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 227:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \ingroup macsc_group
 228:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \defgroup macsc_interrupt_group MAC Symbol Counter (MACSC) interrupt
 229:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * management
 230:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * This group provides functions to configure MACSC module interrupts
 231:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 232:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * @{
 233:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 234:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 235:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 236:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Set MACSC overflow interrupt callback function
 237:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 238:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * This function allows the caller to set and change the interrupt callback
 239:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * function. Without setting a callback function the interrupt handler in the
 240:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * driver will only clear the interrupt flags.
 241:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 242:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param callback Reference to a callback function
 243:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 244:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** void macsc_set_ovf_int_cb(macsc_callback_t callback);
 245:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 246:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 247:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Set MACSC Compare Channel 1 interrupt callback function
 248:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 249:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * This function allows the caller to set and change the interrupt callback
 250:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * function. Without setting a callback function the interrupt handler in the
 251:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * driver will only clear the interrupt flags.
 252:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 253:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param callback Reference to a callback function
 254:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 255:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** void macsc_set_cmp1_int_cb(macsc_callback_t callback);
 256:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 257:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 258:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Set MACSC Compare Channel 2 interrupt callback function
 259:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 260:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * This function allows the caller to set and change the interrupt callback
 261:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * function. Without setting a callback function the interrupt handler in the
 262:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * driver will only clear the interrupt flags.
 263:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 264:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param callback Reference to a callback function
 265:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 266:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** void macsc_set_cmp2_int_cb(macsc_callback_t callback);
 267:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 268:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 269:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Set MACSC Compare Channel 3 interrupt callback function
 270:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 271:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * This function allows the caller to set and change the interrupt callback
 272:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * function. Without setting a callback function the interrupt handler in the
 273:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * driver will only clear the interrupt flags.
 274:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 275:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param callback Reference to a callback function
 276:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 277:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** void macsc_set_cmp3_int_cb(macsc_callback_t callback);
 278:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 279:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 280:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Set MACSC backoff slot counter interrupt callback function
 281:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 282:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * This function allows the caller to set and change the interrupt callback
 283:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * function. Without setting a callback function the interrupt handler in the
 284:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * driver will only clear the interrupt flags.
 285:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 286:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param callback Reference to a callback function
 287:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 288:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** void macsc_set_backoff_slot_cntr_int_cb(macsc_callback_t callback);
 289:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** //@}
 290:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 291:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 292:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Enable 32.768KHz clk using timer 2 async register
 293:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 294:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param none
 295:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 296:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 297:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** static inline void macsc_sleep_clk_enable(void)
 298:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** {
 299:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	ASSR |= (1 << AS2);
 300:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** }
 301:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 302:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 303:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Disable 32.768KHz clk using timer 2 async register
 304:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 305:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param none
 306:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 307:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** static inline void macsc_sleep_clk_disable(void)
 308:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** {
 309:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	ASSR &= ~(1 << AS2);
 310:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** }
 311:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 312:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /* @} */
 313:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 314:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 315:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Configure MAC Symbol Counter Clock Source
 316:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 317:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param macsc macsc clk src
 318:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 319:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** static inline void macsc_write_clock_source(enum macsc_xtal source)
 320:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** {
 321:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	if (source == MACSC_16MHz) {
 322:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		SCCR0 |= (source << SCCKSEL);
 323:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	} else if (source == MACSC_32KHz) {
 324:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		SCCR0 &= ~(1 << SCCKSEL);
 325:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	}
 326:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** }
 327:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 328:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 329:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Read MAC SC Clock Source
 330:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 331:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param none
 332:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \return macsc_xtal enum Clock source selection
 333:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 334:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** static inline enum macsc_xtal macsc_read_clock_source(void)
 335:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** {
 336:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	return (enum macsc_xtal)(SCCR0 & (1 << SCCKSEL));
 337:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** }
 338:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 339:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 340:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Write the Counter value of the MAC Symbol counter
 341:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 342:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param cnt_value Counter value
 343:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 344:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** static inline void macsc_write_count(uint32_t cnt_value)
 345:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** {
 346:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	MACSC_WRITE32(SCCNT, cnt_value);
 347:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** }
 348:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 349:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 350:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Reads the Counter value of the MAC Symbol counter
 351:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 352:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \note Output the Counter value
 353:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 354:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** static inline uint32_t macsc_read_count(void)
 355:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** {
 356:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	return (MACSC_READ32(SCCNT));
 357:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** }
 358:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 359:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 360:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief enable back-off slot counter
 361:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 362:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param none
 363:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \note  Enables interrupt as well	.
 364:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \note This counter works only if transceiver clock is running.So check Trx
 365:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * state in app before using this function in IEEE802.15.4 applications.
 366:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 367:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** static inline bool macsc_backoff_slot_cnt_enable(void)
 368:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** {
 369:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	if (!(PRR1 & (1 << PRTRX24))) {
 370:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		SCCR1 = (1 << SCENBO);
 371:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		SCIRQS |= (1 << IRQSBO);
 372:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		SCIRQM |= (1 << IRQMBO);
 373:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		return true;
 374:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	}
 375:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	else return false;
 376:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** }
 377:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 378:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 379:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Disable back-off slot counter
 380:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 381:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param none
 382:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \note    Disables interrupt as well	.
 383:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \note This counter works only if transceiver clock is running.So check Trx
 384:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * state in app before using this function in IEEE802.15.4 applications.
 385:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 386:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** static inline void macsc_backoff_slot_cnt_disable(void)
 387:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** {
 388:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	SCCR1 &= ~(1 << SCENBO);
 389:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	SCIRQM &= ~(1 << IRQMBO);
 390:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** }
 391:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 392:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 393:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Tests if the Backoff slot cntr interrupt flag is set
 394:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 395:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \return  backoff slot cntr interrupt has occurred or not : IRQSBO
 396:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 397:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** static inline bool macsc_is_slot_cntr_interrupt_flag_set(void)
 398:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** {
 399:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	return (SCIRQS & (1 << IRQSBO));
 400:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** }
 401:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 402:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 403:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Clears the Backoff Slot cntr interrupt flag
 404:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 405:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \note  IRQSBO is cleared
 406:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 407:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** static inline void macsc_clear_slot_cntr_interrupt_flag(void)
 408:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** {
 409:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	SCIRQS |= (1 << IRQSBO);
 410:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** }
 411:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 412:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 413:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Reads the SFD Timestamp register
 414:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 415:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \return Timestamp of last received frame :SCTSR(read-only register)
 416:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 417:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** static inline uint32_t macsc_read_ts(void)
 418:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** {
 419:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	return (MACSC_READ32(SCTSR));
 420:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** }
 421:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 422:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 423:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Reads the Beacon Timestamp register
 424:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 425:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \return Timestamp of last received beacon frame :SCBTSR
 426:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 427:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** static inline uint32_t macsc_read_bts(void)
 428:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** {
 429:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	return (MACSC_READ32(SCBTSR));
 430:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** }
 431:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 432:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 433:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Write the Beacon Timestamp register of the MAC Symbol counter
 434:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * The manual beacon timestamping can be used in conjunction with the
 435:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * relative compare mode of the three compare units to generate compare match
 436:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * interrupts without having a beacon frame received
 437:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 438:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * If set to 1, the current symbol counter value is stored into the beacon
 439:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * timestamp register.
 440:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * The bit is cleared afterwards.
 441:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 442:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 443:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** static inline void macsc_enable_manual_bts(void)
 444:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** {
  26               		.loc 1 444 0
  27               		.cfi_startproc
  28 0000 CF93      		push r28
  29               	.LCFI0:
  30               		.cfi_def_cfa_offset 3
  31               		.cfi_offset 28, -2
  32 0002 DF93      		push r29
  33               	.LCFI1:
  34               		.cfi_def_cfa_offset 4
  35               		.cfi_offset 29, -3
  36 0004 CDB7      		in r28,__SP_L__
  37 0006 DEB7      		in r29,__SP_H__
  38               	.LCFI2:
  39               		.cfi_def_cfa_register 28
  40               	/* prologue: function */
  41               	/* frame size = 0 */
  42               	/* stack size = 2 */
  43               	.L__stack_usage = 2
 445:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	SCCR0 |= (1 << SCMBTS);
  44               		.loc 1 445 0
  45 0008 8CED      		ldi r24,lo8(-36)
  46 000a 90E0      		ldi r25,0
  47 000c 2CED      		ldi r18,lo8(-36)
  48 000e 30E0      		ldi r19,0
  49 0010 F901      		movw r30,r18
  50 0012 2081      		ld r18,Z
  51 0014 2064      		ori r18,lo8(64)
  52 0016 FC01      		movw r30,r24
  53 0018 2083      		st Z,r18
 446:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	SCCR0 &= ~(1 << SCTSE);
  54               		.loc 1 446 0
  55 001a 8CED      		ldi r24,lo8(-36)
  56 001c 90E0      		ldi r25,0
  57 001e 2CED      		ldi r18,lo8(-36)
  58 0020 30E0      		ldi r19,0
  59 0022 F901      		movw r30,r18
  60 0024 2081      		ld r18,Z
  61 0026 277F      		andi r18,lo8(-9)
  62 0028 FC01      		movw r30,r24
  63 002a 2083      		st Z,r18
 447:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** }
  64               		.loc 1 447 0
  65 002c 0000      		nop
  66               	/* epilogue start */
  67 002e DF91      		pop r29
  68 0030 CF91      		pop r28
  69 0032 0895      		ret
  70               		.cfi_endproc
  71               	.LFE96:
  73               		.section	.bss.appState,"aw",@nobits
  76               	appState:
  77 0000 00        		.zero	1
  78               		.section	.bss.msgReq,"aw",@nobits
  81               	msgReq:
  82 0000 0000 0000 		.zero	20
  82      0000 0000 
  82      0000 0000 
  82      0000 0000 
  82      0000 0000 
  83               		.section	.rodata
  84               	.LC0:
  85 0000 0A4D 6573 		.string	"\nMessage Request in Queue"
  85      7361 6765 
  85      2052 6571 
  85      7565 7374 
  85      2069 6E20 
  86               		.text
  88               	appSendData:
  89               	.LFB105:
  90               		.file 2 "ServerLLDN.c"
   1:ServerLLDN.c  **** 	/*
   2:ServerLLDN.c  **** 	 * ServerLLDN.c
   3:ServerLLDN.c  **** 	 *
   4:ServerLLDN.c  **** 	 * Created: 10/18/2019 5:15:37 PM
   5:ServerLLDN.c  **** 	 *  Author: guilh
   6:ServerLLDN.c  **** 	 */ 
   7:ServerLLDN.c  **** 
   8:ServerLLDN.c  **** 	#include <stdlib.h>
   9:ServerLLDN.c  **** 	#include <stdio.h>
  10:ServerLLDN.c  **** 	#include <string.h>
  11:ServerLLDN.c  **** 	#include <inttypes.h>
  12:ServerLLDN.c  **** 	#include "config.h"
  13:ServerLLDN.c  **** 	#include "sys.h"
  14:ServerLLDN.c  **** 	#include "phy.h"
  15:ServerLLDN.c  **** 	#include "sys.h"
  16:ServerLLDN.c  **** 	#include "nwk.h"
  17:ServerLLDN.c  **** 	#include "sysclk.h"
  18:ServerLLDN.c  **** 	#include "sysTimer.h"
  19:ServerLLDN.c  **** 	#include "sleep_mgr.h"
  20:ServerLLDN.c  **** 	#include "sleepmgr.h"
  21:ServerLLDN.c  **** 	#include "led.h"
  22:ServerLLDN.c  **** 	#include "ioport.h"
  23:ServerLLDN.c  **** 	#include "conf_sleepmgr.h"
  24:ServerLLDN.c  **** 	#include "board.h"
  25:ServerLLDN.c  **** 	// #include "Solver.h"
  26:ServerLLDN.c  **** 	// #include "Energy.h"
  27:ServerLLDN.c  **** 	#include "platform.h"
  28:ServerLLDN.c  **** 
  29:ServerLLDN.c  **** #if APP_COORDINATOR
  30:ServerLLDN.c  **** 	#if (SIO2HOST_CHANNEL == SIO_USB)
  31:ServerLLDN.c  **** 		/* Only ARM */
  32:ServerLLDN.c  **** 		#include "stdio_usb.h"
  33:ServerLLDN.c  **** 		#define MASTER_MACSC	0
  34:ServerLLDN.c  **** 	#else
  35:ServerLLDN.c  **** 		/* Only megarf series */
  36:ServerLLDN.c  **** 		#include "conf_sio2host.h"
  37:ServerLLDN.c  **** 		#define MASTER_MACSC	1
  38:ServerLLDN.c  **** 	#endif
  39:ServerLLDN.c  **** #else
  40:ServerLLDN.c  **** 	/* Only megarf series */
  41:ServerLLDN.c  **** 	#define MASTER_MACSC		1
  42:ServerLLDN.c  **** #endif
  43:ServerLLDN.c  **** 
  44:ServerLLDN.c  **** #define HUMAM_READABLE			1
  45:ServerLLDN.c  **** 
  46:ServerLLDN.c  **** #define seconds_3  3 / SYMBOL_TIME 
  47:ServerLLDN.c  **** #define disc_mode	0b100
  48:ServerLLDN.c  **** #define config_mode 0b110
  49:ServerLLDN.c  **** 
  50:ServerLLDN.c  **** 
  51:ServerLLDN.c  **** typedef enum AppState_t {
  52:ServerLLDN.c  **** 	APP_STATE_INITIAL,
  53:ServerLLDN.c  **** 	APP_STATE_IDLE,
  54:ServerLLDN.c  **** 	APP_STATE_SEND,
  55:ServerLLDN.c  **** 	APP_STATE_ATT_PAN_STATE,
  56:ServerLLDN.c  **** 	APP_STATE_PREP_DISC_REPONSE,
  57:ServerLLDN.c  **** 	APP_STATE_CONFIG_INIT
  58:ServerLLDN.c  **** } AppState_t;
  59:ServerLLDN.c  **** 
  60:ServerLLDN.c  **** #if (MASTER_MACSC == 1)
  61:ServerLLDN.c  **** 	#include "macsc_megarf.h"
  62:ServerLLDN.c  **** #else
  63:ServerLLDN.c  **** 	static SYS_Timer_t				tmrBeaconInterval;			// Beacon
  64:ServerLLDN.c  **** 	static SYS_Timer_t				tmrComputeData;				// Compute data
  65:ServerLLDN.c  **** #endif
  66:ServerLLDN.c  **** 	
  67:ServerLLDN.c  **** // equation for tTS gives time in seconds, the division by SYMBOL_TIME changes to symbols for count
  68:ServerLLDN.c  **** static volatile AppState_t		appState					= APP_STATE_INITIAL;
  69:ServerLLDN.c  **** static NWK_DataReq_t msgReq;
  70:ServerLLDN.c  **** 
  71:ServerLLDN.c  **** static void appSendData(void)
  72:ServerLLDN.c  **** {
  91               		.loc 2 72 0
  92               		.cfi_startproc
  93 0034 CF93      		push r28
  94               	.LCFI3:
  95               		.cfi_def_cfa_offset 3
  96               		.cfi_offset 28, -2
  97 0036 DF93      		push r29
  98               	.LCFI4:
  99               		.cfi_def_cfa_offset 4
 100               		.cfi_offset 29, -3
 101 0038 CDB7      		in r28,__SP_L__
 102 003a DEB7      		in r29,__SP_H__
 103               	.LCFI5:
 104               		.cfi_def_cfa_register 28
 105               	/* prologue: function */
 106               	/* frame size = 0 */
 107               	/* stack size = 2 */
 108               	.L__stack_usage = 2
  73:ServerLLDN.c  **** 	if(msgReq.options)
 109               		.loc 2 73 0
 110 003c 8091 0000 		lds r24,msgReq+9
 111 0040 9091 0000 		lds r25,msgReq+9+1
 112 0044 892B      		or r24,r25
 113 0046 01F0      		breq .L4
  74:ServerLLDN.c  **** 	{
  75:ServerLLDN.c  **** 		printf("\nMessage Request in Queue");
 114               		.loc 2 75 0
 115 0048 80E0      		ldi r24,lo8(.LC0)
 116 004a 90E0      		ldi r25,hi8(.LC0)
 117 004c 892F      		mov r24,r25
 118 004e 8F93      		push r24
 119 0050 80E0      		ldi r24,lo8(.LC0)
 120 0052 90E0      		ldi r25,hi8(.LC0)
 121 0054 8F93      		push r24
 122 0056 0E94 0000 		call printf
 123 005a 0F90      		pop __tmp_reg__
 124 005c 0F90      		pop __tmp_reg__
  76:ServerLLDN.c  **** 		NWK_DataReq(&msgReq);
 125               		.loc 2 76 0
 126 005e 80E0      		ldi r24,lo8(msgReq)
 127 0060 90E0      		ldi r25,hi8(msgReq)
 128 0062 0E94 0000 		call NWK_DataReq
 129               	.L4:
  77:ServerLLDN.c  **** 	}
  78:ServerLLDN.c  **** }
 130               		.loc 2 78 0
 131 0066 0000      		nop
 132               	/* epilogue start */
 133 0068 DF91      		pop r29
 134 006a CF91      		pop r28
 135 006c 0895      		ret
 136               		.cfi_endproc
 137               	.LFE105:
 139               		.section	.bss.rec_beacon,"aw",@nobits
 142               	rec_beacon:
 143 0000 0000      		.zero	2
 144               		.section	.bss.msgDiscResponse,"aw",@nobits
 147               	msgDiscResponse:
 148 0000 0000 0000 		.zero	4
 149               		.section	.bss.payloadSize,"aw",@nobits
 152               	payloadSize:
 153 0000 0000      		.zero	2
 154               		.text
 156               	send_message_timeHandler:
 157               	.LFB106:
  79:ServerLLDN.c  **** 
  80:ServerLLDN.c  **** #if APP_COORDINATOR
  81:ServerLLDN.c  **** 
  82:ServerLLDN.c  **** 	typedef enum AppPanState_t {
  83:ServerLLDN.c  **** 		APP_PAN_STATE_IDLE,
  84:ServerLLDN.c  **** 		APP_PAN_STATE_DISC_INITIAL,
  85:ServerLLDN.c  **** 		APP_PAN_STATE_DISC_SECOND_BE,
  86:ServerLLDN.c  **** 		APP_PAN_STATE_DISC_PREPARE_ACK,
  87:ServerLLDN.c  **** 	} AppPanState_t;
  88:ServerLLDN.c  **** 
  89:ServerLLDN.c  **** 	static float	beaconInterval;	
  90:ServerLLDN.c  **** 	static volatile AppPanState_t appPanState = APP_PAN_STATE_DISC_INITIAL;
  91:ServerLLDN.c  **** 	
  92:ServerLLDN.c  **** 	static void lldn_server_beacon(void)
  93:ServerLLDN.c  **** 	{
  94:ServerLLDN.c  **** 		macsc_enable_manual_bts();
  95:ServerLLDN.c  **** 		appState = APP_STATE_SEND;
  96:ServerLLDN.c  **** 	}
  97:ServerLLDN.c  **** 
  98:ServerLLDN.c  **** 	static void appPanDiscInit(void)
  99:ServerLLDN.c  **** 	{
 100:ServerLLDN.c  **** 		/* 
 101:ServerLLDN.c  **** 		* Disable CSMA/CA
 102:ServerLLDN.c  **** 		* Disable auto ACK
 103:ServerLLDN.c  **** 		*/
 104:ServerLLDN.c  **** 		PHY_SetTdmaMode(true);
 105:ServerLLDN.c  **** 		/* Prepare Beacon Message as first beacon in discovery state */
 106:ServerLLDN.c  **** 		msgReq.dstAddr				= 0;
 107:ServerLLDN.c  **** 		msgReq.dstEndpoint			= APP_BEACON_ENDPOINT;
 108:ServerLLDN.c  **** 		msgReq.srcEndpoint			= APP_BEACON_ENDPOINT;
 109:ServerLLDN.c  **** 		msgReq.options				= NWK_OPT_LLDN_BEACON | NWK_OPT_DISCOVERY_STATE;
 110:ServerLLDN.c  **** 		msgReq.data					= NULL;
 111:ServerLLDN.c  **** 		msgReq.size					= 0;
 112:ServerLLDN.c  **** 		/* Calculates Beacon Intervals according to 802.15.4e - 2012 p. 70 */
 113:ServerLLDN.c  **** 		n = 255; // octets
 114:ServerLLDN.c  **** 		tTS =  1.5; //((p_var*sp + (m+n)*sm + macMinLIFSPeriod)/v_var); // 0.009088 seconds with n = 255 
 115:ServerLLDN.c  **** 		#if (MASTER_MACSC == 1)
 116:ServerLLDN.c  **** 			/* 
 117:ServerLLDN.c  **** 			* Beacon Interval values:
 118:ServerLLDN.c  **** 			* 2 x (0.009088 seconds) / (0.000016 seconds) = 1136 symbols
 119:ServerLLDN.c  **** 			* 1136 symbols = 0.0018176 seconds
 120:ServerLLDN.c  **** 			*/ 
 121:ServerLLDN.c  **** 			beaconInterval = numMgmtTs_Disc_Conf * (tTS) / (SYMBOL_TIME);
 122:ServerLLDN.c  **** 			/*
 123:ServerLLDN.c  **** 			* Configure interrupts callback functions
 124:ServerLLDN.c  **** 			* overflow interrupt, compare 1,2,3 interrupts
 125:ServerLLDN.c  **** 			*/
 126:ServerLLDN.c  **** 			macsc_set_cmp1_int_cb(lldn_server_beacon);
 127:ServerLLDN.c  **** 			/*
 128:ServerLLDN.c  **** 			* Configure MACSC to generate compare interrupts from channels 1,2,3
 129:ServerLLDN.c  **** 			* Set compare mode to absolute, set compare value.
 130:ServerLLDN.c  **** 			*/
 131:ServerLLDN.c  **** 			macsc_enable_manual_bts();
 132:ServerLLDN.c  **** 			macsc_enable_cmp_int(MACSC_CC1);
 133:ServerLLDN.c  **** 			macsc_use_cmp(MACSC_RELATIVE_CMP, beaconInterval , MACSC_CC1);
 134:ServerLLDN.c  **** 		#endif
 135:ServerLLDN.c  **** 	}
 136:ServerLLDN.c  **** 
 137:ServerLLDN.c  **** #else 
 138:ServerLLDN.c  **** 
 139:ServerLLDN.c  **** 	static NwkFrameBeaconHeaderLLDN_t *rec_beacon;
 140:ServerLLDN.c  **** 	static NWK_DiscoverResponse_t msgDiscResponse;
 141:ServerLLDN.c  **** 	static int payloadSize;
 142:ServerLLDN.c  **** 	
 143:ServerLLDN.c  **** 	static void send_message_timeHandler(void)
 144:ServerLLDN.c  **** 	{
 158               		.loc 2 144 0
 159               		.cfi_startproc
 160 006e CF93      		push r28
 161               	.LCFI6:
 162               		.cfi_def_cfa_offset 3
 163               		.cfi_offset 28, -2
 164 0070 DF93      		push r29
 165               	.LCFI7:
 166               		.cfi_def_cfa_offset 4
 167               		.cfi_offset 29, -3
 168 0072 CDB7      		in r28,__SP_L__
 169 0074 DEB7      		in r29,__SP_H__
 170               	.LCFI8:
 171               		.cfi_def_cfa_register 28
 172               	/* prologue: function */
 173               	/* frame size = 0 */
 174               	/* stack size = 2 */
 175               	.L__stack_usage = 2
 145:ServerLLDN.c  **** 		appState = APP_STATE_SEND;
 176               		.loc 2 145 0
 177 0076 82E0      		ldi r24,lo8(2)
 178 0078 8093 0000 		sts appState,r24
 146:ServerLLDN.c  **** 	}
 179               		.loc 2 146 0
 180 007c 0000      		nop
 181               	/* epilogue start */
 182 007e DF91      		pop r29
 183 0080 CF91      		pop r28
 184 0082 0895      		ret
 185               		.cfi_endproc
 186               	.LFE106:
 189               	appBeaconInd:
 190               	.LFB107:
 147:ServerLLDN.c  **** 	static bool appBeaconInd(NWK_DataInd_t *ind)
 148:ServerLLDN.c  **** 	{
 191               		.loc 2 148 0
 192               		.cfi_startproc
 193 0084 CF93      		push r28
 194               	.LCFI9:
 195               		.cfi_def_cfa_offset 3
 196               		.cfi_offset 28, -2
 197 0086 DF93      		push r29
 198               	.LCFI10:
 199               		.cfi_def_cfa_offset 4
 200               		.cfi_offset 29, -3
 201 0088 00D0      		rcall .
 202 008a 00D0      		rcall .
 203               	.LCFI11:
 204               		.cfi_def_cfa_offset 8
 205 008c CDB7      		in r28,__SP_L__
 206 008e DEB7      		in r29,__SP_H__
 207               	.LCFI12:
 208               		.cfi_def_cfa_register 28
 209               	/* prologue: function */
 210               	/* frame size = 4 */
 211               	/* stack size = 6 */
 212               	.L__stack_usage = 6
 213 0090 9C83      		std Y+4,r25
 214 0092 8B83      		std Y+3,r24
 149:ServerLLDN.c  **** 		macsc_enable_manual_bts();
 215               		.loc 2 149 0
 216 0094 0E94 0000 		call macsc_enable_manual_bts
 150:ServerLLDN.c  **** 		rec_beacon = (NwkFrameBeaconHeaderLLDN_t*)ind->data;
 217               		.loc 2 150 0
 218 0098 8B81      		ldd r24,Y+3
 219 009a 9C81      		ldd r25,Y+4
 220 009c FC01      		movw r30,r24
 221 009e 8085      		ldd r24,Z+8
 222 00a0 9185      		ldd r25,Z+9
 223 00a2 9093 0000 		sts rec_beacon+1,r25
 224 00a6 8093 0000 		sts rec_beacon,r24
 151:ServerLLDN.c  **** 	
 152:ServerLLDN.c  **** 		if(rec_beacon->Flags.txState == disc_mode ||
 225               		.loc 2 152 0
 226 00aa 8091 0000 		lds r24,rec_beacon
 227 00ae 9091 0000 		lds r25,rec_beacon+1
 228 00b2 FC01      		movw r30,r24
 229 00b4 8381      		ldd r24,Z+3
 230 00b6 8770      		andi r24,lo8(7)
 231 00b8 8430      		cpi r24,lo8(4)
 232 00ba 01F0      		breq .L7
 153:ServerLLDN.c  **** 			rec_beacon->Flags.txState == config_mode)
 233               		.loc 2 153 0 discriminator 1
 234 00bc 8091 0000 		lds r24,rec_beacon
 235 00c0 9091 0000 		lds r25,rec_beacon+1
 236 00c4 FC01      		movw r30,r24
 237 00c6 8381      		ldd r24,Z+3
 238 00c8 8770      		andi r24,lo8(7)
 152:ServerLLDN.c  **** 			rec_beacon->Flags.txState == config_mode)
 239               		.loc 2 152 0 discriminator 1
 240 00ca 8630      		cpi r24,lo8(6)
 241 00cc 01F4      		brne .L8
 242               	.L7:
 243               	.LBB2:
 154:ServerLLDN.c  **** 		{
 155:ServerLLDN.c  **** 			int msg_wait_time = rec_beacon->TimeSlotSize;
 244               		.loc 2 155 0
 245 00ce 8091 0000 		lds r24,rec_beacon
 246 00d2 9091 0000 		lds r25,rec_beacon+1
 247 00d6 FC01      		movw r30,r24
 248 00d8 8681      		ldd r24,Z+6
 249 00da 882F      		mov r24,r24
 250 00dc 90E0      		ldi r25,0
 251 00de 9A83      		std Y+2,r25
 252 00e0 8983      		std Y+1,r24
 156:ServerLLDN.c  **** 			macsc_use_cmp(MACSC_RELATIVE_CMP, msg_wait_time , MACSC_CC1);
 253               		.loc 2 156 0
 254 00e2 8981      		ldd r24,Y+1
 255 00e4 9A81      		ldd r25,Y+2
 256 00e6 092E      		mov __tmp_reg__,r25
 257 00e8 000C      		lsl r0
 258 00ea AA0B      		sbc r26,r26
 259 00ec BB0B      		sbc r27,r27
 260 00ee 21E0      		ldi r18,lo8(1)
 261 00f0 AC01      		movw r20,r24
 262 00f2 BD01      		movw r22,r26
 263 00f4 81E0      		ldi r24,lo8(1)
 264 00f6 0E94 0000 		call macsc_use_cmp
 157:ServerLLDN.c  **** 			appState = (rec_beacon->Flags.txState == disc_mode) ? APP_STATE_PREP_DISC_REPONSE : APP_STATE_CO
 265               		.loc 2 157 0
 266 00fa 8091 0000 		lds r24,rec_beacon
 267 00fe 9091 0000 		lds r25,rec_beacon+1
 268 0102 FC01      		movw r30,r24
 269 0104 8381      		ldd r24,Z+3
 270 0106 8770      		andi r24,lo8(7)
 271 0108 8430      		cpi r24,lo8(4)
 272 010a 01F4      		brne .L9
 273               		.loc 2 157 0 is_stmt 0 discriminator 1
 274 010c 84E0      		ldi r24,lo8(4)
 275 010e 00C0      		rjmp .L10
 276               	.L9:
 277               		.loc 2 157 0 discriminator 2
 278 0110 85E0      		ldi r24,lo8(5)
 279               	.L10:
 280               		.loc 2 157 0 discriminator 4
 281 0112 8093 0000 		sts appState,r24
 282               	.L8:
 283               	.LBE2:
 158:ServerLLDN.c  **** 		}
 159:ServerLLDN.c  **** 	}
 284               		.loc 2 159 0 is_stmt 1
 285 0116 0000      		nop
 286               	/* epilogue start */
 287 0118 0F90      		pop __tmp_reg__
 288 011a 0F90      		pop __tmp_reg__
 289 011c 0F90      		pop __tmp_reg__
 290 011e 0F90      		pop __tmp_reg__
 291 0120 DF91      		pop r29
 292 0122 CF91      		pop r28
 293 0124 0895      		ret
 294               		.cfi_endproc
 295               	.LFE107:
 297               	.global	appPrepareDiscoverResponse
 299               	appPrepareDiscoverResponse:
 300               	.LFB108:
 160:ServerLLDN.c  **** 	void appPrepareDiscoverResponse()
 161:ServerLLDN.c  **** 	{
 301               		.loc 2 161 0
 302               		.cfi_startproc
 303 0126 CF93      		push r28
 304               	.LCFI13:
 305               		.cfi_def_cfa_offset 3
 306               		.cfi_offset 28, -2
 307 0128 DF93      		push r29
 308               	.LCFI14:
 309               		.cfi_def_cfa_offset 4
 310               		.cfi_offset 29, -3
 311 012a CDB7      		in r28,__SP_L__
 312 012c DEB7      		in r29,__SP_H__
 313               	.LCFI15:
 314               		.cfi_def_cfa_register 28
 315               	/* prologue: function */
 316               	/* frame size = 0 */
 317               	/* stack size = 2 */
 318               	.L__stack_usage = 2
 162:ServerLLDN.c  **** 		/* CONTINUAR IMPLEMENTAO */
 163:ServerLLDN.c  **** 		msgDiscResponse.id					= LL_DISCOVER_RESPONSE;
 319               		.loc 2 163 0
 320 012e 8DE0      		ldi r24,lo8(13)
 321 0130 8093 0000 		sts msgDiscResponse,r24
 164:ServerLLDN.c  **** 		msgDiscResponse.macAddr				= APP_ADDR;
 322               		.loc 2 164 0
 323 0134 81E0      		ldi r24,lo8(1)
 324 0136 90E0      		ldi r25,0
 325 0138 9093 0000 		sts msgDiscResponse+1+1,r25
 326 013c 8093 0000 		sts msgDiscResponse+1,r24
 165:ServerLLDN.c  **** 		msgDiscResponse.ts_dir.tsDuration	= payloadSize;
 327               		.loc 2 165 0
 328 0140 8091 0000 		lds r24,payloadSize
 329 0144 9091 0000 		lds r25,payloadSize+1
 330 0148 8F77      		andi r24,lo8(127)
 331 014a 8F77      		andi r24,lo8(127)
 332 014c 9091 0000 		lds r25,msgDiscResponse+3
 333 0150 9078      		andi r25,lo8(-128)
 334 0152 892B      		or r24,r25
 335 0154 8093 0000 		sts msgDiscResponse+3,r24
 166:ServerLLDN.c  **** 		msgDiscResponse.ts_dir.dirIndicator = 1;
 336               		.loc 2 166 0
 337 0158 8091 0000 		lds r24,msgDiscResponse+3
 338 015c 8068      		ori r24,lo8(-128)
 339 015e 8093 0000 		sts msgDiscResponse+3,r24
 167:ServerLLDN.c  **** 		
 168:ServerLLDN.c  **** 		msgReq.dstAddr				= 0;
 340               		.loc 2 168 0
 341 0162 1092 0000 		sts msgReq+5+1,__zero_reg__
 342 0166 1092 0000 		sts msgReq+5,__zero_reg__
 169:ServerLLDN.c  **** 		msgReq.dstEndpoint			= APP_COMMAND_ENDPOINT;
 343               		.loc 2 169 0
 344 016a 83E0      		ldi r24,lo8(3)
 345 016c 8093 0000 		sts msgReq+7,r24
 170:ServerLLDN.c  **** 		msgReq.srcEndpoint			= APP_COMMAND_ENDPOINT;
 346               		.loc 2 170 0
 347 0170 83E0      		ldi r24,lo8(3)
 348 0172 8093 0000 		sts msgReq+8,r24
 171:ServerLLDN.c  **** 		msgReq.options				= NWK_OPT_MAC_COMMAND;
 349               		.loc 2 171 0
 350 0176 80E0      		ldi r24,0
 351 0178 90E8      		ldi r25,lo8(-128)
 352 017a 9093 0000 		sts msgReq+9+1,r25
 353 017e 8093 0000 		sts msgReq+9,r24
 172:ServerLLDN.c  **** 		msgReq.data					= (uint8_t*)&msgDiscResponse;
 354               		.loc 2 172 0
 355 0182 80E0      		ldi r24,lo8(msgDiscResponse)
 356 0184 90E0      		ldi r25,hi8(msgDiscResponse)
 357 0186 9093 0000 		sts msgReq+13+1,r25
 358 018a 8093 0000 		sts msgReq+13,r24
 173:ServerLLDN.c  **** 		msgReq.size					= sizeof(msgDiscResponse);
 359               		.loc 2 173 0
 360 018e 84E0      		ldi r24,lo8(4)
 361 0190 8093 0000 		sts msgReq+15,r24
 174:ServerLLDN.c  **** 	}
 362               		.loc 2 174 0
 363 0194 0000      		nop
 364               	/* epilogue start */
 365 0196 DF91      		pop r29
 366 0198 CF91      		pop r28
 367 019a 0895      		ret
 368               		.cfi_endproc
 369               	.LFE108:
 371               		.section	.rodata
 372               	.LC1:
 373 001a 0A49 6E69 		.string	"\nIniciando...."
 373      6369 616E 
 373      646F 2E2E 
 373      2E2E 00
 374               		.text
 376               	appInit:
 377               	.LFB109:
 175:ServerLLDN.c  **** #endif // APP_COORDINATOR
 176:ServerLLDN.c  **** 
 177:ServerLLDN.c  **** static void appInit(void)
 178:ServerLLDN.c  **** {
 378               		.loc 2 178 0
 379               		.cfi_startproc
 380 019c CF93      		push r28
 381               	.LCFI16:
 382               		.cfi_def_cfa_offset 3
 383               		.cfi_offset 28, -2
 384 019e DF93      		push r29
 385               	.LCFI17:
 386               		.cfi_def_cfa_offset 4
 387               		.cfi_offset 29, -3
 388 01a0 CDB7      		in r28,__SP_L__
 389 01a2 DEB7      		in r29,__SP_H__
 390               	.LCFI18:
 391               		.cfi_def_cfa_register 28
 392               	/* prologue: function */
 393               	/* frame size = 0 */
 394               	/* stack size = 2 */
 395               	.L__stack_usage = 2
 179:ServerLLDN.c  **** 	printf("\nIniciando....");
 396               		.loc 2 179 0
 397 01a4 80E0      		ldi r24,lo8(.LC1)
 398 01a6 90E0      		ldi r25,hi8(.LC1)
 399 01a8 892F      		mov r24,r25
 400 01aa 8F93      		push r24
 401 01ac 80E0      		ldi r24,lo8(.LC1)
 402 01ae 90E0      		ldi r25,hi8(.LC1)
 403 01b0 8F93      		push r24
 404 01b2 0E94 0000 		call printf
 405 01b6 0F90      		pop __tmp_reg__
 406 01b8 0F90      		pop __tmp_reg__
 180:ServerLLDN.c  **** 	NWK_SetAddr(APP_ADDR);
 407               		.loc 2 180 0
 408 01ba 81E0      		ldi r24,lo8(1)
 409 01bc 90E0      		ldi r25,0
 410 01be 0E94 0000 		call NWK_SetAddr
 181:ServerLLDN.c  **** 	NWK_SetPanId(APP_PANID);
 411               		.loc 2 181 0
 412 01c2 8EEF      		ldi r24,lo8(-2)
 413 01c4 9AEC      		ldi r25,lo8(-54)
 414 01c6 0E94 0000 		call NWK_SetPanId
 182:ServerLLDN.c  **** 	PHY_SetChannel(APP_CHANNEL);
 415               		.loc 2 182 0
 416 01ca 8FE0      		ldi r24,lo8(15)
 417 01cc 0E94 0000 		call PHY_SetChannel
 183:ServerLLDN.c  **** 	PHY_SetRxState(true);
 418               		.loc 2 183 0
 419 01d0 81E0      		ldi r24,lo8(1)
 420 01d2 0E94 0000 		call PHY_SetRxState
 184:ServerLLDN.c  **** 		
 185:ServerLLDN.c  **** 	#if APP_COORDINATOR
 186:ServerLLDN.c  **** 	#else
 187:ServerLLDN.c  **** 			PHY_SetTdmaMode(false);
 421               		.loc 2 187 0
 422 01d6 80E0      		ldi r24,0
 423 01d8 0E94 0000 		call PHY_SetTdmaMode
 188:ServerLLDN.c  **** 			payloadSize = 1;
 424               		.loc 2 188 0
 425 01dc 81E0      		ldi r24,lo8(1)
 426 01de 90E0      		ldi r25,0
 427 01e0 9093 0000 		sts payloadSize+1,r25
 428 01e4 8093 0000 		sts payloadSize,r24
 189:ServerLLDN.c  **** 			NWK_OpenEndpoint(APP_BEACON_ENDPOINT, appBeaconInd);
 429               		.loc 2 189 0
 430 01e8 60E0      		ldi r22,lo8(gs(appBeaconInd))
 431 01ea 70E0      		ldi r23,hi8(gs(appBeaconInd))
 432 01ec 80E0      		ldi r24,0
 433 01ee 0E94 0000 		call NWK_OpenEndpoint
 190:ServerLLDN.c  **** 			/*
 191:ServerLLDN.c  **** 			* Configure interrupts callback functions
 192:ServerLLDN.c  **** 			*/
 193:ServerLLDN.c  **** 			macsc_set_cmp1_int_cb(send_message_timeHandler);
 434               		.loc 2 193 0
 435 01f2 80E0      		ldi r24,lo8(gs(send_message_timeHandler))
 436 01f4 90E0      		ldi r25,hi8(gs(send_message_timeHandler))
 437 01f6 0E94 0000 		call macsc_set_cmp1_int_cb
 194:ServerLLDN.c  **** 			macsc_enable_cmp_int(MACSC_CC1);	  
 438               		.loc 2 194 0
 439 01fa 81E0      		ldi r24,lo8(1)
 440 01fc 0E94 0000 		call macsc_enable_cmp_int
 195:ServerLLDN.c  **** 	#endif // APP_COORDENATOR
 196:ServerLLDN.c  **** 
 197:ServerLLDN.c  **** }
 441               		.loc 2 197 0
 442 0200 0000      		nop
 443               	/* epilogue start */
 444 0202 DF91      		pop r29
 445 0204 CF91      		pop r28
 446 0206 0895      		ret
 447               		.cfi_endproc
 448               	.LFE109:
 451               	APP_TaskHandler:
 452               	.LFB110:
 198:ServerLLDN.c  **** 
 199:ServerLLDN.c  **** 	static void APP_TaskHandler(void)
 200:ServerLLDN.c  **** 	{
 453               		.loc 2 200 0
 454               		.cfi_startproc
 455 0208 CF93      		push r28
 456               	.LCFI19:
 457               		.cfi_def_cfa_offset 3
 458               		.cfi_offset 28, -2
 459 020a DF93      		push r29
 460               	.LCFI20:
 461               		.cfi_def_cfa_offset 4
 462               		.cfi_offset 29, -3
 463 020c CDB7      		in r28,__SP_L__
 464 020e DEB7      		in r29,__SP_H__
 465               	.LCFI21:
 466               		.cfi_def_cfa_register 28
 467               	/* prologue: function */
 468               	/* frame size = 0 */
 469               	/* stack size = 2 */
 470               	.L__stack_usage = 2
 201:ServerLLDN.c  **** 		switch (appState){
 471               		.loc 2 201 0
 472 0210 8091 0000 		lds r24,appState
 473 0214 882F      		mov r24,r24
 474 0216 90E0      		ldi r25,0
 475 0218 8230      		cpi r24,2
 476 021a 9105      		cpc r25,__zero_reg__
 477 021c 01F0      		breq .L15
 478 021e 8430      		cpi r24,4
 479 0220 9105      		cpc r25,__zero_reg__
 480 0222 01F0      		breq .L16
 481 0224 892B      		or r24,r25
 482 0226 01F0      		breq .L17
 202:ServerLLDN.c  **** 			case APP_STATE_INITIAL:
 203:ServerLLDN.c  **** 			{
 204:ServerLLDN.c  **** 				appInit();
 205:ServerLLDN.c  **** 				#if APP_COORDINATOR
 206:ServerLLDN.c  **** 					appState = APP_STATE_ATT_PAN_STATE;
 207:ServerLLDN.c  **** 				#else
 208:ServerLLDN.c  **** 					appState = APP_STATE_IDLE;
 209:ServerLLDN.c  **** 				#endif
 210:ServerLLDN.c  **** 				break;
 211:ServerLLDN.c  **** 			}
 212:ServerLLDN.c  **** 			case APP_STATE_SEND:
 213:ServerLLDN.c  **** 			{
 214:ServerLLDN.c  **** 				appSendData();
 215:ServerLLDN.c  **** 				#if APP_COORDINATOR
 216:ServerLLDN.c  **** 					appState = APP_STATE_ATT_PAN_STATE;
 217:ServerLLDN.c  **** 				#else
 218:ServerLLDN.c  **** 					appState = APP_STATE_IDLE;
 219:ServerLLDN.c  **** 				#endif
 220:ServerLLDN.c  **** 				break;
 221:ServerLLDN.c  **** 			}
 222:ServerLLDN.c  **** 			#if APP_COORDINATOR // COORDINATOR SPECIFIC STATE MACHINE
 223:ServerLLDN.c  **** 			case APP_STATE_ATT_PAN_STATE:
 224:ServerLLDN.c  **** 			{
 225:ServerLLDN.c  **** 				switch(appPanState){
 226:ServerLLDN.c  **** 					case APP_PAN_STATE_DISC_INITIAL:
 227:ServerLLDN.c  **** 					{
 228:ServerLLDN.c  **** 						appPanDiscInit();
 229:ServerLLDN.c  **** 						appState	= APP_STATE_IDLE;
 230:ServerLLDN.c  **** 						appPanState = APP_PAN_STATE_DISC_SECOND_BE;
 231:ServerLLDN.c  **** 						break;
 232:ServerLLDN.c  **** 					}
 233:ServerLLDN.c  **** 					case APP_PAN_STATE_DISC_SECOND_BE:
 234:ServerLLDN.c  **** 					{
 235:ServerLLDN.c  **** 						msgReq.options = NWK_OPT_LLDN_BEACON | NWK_OPT_DISCOVERY_STATE | NWK_OPT_SECOND_BEACON ;
 236:ServerLLDN.c  **** 						appState	= APP_STATE_IDLE;
 237:ServerLLDN.c  **** 						appPanState = APP_PAN_STATE_DISC_PREPARE_ACK;
 238:ServerLLDN.c  **** 						break;
 239:ServerLLDN.c  **** 					}
 240:ServerLLDN.c  **** 					case APP_PAN_STATE_DISC_PREPARE_ACK:
 241:ServerLLDN.c  **** 					{
 242:ServerLLDN.c  **** 						/* CONTINUAR APS IMPLEMENTAR NODE DISCOVERY RESPONSE ANTES*/
 243:ServerLLDN.c  **** 						msgReq.options = 0;
 244:ServerLLDN.c  **** 						appState	= APP_STATE_IDLE;
 245:ServerLLDN.c  **** 						appPanState = APP_PAN_STATE_IDLE;
 246:ServerLLDN.c  **** 						break;
 247:ServerLLDN.c  **** 					}
 248:ServerLLDN.c  **** 					default:
 249:ServerLLDN.c  **** 					{
 250:ServerLLDN.c  **** 						appState = APP_STATE_IDLE;
 251:ServerLLDN.c  **** 					}
 252:ServerLLDN.c  **** 					break;
 253:ServerLLDN.c  **** 				}
 254:ServerLLDN.c  **** 				break;	
 255:ServerLLDN.c  **** 			}
 256:ServerLLDN.c  **** 			#else // NODES SPECIFIC STATE MACHINE
 257:ServerLLDN.c  **** 				case APP_STATE_PREP_DISC_REPONSE:
 258:ServerLLDN.c  **** 				{
 259:ServerLLDN.c  **** 					if(rec_beacon->confSeqNumber == 0)
 260:ServerLLDN.c  **** 						appPrepareDiscoverResponse();
 261:ServerLLDN.c  **** 					else
 262:ServerLLDN.c  **** 						appState = APP_STATE_IDLE;
 263:ServerLLDN.c  **** 					break;
 264:ServerLLDN.c  **** 				}
 265:ServerLLDN.c  **** 			#endif
 266:ServerLLDN.c  **** 			default:
 267:ServerLLDN.c  **** 			break;
 483               		.loc 2 267 0
 484 0228 00C0      		rjmp .L18
 485               	.L17:
 204:ServerLLDN.c  **** 				#if APP_COORDINATOR
 486               		.loc 2 204 0
 487 022a 0E94 0000 		call appInit
 208:ServerLLDN.c  **** 				#endif
 488               		.loc 2 208 0
 489 022e 81E0      		ldi r24,lo8(1)
 490 0230 8093 0000 		sts appState,r24
 210:ServerLLDN.c  **** 			}
 491               		.loc 2 210 0
 492 0234 00C0      		rjmp .L18
 493               	.L15:
 214:ServerLLDN.c  **** 				#if APP_COORDINATOR
 494               		.loc 2 214 0
 495 0236 0E94 0000 		call appSendData
 218:ServerLLDN.c  **** 				#endif
 496               		.loc 2 218 0
 497 023a 81E0      		ldi r24,lo8(1)
 498 023c 8093 0000 		sts appState,r24
 220:ServerLLDN.c  **** 			}
 499               		.loc 2 220 0
 500 0240 00C0      		rjmp .L18
 501               	.L16:
 259:ServerLLDN.c  **** 						appPrepareDiscoverResponse();
 502               		.loc 2 259 0
 503 0242 8091 0000 		lds r24,rec_beacon
 504 0246 9091 0000 		lds r25,rec_beacon+1
 505 024a FC01      		movw r30,r24
 506 024c 8581      		ldd r24,Z+5
 507 024e 8823      		tst r24
 508 0250 01F4      		brne .L19
 260:ServerLLDN.c  **** 					else
 509               		.loc 2 260 0
 510 0252 0E94 0000 		call appPrepareDiscoverResponse
 263:ServerLLDN.c  **** 				}
 511               		.loc 2 263 0
 512 0256 00C0      		rjmp .L21
 513               	.L19:
 262:ServerLLDN.c  **** 					break;
 514               		.loc 2 262 0
 515 0258 81E0      		ldi r24,lo8(1)
 516 025a 8093 0000 		sts appState,r24
 517               	.L21:
 263:ServerLLDN.c  **** 				}
 518               		.loc 2 263 0
 519 025e 0000      		nop
 520               	.L18:
 268:ServerLLDN.c  **** 		}
 269:ServerLLDN.c  **** 	}
 521               		.loc 2 269 0
 522 0260 0000      		nop
 523               	/* epilogue start */
 524 0262 DF91      		pop r29
 525 0264 CF91      		pop r28
 526 0266 0895      		ret
 527               		.cfi_endproc
 528               	.LFE110:
 530               	.global	main
 532               	main:
 533               	.LFB111:
 270:ServerLLDN.c  **** 
 271:ServerLLDN.c  **** 	/*****************************************************************************
 272:ServerLLDN.c  **** 	*****************************************************************************/
 273:ServerLLDN.c  **** 	int main(void)
 274:ServerLLDN.c  **** 	{
 534               		.loc 2 274 0
 535               		.cfi_startproc
 536 0268 CF93      		push r28
 537               	.LCFI22:
 538               		.cfi_def_cfa_offset 3
 539               		.cfi_offset 28, -2
 540 026a DF93      		push r29
 541               	.LCFI23:
 542               		.cfi_def_cfa_offset 4
 543               		.cfi_offset 29, -3
 544 026c CDB7      		in r28,__SP_L__
 545 026e DEB7      		in r29,__SP_H__
 546               	.LCFI24:
 547               		.cfi_def_cfa_register 28
 548               	/* prologue: function */
 549               	/* frame size = 0 */
 550               	/* stack size = 2 */
 551               	.L__stack_usage = 2
 275:ServerLLDN.c  **** 		sysclk_init();
 552               		.loc 2 275 0
 553 0270 0E94 0000 		call sysclk_init
 276:ServerLLDN.c  **** 		board_init();
 554               		.loc 2 276 0
 555 0274 0E94 0000 		call board_init
 277:ServerLLDN.c  **** 
 278:ServerLLDN.c  **** 		SYS_Init();
 556               		.loc 2 278 0
 557 0278 0E94 0000 		call SYS_Init
 279:ServerLLDN.c  **** 		/* Disable CSMA/CA
 280:ServerLLDN.c  **** 		 * Disable auto ACK
 281:ServerLLDN.c  **** 		 * Enable Rx of LLDN Frame Type as described in 802.15.4e - 2012 
 282:ServerLLDN.c  **** 		 */
 283:ServerLLDN.c  **** 		PHY_SetPromiscuousMode(true);
 558               		.loc 2 283 0
 559 027c 81E0      		ldi r24,lo8(1)
 560 027e 0E94 0000 		call PHY_SetPromiscuousMode
 284:ServerLLDN.c  **** 		sm_init();
 561               		.loc 2 284 0
 562 0282 0E94 0000 		call sm_init
 285:ServerLLDN.c  **** 
 286:ServerLLDN.c  **** 		// Initialize interrupt vector table support.
 287:ServerLLDN.c  **** 	#if (SIO2HOST_CHANNEL == SIO_USB)
 288:ServerLLDN.c  **** 		irq_initialize_vectors();
 289:ServerLLDN.c  **** 	#endif
 290:ServerLLDN.c  **** 		cpu_irq_enable();
 563               		.loc 2 290 0
 564               	/* #APP */
 565               	 ;  290 "ServerLLDN.c" 1
 566 0286 7894      		sei
 567               	 ;  0 "" 2
 568               	/* #NOAPP */
 569               	.L23:
 291:ServerLLDN.c  **** 
 292:ServerLLDN.c  **** 	#if APP_COORDINATOR
 293:ServerLLDN.c  **** 	#if (SIO2HOST_CHANNEL == SIO_USB)
 294:ServerLLDN.c  **** 		stdio_usb_init();
 295:ServerLLDN.c  **** 	#else
 296:ServerLLDN.c  **** 		const usart_serial_options_t usart_serial_options =
 297:ServerLLDN.c  **** 		{
 298:ServerLLDN.c  **** 			.baudrate     = USART_HOST_BAUDRATE,
 299:ServerLLDN.c  **** 			.charlength   = USART_HOST_CHAR_LENGTH,
 300:ServerLLDN.c  **** 			.paritytype   = USART_HOST_PARITY,
 301:ServerLLDN.c  **** 			.stopbits     = USART_HOST_STOP_BITS
 302:ServerLLDN.c  **** 		};
 303:ServerLLDN.c  **** 
 304:ServerLLDN.c  **** 		stdio_serial_init(USART_HOST, &usart_serial_options);
 305:ServerLLDN.c  **** 		usart_double_baud_enable(USART_HOST);
 306:ServerLLDN.c  **** 		usart_set_baudrate_precalculated(USART_HOST, USART_HOST_BAUDRATE, sysclk_get_source_clock_hz());
 307:ServerLLDN.c  **** 
 308:ServerLLDN.c  **** 	#endif
 309:ServerLLDN.c  **** 	#endif
 310:ServerLLDN.c  **** 		for(;;)
 311:ServerLLDN.c  **** 		{
 312:ServerLLDN.c  **** 			SYS_TaskHandler();
 570               		.loc 2 312 0 discriminator 1
 571 0288 0E94 0000 		call SYS_TaskHandler
 313:ServerLLDN.c  **** 			APP_TaskHandler();
 572               		.loc 2 313 0 discriminator 1
 573 028c 0E94 0000 		call APP_TaskHandler
 314:ServerLLDN.c  **** 		}
 574               		.loc 2 314 0 discriminator 1
 575 0290 00C0      		rjmp .L23
 576               		.cfi_endproc
 577               	.LFE111:
 579               	.Letext0:
 580               		.file 3 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\in
 581               		.file 4 "../../../stack/LwMesh/TDMA/nwk/inc/nwkFrame.h"
 582               		.file 5 "../../../stack/LwMesh/TDMA/nwk/inc/nwkRx.h"
 583               		.file 6 "../../../stack/LwMesh/TDMA/nwk/inc/nwkDataReq.h"
 584               		.file 7 "../../../platform/mega_rf/drivers/sleep/sleep.h"
 585               		.file 8 "config/config.h"
 586               		.file 9 "../../../platform/common/services/sleepmgr/mega_rf/sleepmgr.h"
DEFINED SYMBOLS
                            *ABS*:00000000 ServerLLDN.c
C:\Users\guilh\AppData\Local\Temp\ccm8k9ig.s:2      *ABS*:0000003e __SP_H__
C:\Users\guilh\AppData\Local\Temp\ccm8k9ig.s:3      *ABS*:0000003d __SP_L__
C:\Users\guilh\AppData\Local\Temp\ccm8k9ig.s:4      *ABS*:0000003f __SREG__
C:\Users\guilh\AppData\Local\Temp\ccm8k9ig.s:5      *ABS*:0000003b __RAMPZ__
C:\Users\guilh\AppData\Local\Temp\ccm8k9ig.s:6      *ABS*:00000000 __tmp_reg__
C:\Users\guilh\AppData\Local\Temp\ccm8k9ig.s:7      *ABS*:00000001 __zero_reg__
C:\Users\guilh\AppData\Local\Temp\ccm8k9ig.s:14     .bss.n:00000000 n
C:\Users\guilh\AppData\Local\Temp\ccm8k9ig.s:19     .bss.tTS:00000000 tTS
C:\Users\guilh\AppData\Local\Temp\ccm8k9ig.s:23     .text:00000000 macsc_enable_manual_bts
C:\Users\guilh\AppData\Local\Temp\ccm8k9ig.s:76     .bss.appState:00000000 appState
C:\Users\guilh\AppData\Local\Temp\ccm8k9ig.s:81     .bss.msgReq:00000000 msgReq
C:\Users\guilh\AppData\Local\Temp\ccm8k9ig.s:88     .text:00000034 appSendData
C:\Users\guilh\AppData\Local\Temp\ccm8k9ig.s:142    .bss.rec_beacon:00000000 rec_beacon
C:\Users\guilh\AppData\Local\Temp\ccm8k9ig.s:147    .bss.msgDiscResponse:00000000 msgDiscResponse
C:\Users\guilh\AppData\Local\Temp\ccm8k9ig.s:152    .bss.payloadSize:00000000 payloadSize
C:\Users\guilh\AppData\Local\Temp\ccm8k9ig.s:156    .text:0000006e send_message_timeHandler
C:\Users\guilh\AppData\Local\Temp\ccm8k9ig.s:189    .text:00000084 appBeaconInd
C:\Users\guilh\AppData\Local\Temp\ccm8k9ig.s:299    .text:00000126 appPrepareDiscoverResponse
C:\Users\guilh\AppData\Local\Temp\ccm8k9ig.s:376    .text:0000019c appInit
C:\Users\guilh\AppData\Local\Temp\ccm8k9ig.s:451    .text:00000208 APP_TaskHandler
C:\Users\guilh\AppData\Local\Temp\ccm8k9ig.s:532    .text:00000268 main

UNDEFINED SYMBOLS
printf
NWK_DataReq
macsc_use_cmp
NWK_SetAddr
NWK_SetPanId
PHY_SetChannel
PHY_SetRxState
PHY_SetTdmaMode
NWK_OpenEndpoint
macsc_set_cmp1_int_cb
macsc_enable_cmp_int
sysclk_init
board_init
SYS_Init
PHY_SetPromiscuousMode
sm_init
SYS_TaskHandler
__do_copy_data
__do_clear_bss
