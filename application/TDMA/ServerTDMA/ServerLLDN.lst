   1               		.file	"ServerLLDN.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__RAMPZ__ = 0x3b
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.text
   9               	.Ltext0:
  10               		.cfi_sections	.debug_frame
  11               	.global	n
  12               		.section	.bss.n,"aw",@nobits
  15               	n:
  16 0000 00        		.zero	1
  17               		.comm	tTS,4,1
  18               		.text
  20               	sysclk_get_main_hz:
  21               	.LFB67:
  22               		.file 1 "../../../platform/common/services/clock/mega/sysclk.h"
   1:../../../platform/common/services/clock/mega/sysclk.h **** /**
   2:../../../platform/common/services/clock/mega/sysclk.h ****  * \file
   3:../../../platform/common/services/clock/mega/sysclk.h ****  *
   4:../../../platform/common/services/clock/mega/sysclk.h ****  * \brief Chip-specific system clock management functions
   5:../../../platform/common/services/clock/mega/sysclk.h ****  *
   6:../../../platform/common/services/clock/mega/sysclk.h ****  * Copyright (c) 2012 Atmel Corporation. All rights reserved.
   7:../../../platform/common/services/clock/mega/sysclk.h ****  *
   8:../../../platform/common/services/clock/mega/sysclk.h ****  * \asf_license_start
   9:../../../platform/common/services/clock/mega/sysclk.h ****  *
  10:../../../platform/common/services/clock/mega/sysclk.h ****  * \page License
  11:../../../platform/common/services/clock/mega/sysclk.h ****  *
  12:../../../platform/common/services/clock/mega/sysclk.h ****  * Redistribution and use in source and binary forms, with or without
  13:../../../platform/common/services/clock/mega/sysclk.h ****  * modification, are permitted provided that the following conditions are met:
  14:../../../platform/common/services/clock/mega/sysclk.h ****  *
  15:../../../platform/common/services/clock/mega/sysclk.h ****  * 1. Redistributions of source code must retain the above copyright notice,
  16:../../../platform/common/services/clock/mega/sysclk.h ****  *    this list of conditions and the following disclaimer.
  17:../../../platform/common/services/clock/mega/sysclk.h ****  *
  18:../../../platform/common/services/clock/mega/sysclk.h ****  * 2. Redistributions in binary form must reproduce the above copyright notice,
  19:../../../platform/common/services/clock/mega/sysclk.h ****  *    this list of conditions and the following disclaimer in the documentation
  20:../../../platform/common/services/clock/mega/sysclk.h ****  *    and/or other materials provided with the distribution.
  21:../../../platform/common/services/clock/mega/sysclk.h ****  *
  22:../../../platform/common/services/clock/mega/sysclk.h ****  * 3. The name of Atmel may not be used to endorse or promote products derived
  23:../../../platform/common/services/clock/mega/sysclk.h ****  *    from this software without specific prior written permission.
  24:../../../platform/common/services/clock/mega/sysclk.h ****  *
  25:../../../platform/common/services/clock/mega/sysclk.h ****  * 4. This software may only be redistributed and used in connection with an
  26:../../../platform/common/services/clock/mega/sysclk.h ****  *    Atmel microcontroller product.
  27:../../../platform/common/services/clock/mega/sysclk.h ****  *
  28:../../../platform/common/services/clock/mega/sysclk.h ****  * THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR IMPLIED
  29:../../../platform/common/services/clock/mega/sysclk.h ****  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
  30:../../../platform/common/services/clock/mega/sysclk.h ****  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
  31:../../../platform/common/services/clock/mega/sysclk.h ****  * EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR
  32:../../../platform/common/services/clock/mega/sysclk.h ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  33:../../../platform/common/services/clock/mega/sysclk.h ****  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
  34:../../../platform/common/services/clock/mega/sysclk.h ****  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  35:../../../platform/common/services/clock/mega/sysclk.h ****  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
  36:../../../platform/common/services/clock/mega/sysclk.h ****  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  37:../../../platform/common/services/clock/mega/sysclk.h ****  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  38:../../../platform/common/services/clock/mega/sysclk.h ****  * POSSIBILITY OF SUCH DAMAGE.
  39:../../../platform/common/services/clock/mega/sysclk.h ****  *
  40:../../../platform/common/services/clock/mega/sysclk.h ****  * \asf_license_stop
  41:../../../platform/common/services/clock/mega/sysclk.h ****  *
  42:../../../platform/common/services/clock/mega/sysclk.h ****  */
  43:../../../platform/common/services/clock/mega/sysclk.h **** #ifndef MEGA_SYSCLK_H_INCLUDED
  44:../../../platform/common/services/clock/mega/sysclk.h **** #define MEGA_SYSCLK_H_INCLUDED
  45:../../../platform/common/services/clock/mega/sysclk.h **** 
  46:../../../platform/common/services/clock/mega/sysclk.h **** #include <board.h>
  47:../../../platform/common/services/clock/mega/sysclk.h **** #include <compiler.h>
  48:../../../platform/common/services/clock/mega/sysclk.h **** #include <parts.h>
  49:../../../platform/common/services/clock/mega/sysclk.h **** 
  50:../../../platform/common/services/clock/mega/sysclk.h **** /* Include clock configuration for the project. */
  51:../../../platform/common/services/clock/mega/sysclk.h **** #include <conf_clock.h>
  52:../../../platform/common/services/clock/mega/sysclk.h **** 
  53:../../../platform/common/services/clock/mega/sysclk.h **** #ifdef __cplusplus
  54:../../../platform/common/services/clock/mega/sysclk.h **** extern "C" {
  55:../../../platform/common/services/clock/mega/sysclk.h **** #endif
  56:../../../platform/common/services/clock/mega/sysclk.h **** #define ASM __asm__
  57:../../../platform/common/services/clock/mega/sysclk.h **** 
  58:../../../platform/common/services/clock/mega/sysclk.h **** /* CONFIG_SYSCLK_PSDIV  to use default if not defined*/
  59:../../../platform/common/services/clock/mega/sysclk.h **** #ifndef CONFIG_SYSCLK_PSDIV
  60:../../../platform/common/services/clock/mega/sysclk.h **** # define CONFIG_SYSCLK_PSDIV    SYSCLK_PSDIV_8
  61:../../../platform/common/services/clock/mega/sysclk.h **** #endif
  62:../../../platform/common/services/clock/mega/sysclk.h **** 
  63:../../../platform/common/services/clock/mega/sysclk.h **** /* ! \name Prescaler Setting (relative to CLKsys) */
  64:../../../platform/common/services/clock/mega/sysclk.h **** /* @{ */
  65:../../../platform/common/services/clock/mega/sysclk.h **** #define SYSCLK_PSDIV_1      0   /* !< Do not prescale */
  66:../../../platform/common/services/clock/mega/sysclk.h **** #define SYSCLK_PSDIV_2      1   /* !< Prescale CLKper4 by 2 */
  67:../../../platform/common/services/clock/mega/sysclk.h **** #define SYSCLK_PSDIV_4      2   /* !< Prescale CLKper4 by 4 */
  68:../../../platform/common/services/clock/mega/sysclk.h **** #define SYSCLK_PSDIV_8      3   /* !< Prescale CLKper4 by 8 */
  69:../../../platform/common/services/clock/mega/sysclk.h **** #define SYSCLK_PSDIV_16     4   /* !< Prescale CLKper4 by 16 */
  70:../../../platform/common/services/clock/mega/sysclk.h **** #define SYSCLK_PSDIV_32     5   /* !< Prescale CLKper4 by 32 */
  71:../../../platform/common/services/clock/mega/sysclk.h **** #define SYSCLK_PSDIV_64     6   /* !< Prescale CLKper4 by 64 */
  72:../../../platform/common/services/clock/mega/sysclk.h **** #define SYSCLK_PSDIV_128    7   /* !< Prescale CLKper4 by 128 */
  73:../../../platform/common/services/clock/mega/sysclk.h **** #define SYSCLK_PSDIV_256    8   /* !< Prescale CLKper4 by 256 */
  74:../../../platform/common/services/clock/mega/sysclk.h **** 
  75:../../../platform/common/services/clock/mega/sysclk.h **** /* @} */
  76:../../../platform/common/services/clock/mega/sysclk.h **** 
  77:../../../platform/common/services/clock/mega/sysclk.h **** #if MEGA_RF || MEGA_XX0_1 || MEGA_XX4 || MEGA_XX4_A
  78:../../../platform/common/services/clock/mega/sysclk.h **** 
  79:../../../platform/common/services/clock/mega/sysclk.h **** #define NUMBER_OF_POWER_REG       2
  80:../../../platform/common/services/clock/mega/sysclk.h **** /*Starting Address for power reduction*/
  81:../../../platform/common/services/clock/mega/sysclk.h **** #define POWER_REG_ADD             PRR0
  82:../../../platform/common/services/clock/mega/sysclk.h **** 
  83:../../../platform/common/services/clock/mega/sysclk.h **** /* ! \name Power Reduction  Clock Port Numbers */
  84:../../../platform/common/services/clock/mega/sysclk.h **** enum power_red_id {
  85:../../../platform/common/services/clock/mega/sysclk.h **** 	POWER_RED_REG0,     /* !< Devices on PRR0 */
  86:../../../platform/common/services/clock/mega/sysclk.h **** #if !MEGA_XX4 || !MEGA_XX4_A || MEGA_XX0_1
  87:../../../platform/common/services/clock/mega/sysclk.h **** 	POWER_RED_REG1,     /* !< Devices on PRR1 */
  88:../../../platform/common/services/clock/mega/sysclk.h **** #endif
  89:../../../platform/common/services/clock/mega/sysclk.h **** };
  90:../../../platform/common/services/clock/mega/sysclk.h **** #endif
  91:../../../platform/common/services/clock/mega/sysclk.h **** 
  92:../../../platform/common/services/clock/mega/sysclk.h **** /****************************************************
  93:../../../platform/common/services/clock/mega/sysclk.h ****  * Given a dummy type but not used for these groups
  94:../../../platform/common/services/clock/mega/sysclk.h ****  * to support for otherthen megaRF device.
  95:../../../platform/common/services/clock/mega/sysclk.h ****  **************************************************/
  96:../../../platform/common/services/clock/mega/sysclk.h **** #if MEGA_XX8 || MEGA_XX8_A || MEGA_UNSPECIFIED
  97:../../../platform/common/services/clock/mega/sysclk.h **** #define NUMBER_OF_POWER_REG       1
  98:../../../platform/common/services/clock/mega/sysclk.h **** /*Starting Address for power reduction*/
  99:../../../platform/common/services/clock/mega/sysclk.h **** #define POWER_REG_ADD             PRR
 100:../../../platform/common/services/clock/mega/sysclk.h **** 
 101:../../../platform/common/services/clock/mega/sysclk.h **** /* ! \name Power Reduction  Clock Port Numbers */
 102:../../../platform/common/services/clock/mega/sysclk.h **** enum power_red_id {
 103:../../../platform/common/services/clock/mega/sysclk.h **** 	POWER_RED_REG0,     /* !< Devices on PRR */
 104:../../../platform/common/services/clock/mega/sysclk.h **** };
 105:../../../platform/common/services/clock/mega/sysclk.h **** #endif
 106:../../../platform/common/services/clock/mega/sysclk.h **** 
 107:../../../platform/common/services/clock/mega/sysclk.h **** /* Bit mask for the power reduction register based on */
 108:../../../platform/common/services/clock/mega/sysclk.h **** /*   MCU ARCH.                                        */
 109:../../../platform/common/services/clock/mega/sysclk.h **** #if MEGA_RF
 110:../../../platform/common/services/clock/mega/sysclk.h **** /*Bit mask for PRR2 */
 111:../../../platform/common/services/clock/mega/sysclk.h **** 
 112:../../../platform/common/services/clock/mega/sysclk.h **** #define PRRAM0_bm                       1 << PRRAM0
 113:../../../platform/common/services/clock/mega/sysclk.h **** #define PRRAM1_bm                       1 << PRRAM1
 114:../../../platform/common/services/clock/mega/sysclk.h **** #define PRRAM2_bm                       1 << PRRAM2
 115:../../../platform/common/services/clock/mega/sysclk.h **** #define PRRAM3_bm                       1 << PRRAM3
 116:../../../platform/common/services/clock/mega/sysclk.h **** #endif
 117:../../../platform/common/services/clock/mega/sysclk.h **** 
 118:../../../platform/common/services/clock/mega/sysclk.h **** /*Bit mask for the power reduction 0 or PRR*/
 119:../../../platform/common/services/clock/mega/sysclk.h **** #if !MEGA_XX_UN0 && !MEGA_XX_UN0
 120:../../../platform/common/services/clock/mega/sysclk.h **** #define PRADC_bm                        1 << PRADC
 121:../../../platform/common/services/clock/mega/sysclk.h **** #define PRUSART0_bm                     1 << PRUSART0
 122:../../../platform/common/services/clock/mega/sysclk.h **** #define PRSPI_bm                        1 << PRSPI
 123:../../../platform/common/services/clock/mega/sysclk.h **** #define PRTIM1_bm                       1 << PRTIM1
 124:../../../platform/common/services/clock/mega/sysclk.h **** #endif
 125:../../../platform/common/services/clock/mega/sysclk.h **** 
 126:../../../platform/common/services/clock/mega/sysclk.h **** #if MEGA_RF
 127:../../../platform/common/services/clock/mega/sysclk.h **** #define PRPGA_bm                        1 << PRPGA
 128:../../../platform/common/services/clock/mega/sysclk.h **** #endif
 129:../../../platform/common/services/clock/mega/sysclk.h **** 
 130:../../../platform/common/services/clock/mega/sysclk.h **** #if !MEGA_UNSPECIFIED
 131:../../../platform/common/services/clock/mega/sysclk.h **** #define PRTIM0_bm                       1 << PRTIM0
 132:../../../platform/common/services/clock/mega/sysclk.h **** #define PRTIM2_bm                       1 << PRTIM2
 133:../../../platform/common/services/clock/mega/sysclk.h **** #define PRTWI_bm                        1 << PRTWI
 134:../../../platform/common/services/clock/mega/sysclk.h **** #endif
 135:../../../platform/common/services/clock/mega/sysclk.h **** 
 136:../../../platform/common/services/clock/mega/sysclk.h **** #if MEGA_XX_UN2
 137:../../../platform/common/services/clock/mega/sysclk.h **** #define PRLCD_bm                        1 << PRLCD
 138:../../../platform/common/services/clock/mega/sysclk.h **** #endif
 139:../../../platform/common/services/clock/mega/sysclk.h **** 
 140:../../../platform/common/services/clock/mega/sysclk.h **** /*Bit mask for  PRR1  */
 141:../../../platform/common/services/clock/mega/sysclk.h **** #ifdef PRR1
 142:../../../platform/common/services/clock/mega/sysclk.h **** #if (MEGA_XX4 || MEGA_XX4_A)
 143:../../../platform/common/services/clock/mega/sysclk.h **** #define PRTIM3_bm                       1 << PRTIM3
 144:../../../platform/common/services/clock/mega/sysclk.h **** #endif
 145:../../../platform/common/services/clock/mega/sysclk.h **** #endif
 146:../../../platform/common/services/clock/mega/sysclk.h **** 
 147:../../../platform/common/services/clock/mega/sysclk.h **** #if MEGA_RF || MEGA_XX4 || MEGA_XX4_A
 148:../../../platform/common/services/clock/mega/sysclk.h **** #define PRUSART1_bm                     1 << PRUSART1
 149:../../../platform/common/services/clock/mega/sysclk.h **** #define PRUSART2_bm                     1 << PRUSART2
 150:../../../platform/common/services/clock/mega/sysclk.h **** #define PRUSART3_bm                     1 << PRUSART3
 151:../../../platform/common/services/clock/mega/sysclk.h **** #define PRTIM3_bm                       1 << PRTIM3
 152:../../../platform/common/services/clock/mega/sysclk.h **** #define PRTIM4_bm                       1 << PRTIM4
 153:../../../platform/common/services/clock/mega/sysclk.h **** #define PRTIM5_bm                       1 << PRTIM5
 154:../../../platform/common/services/clock/mega/sysclk.h **** #endif
 155:../../../platform/common/services/clock/mega/sysclk.h **** 
 156:../../../platform/common/services/clock/mega/sysclk.h **** #if MEGA_RF
 157:../../../platform/common/services/clock/mega/sysclk.h **** #define PRTRX24_bm                      1 << PRTRX24
 158:../../../platform/common/services/clock/mega/sysclk.h **** #endif
 159:../../../platform/common/services/clock/mega/sysclk.h **** 
 160:../../../platform/common/services/clock/mega/sysclk.h **** /**
 161:../../../platform/common/services/clock/mega/sysclk.h ****  * \name Querying the system clock and its derived clocks
 162:../../../platform/common/services/clock/mega/sysclk.h ****  */
 163:../../../platform/common/services/clock/mega/sysclk.h **** /* @{ */
 164:../../../platform/common/services/clock/mega/sysclk.h **** 
 165:../../../platform/common/services/clock/mega/sysclk.h **** /**
 166:../../../platform/common/services/clock/mega/sysclk.h ****  * \brief Return the current rate in Hz of the main system clock
 167:../../../platform/common/services/clock/mega/sysclk.h ****  * To know the clock value at what frequency the main clock is running
 168:../../../platform/common/services/clock/mega/sysclk.h ****  * \return Frequency of the main system clock, in Hz.
 169:../../../platform/common/services/clock/mega/sysclk.h ****  * \todo : please initialize the SYSCLK_SOURCE in conf_clock.h file for
 170:../../../platform/common/services/clock/mega/sysclk.h ****  * configured source clock using fuses.
 171:../../../platform/common/services/clock/mega/sysclk.h ****  * \eg. #define SYSCLK_SOURCE SYSCLK_SRC_RC16MHZ to use internal RC
 172:../../../platform/common/services/clock/mega/sysclk.h ****  * oscillator for clock source.
 173:../../../platform/common/services/clock/mega/sysclk.h ****  */
 174:../../../platform/common/services/clock/mega/sysclk.h **** static inline uint32_t sysclk_get_main_hz(void)
 175:../../../platform/common/services/clock/mega/sysclk.h **** {
  23               		.loc 1 175 0
  24               		.cfi_startproc
  25 0000 CF93      		push r28
  26               	.LCFI0:
  27               		.cfi_def_cfa_offset 3
  28               		.cfi_offset 28, -2
  29 0002 DF93      		push r29
  30               	.LCFI1:
  31               		.cfi_def_cfa_offset 4
  32               		.cfi_offset 29, -3
  33 0004 CDB7      		in r28,__SP_L__
  34 0006 DEB7      		in r29,__SP_H__
  35               	.LCFI2:
  36               		.cfi_def_cfa_register 28
  37               	/* prologue: function */
  38               	/* frame size = 0 */
  39               	/* stack size = 2 */
  40               	.L__stack_usage = 2
 176:../../../platform/common/services/clock/mega/sysclk.h **** 	switch (SYSCLK_SOURCE) {
 177:../../../platform/common/services/clock/mega/sysclk.h **** 	case SYSCLK_SRC_RC16MHZ:
 178:../../../platform/common/services/clock/mega/sysclk.h **** 		return 16000000UL;
 179:../../../platform/common/services/clock/mega/sysclk.h **** 
 180:../../../platform/common/services/clock/mega/sysclk.h **** 	case SYSCLK_SRC_RC128KHZ:
 181:../../../platform/common/services/clock/mega/sysclk.h **** 		return 128000UL;
 182:../../../platform/common/services/clock/mega/sysclk.h **** 
 183:../../../platform/common/services/clock/mega/sysclk.h **** #if MEGA_RF
 184:../../../platform/common/services/clock/mega/sysclk.h **** 	case SYSCLK_SRC_TRS16MHZ:
 185:../../../platform/common/services/clock/mega/sysclk.h **** 		return 16000000UL;
  41               		.loc 1 185 0
  42 0008 80E0      		ldi r24,0
  43 000a 94E2      		ldi r25,lo8(36)
  44 000c A4EF      		ldi r26,lo8(-12)
  45 000e B0E0      		ldi r27,0
 186:../../../platform/common/services/clock/mega/sysclk.h **** #endif
 187:../../../platform/common/services/clock/mega/sysclk.h **** #ifdef BOARD_EXTERNAL_CLK
 188:../../../platform/common/services/clock/mega/sysclk.h **** 	case SYSCLK_SRC_EXTERNAL:
 189:../../../platform/common/services/clock/mega/sysclk.h **** 		return BOARD_EXTERNAL_CLK;
 190:../../../platform/common/services/clock/mega/sysclk.h **** #endif
 191:../../../platform/common/services/clock/mega/sysclk.h **** 	default:
 192:../../../platform/common/services/clock/mega/sysclk.h **** 
 193:../../../platform/common/services/clock/mega/sysclk.h **** 		return 1000000UL;
 194:../../../platform/common/services/clock/mega/sysclk.h **** 	}
 195:../../../platform/common/services/clock/mega/sysclk.h **** }
  46               		.loc 1 195 0
  47 0010 BC01      		movw r22,r24
  48 0012 CD01      		movw r24,r26
  49               	/* epilogue start */
  50 0014 DF91      		pop r29
  51 0016 CF91      		pop r28
  52 0018 0895      		ret
  53               		.cfi_endproc
  54               	.LFE67:
  57               	sysclk_get_source_clock_hz:
  58               	.LFB68:
 196:../../../platform/common/services/clock/mega/sysclk.h **** 
 197:../../../platform/common/services/clock/mega/sysclk.h **** /**
 198:../../../platform/common/services/clock/mega/sysclk.h ****  * \brief Return the current rate in Hz of source clock in Hz.
 199:../../../platform/common/services/clock/mega/sysclk.h ****  *
 200:../../../platform/common/services/clock/mega/sysclk.h ****  * This clock always runs at the same rate as the CPU clock unless the divider
 201:../../../platform/common/services/clock/mega/sysclk.h ****  * is set.
 202:../../../platform/common/services/clock/mega/sysclk.h ****  *
 203:../../../platform/common/services/clock/mega/sysclk.h ****  * \return Frequency of the system clock, in Hz.
 204:../../../platform/common/services/clock/mega/sysclk.h ****  */
 205:../../../platform/common/services/clock/mega/sysclk.h **** static inline uint32_t sysclk_get_source_clock_hz(void)
 206:../../../platform/common/services/clock/mega/sysclk.h **** {
  59               		.loc 1 206 0
  60               		.cfi_startproc
  61 001a CF93      		push r28
  62               	.LCFI3:
  63               		.cfi_def_cfa_offset 3
  64               		.cfi_offset 28, -2
  65 001c DF93      		push r29
  66               	.LCFI4:
  67               		.cfi_def_cfa_offset 4
  68               		.cfi_offset 29, -3
  69 001e CDB7      		in r28,__SP_L__
  70 0020 DEB7      		in r29,__SP_H__
  71               	.LCFI5:
  72               		.cfi_def_cfa_register 28
  73               	/* prologue: function */
  74               	/* frame size = 0 */
  75               	/* stack size = 2 */
  76               	.L__stack_usage = 2
 207:../../../platform/common/services/clock/mega/sysclk.h **** 	switch (CONFIG_SYSCLK_PSDIV) {
 208:../../../platform/common/services/clock/mega/sysclk.h **** 	case SYSCLK_PSDIV_1: /* Fall through */
 209:../../../platform/common/services/clock/mega/sysclk.h **** 		if (SYSCLK_SOURCE == SYSCLK_SRC_RC16MHZ ||
 210:../../../platform/common/services/clock/mega/sysclk.h **** 				SYSCLK_SOURCE == SYSCLK_SRC_RC128KHZ) {
 211:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 2;
 212:../../../platform/common/services/clock/mega/sysclk.h **** 		} else {
 213:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz();
  77               		.loc 1 213 0
  78 0022 0E94 0000 		call sysclk_get_main_hz
  79 0026 DC01      		movw r26,r24
  80 0028 CB01      		movw r24,r22
 214:../../../platform/common/services/clock/mega/sysclk.h **** 		}
 215:../../../platform/common/services/clock/mega/sysclk.h **** 
 216:../../../platform/common/services/clock/mega/sysclk.h **** 	case SYSCLK_PSDIV_2:
 217:../../../platform/common/services/clock/mega/sysclk.h **** 		if (SYSCLK_SOURCE == SYSCLK_SRC_RC16MHZ ||
 218:../../../platform/common/services/clock/mega/sysclk.h **** 				SYSCLK_SOURCE == SYSCLK_SRC_RC128KHZ) {
 219:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 4;
 220:../../../platform/common/services/clock/mega/sysclk.h **** 		} else {
 221:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 2;
 222:../../../platform/common/services/clock/mega/sysclk.h **** 		}
 223:../../../platform/common/services/clock/mega/sysclk.h **** 
 224:../../../platform/common/services/clock/mega/sysclk.h **** 	case SYSCLK_PSDIV_4:
 225:../../../platform/common/services/clock/mega/sysclk.h **** 		if (SYSCLK_SOURCE == SYSCLK_SRC_RC16MHZ ||
 226:../../../platform/common/services/clock/mega/sysclk.h **** 				SYSCLK_SOURCE == SYSCLK_SRC_RC128KHZ) {
 227:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 8;
 228:../../../platform/common/services/clock/mega/sysclk.h **** 		} else {
 229:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 4;
 230:../../../platform/common/services/clock/mega/sysclk.h **** 		}
 231:../../../platform/common/services/clock/mega/sysclk.h **** 
 232:../../../platform/common/services/clock/mega/sysclk.h **** 	case SYSCLK_PSDIV_8:
 233:../../../platform/common/services/clock/mega/sysclk.h **** 		if (SYSCLK_SOURCE == SYSCLK_SRC_RC16MHZ ||
 234:../../../platform/common/services/clock/mega/sysclk.h **** 				SYSCLK_SOURCE == SYSCLK_SRC_RC128KHZ) {
 235:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 16;
 236:../../../platform/common/services/clock/mega/sysclk.h **** 		} else {
 237:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 8;
 238:../../../platform/common/services/clock/mega/sysclk.h **** 		}
 239:../../../platform/common/services/clock/mega/sysclk.h **** 
 240:../../../platform/common/services/clock/mega/sysclk.h **** 	case SYSCLK_PSDIV_16:
 241:../../../platform/common/services/clock/mega/sysclk.h **** 		if (SYSCLK_SOURCE == SYSCLK_SRC_RC16MHZ ||
 242:../../../platform/common/services/clock/mega/sysclk.h **** 				SYSCLK_SOURCE == SYSCLK_SRC_RC128KHZ) {
 243:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 32;
 244:../../../platform/common/services/clock/mega/sysclk.h **** 		} else {
 245:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 16;
 246:../../../platform/common/services/clock/mega/sysclk.h **** 		}
 247:../../../platform/common/services/clock/mega/sysclk.h **** 
 248:../../../platform/common/services/clock/mega/sysclk.h **** 	case SYSCLK_PSDIV_32:
 249:../../../platform/common/services/clock/mega/sysclk.h **** 		if (SYSCLK_SOURCE == SYSCLK_SRC_RC16MHZ ||
 250:../../../platform/common/services/clock/mega/sysclk.h **** 				SYSCLK_SOURCE == SYSCLK_SRC_RC128KHZ) {
 251:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 64;
 252:../../../platform/common/services/clock/mega/sysclk.h **** 		} else {
 253:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 32;
 254:../../../platform/common/services/clock/mega/sysclk.h **** 		}
 255:../../../platform/common/services/clock/mega/sysclk.h **** 
 256:../../../platform/common/services/clock/mega/sysclk.h **** 	case SYSCLK_PSDIV_64:
 257:../../../platform/common/services/clock/mega/sysclk.h **** 		if (SYSCLK_SOURCE == SYSCLK_SRC_RC16MHZ ||
 258:../../../platform/common/services/clock/mega/sysclk.h **** 				SYSCLK_SOURCE == SYSCLK_SRC_RC128KHZ) {
 259:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 128;
 260:../../../platform/common/services/clock/mega/sysclk.h **** 		} else {
 261:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 64;
 262:../../../platform/common/services/clock/mega/sysclk.h **** 		}
 263:../../../platform/common/services/clock/mega/sysclk.h **** 
 264:../../../platform/common/services/clock/mega/sysclk.h **** 	case SYSCLK_PSDIV_128:
 265:../../../platform/common/services/clock/mega/sysclk.h **** 		if (SYSCLK_SOURCE == SYSCLK_SRC_RC16MHZ ||
 266:../../../platform/common/services/clock/mega/sysclk.h **** 				SYSCLK_SOURCE == SYSCLK_SRC_RC128KHZ) {
 267:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 256;
 268:../../../platform/common/services/clock/mega/sysclk.h **** 		} else {
 269:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 128;
 270:../../../platform/common/services/clock/mega/sysclk.h **** 		}
 271:../../../platform/common/services/clock/mega/sysclk.h **** 
 272:../../../platform/common/services/clock/mega/sysclk.h **** 	case SYSCLK_PSDIV_256:
 273:../../../platform/common/services/clock/mega/sysclk.h **** 		if (SYSCLK_SOURCE == SYSCLK_SRC_RC16MHZ ||
 274:../../../platform/common/services/clock/mega/sysclk.h **** 				SYSCLK_SOURCE == SYSCLK_SRC_RC128KHZ) {
 275:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 512;
 276:../../../platform/common/services/clock/mega/sysclk.h **** 		} else {
 277:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 256;
 278:../../../platform/common/services/clock/mega/sysclk.h **** 		}
 279:../../../platform/common/services/clock/mega/sysclk.h **** 
 280:../../../platform/common/services/clock/mega/sysclk.h **** 	default:
 281:../../../platform/common/services/clock/mega/sysclk.h **** 		/*Invalide case*/
 282:../../../platform/common/services/clock/mega/sysclk.h **** 		return 0;
 283:../../../platform/common/services/clock/mega/sysclk.h **** 	}
 284:../../../platform/common/services/clock/mega/sysclk.h **** }
  81               		.loc 1 284 0
  82 002a BC01      		movw r22,r24
  83 002c CD01      		movw r24,r26
  84               	/* epilogue start */
  85 002e DF91      		pop r29
  86 0030 CF91      		pop r28
  87 0032 0895      		ret
  88               		.cfi_endproc
  89               	.LFE68:
  91               		.section	.progmem.data.baudctrl_1mhz,"a",@progbits
  94               	baudctrl_1mhz:
  95 0000 3300      		.word	51
  96 0002 1900      		.word	25
  97 0004 0C00      		.word	12
  98 0006 0600      		.word	6
  99 0008 0300      		.word	3
 100 000a 0200      		.word	2
 101 000c 0100      		.word	1
 102 000e FF00      		.word	255
 103               		.section	.progmem.data.baudctrl_8mhz,"a",@progbits
 106               	baudctrl_8mhz:
 107 0000 A001      		.word	416
 108 0002 CF00      		.word	207
 109 0004 6700      		.word	103
 110 0006 3300      		.word	51
 111 0008 1900      		.word	25
 112 000a 0C00      		.word	12
 113 000c 0700      		.word	7
 114 000e 0800      		.word	8
 115               		.section	.progmem.data.baudctrl_16mhz,"a",@progbits
 118               	baudctrl_16mhz:
 119 0000 4003      		.word	832
 120 0002 A001      		.word	416
 121 0004 CF00      		.word	207
 122 0006 6700      		.word	103
 123 0008 3300      		.word	51
 124 000a 1900      		.word	25
 125 000c 1000      		.word	16
 126 000e 1000      		.word	16
 127               		.text
 129               	usart_double_baud_enable:
 130               	.LFB101:
 131               		.file 2 "../../../platform/mega_rf/drivers/usart/usart_megarf.h"
   1:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
   2:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \file
   3:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
   4:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief USART driver for AVR MEGARF.
   5:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
   6:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * This file contains basic functions for the AVR MEGA USART, with support for
   7:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * all modes, settings and clock speeds.
   8:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
   9:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * Copyright (c) 2013-2015 Atmel Corporation. All rights reserved.
  10:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
  11:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \asf_license_start
  12:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
  13:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \page License
  14:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
  15:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * Redistribution and use in source and binary forms, with or without
  16:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * modification, are permitted provided that the following conditions are met:
  17:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
  18:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * 1. Redistributions of source code must retain the above copyright notice,
  19:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *    this list of conditions and the following disclaimer.
  20:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
  21:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * 2. Redistributions in binary form must reproduce the above copyright notice,
  22:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *    this list of conditions and the following disclaimer in the documentation
  23:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *    and/or other materials provided with the distribution.
  24:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
  25:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * 3. The name of Atmel may not be used to endorse or promote products derived
  26:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *    from this software without specific prior written permission.
  27:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
  28:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * 4. This software may only be redistributed and used in connection with an
  29:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *    Atmel microcontroller product.
  30:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
  31:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR IMPLIED
  32:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
  33:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
  34:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR
  35:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  36:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
  37:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  38:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
  39:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  40:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  41:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * POSSIBILITY OF SUCH DAMAGE.
  42:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
  43:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \asf_license_stop
  44:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
  45:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
  46:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #ifndef _USART_MEGARF_H_
  47:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define _USART_MEGARF_H_
  48:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
  49:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #ifdef __cplusplus
  50:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** extern "C" {
  51:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #endif
  52:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
  53:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #include "compiler.h"
  54:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #include "status_codes.h"
  55:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
  56:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
  57:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \defgroup megarf_usart_group USART module (USART)
  58:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
  59:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * See \ref megarf_usart_quickstart.
  60:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
  61:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * This is a driver for configuring, enabling, disabling and use of the on-chip
  62:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * USART.
  63:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
  64:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \section dependencies Dependencies
  65:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
  66:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * The USART module depends on the following modules:
  67:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *  - \ref sysclk_group for peripheral clock control.
  68:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *  - \ref port_driver_group for peripheral io port control.
  69:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
  70:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * @{
  71:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
  72:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
  73:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* ! Offset in lookup table for baudrate 1200 */
  74:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_BAUD_1200      0x00
  75:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* ! Offset in lookup table for baudrate 2400 */
  76:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_BAUD_2400      0x01
  77:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* ! Offset in lookup table for baudrate 4800 */
  78:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_BAUD_4800      0x02
  79:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* ! Offset in lookup table for baudrate 9600 */
  80:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_BAUD_9600      0x03
  81:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* ! Offset in lookup table for baudrate 19200 */
  82:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_BAUD_19200     0x04
  83:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* ! Offset in lookup table for baudrate 38400 */
  84:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_BAUD_38400     0x05
  85:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* ! Offset in lookup table for baudrate 57600 */
  86:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_BAUD_57600     0x06
  87:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* ! Offset in lookup table for baudrate 115200 */
  88:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_BAUD_115200    0x07
  89:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* ! Baudrate not in lookup table */
  90:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_BAUD_UNDEFINED 0xFF
  91:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
  92:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** typedef volatile uint8_t register8_t;
  93:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** typedef volatile uint16_t register16_t;
  94:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* Universal Synchronous/Asynchronous Receiver/Transmitter */
  95:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** typedef struct USART_struct {
  96:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	register8_t UCSRnA;  /* Control Register A */
  97:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	register8_t UCSRnB;  /* Control Register B */
  98:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	register8_t UCSRnC;  /* Control Register C */
  99:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	register8_t reserved;
 100:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	register16_t UBRR;  /* Baud Rate Register Value */
 101:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	register8_t UDR;  /* I/O Data Register */
 102:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** } USART_t;
 103:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 104:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USARTA0    (*(USART_t *)0xC0)   /* Universal Asynchronous
 105:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	                                 * Receiver-Transmitter A0 */
 106:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USARTA1    (*(USART_t *)0XC8)   /* Universal Asynchronous
 107:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	                                 * Receiver-Transmitter A1 */
 108:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 109:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* USART.UCSRxA  bit masks and bit positions */
 110:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_RXC_bm  0x80 /* RX complete bit mask.*/
 111:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_RXC_bp  7 /* RX complete bit position.*/
 112:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 113:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_TXC_bm  0x40 /* TX complete bit mask.*/
 114:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_TXC_bp  6 /* TX complete bit position.*/
 115:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 116:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_DRE_bm  0x20 /* DATA Register Empty Bit mask.*/
 117:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_DRE_bp  5 /*  DATA Register Empty bit position.*/
 118:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 119:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_FE_bm   0x10 /* Frame Error bit mask.*/
 120:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_FE_bp   4 /*Frame error bit position.*/
 121:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 122:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_DOR_bm  0x08 /* Data Over Run bit mask.*/
 123:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_DOR_bp  3 /* Data Over Run bit position.*/
 124:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 125:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_UPE_bm  0x04 /* Parity error bit mask.*/
 126:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_UPE_bp  2 /* Parity error bit position.*/
 127:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 128:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_U2X_bm  0x02 /* Double TX speed bit mask.*/
 129:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_U2X_bp  1 /* Double TX speed bit position.*/
 130:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 131:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_MPCM_bm  0x01 /* Multi Processor bit mask.*/
 132:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_MPMC_bp  0 /* Multi processor bit position.*/
 133:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 134:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* USART.UCSRxB  bit masks and bit positions */
 135:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_RXCIE_bm  0x80 /* RX complete interrupt Enable bit mask.*/
 136:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_RXCIE_bp  7 /* RX complete interrupt Enable bit position.*/
 137:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 138:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_TXCIE_bm  0x40 /* TX complete interrupt Enable bit mask.*/
 139:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_TXCIE_bp  6 /* TX complete interrupt Enable bit position.*/
 140:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 141:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_DRIE_bm  0x20 /* Data register empty interrupt Enable bit mask.*/
 142:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_DRIE_bp  5 /* Data register empty interrupt Enable bit position.*/
 143:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 144:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_RXEN_bm  0x10  /* Receiver Enable bit mask. */
 145:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_RXEN_bp  4  /* Receiver Enable bit position. */
 146:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 147:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_TXEN_bm  0x08  /* Transmitter Enable bit mask. */
 148:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_TXEN_bp  3  /* Transmitter Enable bit position. */
 149:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 150:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_CHSIZE2_bm  0x04  /* Character Size bit mask. */
 151:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_CHSIZE2_bp  2 /* Character Size bit position. */
 152:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 153:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_RXB8_bm  0x02  /* Transmit bit 8 bit mask. */
 154:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_RXB8_bp  1  /* Transmit bit 8 bit position. */
 155:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 156:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_TXB8_bm  0x01  /* Transmit bit 8 bit mask. */
 157:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_TXB8_bp  0  /* Transmit bit 8 bit position. */
 158:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 159:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* USART.UCSRxC  bit masks and bit positions */
 160:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_UMSEL01_gm  0xC0 /* USART Mode Select 01 grp mask.*/
 161:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_UMSEL01_gp  6 /* USART Mode Select 01 grp position.*/
 162:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 163:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_UMSEL01_bm  0x80 /* USART Mode Select 01 bit mask.*/
 164:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_UMSEL01_bp  7 /* USART Mode Select 01 bit position.*/
 165:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 166:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_UMSEL00_bm  0x40 /* USART Mode Select 00 bit mask.*/
 167:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_UMSEL00_bp  6 /* USART Mode Select 00 bit position.*/
 168:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 169:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_PMODE_gm  0x30 /* USART Parity Mode Select grp mask.*/
 170:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_PMODE_gp  4 /* USART Parity Mode Select grp position.*/
 171:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 172:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_PMODE01_bm  0x20 /* USART Parity Mode Select 01 bit mask.*/
 173:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_PMODE01_bp  5 /* USART Parity Mode Select 01 bit position.*/
 174:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 175:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_PMODE00_bm  0x10 /* USART Parity Mode Select 00 bit mask.*/
 176:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_PMODE00_bp  4 /* USART Parity Mode Select 00 bit position.*/
 177:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 178:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_STOPB_bm  0x08 /* USART stop bit mask.*/
 179:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_STOPB_bp  3 /* USART stop bit Position.*/
 180:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 181:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_CHSIZE01C_gm  0x06  /* Character Size 10 bit 1 mask. */
 182:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_CHSIZE01C_gp  1 /* Character Size 10 bit position. */
 183:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 184:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_CHSIZE01_bm  0x04  /* Character Size 10 bit 1 mask. */
 185:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_CHSIZE01_bp  2 /* Character Size 10 bit position. */
 186:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 187:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_CHSIZE00_bm  0x02  /* Character Size 00 bit 1 mask. */
 188:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_CHSIZE00_bp  1 /* Character Size bit 00 position. */
 189:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 190:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_UCPOL_bm  0x01  /* Sync mode Pol bit 1 mask. */
 191:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_UCPOL_bp  0 /*Sync mode Pol bit 0 position */
 192:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 193:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_UCPHA_bm 0x02 /* Clock Phase bit mask. */
 194:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_UCPHA_bp 1 /* Clock Phase bit position. */
 195:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 196:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_DORD_bm 0x04 /* Data order bit mask. */
 197:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_DORD_bp 2 /* Data order bit position. */
 198:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 199:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* Character Size */
 200:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** typedef enum USART_CHSIZE_enum {
 201:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	USART_CHSIZE_5BIT_gc = (0x00),  /* Character size: 5 bit */
 202:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	USART_CHSIZE_6BIT_gc = (0x01),  /* Character size: 6 bit */
 203:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	USART_CHSIZE_7BIT_gc = (0x02),  /* Character size: 7 bit */
 204:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	USART_CHSIZE_8BIT_gc = (0x03),  /* Character size: 8 bit */
 205:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	USART_CHSIZE_9BIT_gc = (0x07),  /* Character size: 9 bit */
 206:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** } USART_CHSIZE_t;
 207:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 208:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* Communication Mode */
 209:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** typedef enum USART_CMODE_enum {
 210:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	USART_CMODE_ASYNCHRONOUS_gc = (0x00 << USART_UMSEL01_gp),  /*
 211:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	                                                            *
 212:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	                                                            *
 213:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	                                                            *Asynchronous
 214:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	                                                            * Mode */
 215:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	USART_CMODE_SYNCHRONOUS_gc = (0x01 << USART_UMSEL01_gp),  /* Synchronous
 216:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	                                                           * Mode */
 217:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	USART_CMODE_IRDA_gc = (0x02 << USART_UMSEL01_gp),  /* IrDA Mode */
 218:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	USART_CMODE_MSPI_gc = (0x03 << USART_UMSEL01_gp),  /* Master SPI Mode */
 219:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** } USART_CMODE_t;
 220:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 221:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* Parity Mode */
 222:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** typedef enum USART_PMODE_enum {
 223:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	USART_PMODE_DISABLED_gc = (0x00 << USART_PMODE_gp),  /* No Parity */
 224:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	USART_PMODE_EVEN_gc = (0x02 << USART_PMODE_gp),  /* Even Parity */
 225:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	USART_PMODE_ODD_gc = (0x03 << USART_PMODE_gp),  /* Odd Parity */
 226:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** } USART_PMODE_t;
 227:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 228:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* ! Lookup table containing baudctrl values for CPU frequency 1 Mhz */
 229:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static PROGMEM_DECLARE(uint16_t, baudctrl_1mhz[]) = {
 230:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0033, /* Baud: 1200 */
 231:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0019, /* Baud: 2400 */
 232:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x000C, /* Baud: 4800 */
 233:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0006, /* Baud: 9600 */
 234:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0003, /* Baud: 19200 */
 235:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0002, /* Baud: 38400 */
 236:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0001, /* Baud: 57600 */
 237:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	USART_BAUD_UNDEFINED, /* Baud: 115200 */
 238:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** };
 239:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 240:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* ! Lookup table containing baudctrl values for CPU frequency 8 Mhz */
 241:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static PROGMEM_DECLARE(uint16_t, baudctrl_8mhz[]) = {
 242:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x01A0, /* Baud: 1200 */
 243:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x00CF, /* Baud: 2400 */
 244:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0067, /* Baud: 4800 */
 245:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0033, /* Baud: 9600 */
 246:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0019, /* Baud: 19200 */
 247:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x000C, /* Baud: 38400 */
 248:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0007, /* Baud: 57600 */
 249:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0008, /* Baud: 115200 */
 250:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** };
 251:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 252:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* ! Lookup table containing baudctrl values for CPU frequency 16 Mhz */
 253:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static PROGMEM_DECLARE(uint16_t, baudctrl_16mhz[]) = {
 254:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0340, /* Baud: 1200 */
 255:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x01A0, /* Baud: 2400 */
 256:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x00CF, /* Baud: 4800 */
 257:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0067, /* Baud: 9600 */
 258:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0033, /* Baud: 19200 */
 259:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0019, /* Baud: 38400 */
 260:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0010, /* Baud: 57600 */
 261:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0010, /* Baud: 115200 */
 262:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** };
 263:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 264:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 265:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* ! Input parameters when initializing RS232 and similar modes. */
 266:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** typedef struct usart_rs232_options {
 267:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	/* ! Set baud rate of the USART (unused in slave modes). */
 268:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	uint32_t baudrate;
 269:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 270:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	/* ! Number of bits to transmit as a character (5 to 9). */
 271:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	USART_CHSIZE_t charlength;
 272:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 273:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	/* ! Parity type: USART_PMODE_DISABLED_gc, USART_PMODE_EVEN_gc, */
 274:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	/* ! USART_PMODE_ODD_gc. */
 275:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	USART_PMODE_t paritytype;
 276:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 277:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	/* ! Number of stop bits between two characters: */
 278:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	/* ! true: 2 stop bits */
 279:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	/* ! false: 1 stop bit */
 280:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	bool stopbits;
 281:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** } usart_rs232_options_t;
 282:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 283:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* ! Input parameters when initializing SPI master mode. */
 284:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** typedef struct usart_spi_options {
 285:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	/* ! Set baud rate of the USART in SPI mode. */
 286:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	uint32_t baudrate;
 287:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 288:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	/* ! SPI transmission mode. */
 289:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	uint8_t spimode;
 290:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 291:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	uint8_t data_order;
 292:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** } usart_spi_options_t;
 293:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 294:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 295:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 296:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Enable USART receiver.
 297:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 298:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart Pointer to the USART module
 299:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 300:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline void usart_rx_enable(USART_t *usart)
 301:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 302:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	(usart)->UCSRnB |= USART_RXEN_bm;
 303:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 304:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 305:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 306:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Disable USART receiver.
 307:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 308:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart Pointer to the USART module.
 309:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 310:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline void usart_rx_disable(USART_t *usart)
 311:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 312:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	(usart)->UCSRnB &= ~USART_RXEN_bm;
 313:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 314:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 315:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 316:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief  Configure the USART frame format.
 317:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 318:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *  Sets the frame format, Frame Size, parity mode and number of stop bits.
 319:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 320:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *  \param usart Pointer to the USART module
 321:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *  \param charSize The character size. Use USART_CHSIZE_t type.
 322:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *  \param parityMode The parity Mode. Use USART_PMODE_t type.
 323:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *  \param twoStopBits Enable two stop bit mode. Use bool type.
 324:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 325:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline void usart_format_set(USART_t *usart, USART_CHSIZE_t charSize,
 326:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 		USART_PMODE_t parityMode, bool twoStopBits)
 327:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 328:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	(usart)->UCSRnC
 329:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 		= ((usart)->UCSRnC &
 330:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 			(~USART_CHSIZE01C_gm)) | ((charSize & 0x03)
 331:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 			<< USART_CHSIZE01C_gp);
 332:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	(usart)->UCSRnB
 333:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 		= ((usart)->UCSRnB &
 334:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 			(~USART_CHSIZE2_bm)) | ((charSize & 0x04)
 335:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 			<< USART_CHSIZE2_bp);
 336:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 337:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	(usart)->UCSRnC = ((usart)->UCSRnC & (~USART_PMODE_gm)) | parityMode;
 338:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 339:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	(usart)->UCSRnC = ((usart)->UCSRnC & (~USART_STOPB_bm)) | (twoStopBits
 340:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 			<< USART_STOPB_bp);
 341:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 342:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 343:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 344:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Enable USART transmitter.
 345:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 346:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart Pointer to the USART module.
 347:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 348:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline void usart_tx_enable(USART_t *usart)
 349:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 350:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	(usart)->UCSRnB |= USART_TXEN_bm;
 351:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 352:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 353:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 354:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Disable USART transmitter.
 355:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 356:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart Pointer to the USART module.
 357:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 358:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline void usart_tx_disable(USART_t *usart)
 359:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 360:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	(usart)->UCSRnB &= ~USART_TXEN_bm;
 361:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 362:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 363:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 364:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Enable USART transmit complete interrupt.
 365:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 366:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart Pointer to the USART module.
 367:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 368:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline void usart_tx_complete_interrupt_enable(USART_t *usart)
 369:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 370:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	(usart)->UCSRnB |= USART_TXC_bm;
 371:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 372:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 373:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 374:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Enable USART receive complete interrupt.
 375:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 376:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart Pointer to the USART module.
 377:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 378:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline void usart_rx_complete_interrupt_enable(USART_t *usart)
 379:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 380:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	(usart)->UCSRnB |= USART_RXC_bm;
 381:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 382:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 383:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 384:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Enable USART data register empty interrupt.
 385:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 386:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart Pointer to the USART module.
 387:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 388:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline void usart_data_empty_interrupt_enable(USART_t *usart)
 389:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 390:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	(usart)->UCSRnB |= USART_DRIE_bm;
 391:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 392:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 393:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 394:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Disable USART transmit complete interrupt.
 395:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 396:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart Pointer to the USART module.
 397:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 398:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline void usart_tx_complete_interrupt_disable(USART_t *usart)
 399:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 400:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	(usart)->UCSRnB &= ~USART_TXC_bm;
 401:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 402:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 403:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 404:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Disable USART receive complete interrupt.
 405:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 406:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart Pointer to the USART module.
 407:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 408:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline void usart_rx_complete_interrupt_disable(USART_t *usart)
 409:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 410:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	(usart)->UCSRnB &= ~USART_RXC_bm;
 411:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 412:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 413:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 414:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Disable USART data register empty interrupt.
 415:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 416:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart Pointer to the USART module.
 417:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 418:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline void usart_data_empty_interrupt_disable(USART_t *usart)
 419:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 420:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	(usart)->UCSRnB &= ~USART_DRIE_bm;
 421:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 422:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 423:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 424:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Set the mode the USART run in.
 425:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 426:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * Set the mode the USART run in. The default mode is asynchronous mode.
 427:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 428:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart Pointer to the USART module register section.
 429:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usartmode Selects the USART mode. Use USART_CMODE_t type.
 430:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 431:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * USART modes:
 432:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * - 0x0        : Asynchronous mode.
 433:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * - 0x1        : Synchronous mode.
 434:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * - 0x2        : IrDA mode.
 435:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * - 0x3        : Master SPI mode.
 436:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 437:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline void usart_set_mode(USART_t *usart, USART_CMODE_t usartmode)
 438:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 439:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	(usart)->UCSRnC = ((usart)->UCSRnC & (~USART_UMSEL01_gm)) | usartmode;
 440:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 441:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 442:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 443:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Check if data register empty flag is set.
 444:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 445:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart The USART module.
 446:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 447:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline bool usart_data_register_is_empty(USART_t *usart)
 448:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 449:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	return (usart)->UCSRnA & USART_DRE_bm;
 450:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 451:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 452:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 453:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Checks if the RX complete interrupt flag is set.
 454:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 455:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * Checks if the RX complete interrupt flag is set.
 456:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 457:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart The USART module.
 458:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 459:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline bool usart_rx_is_complete(USART_t *usart)
 460:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 461:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	return (usart)->UCSRnA & USART_RXC_bm;
 462:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 463:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 464:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 465:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Checks if the TX complete interrupt flag is set.
 466:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 467:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * Checks if the TX complete interrupt flag is set.
 468:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 469:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart The USART module.
 470:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 471:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline bool usart_tx_is_complete(USART_t *usart)
 472:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 473:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	return (usart)->UCSRnA & USART_TXC_bm;
 474:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 475:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 476:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 477:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Clear TX complete interrupt flag.
 478:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * TX flag is clear after complete transmission, automatically.
 479:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart The USART module.
 480:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 481:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline void usart_clear_tx_complete(USART_t *usart)
 482:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 483:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****          usart->UCSRnA |=  USART_TXC_bm;
 484:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 485:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 486:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 487:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Write a data to the USART data register.
 488:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 489:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart The USART module.
 490:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param txdata The data to be transmitted.
 491:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 492:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline void usart_put(USART_t *usart, uint8_t txdata)
 493:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 494:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	(usart)->UDR = txdata;
 495:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 496:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 497:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 498:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief  Read a data to the USART data register.
 499:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 500:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart The USART module.
 501:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 502:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \return The received data
 503:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 504:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline uint8_t usart_get(USART_t *usart)
 505:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 506:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	return (usart)->UDR;
 507:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 508:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 509:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 510:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Double the USART transmission speed.
 511:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 512:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart The USART module.
 513:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 514:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline void usart_double_baud_enable(USART_t *usart)
 515:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 132               		.loc 2 515 0
 133               		.cfi_startproc
 134 0034 CF93      		push r28
 135               	.LCFI6:
 136               		.cfi_def_cfa_offset 3
 137               		.cfi_offset 28, -2
 138 0036 DF93      		push r29
 139               	.LCFI7:
 140               		.cfi_def_cfa_offset 4
 141               		.cfi_offset 29, -3
 142 0038 00D0      		rcall .
 143               	.LCFI8:
 144               		.cfi_def_cfa_offset 6
 145 003a CDB7      		in r28,__SP_L__
 146 003c DEB7      		in r29,__SP_H__
 147               	.LCFI9:
 148               		.cfi_def_cfa_register 28
 149               	/* prologue: function */
 150               	/* frame size = 2 */
 151               	/* stack size = 4 */
 152               	.L__stack_usage = 4
 153 003e 9A83      		std Y+2,r25
 154 0040 8983      		std Y+1,r24
 516:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	usart->UCSRnA |=  USART_U2X_bm;
 155               		.loc 2 516 0
 156 0042 8981      		ldd r24,Y+1
 157 0044 9A81      		ldd r25,Y+2
 158 0046 FC01      		movw r30,r24
 159 0048 8081      		ld r24,Z
 160 004a 282F      		mov r18,r24
 161 004c 2260      		ori r18,lo8(2)
 162 004e 8981      		ldd r24,Y+1
 163 0050 9A81      		ldd r25,Y+2
 164 0052 FC01      		movw r30,r24
 165 0054 2083      		st Z,r18
 517:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 166               		.loc 2 517 0
 167 0056 0000      		nop
 168               	/* epilogue start */
 169 0058 0F90      		pop __tmp_reg__
 170 005a 0F90      		pop __tmp_reg__
 171 005c DF91      		pop r29
 172 005e CF91      		pop r28
 173 0060 0895      		ret
 174               		.cfi_endproc
 175               	.LFE101:
 178               	usart_serial_init:
 179               	.LFB104:
 180               		.file 3 "../../../platform/common/services/serial/megarf_usart/usart_serial.h"
   1:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** /**
   2:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * \file
   3:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
   4:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * \brief This file defines a useful set of functions for the Serial interface on 
   5:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * AVR MEGARF devices.
   6:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
   7:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * Copyright (c) 2013 Atmel Corporation. All rights reserved.
   8:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
   9:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * \asf_license_start
  10:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
  11:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * \page License
  12:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
  13:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * Redistribution and use in source and binary forms, with or without
  14:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * modification, are permitted provided that the following conditions are met:
  15:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
  16:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * 1. Redistributions of source code must retain the above copyright notice,
  17:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *    this list of conditions and the following disclaimer.
  18:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
  19:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * 2. Redistributions in binary form must reproduce the above copyright notice,
  20:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *    this list of conditions and the following disclaimer in the documentation
  21:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *    and/or other materials provided with the distribution.
  22:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
  23:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * 3. The name of Atmel may not be used to endorse or promote products derived
  24:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *    from this software without specific prior written permission.
  25:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
  26:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * 4. This software may only be redistributed and used in connection with an
  27:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *    Atmel microcontroller product.
  28:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
  29:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR IMPLIED
  30:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
  31:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
  32:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR
  33:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  34:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
  35:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  36:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
  37:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  38:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  39:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * POSSIBILITY OF SUCH DAMAGE.
  40:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
  41:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * \asf_license_stop
  42:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
  43:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  */
  44:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** #ifndef _USART_SERIAL_H_
  45:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** #define _USART_SERIAL_H_
  46:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 
  47:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** #ifdef __cplusplus
  48:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** extern "C" {
  49:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** #endif
  50:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 
  51:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** #include "compiler.h"
  52:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** #include "sysclk.h"
  53:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** #include "status_codes.h"
  54:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** #include "usart_megarf.h"
  55:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 
  56:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** /*! \name Serial Management Configuration
  57:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  */
  58:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** /* ! @{ */
  59:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** #include "conf_usart_serial.h"
  60:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** /* ! @} */
  61:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 
  62:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** typedef usart_rs232_options_t usart_serial_options_t;
  63:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 
  64:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** typedef USART_t *usart_if;
  65:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 
  66:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** /*! \brief Initializes the Usart in master mode.
  67:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
  68:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * \param usart       Base address of the USART instance.
  69:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * \param options     Options needed to set up RS232 communication (see \ref
  70:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * usart_serial_options_t).
  71:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
  72:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * \retval true if the initialization was successful
  73:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * \retval false if initialization failed (error in baud rate calculation)
  74:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  */
  75:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** static inline bool usart_serial_init(usart_if usart, const
  76:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 		usart_serial_options_t *options)
  77:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** {
 181               		.loc 3 77 0
 182               		.cfi_startproc
 183 0062 CF93      		push r28
 184               	.LCFI10:
 185               		.cfi_def_cfa_offset 3
 186               		.cfi_offset 28, -2
 187 0064 DF93      		push r29
 188               	.LCFI11:
 189               		.cfi_def_cfa_offset 4
 190               		.cfi_offset 29, -3
 191 0066 CDB7      		in r28,__SP_L__
 192 0068 DEB7      		in r29,__SP_H__
 193               	.LCFI12:
 194               		.cfi_def_cfa_register 28
 195 006a 2B97      		sbiw r28,11
 196               	.LCFI13:
 197               		.cfi_def_cfa_offset 15
 198 006c 0FB6      		in __tmp_reg__,__SREG__
 199 006e F894      		cli
 200 0070 DEBF      		out __SP_H__,r29
 201 0072 0FBE      		out __SREG__,__tmp_reg__
 202 0074 CDBF      		out __SP_L__,r28
 203               	/* prologue: function */
 204               	/* frame size = 11 */
 205               	/* stack size = 13 */
 206               	.L__stack_usage = 13
 207 0076 9987      		std Y+9,r25
 208 0078 8887      		std Y+8,r24
 209 007a 7B87      		std Y+11,r23
 210 007c 6A87      		std Y+10,r22
  78:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 	/* USART options. */
  79:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 	usart_rs232_options_t usart_rs232_options;
  80:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 	usart_rs232_options.charlength   = options->charlength;
 211               		.loc 3 80 0
 212 007e 8A85      		ldd r24,Y+10
 213 0080 9B85      		ldd r25,Y+11
 214 0082 FC01      		movw r30,r24
 215 0084 8481      		ldd r24,Z+4
 216 0086 8D83      		std Y+5,r24
  81:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 	usart_rs232_options.paritytype   = options->paritytype;
 217               		.loc 3 81 0
 218 0088 8A85      		ldd r24,Y+10
 219 008a 9B85      		ldd r25,Y+11
 220 008c FC01      		movw r30,r24
 221 008e 8581      		ldd r24,Z+5
 222 0090 8E83      		std Y+6,r24
  82:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 	usart_rs232_options.stopbits     = options->stopbits;
 223               		.loc 3 82 0
 224 0092 8A85      		ldd r24,Y+10
 225 0094 9B85      		ldd r25,Y+11
 226 0096 FC01      		movw r30,r24
 227 0098 8681      		ldd r24,Z+6
 228 009a 8F83      		std Y+7,r24
  83:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 	usart_rs232_options.baudrate     = options->baudrate;
 229               		.loc 3 83 0
 230 009c 8A85      		ldd r24,Y+10
 231 009e 9B85      		ldd r25,Y+11
 232 00a0 FC01      		movw r30,r24
 233 00a2 8081      		ld r24,Z
 234 00a4 9181      		ldd r25,Z+1
 235 00a6 A281      		ldd r26,Z+2
 236 00a8 B381      		ldd r27,Z+3
 237 00aa 8983      		std Y+1,r24
 238 00ac 9A83      		std Y+2,r25
 239 00ae AB83      		std Y+3,r26
 240 00b0 BC83      		std Y+4,r27
  84:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 
  85:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 	if (usart_init_rs232(usart, &usart_rs232_options)) {
 241               		.loc 3 85 0
 242 00b2 8885      		ldd r24,Y+8
 243 00b4 9985      		ldd r25,Y+9
 244 00b6 9E01      		movw r18,r28
 245 00b8 2F5F      		subi r18,-1
 246 00ba 3F4F      		sbci r19,-1
 247 00bc B901      		movw r22,r18
 248 00be 0E94 0000 		call usart_init_rs232
 249 00c2 8823      		tst r24
 250 00c4 01F0      		breq .L7
  86:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 		return true;
 251               		.loc 3 86 0
 252 00c6 81E0      		ldi r24,lo8(1)
 253 00c8 00C0      		rjmp .L9
 254               	.L7:
  87:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 	} else {
  88:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 		return false;
 255               		.loc 3 88 0
 256 00ca 80E0      		ldi r24,0
 257               	.L9:
 258               	/* epilogue start */
  89:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 	}
  90:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** }
 259               		.loc 3 90 0 discriminator 1
 260 00cc 2B96      		adiw r28,11
 261 00ce 0FB6      		in __tmp_reg__,__SREG__
 262 00d0 F894      		cli
 263 00d2 DEBF      		out __SP_H__,r29
 264 00d4 0FBE      		out __SREG__,__tmp_reg__
 265 00d6 CDBF      		out __SP_L__,r28
 266 00d8 DF91      		pop r29
 267 00da CF91      		pop r28
 268 00dc 0895      		ret
 269               		.cfi_endproc
 270               	.LFE104:
 273               	usart_serial_putchar:
 274               	.LFB105:
  91:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 
  92:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** /*! \brief Sends a character with the USART.
  93:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
  94:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * \param usart   Base address of the USART instance.
  95:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * \param c       Character to write.
  96:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
  97:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * \return Status code
  98:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  */
  99:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** static inline status_code_t usart_serial_putchar(usart_if usart, uint8_t c)
 100:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** {
 275               		.loc 3 100 0
 276               		.cfi_startproc
 277 00de CF93      		push r28
 278               	.LCFI14:
 279               		.cfi_def_cfa_offset 3
 280               		.cfi_offset 28, -2
 281 00e0 DF93      		push r29
 282               	.LCFI15:
 283               		.cfi_def_cfa_offset 4
 284               		.cfi_offset 29, -3
 285 00e2 00D0      		rcall .
 286 00e4 1F92      		push __zero_reg__
 287               	.LCFI16:
 288               		.cfi_def_cfa_offset 7
 289 00e6 CDB7      		in r28,__SP_L__
 290 00e8 DEB7      		in r29,__SP_H__
 291               	.LCFI17:
 292               		.cfi_def_cfa_register 28
 293               	/* prologue: function */
 294               	/* frame size = 3 */
 295               	/* stack size = 5 */
 296               	.L__stack_usage = 5
 297 00ea 9A83      		std Y+2,r25
 298 00ec 8983      		std Y+1,r24
 299 00ee 6B83      		std Y+3,r22
 101:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 	return usart_putchar(usart, c);
 300               		.loc 3 101 0
 301 00f0 8981      		ldd r24,Y+1
 302 00f2 9A81      		ldd r25,Y+2
 303 00f4 6B81      		ldd r22,Y+3
 304 00f6 0E94 0000 		call usart_putchar
 305               	/* epilogue start */
 102:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** }
 306               		.loc 3 102 0
 307 00fa 0F90      		pop __tmp_reg__
 308 00fc 0F90      		pop __tmp_reg__
 309 00fe 0F90      		pop __tmp_reg__
 310 0100 DF91      		pop r29
 311 0102 CF91      		pop r28
 312 0104 0895      		ret
 313               		.cfi_endproc
 314               	.LFE105:
 317               	usart_serial_getchar:
 318               	.LFB106:
 103:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 
 104:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** /*! \brief Waits until a character is received, and returns it.
 105:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
 106:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * \param usart   Base address of the USART instance.
 107:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * \param data   Data to read
 108:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
 109:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  */
 110:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** static inline void usart_serial_getchar(usart_if usart, uint8_t *data)
 111:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** {
 319               		.loc 3 111 0
 320               		.cfi_startproc
 321 0106 CF93      		push r28
 322               	.LCFI18:
 323               		.cfi_def_cfa_offset 3
 324               		.cfi_offset 28, -2
 325 0108 DF93      		push r29
 326               	.LCFI19:
 327               		.cfi_def_cfa_offset 4
 328               		.cfi_offset 29, -3
 329 010a 00D0      		rcall .
 330 010c 00D0      		rcall .
 331               	.LCFI20:
 332               		.cfi_def_cfa_offset 8
 333 010e CDB7      		in r28,__SP_L__
 334 0110 DEB7      		in r29,__SP_H__
 335               	.LCFI21:
 336               		.cfi_def_cfa_register 28
 337               	/* prologue: function */
 338               	/* frame size = 4 */
 339               	/* stack size = 6 */
 340               	.L__stack_usage = 6
 341 0112 9A83      		std Y+2,r25
 342 0114 8983      		std Y+1,r24
 343 0116 7C83      		std Y+4,r23
 344 0118 6B83      		std Y+3,r22
 112:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 	*data = usart_getchar(usart);
 345               		.loc 3 112 0
 346 011a 8981      		ldd r24,Y+1
 347 011c 9A81      		ldd r25,Y+2
 348 011e 0E94 0000 		call usart_getchar
 349 0122 282F      		mov r18,r24
 350 0124 8B81      		ldd r24,Y+3
 351 0126 9C81      		ldd r25,Y+4
 352 0128 FC01      		movw r30,r24
 353 012a 2083      		st Z,r18
 113:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** }
 354               		.loc 3 113 0
 355 012c 0000      		nop
 356               	/* epilogue start */
 357 012e 0F90      		pop __tmp_reg__
 358 0130 0F90      		pop __tmp_reg__
 359 0132 0F90      		pop __tmp_reg__
 360 0134 0F90      		pop __tmp_reg__
 361 0136 DF91      		pop r29
 362 0138 CF91      		pop r28
 363 013a 0895      		ret
 364               		.cfi_endproc
 365               	.LFE106:
 368               	stdio_serial_init:
 369               	.LFB107:
 370               		.file 4 "../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h"
   1:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** /**
   2:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
   3:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * \file
   4:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
   5:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * \brief Common Standard I/O Serial Management.
   6:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
   7:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * This file defines a useful set of functions for the Stdio Serial interface on AVR
   8:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * and SAM devices.
   9:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
  10:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * Copyright (c) 2009-2013 Atmel Corporation. All rights reserved.
  11:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
  12:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * \asf_license_start
  13:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
  14:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * \page License
  15:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
  16:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * Redistribution and use in source and binary forms, with or without
  17:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * modification, are permitted provided that the following conditions are met:
  18:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
  19:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * 1. Redistributions of source code must retain the above copyright notice,
  20:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *    this list of conditions and the following disclaimer.
  21:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
  22:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * 2. Redistributions in binary form must reproduce the above copyright notice,
  23:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *    this list of conditions and the following disclaimer in the documentation
  24:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *    and/or other materials provided with the distribution.
  25:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
  26:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * 3. The name of Atmel may not be used to endorse or promote products derived
  27:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *    from this software without specific prior written permission.
  28:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
  29:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * 4. This software may only be redistributed and used in connection with an
  30:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *    Atmel microcontroller product.
  31:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
  32:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR IMPLIED
  33:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
  34:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
  35:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR
  36:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  37:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
  38:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  39:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
  40:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  41:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  42:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * POSSIBILITY OF SUCH DAMAGE.
  43:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
  44:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * \asf_license_stop
  45:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
  46:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  ******************************************************************************/
  47:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 
  48:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 
  49:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** #ifndef _STDIO_SERIAL_H_
  50:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** #define _STDIO_SERIAL_H_
  51:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 
  52:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** /**
  53:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * \defgroup group_common_utils_stdio_stdio_serial Standard serial I/O (stdio)
  54:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * \ingroup group_common_utils_stdio
  55:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
  56:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * Common standard serial I/O management driver that
  57:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * implements a stdio serial interface on AVR and SAM devices.
  58:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
  59:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * \{
  60:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  */
  61:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 
  62:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** #include <stdio.h>
  63:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** #include "compiler.h"
  64:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** #ifndef SAMD20
  65:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** # include "sysclk.h"
  66:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** #endif
  67:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** #include "serial.h"
  68:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 
  69:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** #if (XMEGA || MEGA_RF) && defined(__GNUC__)
  70:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	extern int _write (char c, int *f);
  71:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	extern int _read (int *f);
  72:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** #endif
  73:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 
  74:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 
  75:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** //! Pointer to the base of the USART module instance to use for stdio.
  76:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** extern volatile void *volatile stdio_base;
  77:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** //! Pointer to the external low level write function.
  78:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** extern int (*ptr_put)(void volatile*, char);
  79:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 
  80:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** //! Pointer to the external low level read function.
  81:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** extern void (*ptr_get)(void volatile*, char*);
  82:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 
  83:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** /*! \brief Initializes the stdio in Serial Mode.
  84:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
  85:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * \param usart       Base address of the USART instance.
  86:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * \param opt         Options needed to set up RS232 communication (see \ref usart_options_t).
  87:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
  88:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  */
  89:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** static inline void stdio_serial_init(volatile void *usart, const usart_serial_options_t *opt)
  90:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** {
 371               		.loc 4 90 0
 372               		.cfi_startproc
 373 013c CF93      		push r28
 374               	.LCFI22:
 375               		.cfi_def_cfa_offset 3
 376               		.cfi_offset 28, -2
 377 013e DF93      		push r29
 378               	.LCFI23:
 379               		.cfi_def_cfa_offset 4
 380               		.cfi_offset 29, -3
 381 0140 00D0      		rcall .
 382 0142 00D0      		rcall .
 383               	.LCFI24:
 384               		.cfi_def_cfa_offset 8
 385 0144 CDB7      		in r28,__SP_L__
 386 0146 DEB7      		in r29,__SP_H__
 387               	.LCFI25:
 388               		.cfi_def_cfa_register 28
 389               	/* prologue: function */
 390               	/* frame size = 4 */
 391               	/* stack size = 6 */
 392               	.L__stack_usage = 6
 393 0148 9A83      		std Y+2,r25
 394 014a 8983      		std Y+1,r24
 395 014c 7C83      		std Y+4,r23
 396 014e 6B83      		std Y+3,r22
  91:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	stdio_base = (void *)usart;
 397               		.loc 4 91 0
 398 0150 8981      		ldd r24,Y+1
 399 0152 9A81      		ldd r25,Y+2
 400 0154 9093 0000 		sts stdio_base+1,r25
 401 0158 8093 0000 		sts stdio_base,r24
  92:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	ptr_put = (int (*)(void volatile*,char))&usart_serial_putchar;
 402               		.loc 4 92 0
 403 015c 80E0      		ldi r24,lo8(gs(usart_serial_putchar))
 404 015e 90E0      		ldi r25,hi8(gs(usart_serial_putchar))
 405 0160 9093 0000 		sts ptr_put+1,r25
 406 0164 8093 0000 		sts ptr_put,r24
  93:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	ptr_get = (void (*)(void volatile*,char*))&usart_serial_getchar;
 407               		.loc 4 93 0
 408 0168 80E0      		ldi r24,lo8(gs(usart_serial_getchar))
 409 016a 90E0      		ldi r25,hi8(gs(usart_serial_getchar))
 410 016c 9093 0000 		sts ptr_get+1,r25
 411 0170 8093 0000 		sts ptr_get,r24
  94:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** # if (XMEGA || MEGA_RF)
  95:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	usart_serial_init((USART_t *)usart,opt);
 412               		.loc 4 95 0
 413 0174 2B81      		ldd r18,Y+3
 414 0176 3C81      		ldd r19,Y+4
 415 0178 8981      		ldd r24,Y+1
 416 017a 9A81      		ldd r25,Y+2
 417 017c B901      		movw r22,r18
 418 017e 0E94 0000 		call usart_serial_init
  96:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** # elif UC3
  97:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	usart_serial_init(usart,(usart_serial_options_t *)opt);
  98:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** # elif SAM
  99:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	usart_serial_init((Usart *)usart,(usart_serial_options_t *)opt);
 100:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** # else
 101:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** #  error Unsupported chip type
 102:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** # endif
 103:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 
 104:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** # if defined(__GNUC__)
 105:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** #  if (XMEGA || MEGA_RF)
 106:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	// For AVR GCC libc print redirection uses fdevopen.
 107:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	fdevopen((int (*)(char, FILE*))(_write),(int (*)(FILE*))(_read));
 419               		.loc 4 107 0
 420 0182 60E0      		ldi r22,lo8(gs(_read))
 421 0184 70E0      		ldi r23,hi8(gs(_read))
 422 0186 80E0      		ldi r24,lo8(gs(_write))
 423 0188 90E0      		ldi r25,hi8(gs(_write))
 424 018a 0E94 0000 		call fdevopen
 108:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** #  endif
 109:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** #  if UC3 || SAM
 110:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	// For AVR32 and SAM GCC
 111:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	// Specify that stdout and stdin should not be buffered.
 112:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	setbuf(stdout, NULL);
 113:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	setbuf(stdin, NULL);
 114:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	// Note: Already the case in IAR's Normal DLIB default configuration
 115:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	// and AVR GCC library:
 116:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	// - printf() emits one character at a time.
 117:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	// - getchar() requests only 1 byte to exit.
 118:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** #  endif
 119:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** # endif
 120:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** }
 425               		.loc 4 120 0
 426 018e 0000      		nop
 427               	/* epilogue start */
 428 0190 0F90      		pop __tmp_reg__
 429 0192 0F90      		pop __tmp_reg__
 430 0194 0F90      		pop __tmp_reg__
 431 0196 0F90      		pop __tmp_reg__
 432 0198 DF91      		pop r29
 433 019a CF91      		pop r28
 434 019c 0895      		ret
 435               		.cfi_endproc
 436               	.LFE107:
 439               	macsc_enable_manual_bts:
 440               	.LFB121:
 441               		.file 5 "../../../platform/mega_rf/drivers/macsc/macsc_megarf.h"
   1:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
   2:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \file
   3:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
   4:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief AVR MEGARF MAC Symbol Counter Driver Definitions
   5:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
   6:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * Copyright (c) 2013 Atmel Corporation. All rights reserved.
   7:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
   8:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \asf_license_start
   9:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  10:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \page License
  11:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  12:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * Redistribution and use in source and binary forms, with or without
  13:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * modification, are permitted provided that the following conditions are met:
  14:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  15:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * 1. Redistributions of source code must retain the above copyright notice,
  16:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *    this list of conditions and the following disclaimer.
  17:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  18:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * 2. Redistributions in binary form must reproduce the above copyright notice,
  19:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *    this list of conditions and the following disclaimer in the documentation
  20:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *    and/or other materials provided with the distribution.
  21:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  22:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * 3. The name of Atmel may not be used to endorse or promote products derived
  23:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *    from this software without specific prior written permission.
  24:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  25:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * 4. This software may only be redistributed and used in connection with an
  26:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *    Atmel microcontroller product.
  27:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  28:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR IMPLIED
  29:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
  30:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
  31:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR
  32:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  33:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
  34:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  35:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
  36:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  37:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  38:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * POSSIBILITY OF SUCH DAMAGE.
  39:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  40:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \asf_license_stop
  41:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  42:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
  43:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** #ifndef MACSC_MEGARF_H
  44:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** #define MACSC_MEGARF_H
  45:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
  46:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** #include <compiler.h>
  47:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** #include <parts.h>
  48:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** #include "status_codes.h"
  49:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
  50:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** #ifdef __cplusplus
  51:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** extern "C" {
  52:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** #endif
  53:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
  54:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
  55:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \defgroup macsc_group MAC Symbol Counter Driver(MACSC)
  56:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  57:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * See \ref megarf_macsc_quickstart
  58:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  59:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * This is a driver for the AVR MEGARF MAC Symbol Counter Driver(MACSC).
  60:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * It provides functions for enabling, disabling and configuring the module.
  61:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  62:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \section dependencies Dependencies
  63:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * This driver depends on the following modules:
  64:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * - \ref interrupt_group for ISR definition and disabling interrupts during
  65:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * critical code sections.
  66:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * @{
  67:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
  68:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
  69:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
  70:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Interrupt event callback function type
  71:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  72:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * The interrupt handler can be configured to do a function callback,
  73:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * the callback function must match the macsc_callback_t type.
  74:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  75:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
  76:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** typedef void (*macsc_callback_t)(void);
  77:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
  78:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /* ! MAC symbol counter compare Channel index */
  79:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** enum macsc_cc_channel {
  80:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	/* ! Channel 1 */
  81:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	MACSC_CC1 = 1,
  82:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	/* ! Channel 2 */
  83:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	MACSC_CC2 = 2,
  84:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	/* ! Channel 3 */
  85:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	MACSC_CC3 = 3,
  86:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** };
  87:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
  88:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief MAC SC clock source select
  89:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  90:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * uses the SCCKSEL bit in SSCR register to select macsc clk src
  91:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  92:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * If the bit is one,the RTC clock from TOSC1 is selected, otherwise the symbol
  93:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * counter operates with the clock from XTAL1.
  94:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * During transceiver sleep modes the clock falls back to the RTC clock source,
  95:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * regardless of the selected clock. After wakeup, it switches back to the
  96:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * previosly
  97:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * selected clock source.
  98:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
  99:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 100:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** enum macsc_xtal {
 101:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	/* ! 16MHz as macsc clock */
 102:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	MACSC_16MHz = 0,
 103:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	MACSC_32KHz = 1,
 104:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** };
 105:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 106:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 107:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * @brief Reads the 32-bit timer register in the required order of bytes
 108:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 109:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * @param hh hh octet of 32-bit register
 110:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * @param hl hl octet of 32-bit register
 111:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * @param lh lh octet of 32-bit register
 112:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * @param ll ll octet of 32-bit register
 113:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 114:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * @returns uint32_t Value of timer register
 115:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 116:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** static inline uint32_t macsc_read32(volatile uint8_t *hh,
 117:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		volatile uint8_t *hl,
 118:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		volatile uint8_t *lh,
 119:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		volatile uint8_t *ll)
 120:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** {
 121:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	union {
 122:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		uint8_t a[4];
 123:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		uint32_t rv;
 124:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	}
 125:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	x;
 126:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 127:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	x.a[0] = *ll;
 128:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	x.a[1] = *lh;
 129:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	x.a[2] = *hl;
 130:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	x.a[3] = *hh;
 131:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 132:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	return x.rv;
 133:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** }
 134:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 135:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /* ! compare modes */
 136:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** #define MACSC_ABSOLUTE_CMP 0
 137:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** #define MACSC_RELATIVE_CMP 1
 138:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 139:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /** String concatenation by preprocessor used to create proper register names.
 140:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  **/
 141:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** #define CONCAT(a, b) a ## b
 142:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 143:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /** Creates proper subregister names and reads the corresponding values. */
 144:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** #define MACSC_READ32(reg)                  macsc_read32(&CONCAT(reg, HH), \
 145:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		&CONCAT(reg, HL), \
 146:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		&CONCAT(reg, LH), \
 147:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		&CONCAT(reg, LL))
 148:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 149:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** #define MACSC_WRITE32(reg, val)	\
 150:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	do { \
 151:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		union { uint8_t a[4]; uint32_t v; } \
 152:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		x; \
 153:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		x.v = val; \
 154:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		CONCAT(reg, HH) = x.a[3]; \
 155:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		CONCAT(reg, HL) = x.a[2]; \
 156:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		CONCAT(reg, LH) = x.a[1]; \
 157:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		CONCAT(reg, LL) = x.a[0]; \
 158:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	} \
 159:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	while (0)
 160:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 161:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 162:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Enable MAC SC
 163:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 164:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * Enables the SC
 165:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 166:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param clk_src selection of clk source,avalable options in macsc_xtal,fixed
 167:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *  prescalar
 168:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param sleep_enable enable RTC as clock source during sleep
 169:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param auto_ts enable automatic timestamping
 170:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 171:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 172:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** void macsc_enable(void);
 173:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 174:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 175:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Check if MACSC is enabled
 176:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 177:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * check if the MACSC is enabled.
 178:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 179:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param none
 180:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 181:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 182:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** bool is_macsc_enable(void);
 183:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 184:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 185:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Disable MAC SC
 186:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 187:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * Disables the MAC SC
 188:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 189:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param none
 190:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 191:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 192:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** void macsc_disable(void);
 193:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 194:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 195:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Check if back-off slot counter is enabled
 196:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 197:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * check if the back-off slot counter is enabled.
 198:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 199:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param none
 200:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 201:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 202:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** bool is_macsc_backoff_enable(void);
 203:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 204:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 205:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Enables compare interrupts of the MACSC
 206:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 207:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param channel Compare channel
 208:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 209:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** void macsc_enable_cmp_int(enum macsc_cc_channel channel);
 210:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 211:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 212:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Disables compare interrupts of the MACSC
 213:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 214:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param channel Compare channel
 215:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */void macsc_disable_cmp_int(enum macsc_cc_channel channel);
 216:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 217:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 218:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Usage of Absolute compare mode of the MACSC
 219:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 220:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param abs_rel  0 for absoulte cmp;1 for relative cmp
 221:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param cmp compare value for SCOCRx register
 222:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param channel Compare channel
 223:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 224:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** void macsc_use_cmp(bool abs_rel, uint32_t cmp,enum macsc_cc_channel channel);
 225:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 226:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 227:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \ingroup macsc_group
 228:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \defgroup macsc_interrupt_group MAC Symbol Counter (MACSC) interrupt
 229:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * management
 230:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * This group provides functions to configure MACSC module interrupts
 231:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 232:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * @{
 233:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 234:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 235:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 236:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Set MACSC overflow interrupt callback function
 237:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 238:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * This function allows the caller to set and change the interrupt callback
 239:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * function. Without setting a callback function the interrupt handler in the
 240:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * driver will only clear the interrupt flags.
 241:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 242:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param callback Reference to a callback function
 243:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 244:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** void macsc_set_ovf_int_cb(macsc_callback_t callback);
 245:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 246:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 247:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Set MACSC Compare Channel 1 interrupt callback function
 248:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 249:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * This function allows the caller to set and change the interrupt callback
 250:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * function. Without setting a callback function the interrupt handler in the
 251:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * driver will only clear the interrupt flags.
 252:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 253:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param callback Reference to a callback function
 254:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 255:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** void macsc_set_cmp1_int_cb(macsc_callback_t callback);
 256:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 257:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 258:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Set MACSC Compare Channel 2 interrupt callback function
 259:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 260:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * This function allows the caller to set and change the interrupt callback
 261:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * function. Without setting a callback function the interrupt handler in the
 262:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * driver will only clear the interrupt flags.
 263:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 264:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param callback Reference to a callback function
 265:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 266:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** void macsc_set_cmp2_int_cb(macsc_callback_t callback);
 267:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 268:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 269:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Set MACSC Compare Channel 3 interrupt callback function
 270:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 271:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * This function allows the caller to set and change the interrupt callback
 272:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * function. Without setting a callback function the interrupt handler in the
 273:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * driver will only clear the interrupt flags.
 274:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 275:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param callback Reference to a callback function
 276:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 277:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** void macsc_set_cmp3_int_cb(macsc_callback_t callback);
 278:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 279:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 280:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Set MACSC backoff slot counter interrupt callback function
 281:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 282:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * This function allows the caller to set and change the interrupt callback
 283:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * function. Without setting a callback function the interrupt handler in the
 284:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * driver will only clear the interrupt flags.
 285:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 286:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param callback Reference to a callback function
 287:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 288:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** void macsc_set_backoff_slot_cntr_int_cb(macsc_callback_t callback);
 289:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** //@}
 290:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 291:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 292:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Enable 32.768KHz clk using timer 2 async register
 293:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 294:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param none
 295:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 296:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 297:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** static inline void macsc_sleep_clk_enable(void)
 298:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** {
 299:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	ASSR |= (1 << AS2);
 300:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** }
 301:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 302:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 303:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Disable 32.768KHz clk using timer 2 async register
 304:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 305:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param none
 306:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 307:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** static inline void macsc_sleep_clk_disable(void)
 308:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** {
 309:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	ASSR &= ~(1 << AS2);
 310:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** }
 311:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 312:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /* @} */
 313:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 314:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 315:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Configure MAC Symbol Counter Clock Source
 316:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 317:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param macsc macsc clk src
 318:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 319:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** static inline void macsc_write_clock_source(enum macsc_xtal source)
 320:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** {
 321:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	if (source == MACSC_16MHz) {
 322:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		SCCR0 |= (source << SCCKSEL);
 323:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	} else if (source == MACSC_32KHz) {
 324:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		SCCR0 &= ~(1 << SCCKSEL);
 325:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	}
 326:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** }
 327:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 328:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 329:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Read MAC SC Clock Source
 330:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 331:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param none
 332:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \return macsc_xtal enum Clock source selection
 333:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 334:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** static inline enum macsc_xtal macsc_read_clock_source(void)
 335:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** {
 336:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	return (enum macsc_xtal)(SCCR0 & (1 << SCCKSEL));
 337:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** }
 338:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 339:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 340:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Write the Counter value of the MAC Symbol counter
 341:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 342:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param cnt_value Counter value
 343:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 344:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** static inline void macsc_write_count(uint32_t cnt_value)
 345:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** {
 346:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	MACSC_WRITE32(SCCNT, cnt_value);
 347:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** }
 348:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 349:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 350:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Reads the Counter value of the MAC Symbol counter
 351:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 352:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \note Output the Counter value
 353:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 354:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** static inline uint32_t macsc_read_count(void)
 355:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** {
 356:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	return (MACSC_READ32(SCCNT));
 357:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** }
 358:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 359:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 360:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief enable back-off slot counter
 361:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 362:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param none
 363:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \note  Enables interrupt as well	.
 364:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \note This counter works only if transceiver clock is running.So check Trx
 365:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * state in app before using this function in IEEE802.15.4 applications.
 366:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 367:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** static inline bool macsc_backoff_slot_cnt_enable(void)
 368:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** {
 369:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	if (!(PRR1 & (1 << PRTRX24))) {
 370:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		SCCR1 = (1 << SCENBO);
 371:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		SCIRQS |= (1 << IRQSBO);
 372:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		SCIRQM |= (1 << IRQMBO);
 373:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		return true;
 374:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	}
 375:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	else return false;
 376:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** }
 377:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 378:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 379:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Disable back-off slot counter
 380:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 381:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param none
 382:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \note    Disables interrupt as well	.
 383:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \note This counter works only if transceiver clock is running.So check Trx
 384:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * state in app before using this function in IEEE802.15.4 applications.
 385:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 386:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** static inline void macsc_backoff_slot_cnt_disable(void)
 387:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** {
 388:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	SCCR1 &= ~(1 << SCENBO);
 389:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	SCIRQM &= ~(1 << IRQMBO);
 390:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** }
 391:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 392:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 393:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Tests if the Backoff slot cntr interrupt flag is set
 394:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 395:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \return  backoff slot cntr interrupt has occurred or not : IRQSBO
 396:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 397:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** static inline bool macsc_is_slot_cntr_interrupt_flag_set(void)
 398:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** {
 399:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	return (SCIRQS & (1 << IRQSBO));
 400:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** }
 401:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 402:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 403:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Clears the Backoff Slot cntr interrupt flag
 404:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 405:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \note  IRQSBO is cleared
 406:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 407:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** static inline void macsc_clear_slot_cntr_interrupt_flag(void)
 408:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** {
 409:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	SCIRQS |= (1 << IRQSBO);
 410:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** }
 411:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 412:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 413:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Reads the SFD Timestamp register
 414:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 415:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \return Timestamp of last received frame :SCTSR(read-only register)
 416:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 417:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** static inline uint32_t macsc_read_ts(void)
 418:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** {
 419:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	return (MACSC_READ32(SCTSR));
 420:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** }
 421:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 422:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 423:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Reads the Beacon Timestamp register
 424:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 425:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \return Timestamp of last received beacon frame :SCBTSR
 426:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 427:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** static inline uint32_t macsc_read_bts(void)
 428:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** {
 429:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	return (MACSC_READ32(SCBTSR));
 430:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** }
 431:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 432:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 433:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Write the Beacon Timestamp register of the MAC Symbol counter
 434:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * The manual beacon timestamping can be used in conjunction with the
 435:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * relative compare mode of the three compare units to generate compare match
 436:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * interrupts without having a beacon frame received
 437:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 438:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * If set to 1, the current symbol counter value is stored into the beacon
 439:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * timestamp register.
 440:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * The bit is cleared afterwards.
 441:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 442:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 443:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** static inline void macsc_enable_manual_bts(void)
 444:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** {
 442               		.loc 5 444 0
 443               		.cfi_startproc
 444 019e CF93      		push r28
 445               	.LCFI26:
 446               		.cfi_def_cfa_offset 3
 447               		.cfi_offset 28, -2
 448 01a0 DF93      		push r29
 449               	.LCFI27:
 450               		.cfi_def_cfa_offset 4
 451               		.cfi_offset 29, -3
 452 01a2 CDB7      		in r28,__SP_L__
 453 01a4 DEB7      		in r29,__SP_H__
 454               	.LCFI28:
 455               		.cfi_def_cfa_register 28
 456               	/* prologue: function */
 457               	/* frame size = 0 */
 458               	/* stack size = 2 */
 459               	.L__stack_usage = 2
 445:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	SCCR0 |= (1 << SCMBTS);
 460               		.loc 5 445 0
 461 01a6 8CED      		ldi r24,lo8(-36)
 462 01a8 90E0      		ldi r25,0
 463 01aa 2CED      		ldi r18,lo8(-36)
 464 01ac 30E0      		ldi r19,0
 465 01ae F901      		movw r30,r18
 466 01b0 2081      		ld r18,Z
 467 01b2 2064      		ori r18,lo8(64)
 468 01b4 FC01      		movw r30,r24
 469 01b6 2083      		st Z,r18
 446:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	SCCR0 &= ~(1 << SCTSE);
 470               		.loc 5 446 0
 471 01b8 8CED      		ldi r24,lo8(-36)
 472 01ba 90E0      		ldi r25,0
 473 01bc 2CED      		ldi r18,lo8(-36)
 474 01be 30E0      		ldi r19,0
 475 01c0 F901      		movw r30,r18
 476 01c2 2081      		ld r18,Z
 477 01c4 277F      		andi r18,lo8(-9)
 478 01c6 FC01      		movw r30,r24
 479 01c8 2083      		st Z,r18
 447:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** }
 480               		.loc 5 447 0
 481 01ca 0000      		nop
 482               	/* epilogue start */
 483 01cc DF91      		pop r29
 484 01ce CF91      		pop r28
 485 01d0 0895      		ret
 486               		.cfi_endproc
 487               	.LFE121:
 489               	.global	appState
 490               		.section	.bss.appState,"aw",@nobits
 493               	appState:
 494 0000 00        		.zero	1
 495               		.section	.bss.msgReq,"aw",@nobits
 498               	msgReq:
 499 0000 0000 0000 		.zero	20
 499      0000 0000 
 499      0000 0000 
 499      0000 0000 
 499      0000 0000 
 500               		.section	.bss.PanId,"aw",@nobits
 503               	PanId:
 504 0000 00        		.zero	1
 505               		.section	.rodata
 506               	.LC1:
 507 0000 0A4D 5347 		.string	"\nMSG REQ SENT %d"
 507      2052 4551 
 507      2053 454E 
 507      5420 2564 
 507      00
 508               		.text
 509               	.global	appSendData
 511               	appSendData:
 512               	.LFB130:
 513               		.file 6 "ServerLLDN.c"
   1:ServerLLDN.c  **** /*
   2:ServerLLDN.c  **** 	* ServerLLDN.c
   3:ServerLLDN.c  **** 	*
   4:ServerLLDN.c  **** 	* Created: 10/18/2019 5:15:37 PM
   5:ServerLLDN.c  **** 	*  Author: guilherme
   6:ServerLLDN.c  **** 	*/ 
   7:ServerLLDN.c  **** 
   8:ServerLLDN.c  **** #include <stdlib.h>
   9:ServerLLDN.c  **** #include <stdio.h>
  10:ServerLLDN.c  **** #include <string.h>
  11:ServerLLDN.c  **** #include <inttypes.h>
  12:ServerLLDN.c  **** #include "config.h"
  13:ServerLLDN.c  **** #include "sys.h"
  14:ServerLLDN.c  **** #include "phy.h"
  15:ServerLLDN.c  **** #include "sys.h"
  16:ServerLLDN.c  **** #include "nwk.h"
  17:ServerLLDN.c  **** #include "sysclk.h"
  18:ServerLLDN.c  **** #include "sysTimer.h"
  19:ServerLLDN.c  **** #include "sleep_mgr.h"
  20:ServerLLDN.c  **** #include "sleepmgr.h"
  21:ServerLLDN.c  **** #include "led.h"
  22:ServerLLDN.c  **** #include "ioport.h"
  23:ServerLLDN.c  **** #include "conf_sleepmgr.h"
  24:ServerLLDN.c  **** #include "board.h"
  25:ServerLLDN.c  **** #include "platform.h"
  26:ServerLLDN.c  **** 
  27:ServerLLDN.c  **** #include "lldn.h"
  28:ServerLLDN.c  **** 
  29:ServerLLDN.c  **** #if 1
  30:ServerLLDN.c  **** #if (SIO2HOST_CHANNEL == SIO_USB)
  31:ServerLLDN.c  **** /* Only ARM */
  32:ServerLLDN.c  **** #include "hw_timer_lldn.h"
  33:ServerLLDN.c  **** #include "stdio_usb.h"
  34:ServerLLDN.c  **** #define MASTER_MACSC	0
  35:ServerLLDN.c  **** #else
  36:ServerLLDN.c  **** /* Only megarf series */
  37:ServerLLDN.c  **** #include "conf_sio2host.h"
  38:ServerLLDN.c  **** #define MASTER_MACSC	1
  39:ServerLLDN.c  **** #endif
  40:ServerLLDN.c  **** #else
  41:ServerLLDN.c  **** /* Only megarf series */
  42:ServerLLDN.c  **** #define MASTER_MACSC		1
  43:ServerLLDN.c  **** #endif
  44:ServerLLDN.c  **** 
  45:ServerLLDN.c  **** #define HUMAM_READABLE			1
  46:ServerLLDN.c  **** 
  47:ServerLLDN.c  **** #if (MASTER_MACSC == 1)
  48:ServerLLDN.c  **** #include "macsc_megarf.h"
  49:ServerLLDN.c  **** #define TIMESLOT_TIMER 1
  50:ServerLLDN.c  **** #else
  51:ServerLLDN.c  **** static SYS_Timer_t				tmrBeaconInterval;			// Beacon
  52:ServerLLDN.c  **** static SYS_Timer_t				tmrComputeData;				// Compute data
  53:ServerLLDN.c  **** #endif
  54:ServerLLDN.c  **** 
  55:ServerLLDN.c  **** #define PRINT 1
  56:ServerLLDN.c  **** 
  57:ServerLLDN.c  **** 	
  58:ServerLLDN.c  **** // equation for tTS gives time in seconds, the division by SYMBOL_TIME changes to symbols for count
  59:ServerLLDN.c  **** AppState_t	appState = APP_STATE_INITIAL;
  60:ServerLLDN.c  **** static NWK_DataReq_t msgReq;
  61:ServerLLDN.c  **** static uint8_t PanId;
  62:ServerLLDN.c  **** 
  63:ServerLLDN.c  ****  void appSendData(void)
  64:ServerLLDN.c  **** {
 514               		.loc 6 64 0
 515               		.cfi_startproc
 516 01d2 CF93      		push r28
 517               	.LCFI29:
 518               		.cfi_def_cfa_offset 3
 519               		.cfi_offset 28, -2
 520 01d4 DF93      		push r29
 521               	.LCFI30:
 522               		.cfi_def_cfa_offset 4
 523               		.cfi_offset 29, -3
 524 01d6 CDB7      		in r28,__SP_L__
 525 01d8 DEB7      		in r29,__SP_H__
 526               	.LCFI31:
 527               		.cfi_def_cfa_register 28
 528               	/* prologue: function */
 529               	/* frame size = 0 */
 530               	/* stack size = 2 */
 531               	.L__stack_usage = 2
  65:ServerLLDN.c  **** 	if(msgReq.options != 0)
 532               		.loc 6 65 0
 533 01da 8091 0000 		lds r24,msgReq+9
 534 01de 9091 0000 		lds r25,msgReq+9+1
 535 01e2 892B      		or r24,r25
 536 01e4 01F0      		breq .L17
  66:ServerLLDN.c  **** 	{
  67:ServerLLDN.c  **** 		printf("\nMSG REQ SENT %d",msgReq.options);
 537               		.loc 6 67 0
 538 01e6 8091 0000 		lds r24,msgReq+9
 539 01ea 9091 0000 		lds r25,msgReq+9+1
 540 01ee 292F      		mov r18,r25
 541 01f0 2F93      		push r18
 542 01f2 8F93      		push r24
 543 01f4 80E0      		ldi r24,lo8(.LC1)
 544 01f6 90E0      		ldi r25,hi8(.LC1)
 545 01f8 892F      		mov r24,r25
 546 01fa 8F93      		push r24
 547 01fc 80E0      		ldi r24,lo8(.LC1)
 548 01fe 90E0      		ldi r25,hi8(.LC1)
 549 0200 8F93      		push r24
 550 0202 0E94 0000 		call printf
 551 0206 0F90      		pop __tmp_reg__
 552 0208 0F90      		pop __tmp_reg__
 553 020a 0F90      		pop __tmp_reg__
 554 020c 0F90      		pop __tmp_reg__
  68:ServerLLDN.c  **** 		NWK_DataReq(&msgReq);
 555               		.loc 6 68 0
 556 020e 80E0      		ldi r24,lo8(msgReq)
 557 0210 90E0      		ldi r25,hi8(msgReq)
 558 0212 0E94 0000 		call NWK_DataReq
 559               	.L17:
  69:ServerLLDN.c  **** 	#if !APP_COORDINATOR
  70:ServerLLDN.c  **** 	#endif
  71:ServerLLDN.c  **** 	}
  72:ServerLLDN.c  **** }
 560               		.loc 6 72 0
 561 0216 0000      		nop
 562               	/* epilogue start */
 563 0218 DF91      		pop r29
 564 021a CF91      		pop r28
 565 021c 0895      		ret
 566               		.cfi_endproc
 567               	.LFE130:
 569               	.global	payloadSize
 570               		.section	.data.payloadSize,"aw",@progbits
 573               	payloadSize:
 574 0000 7F        		.byte	127
 575               	.global	assTimeSlot
 576               		.section	.data.assTimeSlot,"aw",@progbits
 579               	assTimeSlot:
 580 0000 FF        		.byte	-1
 581               		.section	.bss.rec_beacon,"aw",@nobits
 584               	rec_beacon:
 585 0000 0000      		.zero	2
 586               		.section	.data.msgDiscResponse,"aw",@progbits
 589               	msgDiscResponse:
 590 0000 0D        		.byte	13
 591 0001 01        		.byte	1
 592 0002 FF        		.byte	255
 593               		.section	.data.msgConfigStatus,"aw",@progbits
 596               	msgConfigStatus:
 597 0000 0E        		.byte	14
 598 0001 01        		.byte	1
 599 0002 FF        		.byte	-1
 600 0003 01        		.byte	1
 601 0004 FF        		.byte	255
 602               	.global	data_payload
 603               		.section	.data.data_payload,"aw",@progbits
 606               	data_payload:
 607 0000 FA        		.byte	-6
 608               		.section	.bss.ack_received,"aw",@nobits
 611               	ack_received:
 612 0000 00        		.zero	1
 613               	.global	MacLLDNMgmtTS
 614               		.section	.bss.MacLLDNMgmtTS,"aw",@nobits
 617               	MacLLDNMgmtTS:
 618 0000 00        		.zero	1
 619               	.global	associated
 620               		.section	.bss.associated,"aw",@nobits
 623               	associated:
 624 0000 00        		.zero	1
 625               		.section	.rodata
 626               	.LC2:
 627 0011 0A54 494D 		.string	"\nTIMER"
 627      4552 00
 628               		.text
 630               	send_message_timeHandler:
 631               	.LFB131:
  73:ServerLLDN.c  **** 
  74:ServerLLDN.c  **** #if APP_COORDINATOR
  75:ServerLLDN.c  **** 
  76:ServerLLDN.c  **** 	#define NODOS_ASSOCIADOS_ESPERADOS 12
  77:ServerLLDN.c  **** 	
  78:ServerLLDN.c  **** 	AppPanState_t appPanState = APP_PAN_STATE_RESET; // Initial state of PAN node
  79:ServerLLDN.c  **** 	
  80:ServerLLDN.c  **** 	/* Configuration Request Frames */
  81:ServerLLDN.c  **** 	/* Da pra mudar o envio do confrequest pra ja usar essa array com as informas dos nodos */	
  82:ServerLLDN.c  **** 	nodes_info_t nodes_info_arr[254]; // Array for Configure Request messages, one position per node, 
  83:ServerLLDN.c  **** 	NWK_ConfigRequest_t config_request_frame = { .id = LL_CONFIGURATION_REQUEST,
  84:ServerLLDN.c  **** 												 .s_macAddr = APP_ADDR,
  85:ServerLLDN.c  **** 												 .tx_channel = APP_CHANNEL,
  86:ServerLLDN.c  **** 												 .conf.macLLDNmgmtTS = MacLLDNMgmtTS };
  87:ServerLLDN.c  **** 	nodes_info_list_t *conf_req_list = NULL;
  88:ServerLLDN.c  **** 
  89:ServerLLDN.c  **** 	/* Acknowledge Frame and Array */
  90:ServerLLDN.c  **** 	NWK_ACKFormat_t ACKFrame;	// ACK Frame Payload used in Discovery State
  91:ServerLLDN.c  **** 	int ACKFrame_size = 0;
  92:ServerLLDN.c  **** 
  93:ServerLLDN.c  **** 	float beaconInterval = 0; // no precisa ser global
  94:ServerLLDN.c  **** 	
  95:ServerLLDN.c  **** 	int macLLDNnumUplinkTS = 0;		// Number of uplink timeslots, is also the control of associated node
  96:ServerLLDN.c  **** 	
  97:ServerLLDN.c  **** 	/* This timer implements a delay between messages, 
  98:ServerLLDN.c  **** 	 * if not used the nodes are not able to receive the message
  99:ServerLLDN.c  **** 	 */
 100:ServerLLDN.c  **** 	static SYS_Timer_t tmrDelay;	
 101:ServerLLDN.c  **** 	
 102:ServerLLDN.c  **** 	/*  Control variables for testing */	
 103:ServerLLDN.c  **** 	int assTimeSlot = 0;
 104:ServerLLDN.c  **** 	uint8_t timeslot_counter = 0;
 105:ServerLLDN.c  **** 
 106:ServerLLDN.c  **** 	int counter_associados = 0;		// Associated nodes counter
 107:ServerLLDN.c  **** 	uint8_t cycles_counter = macLLDNdiscoveryModeTimeout;
 108:ServerLLDN.c  **** 
 109:ServerLLDN.c  **** 	float succes_rate = 0;
 110:ServerLLDN.c  **** 
 111:ServerLLDN.c  **** 	
 112:ServerLLDN.c  **** 	static void tmrDelayHandler(SYS_Timer_t *timer)
 113:ServerLLDN.c  **** 	{
 114:ServerLLDN.c  **** 		appState = APP_STATE_SEND;
 115:ServerLLDN.c  **** 	}
 116:ServerLLDN.c  **** 	
 117:ServerLLDN.c  **** 	static void lldn_server_beacon(void)
 118:ServerLLDN.c  **** 	{
 119:ServerLLDN.c  **** 		macsc_enable_manual_bts();
 120:ServerLLDN.c  **** 		appState = APP_STATE_SEND;
 121:ServerLLDN.c  **** 	}
 122:ServerLLDN.c  **** 	
 123:ServerLLDN.c  **** 	static void time_slot_handler(void)
 124:ServerLLDN.c  **** 	{
 125:ServerLLDN.c  **** 		macsc_enable_manual_bts();
 126:ServerLLDN.c  **** 		appState = APP_STATE_ATT_PAN_STATE;
 127:ServerLLDN.c  **** 	}
 128:ServerLLDN.c  **** 	
 129:ServerLLDN.c  **** 	static void downlink_delay_handler(void)
 130:ServerLLDN.c  **** 	{
 131:ServerLLDN.c  **** 		if(msgReq.options == NWK_OPT_LLDN_ACK)
 132:ServerLLDN.c  **** 		{
 133:ServerLLDN.c  **** 		appState = APP_STATE_SEND;
 134:ServerLLDN.c  **** 		}
 135:ServerLLDN.c  **** 	}
 136:ServerLLDN.c  **** 
 137:ServerLLDN.c  **** 	static void end_of_online_handler(void)
 138:ServerLLDN.c  **** 	{
 139:ServerLLDN.c  **** 		appState = APP_STATE_ATT_PAN_STATE;
 140:ServerLLDN.c  **** 		appPanState = APP_PAN_STATE_ONLINE_END_BE;
 141:ServerLLDN.c  **** 	}
 142:ServerLLDN.c  **** 	
 143:ServerLLDN.c  **** 	#if TIMESLOT_TIMER
 144:ServerLLDN.c  **** 	static void teste_handler(void)
 145:ServerLLDN.c  **** 	{
 146:ServerLLDN.c  **** 		if(msgReq.options)
 147:ServerLLDN.c  **** 			printf("\n***TIMESLOT****");
 148:ServerLLDN.c  **** 		macsc_disable_cmp_int(MACSC_CC3);
 149:ServerLLDN.c  **** 	}
 150:ServerLLDN.c  **** 	#endif
 151:ServerLLDN.c  **** 	
 152:ServerLLDN.c  **** 	static bool addToAckArray(uint8_t addres)
 153:ServerLLDN.c  **** 	{	
 154:ServerLLDN.c  **** 		int pos =(int) addres / 8;
 155:ServerLLDN.c  **** 		int bit_shift = 8 - (addres % 8);
 156:ServerLLDN.c  **** 		
 157:ServerLLDN.c  **** 		if(ACKFrame.ackFlags[pos] & 1 << bit_shift)
 158:ServerLLDN.c  **** 		{
 159:ServerLLDN.c  **** 			printf("\nAddr rep %d", addres);
 160:ServerLLDN.c  **** 			return false;
 161:ServerLLDN.c  **** 		}
 162:ServerLLDN.c  **** 		ACKFrame.ackFlags[pos] = 1 << bit_shift;
 163:ServerLLDN.c  **** 		if (pos + 1 > ACKFrame_size)
 164:ServerLLDN.c  **** 			ACKFrame_size = pos + 1;
 165:ServerLLDN.c  **** 		
 166:ServerLLDN.c  **** 		return true;
 167:ServerLLDN.c  **** 	}
 168:ServerLLDN.c  **** 
 169:ServerLLDN.c  **** 	static void addConfRequestArray(NWK_ConfigStatus_t *node)
 170:ServerLLDN.c  **** 	{
 171:ServerLLDN.c  **** 
 172:ServerLLDN.c  **** 		uint8_t i;
 173:ServerLLDN.c  **** 		for (i= 0;i < 256 && nodes_info_arr[i].mac_addr != 0; i++);
 174:ServerLLDN.c  **** 		
 175:ServerLLDN.c  **** 		assTimeSlot++;
 176:ServerLLDN.c  **** 	
 177:ServerLLDN.c  **** 		if(node->ts_dir.tsDuration > config_request_frame.conf.tsDuration)
 178:ServerLLDN.c  **** 		config_request_frame.conf.tsDuration =  node->ts_dir.tsDuration;
 179:ServerLLDN.c  **** 		
 180:ServerLLDN.c  **** 		nodes_info_arr[i].req_timeslot_duration = node->ts_dir.tsDuration;
 181:ServerLLDN.c  **** 		nodes_info_arr[i].mac_addr = node->macAddr;
 182:ServerLLDN.c  **** 		nodes_info_arr[i].assigned_time_slot = (uint8_t)i;
 183:ServerLLDN.c  **** 		
 184:ServerLLDN.c  **** 		if(conf_req_list != NULL)
 185:ServerLLDN.c  **** 		{
 186:ServerLLDN.c  **** 			nodes_info_list_t *tmp = (nodes_info_list_t*)malloc(sizeof(nodes_info_list_t));
 187:ServerLLDN.c  **** 			tmp->node = &nodes_info_arr[i];
 188:ServerLLDN.c  **** 			tmp->next = conf_req_list;
 189:ServerLLDN.c  **** 			conf_req_list = tmp;
 190:ServerLLDN.c  **** 		}
 191:ServerLLDN.c  **** 		else
 192:ServerLLDN.c  **** 		{
 193:ServerLLDN.c  **** 			conf_req_list = (nodes_info_list_t*)malloc(sizeof(nodes_info_list_t));
 194:ServerLLDN.c  **** 			conf_req_list->node = &nodes_info_arr[i];
 195:ServerLLDN.c  **** 			conf_req_list->next = NULL;
 196:ServerLLDN.c  **** 		}
 197:ServerLLDN.c  **** 	}
 198:ServerLLDN.c  **** 
 199:ServerLLDN.c  **** 	static void CopyToConfigRequest()
 200:ServerLLDN.c  **** 	{
 201:ServerLLDN.c  **** 		config_request_frame.assTimeSlot = conf_req_list->node->assigned_time_slot;
 202:ServerLLDN.c  **** 		config_request_frame.macAddr = conf_req_list->node->mac_addr;
 203:ServerLLDN.c  **** 		nodes_info_list_t *tmp = conf_req_list;
 204:ServerLLDN.c  **** 		conf_req_list = conf_req_list->next;
 205:ServerLLDN.c  **** 		tmp->node = NULL;
 206:ServerLLDN.c  **** 		tmp->next = NULL;
 207:ServerLLDN.c  **** 		free(tmp);
 208:ServerLLDN.c  **** 	}
 209:ServerLLDN.c  **** 
 210:ServerLLDN.c  **** 
 211:ServerLLDN.c  **** 	static bool appCommandInd(NWK_DataInd_t *ind)
 212:ServerLLDN.c  **** 	{
 213:ServerLLDN.c  **** 		if(ind->data[0] == LL_DISCOVER_RESPONSE)
 214:ServerLLDN.c  **** 		{
 215:ServerLLDN.c  **** 			NWK_DiscoverResponse_t *msg = (NWK_DiscoverResponse_t*)ind->data;
 216:ServerLLDN.c  **** 			addToAckArray(msg->macAddr);	
 217:ServerLLDN.c  **** 					
 218:ServerLLDN.c  **** 			#if PRINT
 219:ServerLLDN.c  **** 			printf("\nDISC %hhx", msg->macAddr);	
 220:ServerLLDN.c  **** 			#endif
 221:ServerLLDN.c  **** 		}
 222:ServerLLDN.c  **** 		else if(ind->data[0] == LL_CONFIGURATION_STATUS)
 223:ServerLLDN.c  **** 		{
 224:ServerLLDN.c  **** 			NWK_ConfigStatus_t *msg = (NWK_ConfigStatus_t*)ind->data;
 225:ServerLLDN.c  **** 			addConfRequestArray(msg);
 226:ServerLLDN.c  **** 			#if PRINT
 227:ServerLLDN.c  **** 			printf("\nCONF %d", msg->macAddr);	
 228:ServerLLDN.c  **** 			#endif
 229:ServerLLDN.c  **** 		}
 230:ServerLLDN.c  **** 		else return false;			
 231:ServerLLDN.c  **** 		return true;
 232:ServerLLDN.c  **** 	}
 233:ServerLLDN.c  **** 	
 234:ServerLLDN.c  **** 	static bool appDataInd(NWK_DataInd_t *ind)
 235:ServerLLDN.c  **** 	{
 236:ServerLLDN.c  **** 		
 237:ServerLLDN.c  **** 		int curr_ts = timeslot_counter - 2*MacLLDNMgmtTS;
 238:ServerLLDN.c  **** 		printf("\n");
 239:ServerLLDN.c  **** 		for (int i = 0; i < ind->size; i++)
 240:ServerLLDN.c  **** 			printf("%hhx ", ind->data[i]);
 241:ServerLLDN.c  **** 			
 242:ServerLLDN.c  **** 	}
 243:ServerLLDN.c  **** 	
 244:ServerLLDN.c  **** 	static void appPanPrepareACK(void)
 245:ServerLLDN.c  **** 	{
 246:ServerLLDN.c  **** 		msgReq.dstAddr		= 0;
 247:ServerLLDN.c  **** 		msgReq.dstEndpoint	= APP_BEACON_ENDPOINT;
 248:ServerLLDN.c  **** 		msgReq.srcEndpoint	= APP_BEACON_ENDPOINT;
 249:ServerLLDN.c  **** 		msgReq.options		= NWK_OPT_LLDN_ACK;
 250:ServerLLDN.c  **** 		msgReq.data	= (uint8_t *)&ACKFrame;
 251:ServerLLDN.c  **** 		msgReq.size	= sizeof(uint8_t)*(ACKFrame_size + 1);
 252:ServerLLDN.c  **** 
 253:ServerLLDN.c  **** 	}
 254:ServerLLDN.c  **** 
 255:ServerLLDN.c  **** 	static void appPanReset(void)
 256:ServerLLDN.c  **** 	{
 257:ServerLLDN.c  **** 		// prepare beacon reset message
 258:ServerLLDN.c  **** 		msgReq.dstAddr		= 0;
 259:ServerLLDN.c  **** 		msgReq.dstEndpoint	= APP_BEACON_ENDPOINT;
 260:ServerLLDN.c  **** 		msgReq.srcEndpoint	= APP_BEACON_ENDPOINT;
 261:ServerLLDN.c  **** 		msgReq.options		= NWK_OPT_LLDN_BEACON | NWK_OPT_RESET_STATE;
 262:ServerLLDN.c  **** 		msgReq.data			= NULL;
 263:ServerLLDN.c  **** 		msgReq.size			= 0;
 264:ServerLLDN.c  **** 
 265:ServerLLDN.c  **** 		for(int i = 0; i < 32; i++)
 266:ServerLLDN.c  **** 			ACKFrame.ackFlags[i] = 0;
 267:ServerLLDN.c  **** 			
 268:ServerLLDN.c  **** 		for (int i = 0; i < 255; i++)
 269:ServerLLDN.c  **** 			nodes_info_arr[i].mac_addr = 0;
 270:ServerLLDN.c  **** 			
 271:ServerLLDN.c  **** 		assTimeSlot = MacLLDNMgmtTS * 2;	
 272:ServerLLDN.c  **** 		ACKFrame_size = 0;
 273:ServerLLDN.c  **** 		counter_associados = 0;
 274:ServerLLDN.c  **** 		n = 0;
 275:ServerLLDN.c  **** 	}
 276:ServerLLDN.c  **** 
 277:ServerLLDN.c  **** 	static void appPanDiscInit(void)
 278:ServerLLDN.c  **** 	{	
 279:ServerLLDN.c  **** 		/* clear Ack array of previous discovery state */
 280:ServerLLDN.c  **** 		for(int i = 0; i < 32; i++)
 281:ServerLLDN.c  **** 			ACKFrame.ackFlags[i] = 0;
 282:ServerLLDN.c  **** 		ACKFrame_size = 0;
 283:ServerLLDN.c  **** 		/* Prepare Beacon Message as first beacon in discovery state */		
 284:ServerLLDN.c  **** 		msgReq.dstAddr				= 0;
 285:ServerLLDN.c  **** 		msgReq.dstEndpoint			= APP_BEACON_ENDPOINT;
 286:ServerLLDN.c  **** 		msgReq.srcEndpoint			= APP_BEACON_ENDPOINT;
 287:ServerLLDN.c  **** 		msgReq.options				= NWK_OPT_LLDN_BEACON | NWK_OPT_DISCOVERY_STATE;
 288:ServerLLDN.c  **** 		msgReq.data					= NULL;
 289:ServerLLDN.c  **** 		msgReq.size					= 0;
 290:ServerLLDN.c  **** 		
 291:ServerLLDN.c  **** 		
 292:ServerLLDN.c  **** 		/* Only start timers if it is the first association process */
 293:ServerLLDN.c  **** 		if(cycles_counter == 0) 
 294:ServerLLDN.c  **** 		{
 295:ServerLLDN.c  **** 			
 296:ServerLLDN.c  **** 		/* Calculates Beacon Intervals according to 802.15.4e - 2012 p. 70 */
 297:ServerLLDN.c  **** 		n = 127; 
 298:ServerLLDN.c  **** 		tTS =  ((p_var*sp + (m+n)*sm + macMinLIFSPeriod)/v_var);
 299:ServerLLDN.c  **** 		#if (MASTER_MACSC == 1)
 300:ServerLLDN.c  **** 		
 301:ServerLLDN.c  **** 			beaconInterval = 2 * numBaseTimeSlotperMgmt * (tTS) / (SYMBOL_TIME);
 302:ServerLLDN.c  **** 			/*
 303:ServerLLDN.c  **** 			* Configure interrupts callback functions
 304:ServerLLDN.c  **** 			* overflow interrupt, compare 1,2,3 interrupts
 305:ServerLLDN.c  **** 			*/
 306:ServerLLDN.c  **** 			macsc_set_cmp1_int_cb(lldn_server_beacon);
 307:ServerLLDN.c  **** 			/*
 308:ServerLLDN.c  **** 			* Configure MACSC to generate compare interrupts from channels 1,2,3
 309:ServerLLDN.c  **** 			* Set compare mode to absolute, set compare value.
 310:ServerLLDN.c  **** 			*/
 311:ServerLLDN.c  **** 			macsc_enable_manual_bts();
 312:ServerLLDN.c  **** 			macsc_enable_cmp_int(MACSC_CC1);
 313:ServerLLDN.c  **** 
 314:ServerLLDN.c  **** 			macsc_use_cmp(MACSC_RELATIVE_CMP, beaconInterval , MACSC_CC1);
 315:ServerLLDN.c  **** 			
 316:ServerLLDN.c  **** 			/* Timer used in testing */
 317:ServerLLDN.c  **** 			#if TIMESLOT_TIMER
 318:ServerLLDN.c  **** 			macsc_set_cmp2_int_cb(teste_handler);	
 319:ServerLLDN.c  **** 			macsc_enable_cmp_int(MACSC_CC2);
 320:ServerLLDN.c  **** 			macsc_use_cmp(MACSC_RELATIVE_CMP, beaconInterval / 2, MACSC_CC2);
 321:ServerLLDN.c  **** 			#endif
 322:ServerLLDN.c  **** 			
 323:ServerLLDN.c  **** 		#endif
 324:ServerLLDN.c  **** 		}
 325:ServerLLDN.c  **** 	}
 326:ServerLLDN.c  **** 
 327:ServerLLDN.c  **** 	static void appPanOnlineInit()
 328:ServerLLDN.c  **** 	{
 329:ServerLLDN.c  **** 			timeslot_counter = 0;
 330:ServerLLDN.c  **** 			
 331:ServerLLDN.c  **** 			tTS =  ((p_var*sp + (m+ /*config_request_frame.conf.tsDuration */ 127 )*sm + macMinLIFSPeriod)/v
 332:ServerLLDN.c  **** 			
 333:ServerLLDN.c  **** 			n = /*config_request_frame.conf.tsDuration */ 127;
 334:ServerLLDN.c  **** 			
 335:ServerLLDN.c  **** 			msgReq.dstAddr				= 0;
 336:ServerLLDN.c  **** 			msgReq.dstEndpoint			= APP_BEACON_ENDPOINT;
 337:ServerLLDN.c  **** 			msgReq.srcEndpoint			= APP_BEACON_ENDPOINT;
 338:ServerLLDN.c  **** 			msgReq.options				= NWK_OPT_LLDN_BEACON | NWK_OPT_ONLINE_STATE;
 339:ServerLLDN.c  **** 			msgReq.data					= NULL;
 340:ServerLLDN.c  **** 			msgReq.size					= 0;
 341:ServerLLDN.c  **** 			
 342:ServerLLDN.c  **** 			// (number of time slots x mgmt time solts) x base timelosts
 343:ServerLLDN.c  **** 			beaconInterval = (assTimeSlot + 2*MacLLDNMgmtTS) * tTS / (SYMBOL_TIME);
 344:ServerLLDN.c  **** 			
 345:ServerLLDN.c  **** 			// Configure Timers
 346:ServerLLDN.c  **** 			macsc_set_cmp1_int_cb(time_slot_handler);
 347:ServerLLDN.c  **** 			
 348:ServerLLDN.c  **** 			macsc_enable_manual_bts();
 349:ServerLLDN.c  **** 			
 350:ServerLLDN.c  **** 			macsc_enable_cmp_int(MACSC_CC1);
 351:ServerLLDN.c  **** 			macsc_use_cmp(MACSC_RELATIVE_CMP, tTS / (SYMBOL_TIME), MACSC_CC1);
 352:ServerLLDN.c  **** 			
 353:ServerLLDN.c  **** 			NWK_OpenEndpoint(APP_DATA_ENDPOINT, appDataInd);
 354:ServerLLDN.c  **** 
 355:ServerLLDN.c  **** 			
 356:ServerLLDN.c  **** 	}
 357:ServerLLDN.c  **** 
 358:ServerLLDN.c  **** 
 359:ServerLLDN.c  **** #else 
 360:ServerLLDN.c  **** 	uint8_t payloadSize = 127;
 361:ServerLLDN.c  **** 	uint8_t assTimeSlot = 0xFF;
 362:ServerLLDN.c  **** 	uint8_t n = 0;
 363:ServerLLDN.c  **** 	
 364:ServerLLDN.c  **** 	static NwkFrameBeaconHeaderLLDN_t *rec_beacon;
 365:ServerLLDN.c  **** 	static NWK_DiscoverResponse_t msgDiscResponse = { .id = LL_DISCOVER_RESPONSE,
 366:ServerLLDN.c  **** 													 .macAddr = APP_ADDR,
 367:ServerLLDN.c  **** 													 .ts_dir.tsDuration = 127,
 368:ServerLLDN.c  **** 													 .ts_dir.dirIndicator = 0b1 };
 369:ServerLLDN.c  **** 	static NWK_ConfigStatus_t msgConfigStatus = { .id = LL_CONFIGURATION_STATUS,
 370:ServerLLDN.c  **** 												 .macAddr = APP_ADDR,
 371:ServerLLDN.c  **** 												 .s_macAddr = APP_ADDR,
 372:ServerLLDN.c  **** 												 .ts_dir.tsDuration = 127,
 373:ServerLLDN.c  **** 												 .ts_dir.dirIndicator = 1,
 374:ServerLLDN.c  **** 												 .assTimeSlot = 0xff };
 375:ServerLLDN.c  **** 	uint8_t data_payload = 0xFA;
 376:ServerLLDN.c  **** 	static bool ack_received;
 377:ServerLLDN.c  **** 	bool MacLLDNMgmtTS = 0; 
 378:ServerLLDN.c  **** 	bool associated = 0;
 379:ServerLLDN.c  **** 	
 380:ServerLLDN.c  **** 	static void send_message_timeHandler(void)
 381:ServerLLDN.c  **** 	{
 632               		.loc 6 381 0
 633               		.cfi_startproc
 634 021e CF93      		push r28
 635               	.LCFI32:
 636               		.cfi_def_cfa_offset 3
 637               		.cfi_offset 28, -2
 638 0220 DF93      		push r29
 639               	.LCFI33:
 640               		.cfi_def_cfa_offset 4
 641               		.cfi_offset 29, -3
 642 0222 CDB7      		in r28,__SP_L__
 643 0224 DEB7      		in r29,__SP_H__
 644               	.LCFI34:
 645               		.cfi_def_cfa_register 28
 646               	/* prologue: function */
 647               	/* frame size = 0 */
 648               	/* stack size = 2 */
 649               	.L__stack_usage = 2
 382:ServerLLDN.c  **** 		printf("\nTIMER");
 650               		.loc 6 382 0
 651 0226 80E0      		ldi r24,lo8(.LC2)
 652 0228 90E0      		ldi r25,hi8(.LC2)
 653 022a 892F      		mov r24,r25
 654 022c 8F93      		push r24
 655 022e 80E0      		ldi r24,lo8(.LC2)
 656 0230 90E0      		ldi r25,hi8(.LC2)
 657 0232 8F93      		push r24
 658 0234 0E94 0000 		call printf
 659 0238 0F90      		pop __tmp_reg__
 660 023a 0F90      		pop __tmp_reg__
 383:ServerLLDN.c  **** 		appState = APP_STATE_SEND;	
 661               		.loc 6 383 0
 662 023c 82E0      		ldi r24,lo8(2)
 663 023e 8093 0000 		sts appState,r24
 384:ServerLLDN.c  **** 		#if MASTER_MACSC == 0
 385:ServerLLDN.c  **** 			timer_stop();
 386:ServerLLDN.c  **** 		#endif
 387:ServerLLDN.c  **** 	}
 664               		.loc 6 387 0
 665 0242 0000      		nop
 666               	/* epilogue start */
 667 0244 DF91      		pop r29
 668 0246 CF91      		pop r28
 669 0248 0895      		ret
 670               		.cfi_endproc
 671               	.LFE131:
 674               	start_timer:
 675               	.LFB132:
 388:ServerLLDN.c  **** 
 389:ServerLLDN.c  **** 	static void start_timer(int delay)
 390:ServerLLDN.c  **** 	{
 676               		.loc 6 390 0
 677               		.cfi_startproc
 678 024a CF93      		push r28
 679               	.LCFI35:
 680               		.cfi_def_cfa_offset 3
 681               		.cfi_offset 28, -2
 682 024c DF93      		push r29
 683               	.LCFI36:
 684               		.cfi_def_cfa_offset 4
 685               		.cfi_offset 29, -3
 686 024e 00D0      		rcall .
 687               	.LCFI37:
 688               		.cfi_def_cfa_offset 6
 689 0250 CDB7      		in r28,__SP_L__
 690 0252 DEB7      		in r29,__SP_H__
 691               	.LCFI38:
 692               		.cfi_def_cfa_register 28
 693               	/* prologue: function */
 694               	/* frame size = 2 */
 695               	/* stack size = 4 */
 696               	.L__stack_usage = 4
 697 0254 9A83      		std Y+2,r25
 698 0256 8983      		std Y+1,r24
 391:ServerLLDN.c  **** 		#if MASTER_MACSC
 392:ServerLLDN.c  **** 		macsc_enable_manual_bts();
 699               		.loc 6 392 0
 700 0258 0E94 0000 		call macsc_enable_manual_bts
 393:ServerLLDN.c  **** 		macsc_set_cmp1_int_cb(send_message_timeHandler);
 701               		.loc 6 393 0
 702 025c 80E0      		ldi r24,lo8(gs(send_message_timeHandler))
 703 025e 90E0      		ldi r25,hi8(gs(send_message_timeHandler))
 704 0260 0E94 0000 		call macsc_set_cmp1_int_cb
 394:ServerLLDN.c  **** 		macsc_enable_cmp_int(MACSC_CC1);
 705               		.loc 6 394 0
 706 0264 81E0      		ldi r24,lo8(1)
 707 0266 0E94 0000 		call macsc_enable_cmp_int
 395:ServerLLDN.c  **** 		macsc_use_cmp(MACSC_RELATIVE_CMP, delay - 250, MACSC_CC1);
 708               		.loc 6 395 0
 709 026a 8981      		ldd r24,Y+1
 710 026c 9A81      		ldd r25,Y+2
 711 026e 8A5F      		subi r24,-6
 712 0270 9109      		sbc r25,__zero_reg__
 713 0272 092E      		mov __tmp_reg__,r25
 714 0274 000C      		lsl r0
 715 0276 AA0B      		sbc r26,r26
 716 0278 BB0B      		sbc r27,r27
 717 027a 21E0      		ldi r18,lo8(1)
 718 027c AC01      		movw r20,r24
 719 027e BD01      		movw r22,r26
 720 0280 81E0      		ldi r24,lo8(1)
 721 0282 0E94 0000 		call macsc_use_cmp
 396:ServerLLDN.c  **** 		#else
 397:ServerLLDN.c  **** 		timer_init();
 398:ServerLLDN.c  **** 		timer_delay(delay/2);
 399:ServerLLDN.c  **** 		hw_timer_setup_handler(send_message_timeHandler);
 400:ServerLLDN.c  **** 		timer_start();
 401:ServerLLDN.c  **** 		#endif
 402:ServerLLDN.c  **** 	}
 722               		.loc 6 402 0
 723 0286 0000      		nop
 724               	/* epilogue start */
 725 0288 0F90      		pop __tmp_reg__
 726 028a 0F90      		pop __tmp_reg__
 727 028c DF91      		pop r29
 728 028e CF91      		pop r28
 729 0290 0895      		ret
 730               		.cfi_endproc
 731               	.LFE132:
 733               		.section	.rodata
 734               	.LC3:
 735 0018 0A52 6563 		.string	"\nRecebendo Beacon "
 735      6562 656E 
 735      646F 2042 
 735      6561 636F 
 735      6E20 00
 736               	.global	__floatsisf
 737               	.global	__addsf3
 738               	.global	__divsf3
 739               	.global	__fixsfsi
 740               	.LC4:
 741 002b 0A20 5469 		.string	"\n TimeSlotSize %d"
 741      6D65 536C 
 741      6F74 5369 
 741      7A65 2025 
 741      6400 
 742               		.text
 744               	appBeaconInd:
 745               	.LFB133:
 403:ServerLLDN.c  **** 	
 404:ServerLLDN.c  **** 	static bool appBeaconInd(NWK_DataInd_t *ind)
 405:ServerLLDN.c  **** 	{
 746               		.loc 6 405 0
 747               		.cfi_startproc
 748 0292 CF93      		push r28
 749               	.LCFI39:
 750               		.cfi_def_cfa_offset 3
 751               		.cfi_offset 28, -2
 752 0294 DF93      		push r29
 753               	.LCFI40:
 754               		.cfi_def_cfa_offset 4
 755               		.cfi_offset 29, -3
 756 0296 CDB7      		in r28,__SP_L__
 757 0298 DEB7      		in r29,__SP_H__
 758               	.LCFI41:
 759               		.cfi_def_cfa_register 28
 760 029a 2A97      		sbiw r28,10
 761               	.LCFI42:
 762               		.cfi_def_cfa_offset 14
 763 029c 0FB6      		in __tmp_reg__,__SREG__
 764 029e F894      		cli
 765 02a0 DEBF      		out __SP_H__,r29
 766 02a2 0FBE      		out __SREG__,__tmp_reg__
 767 02a4 CDBF      		out __SP_L__,r28
 768               	/* prologue: function */
 769               	/* frame size = 10 */
 770               	/* stack size = 12 */
 771               	.L__stack_usage = 12
 772 02a6 9A87      		std Y+10,r25
 773 02a8 8987      		std Y+9,r24
 406:ServerLLDN.c  **** 		printf("\nRecebendo Beacon ");
 774               		.loc 6 406 0
 775 02aa 80E0      		ldi r24,lo8(.LC3)
 776 02ac 90E0      		ldi r25,hi8(.LC3)
 777 02ae 892F      		mov r24,r25
 778 02b0 8F93      		push r24
 779 02b2 80E0      		ldi r24,lo8(.LC3)
 780 02b4 90E0      		ldi r25,hi8(.LC3)
 781 02b6 8F93      		push r24
 782 02b8 0E94 0000 		call printf
 783 02bc 0F90      		pop __tmp_reg__
 784 02be 0F90      		pop __tmp_reg__
 407:ServerLLDN.c  **** 		rec_beacon = (NwkFrameBeaconHeaderLLDN_t*)ind->data;
 785               		.loc 6 407 0
 786 02c0 8985      		ldd r24,Y+9
 787 02c2 9A85      		ldd r25,Y+10
 788 02c4 FC01      		movw r30,r24
 789 02c6 8085      		ldd r24,Z+8
 790 02c8 9185      		ldd r25,Z+9
 791 02ca 9093 0000 		sts rec_beacon+1,r25
 792 02ce 8093 0000 		sts rec_beacon,r24
 408:ServerLLDN.c  **** 		PanId = rec_beacon->PanId;
 793               		.loc 6 408 0
 794 02d2 8091 0000 		lds r24,rec_beacon
 795 02d6 9091 0000 		lds r25,rec_beacon+1
 796 02da FC01      		movw r30,r24
 797 02dc 8481      		ldd r24,Z+4
 798 02de 8093 0000 		sts PanId,r24
 409:ServerLLDN.c  **** 		//  bom implementar rotinas pra se o nodo estiver associado a um coordeandor e se no estiver
 410:ServerLLDN.c  **** 		if( ((rec_beacon->Flags.txState == DISC_MODE && !ack_received && rec_beacon->confSeqNumber == 0x0
 799               		.loc 6 410 0
 800 02e2 8091 0000 		lds r24,rec_beacon
 801 02e6 9091 0000 		lds r25,rec_beacon+1
 802 02ea FC01      		movw r30,r24
 803 02ec 8381      		ldd r24,Z+3
 804 02ee 8770      		andi r24,lo8(7)
 805 02f0 8430      		cpi r24,lo8(4)
 806 02f2 01F4      		brne .L21
 807               		.loc 6 410 0 is_stmt 0 discriminator 1
 808 02f4 9091 0000 		lds r25,ack_received
 809 02f8 81E0      		ldi r24,lo8(1)
 810 02fa 8927      		eor r24,r25
 811 02fc 8823      		tst r24
 812 02fe 01F0      		breq .L21
 813               		.loc 6 410 0 discriminator 3
 814 0300 8091 0000 		lds r24,rec_beacon
 815 0304 9091 0000 		lds r25,rec_beacon+1
 816 0308 FC01      		movw r30,r24
 817 030a 8581      		ldd r24,Z+5
 818 030c 8823      		tst r24
 819 030e 01F0      		breq .L22
 820               	.L21:
 411:ServerLLDN.c  **** 			(rec_beacon->Flags.txState == CONFIG_MODE && ack_received)) && associated == 0)
 821               		.loc 6 411 0 is_stmt 1 discriminator 5
 822 0310 8091 0000 		lds r24,rec_beacon
 823 0314 9091 0000 		lds r25,rec_beacon+1
 824 0318 FC01      		movw r30,r24
 825 031a 8381      		ldd r24,Z+3
 826 031c 8770      		andi r24,lo8(7)
 410:ServerLLDN.c  **** 			(rec_beacon->Flags.txState == CONFIG_MODE && ack_received)) && associated == 0)
 827               		.loc 6 410 0 discriminator 5
 828 031e 8630      		cpi r24,lo8(6)
 829 0320 01F0      		breq .+2
 830 0322 00C0      		rjmp .L23
 831               		.loc 6 411 0
 832 0324 8091 0000 		lds r24,ack_received
 833 0328 8823      		tst r24
 834 032a 01F4      		brne .+2
 835 032c 00C0      		rjmp .L23
 836               	.L22:
 837               		.loc 6 411 0 is_stmt 0 discriminator 1
 838 032e 9091 0000 		lds r25,associated
 839 0332 81E0      		ldi r24,lo8(1)
 840 0334 8927      		eor r24,r25
 841 0336 8823      		tst r24
 842 0338 01F4      		brne .+2
 843 033a 00C0      		rjmp .L23
 844               	.LBB2:
 412:ServerLLDN.c  **** 		{
 413:ServerLLDN.c  **** 	
 414:ServerLLDN.c  **** 			int ts_time =  ((p_var*sp + (m+ rec_beacon->TimeSlotSize  )*sm + macMinLIFSPeriod)/v_var)  / (SY
 845               		.loc 6 414 0 is_stmt 1
 846 033c 8091 0000 		lds r24,rec_beacon
 847 0340 9091 0000 		lds r25,rec_beacon+1
 848 0344 FC01      		movw r30,r24
 849 0346 8681      		ldd r24,Z+6
 850 0348 882F      		mov r24,r24
 851 034a 90E0      		ldi r25,0
 852 034c 0396      		adiw r24,3
 853 034e 880F      		lsl r24
 854 0350 991F      		rol r25
 855 0352 092E      		mov __tmp_reg__,r25
 856 0354 000C      		lsl r0
 857 0356 AA0B      		sbc r26,r26
 858 0358 BB0B      		sbc r27,r27
 859 035a BC01      		movw r22,r24
 860 035c CD01      		movw r24,r26
 861 035e 0E94 0000 		call __floatsisf
 862 0362 DC01      		movw r26,r24
 863 0364 CB01      		movw r24,r22
 864 0366 20E0      		ldi r18,0
 865 0368 30E0      		ldi r19,0
 866 036a 40E4      		ldi r20,lo8(64)
 867 036c 51E4      		ldi r21,lo8(65)
 868 036e BC01      		movw r22,r24
 869 0370 CD01      		movw r24,r26
 870 0372 0E94 0000 		call __addsf3
 871 0376 DC01      		movw r26,r24
 872 0378 CB01      		movw r24,r22
 873 037a 20E0      		ldi r18,0
 874 037c 30E0      		ldi r19,0
 875 037e 40E2      		ldi r20,lo8(32)
 876 0380 52E4      		ldi r21,lo8(66)
 877 0382 BC01      		movw r22,r24
 878 0384 CD01      		movw r24,r26
 879 0386 0E94 0000 		call __addsf3
 880 038a DC01      		movw r26,r24
 881 038c CB01      		movw r24,r22
 882 038e 20E0      		ldi r18,0
 883 0390 34E2      		ldi r19,lo8(36)
 884 0392 44E7      		ldi r20,lo8(116)
 885 0394 57E4      		ldi r21,lo8(71)
 886 0396 BC01      		movw r22,r24
 887 0398 CD01      		movw r24,r26
 888 039a 0E94 0000 		call __divsf3
 889 039e DC01      		movw r26,r24
 890 03a0 CB01      		movw r24,r22
 891 03a2 2DEB      		ldi r18,lo8(-67)
 892 03a4 37E3      		ldi r19,lo8(55)
 893 03a6 46E8      		ldi r20,lo8(-122)
 894 03a8 57E3      		ldi r21,lo8(55)
 895 03aa BC01      		movw r22,r24
 896 03ac CD01      		movw r24,r26
 897 03ae 0E94 0000 		call __divsf3
 898 03b2 DC01      		movw r26,r24
 899 03b4 CB01      		movw r24,r22
 900 03b6 BC01      		movw r22,r24
 901 03b8 CD01      		movw r24,r26
 902 03ba 0E94 0000 		call __fixsfsi
 903 03be DC01      		movw r26,r24
 904 03c0 CB01      		movw r24,r22
 905 03c2 9A83      		std Y+2,r25
 906 03c4 8983      		std Y+1,r24
 415:ServerLLDN.c  **** 			int msg_wait_time = rec_beacon->Flags.numBaseMgmtTimeslots * rec_beacon->TimeSlotSize * 2; // sy
 907               		.loc 6 415 0
 908 03c6 8091 0000 		lds r24,rec_beacon
 909 03ca 9091 0000 		lds r25,rec_beacon+1
 910 03ce FC01      		movw r30,r24
 911 03d0 8381      		ldd r24,Z+3
 912 03d2 8295      		swap r24
 913 03d4 8695      		lsr r24
 914 03d6 8770      		andi r24,lo8(7)
 915 03d8 482F      		mov r20,r24
 916 03da 50E0      		ldi r21,0
 917 03dc 8091 0000 		lds r24,rec_beacon
 918 03e0 9091 0000 		lds r25,rec_beacon+1
 919 03e4 FC01      		movw r30,r24
 920 03e6 8681      		ldd r24,Z+6
 921 03e8 282F      		mov r18,r24
 922 03ea 30E0      		ldi r19,0
 923 03ec 429F      		mul r20,r18
 924 03ee C001      		movw r24,r0
 925 03f0 439F      		mul r20,r19
 926 03f2 900D      		add r25,r0
 927 03f4 529F      		mul r21,r18
 928 03f6 900D      		add r25,r0
 929 03f8 1124      		clr r1
 930 03fa 880F      		lsl r24
 931 03fc 991F      		rol r25
 932 03fe 9C83      		std Y+4,r25
 933 0400 8B83      		std Y+3,r24
 416:ServerLLDN.c  **** 			printf("\n TimeSlotSize %d", rec_beacon->TimeSlotSize);
 934               		.loc 6 416 0
 935 0402 8091 0000 		lds r24,rec_beacon
 936 0406 9091 0000 		lds r25,rec_beacon+1
 937 040a FC01      		movw r30,r24
 938 040c 8681      		ldd r24,Z+6
 939 040e 882F      		mov r24,r24
 940 0410 90E0      		ldi r25,0
 941 0412 292F      		mov r18,r25
 942 0414 2F93      		push r18
 943 0416 8F93      		push r24
 944 0418 80E0      		ldi r24,lo8(.LC4)
 945 041a 90E0      		ldi r25,hi8(.LC4)
 946 041c 892F      		mov r24,r25
 947 041e 8F93      		push r24
 948 0420 80E0      		ldi r24,lo8(.LC4)
 949 0422 90E0      		ldi r25,hi8(.LC4)
 950 0424 8F93      		push r24
 951 0426 0E94 0000 		call printf
 952 042a 0F90      		pop __tmp_reg__
 953 042c 0F90      		pop __tmp_reg__
 954 042e 0F90      		pop __tmp_reg__
 955 0430 0F90      		pop __tmp_reg__
 417:ServerLLDN.c  **** 			
 418:ServerLLDN.c  **** 			start_timer(msg_wait_time);
 956               		.loc 6 418 0
 957 0432 8B81      		ldd r24,Y+3
 958 0434 9C81      		ldd r25,Y+4
 959 0436 0E94 0000 		call start_timer
 419:ServerLLDN.c  **** 			
 420:ServerLLDN.c  **** 			appState = (rec_beacon->Flags.txState == DISC_MODE) ? APP_STATE_PREP_DISC_REPONSE : APP_STATE_PR
 960               		.loc 6 420 0
 961 043a 8091 0000 		lds r24,rec_beacon
 962 043e 9091 0000 		lds r25,rec_beacon+1
 963 0442 FC01      		movw r30,r24
 964 0444 8381      		ldd r24,Z+3
 965 0446 8770      		andi r24,lo8(7)
 966 0448 8430      		cpi r24,lo8(4)
 967 044a 01F4      		brne .L24
 968               		.loc 6 420 0 is_stmt 0 discriminator 1
 969 044c 84E0      		ldi r24,lo8(4)
 970 044e 00C0      		rjmp .L25
 971               	.L24:
 972               		.loc 6 420 0 discriminator 2
 973 0450 85E0      		ldi r24,lo8(5)
 974               	.L25:
 975               		.loc 6 420 0 discriminator 4
 976 0452 8093 0000 		sts appState,r24
 977               	.LBE2:
 412:ServerLLDN.c  **** 	
 978               		.loc 6 412 0 is_stmt 1 discriminator 4
 979 0456 00C0      		rjmp .L26
 980               	.L23:
 421:ServerLLDN.c  **** 		}
 422:ServerLLDN.c  **** 		else if (rec_beacon->Flags.txState == ONLINE_MODE && assTimeSlot != 0xFF && associated == 1)
 981               		.loc 6 422 0
 982 0458 8091 0000 		lds r24,rec_beacon
 983 045c 9091 0000 		lds r25,rec_beacon+1
 984 0460 FC01      		movw r30,r24
 985 0462 8381      		ldd r24,Z+3
 986 0464 8770      		andi r24,lo8(7)
 987 0466 8823      		tst r24
 988 0468 01F0      		breq .+2
 989 046a 00C0      		rjmp .L27
 990               		.loc 6 422 0 is_stmt 0 discriminator 1
 991 046c 8091 0000 		lds r24,assTimeSlot
 992 0470 8F3F      		cpi r24,lo8(-1)
 993 0472 01F4      		brne .+2
 994 0474 00C0      		rjmp .L27
 995               		.loc 6 422 0 discriminator 2
 996 0476 8091 0000 		lds r24,associated
 997 047a 8823      		tst r24
 998 047c 01F4      		brne .+2
 999 047e 00C0      		rjmp .L27
 1000               	.LBB3:
 423:ServerLLDN.c  **** 		{
 424:ServerLLDN.c  **** 			int ts_time = ((p_var*sp + (m+ n)*sm + macMinLIFSPeriod)/v_var)  / (SYMBOL_TIME);
 1001               		.loc 6 424 0 is_stmt 1
 1002 0480 8091 0000 		lds r24,n
 1003 0484 882F      		mov r24,r24
 1004 0486 90E0      		ldi r25,0
 1005 0488 0396      		adiw r24,3
 1006 048a 880F      		lsl r24
 1007 048c 991F      		rol r25
 1008 048e 092E      		mov __tmp_reg__,r25
 1009 0490 000C      		lsl r0
 1010 0492 AA0B      		sbc r26,r26
 1011 0494 BB0B      		sbc r27,r27
 1012 0496 BC01      		movw r22,r24
 1013 0498 CD01      		movw r24,r26
 1014 049a 0E94 0000 		call __floatsisf
 1015 049e DC01      		movw r26,r24
 1016 04a0 CB01      		movw r24,r22
 1017 04a2 20E0      		ldi r18,0
 1018 04a4 30E0      		ldi r19,0
 1019 04a6 40E4      		ldi r20,lo8(64)
 1020 04a8 51E4      		ldi r21,lo8(65)
 1021 04aa BC01      		movw r22,r24
 1022 04ac CD01      		movw r24,r26
 1023 04ae 0E94 0000 		call __addsf3
 1024 04b2 DC01      		movw r26,r24
 1025 04b4 CB01      		movw r24,r22
 1026 04b6 20E0      		ldi r18,0
 1027 04b8 30E0      		ldi r19,0
 1028 04ba 40E2      		ldi r20,lo8(32)
 1029 04bc 52E4      		ldi r21,lo8(66)
 1030 04be BC01      		movw r22,r24
 1031 04c0 CD01      		movw r24,r26
 1032 04c2 0E94 0000 		call __addsf3
 1033 04c6 DC01      		movw r26,r24
 1034 04c8 CB01      		movw r24,r22
 1035 04ca 20E0      		ldi r18,0
 1036 04cc 34E2      		ldi r19,lo8(36)
 1037 04ce 44E7      		ldi r20,lo8(116)
 1038 04d0 57E4      		ldi r21,lo8(71)
 1039 04d2 BC01      		movw r22,r24
 1040 04d4 CD01      		movw r24,r26
 1041 04d6 0E94 0000 		call __divsf3
 1042 04da DC01      		movw r26,r24
 1043 04dc CB01      		movw r24,r22
 1044 04de 2DEB      		ldi r18,lo8(-67)
 1045 04e0 37E3      		ldi r19,lo8(55)
 1046 04e2 46E8      		ldi r20,lo8(-122)
 1047 04e4 57E3      		ldi r21,lo8(55)
 1048 04e6 BC01      		movw r22,r24
 1049 04e8 CD01      		movw r24,r26
 1050 04ea 0E94 0000 		call __divsf3
 1051 04ee DC01      		movw r26,r24
 1052 04f0 CB01      		movw r24,r22
 1053 04f2 BC01      		movw r22,r24
 1054 04f4 CD01      		movw r24,r26
 1055 04f6 0E94 0000 		call __fixsfsi
 1056 04fa DC01      		movw r26,r24
 1057 04fc CB01      		movw r24,r22
 1058 04fe 9E83      		std Y+6,r25
 1059 0500 8D83      		std Y+5,r24
 425:ServerLLDN.c  **** 			int msg_wait_time = (2*rec_beacon->Flags.numBaseMgmtTimeslots + assTimeSlot) * n;
 1060               		.loc 6 425 0
 1061 0502 8091 0000 		lds r24,rec_beacon
 1062 0506 9091 0000 		lds r25,rec_beacon+1
 1063 050a FC01      		movw r30,r24
 1064 050c 8381      		ldd r24,Z+3
 1065 050e 8295      		swap r24
 1066 0510 8695      		lsr r24
 1067 0512 8770      		andi r24,lo8(7)
 1068 0514 882F      		mov r24,r24
 1069 0516 90E0      		ldi r25,0
 1070 0518 9C01      		movw r18,r24
 1071 051a 220F      		lsl r18
 1072 051c 331F      		rol r19
 1073 051e 8091 0000 		lds r24,assTimeSlot
 1074 0522 882F      		mov r24,r24
 1075 0524 90E0      		ldi r25,0
 1076 0526 A901      		movw r20,r18
 1077 0528 480F      		add r20,r24
 1078 052a 591F      		adc r21,r25
 1079 052c 8091 0000 		lds r24,n
 1080 0530 282F      		mov r18,r24
 1081 0532 30E0      		ldi r19,0
 1082 0534 429F      		mul r20,r18
 1083 0536 C001      		movw r24,r0
 1084 0538 439F      		mul r20,r19
 1085 053a 900D      		add r25,r0
 1086 053c 529F      		mul r21,r18
 1087 053e 900D      		add r25,r0
 1088 0540 1124      		clr r1
 1089 0542 9887      		std Y+8,r25
 1090 0544 8F83      		std Y+7,r24
 426:ServerLLDN.c  **** 			start_timer(msg_wait_time);
 1091               		.loc 6 426 0
 1092 0546 8F81      		ldd r24,Y+7
 1093 0548 9885      		ldd r25,Y+8
 1094 054a 0E94 0000 		call start_timer
 427:ServerLLDN.c  **** 			appState = APP_STATE_PREP_DATA_FRAME;
 1095               		.loc 6 427 0
 1096 054e 86E0      		ldi r24,lo8(6)
 1097 0550 8093 0000 		sts appState,r24
 1098               	.LBE3:
 423:ServerLLDN.c  **** 			int ts_time = ((p_var*sp + (m+ n)*sm + macMinLIFSPeriod)/v_var)  / (SYMBOL_TIME);
 1099               		.loc 6 423 0
 1100 0554 00C0      		rjmp .L26
 1101               	.L27:
 428:ServerLLDN.c  **** 		}
 429:ServerLLDN.c  **** 		else if (rec_beacon->Flags.txState == RESET_MODE)
 1102               		.loc 6 429 0
 1103 0556 8091 0000 		lds r24,rec_beacon
 1104 055a 9091 0000 		lds r25,rec_beacon+1
 1105 055e FC01      		movw r30,r24
 1106 0560 8381      		ldd r24,Z+3
 1107 0562 8770      		andi r24,lo8(7)
 1108 0564 8730      		cpi r24,lo8(7)
 1109 0566 01F4      		brne .L26
 430:ServerLLDN.c  **** 		{
 431:ServerLLDN.c  **** 			ack_received = 0;
 1110               		.loc 6 431 0
 1111 0568 1092 0000 		sts ack_received,__zero_reg__
 432:ServerLLDN.c  **** 			associated = 0;
 1112               		.loc 6 432 0
 1113 056c 1092 0000 		sts associated,__zero_reg__
 1114               	.L26:
 433:ServerLLDN.c  **** 		}
 434:ServerLLDN.c  **** 		return true;
 1115               		.loc 6 434 0
 1116 0570 81E0      		ldi r24,lo8(1)
 1117               	/* epilogue start */
 435:ServerLLDN.c  **** 	}
 1118               		.loc 6 435 0
 1119 0572 2A96      		adiw r28,10
 1120 0574 0FB6      		in __tmp_reg__,__SREG__
 1121 0576 F894      		cli
 1122 0578 DEBF      		out __SP_H__,r29
 1123 057a 0FBE      		out __SREG__,__tmp_reg__
 1124 057c CDBF      		out __SP_L__,r28
 1125 057e DF91      		pop r29
 1126 0580 CF91      		pop r28
 1127 0582 0895      		ret
 1128               		.cfi_endproc
 1129               	.LFE133:
 1131               		.section	.rodata
 1132               	.LC5:
 1133 003d 0A20 6163 		.string	"\n ack true"
 1133      6B20 7472 
 1133      7565 00
 1134               		.text
 1136               	appAckInd:
 1137               	.LFB134:
 436:ServerLLDN.c  **** 	
 437:ServerLLDN.c  **** 	static bool appAckInd(NWK_DataInd_t *ind)
 438:ServerLLDN.c  **** 	{
 1138               		.loc 6 438 0
 1139               		.cfi_startproc
 1140 0584 CF93      		push r28
 1141               	.LCFI43:
 1142               		.cfi_def_cfa_offset 3
 1143               		.cfi_offset 28, -2
 1144 0586 DF93      		push r29
 1145               	.LCFI44:
 1146               		.cfi_def_cfa_offset 4
 1147               		.cfi_offset 29, -3
 1148 0588 CDB7      		in r28,__SP_L__
 1149 058a DEB7      		in r29,__SP_H__
 1150               	.LCFI45:
 1151               		.cfi_def_cfa_register 28
 1152 058c 2897      		sbiw r28,8
 1153               	.LCFI46:
 1154               		.cfi_def_cfa_offset 12
 1155 058e 0FB6      		in __tmp_reg__,__SREG__
 1156 0590 F894      		cli
 1157 0592 DEBF      		out __SP_H__,r29
 1158 0594 0FBE      		out __SREG__,__tmp_reg__
 1159 0596 CDBF      		out __SP_L__,r28
 1160               	/* prologue: function */
 1161               	/* frame size = 8 */
 1162               	/* stack size = 10 */
 1163               	.L__stack_usage = 10
 1164 0598 9887      		std Y+8,r25
 1165 059a 8F83      		std Y+7,r24
 439:ServerLLDN.c  **** 		#if !MASTER_MACSC
 440:ServerLLDN.c  **** 		ind->data = ind->data - (uint8_t) 1;
 441:ServerLLDN.c  **** 		#endif
 442:ServerLLDN.c  **** 		NWK_ACKFormat_t *ackframe = (NWK_ACKFormat_t*)ind->data;
 1166               		.loc 6 442 0
 1167 059c 8F81      		ldd r24,Y+7
 1168 059e 9885      		ldd r25,Y+8
 1169 05a0 FC01      		movw r30,r24
 1170 05a2 8085      		ldd r24,Z+8
 1171 05a4 9185      		ldd r25,Z+9
 1172 05a6 9A83      		std Y+2,r25
 1173 05a8 8983      		std Y+1,r24
 443:ServerLLDN.c  **** 		if(PanId == ackframe->sourceId)
 1174               		.loc 6 443 0
 1175 05aa 8981      		ldd r24,Y+1
 1176 05ac 9A81      		ldd r25,Y+2
 1177 05ae FC01      		movw r30,r24
 1178 05b0 9081      		ld r25,Z
 1179 05b2 8091 0000 		lds r24,PanId
 1180 05b6 9817      		cp r25,r24
 1181 05b8 01F4      		brne .L30
 1182               	.LBB4:
 444:ServerLLDN.c  **** 		{
 445:ServerLLDN.c  **** 			int pos = (int) APP_ADDR / 8;
 1183               		.loc 6 445 0
 1184 05ba 1C82      		std Y+4,__zero_reg__
 1185 05bc 1B82      		std Y+3,__zero_reg__
 446:ServerLLDN.c  **** 			int bit_shift = 8 - APP_ADDR % 8;
 1186               		.loc 6 446 0
 1187 05be 87E0      		ldi r24,lo8(7)
 1188 05c0 90E0      		ldi r25,0
 1189 05c2 9E83      		std Y+6,r25
 1190 05c4 8D83      		std Y+5,r24
 447:ServerLLDN.c  **** 			if( ackframe->ackFlags[pos] & 1 << bit_shift)	
 1191               		.loc 6 447 0
 1192 05c6 2981      		ldd r18,Y+1
 1193 05c8 3A81      		ldd r19,Y+2
 1194 05ca 8B81      		ldd r24,Y+3
 1195 05cc 9C81      		ldd r25,Y+4
 1196 05ce 820F      		add r24,r18
 1197 05d0 931F      		adc r25,r19
 1198 05d2 0196      		adiw r24,1
 1199 05d4 FC01      		movw r30,r24
 1200 05d6 8081      		ld r24,Z
 1201 05d8 882F      		mov r24,r24
 1202 05da 90E0      		ldi r25,0
 1203 05dc 0D80      		ldd r0,Y+5
 1204 05de 00C0      		rjmp 2f
 1205               		1:
 1206 05e0 9595      		asr r25
 1207 05e2 8795      		ror r24
 1208               		2:
 1209 05e4 0A94      		dec r0
 1210 05e6 02F4      		brpl 1b
 1211 05e8 8170      		andi r24,1
 1212 05ea 9927      		clr r25
 1213 05ec 892B      		or r24,r25
 1214 05ee 01F0      		breq .L30
 448:ServerLLDN.c  **** 			{
 449:ServerLLDN.c  **** 				printf("\n ack true");
 1215               		.loc 6 449 0
 1216 05f0 80E0      		ldi r24,lo8(.LC5)
 1217 05f2 90E0      		ldi r25,hi8(.LC5)
 1218 05f4 892F      		mov r24,r25
 1219 05f6 8F93      		push r24
 1220 05f8 80E0      		ldi r24,lo8(.LC5)
 1221 05fa 90E0      		ldi r25,hi8(.LC5)
 1222 05fc 8F93      		push r24
 1223 05fe 0E94 0000 		call printf
 1224 0602 0F90      		pop __tmp_reg__
 1225 0604 0F90      		pop __tmp_reg__
 450:ServerLLDN.c  **** 				ack_received = true;
 1226               		.loc 6 450 0
 1227 0606 81E0      		ldi r24,lo8(1)
 1228 0608 8093 0000 		sts ack_received,r24
 1229               	.L30:
 1230               	.LBE4:
 451:ServerLLDN.c  **** 			}
 452:ServerLLDN.c  **** 		}
 453:ServerLLDN.c  **** 		return true;
 1231               		.loc 6 453 0
 1232 060c 81E0      		ldi r24,lo8(1)
 1233               	/* epilogue start */
 454:ServerLLDN.c  **** 	}
 1234               		.loc 6 454 0
 1235 060e 2896      		adiw r28,8
 1236 0610 0FB6      		in __tmp_reg__,__SREG__
 1237 0612 F894      		cli
 1238 0614 DEBF      		out __SP_H__,r29
 1239 0616 0FBE      		out __SREG__,__tmp_reg__
 1240 0618 CDBF      		out __SP_L__,r28
 1241 061a DF91      		pop r29
 1242 061c CF91      		pop r28
 1243 061e 0895      		ret
 1244               		.cfi_endproc
 1245               	.LFE134:
 1247               		.section	.rodata
 1248               	.LC6:
 1249 0048 0A52 6563 		.string	"\nRecebeu conf request"
 1249      6562 6575 
 1249      2063 6F6E 
 1249      6620 7265 
 1249      7175 6573 
 1250               		.text
 1252               	appCommandInd:
 1253               	.LFB135:
 455:ServerLLDN.c  **** 	
 456:ServerLLDN.c  **** 	static bool appCommandInd(NWK_DataInd_t *ind)
 457:ServerLLDN.c  **** 	{
 1254               		.loc 6 457 0
 1255               		.cfi_startproc
 1256 0620 CF93      		push r28
 1257               	.LCFI47:
 1258               		.cfi_def_cfa_offset 3
 1259               		.cfi_offset 28, -2
 1260 0622 DF93      		push r29
 1261               	.LCFI48:
 1262               		.cfi_def_cfa_offset 4
 1263               		.cfi_offset 29, -3
 1264 0624 00D0      		rcall .
 1265 0626 00D0      		rcall .
 1266               	.LCFI49:
 1267               		.cfi_def_cfa_offset 8
 1268 0628 CDB7      		in r28,__SP_L__
 1269 062a DEB7      		in r29,__SP_H__
 1270               	.LCFI50:
 1271               		.cfi_def_cfa_register 28
 1272               	/* prologue: function */
 1273               	/* frame size = 4 */
 1274               	/* stack size = 6 */
 1275               	.L__stack_usage = 6
 1276 062c 9C83      		std Y+4,r25
 1277 062e 8B83      		std Y+3,r24
 458:ServerLLDN.c  **** 		#if !MASTER_MACSC
 459:ServerLLDN.c  **** 		ind->data = ind->data - (uint8_t) 1;
 460:ServerLLDN.c  **** 		#endif
 461:ServerLLDN.c  **** 		
 462:ServerLLDN.c  **** 		if(ind->data[0] == LL_CONFIGURATION_REQUEST)
 1278               		.loc 6 462 0
 1279 0630 8B81      		ldd r24,Y+3
 1280 0632 9C81      		ldd r25,Y+4
 1281 0634 FC01      		movw r30,r24
 1282 0636 8085      		ldd r24,Z+8
 1283 0638 9185      		ldd r25,Z+9
 1284 063a FC01      		movw r30,r24
 1285 063c 8081      		ld r24,Z
 1286 063e 8F30      		cpi r24,lo8(15)
 1287 0640 01F4      		brne .L33
 1288               	.LBB5:
 463:ServerLLDN.c  **** 		{
 464:ServerLLDN.c  **** 			NWK_ConfigRequest_t *msg = (NWK_ConfigRequest_t*)ind->data;
 1289               		.loc 6 464 0
 1290 0642 8B81      		ldd r24,Y+3
 1291 0644 9C81      		ldd r25,Y+4
 1292 0646 FC01      		movw r30,r24
 1293 0648 8085      		ldd r24,Z+8
 1294 064a 9185      		ldd r25,Z+9
 1295 064c 9A83      		std Y+2,r25
 1296 064e 8983      		std Y+1,r24
 465:ServerLLDN.c  **** 			if(msg->macAddr == APP_ADDR)
 1297               		.loc 6 465 0
 1298 0650 8981      		ldd r24,Y+1
 1299 0652 9A81      		ldd r25,Y+2
 1300 0654 FC01      		movw r30,r24
 1301 0656 8481      		ldd r24,Z+4
 1302 0658 8130      		cpi r24,lo8(1)
 1303 065a 01F4      		brne .L33
 466:ServerLLDN.c  **** 			{
 467:ServerLLDN.c  **** 				PHY_SetChannel(msg->tx_channel);
 1304               		.loc 6 467 0
 1305 065c 8981      		ldd r24,Y+1
 1306 065e 9A81      		ldd r25,Y+2
 1307 0660 FC01      		movw r30,r24
 1308 0662 8281      		ldd r24,Z+2
 1309 0664 0E94 0000 		call PHY_SetChannel
 468:ServerLLDN.c  **** 				NWK_SetPanId(msg->s_macAddr);
 1310               		.loc 6 468 0
 1311 0668 8981      		ldd r24,Y+1
 1312 066a 9A81      		ldd r25,Y+2
 1313 066c FC01      		movw r30,r24
 1314 066e 8181      		ldd r24,Z+1
 1315 0670 882F      		mov r24,r24
 1316 0672 90E0      		ldi r25,0
 1317 0674 0E94 0000 		call NWK_SetPanId
 469:ServerLLDN.c  **** 				PanId = msg->s_macAddr;
 1318               		.loc 6 469 0
 1319 0678 8981      		ldd r24,Y+1
 1320 067a 9A81      		ldd r25,Y+2
 1321 067c FC01      		movw r30,r24
 1322 067e 8181      		ldd r24,Z+1
 1323 0680 8093 0000 		sts PanId,r24
 470:ServerLLDN.c  **** 				assTimeSlot = msg->assTimeSlot;
 1324               		.loc 6 470 0
 1325 0684 8981      		ldd r24,Y+1
 1326 0686 9A81      		ldd r25,Y+2
 1327 0688 FC01      		movw r30,r24
 1328 068a 8381      		ldd r24,Z+3
 1329 068c 8093 0000 		sts assTimeSlot,r24
 471:ServerLLDN.c  **** 				n = msg->conf.tsDuration;
 1330               		.loc 6 471 0
 1331 0690 8981      		ldd r24,Y+1
 1332 0692 9A81      		ldd r25,Y+2
 1333 0694 FC01      		movw r30,r24
 1334 0696 8581      		ldd r24,Z+5
 1335 0698 8F77      		andi r24,lo8(127)
 1336 069a 8093 0000 		sts n,r24
 472:ServerLLDN.c  **** 				associated = 1;
 1337               		.loc 6 472 0
 1338 069e 81E0      		ldi r24,lo8(1)
 1339 06a0 8093 0000 		sts associated,r24
 473:ServerLLDN.c  **** 				printf("\nRecebeu conf request");
 1340               		.loc 6 473 0
 1341 06a4 80E0      		ldi r24,lo8(.LC6)
 1342 06a6 90E0      		ldi r25,hi8(.LC6)
 1343 06a8 892F      		mov r24,r25
 1344 06aa 8F93      		push r24
 1345 06ac 80E0      		ldi r24,lo8(.LC6)
 1346 06ae 90E0      		ldi r25,hi8(.LC6)
 1347 06b0 8F93      		push r24
 1348 06b2 0E94 0000 		call printf
 1349 06b6 0F90      		pop __tmp_reg__
 1350 06b8 0F90      		pop __tmp_reg__
 1351               	.L33:
 1352               	.LBE5:
 474:ServerLLDN.c  **** 			}
 475:ServerLLDN.c  **** 		}
 476:ServerLLDN.c  **** 		return true;
 1353               		.loc 6 476 0
 1354 06ba 81E0      		ldi r24,lo8(1)
 1355               	/* epilogue start */
 477:ServerLLDN.c  **** 	}
 1356               		.loc 6 477 0
 1357 06bc 0F90      		pop __tmp_reg__
 1358 06be 0F90      		pop __tmp_reg__
 1359 06c0 0F90      		pop __tmp_reg__
 1360 06c2 0F90      		pop __tmp_reg__
 1361 06c4 DF91      		pop r29
 1362 06c6 CF91      		pop r28
 1363 06c8 0895      		ret
 1364               		.cfi_endproc
 1365               	.LFE135:
 1367               	.global	appPrepareDiscoverResponse
 1369               	appPrepareDiscoverResponse:
 1370               	.LFB136:
 478:ServerLLDN.c  **** 
 479:ServerLLDN.c  **** 	void appPrepareDiscoverResponse()
 480:ServerLLDN.c  **** 	{
 1371               		.loc 6 480 0
 1372               		.cfi_startproc
 1373 06ca CF93      		push r28
 1374               	.LCFI51:
 1375               		.cfi_def_cfa_offset 3
 1376               		.cfi_offset 28, -2
 1377 06cc DF93      		push r29
 1378               	.LCFI52:
 1379               		.cfi_def_cfa_offset 4
 1380               		.cfi_offset 29, -3
 1381 06ce CDB7      		in r28,__SP_L__
 1382 06d0 DEB7      		in r29,__SP_H__
 1383               	.LCFI53:
 1384               		.cfi_def_cfa_register 28
 1385               	/* prologue: function */
 1386               	/* frame size = 0 */
 1387               	/* stack size = 2 */
 1388               	.L__stack_usage = 2
 481:ServerLLDN.c  **** 		msgReq.dstAddr				= 0;
 1389               		.loc 6 481 0
 1390 06d2 1092 0000 		sts msgReq+5+1,__zero_reg__
 1391 06d6 1092 0000 		sts msgReq+5,__zero_reg__
 482:ServerLLDN.c  **** 		msgReq.dstEndpoint			= APP_COMMAND_ENDPOINT;
 1392               		.loc 6 482 0
 1393 06da 83E0      		ldi r24,lo8(3)
 1394 06dc 8093 0000 		sts msgReq+7,r24
 483:ServerLLDN.c  **** 		msgReq.srcEndpoint			= APP_COMMAND_ENDPOINT;
 1395               		.loc 6 483 0
 1396 06e0 83E0      		ldi r24,lo8(3)
 1397 06e2 8093 0000 		sts msgReq+8,r24
 484:ServerLLDN.c  **** 		msgReq.options				= NWK_OPT_MAC_COMMAND;
 1398               		.loc 6 484 0
 1399 06e6 80E0      		ldi r24,0
 1400 06e8 90E8      		ldi r25,lo8(-128)
 1401 06ea 9093 0000 		sts msgReq+9+1,r25
 1402 06ee 8093 0000 		sts msgReq+9,r24
 485:ServerLLDN.c  **** 		msgReq.data					= (uint8_t*)&msgDiscResponse;
 1403               		.loc 6 485 0
 1404 06f2 80E0      		ldi r24,lo8(msgDiscResponse)
 1405 06f4 90E0      		ldi r25,hi8(msgDiscResponse)
 1406 06f6 9093 0000 		sts msgReq+13+1,r25
 1407 06fa 8093 0000 		sts msgReq+13,r24
 486:ServerLLDN.c  **** 		msgReq.size					= sizeof(msgDiscResponse);
 1408               		.loc 6 486 0
 1409 06fe 83E0      		ldi r24,lo8(3)
 1410 0700 8093 0000 		sts msgReq+15,r24
 487:ServerLLDN.c  **** 	}
 1411               		.loc 6 487 0
 1412 0704 0000      		nop
 1413               	/* epilogue start */
 1414 0706 DF91      		pop r29
 1415 0708 CF91      		pop r28
 1416 070a 0895      		ret
 1417               		.cfi_endproc
 1418               	.LFE136:
 1420               	.global	appPrepareConfigurationStatus
 1422               	appPrepareConfigurationStatus:
 1423               	.LFB137:
 488:ServerLLDN.c  **** 	
 489:ServerLLDN.c  **** 	void appPrepareConfigurationStatus()
 490:ServerLLDN.c  **** 	{		
 1424               		.loc 6 490 0
 1425               		.cfi_startproc
 1426 070c CF93      		push r28
 1427               	.LCFI54:
 1428               		.cfi_def_cfa_offset 3
 1429               		.cfi_offset 28, -2
 1430 070e DF93      		push r29
 1431               	.LCFI55:
 1432               		.cfi_def_cfa_offset 4
 1433               		.cfi_offset 29, -3
 1434 0710 CDB7      		in r28,__SP_L__
 1435 0712 DEB7      		in r29,__SP_H__
 1436               	.LCFI56:
 1437               		.cfi_def_cfa_register 28
 1438               	/* prologue: function */
 1439               	/* frame size = 0 */
 1440               	/* stack size = 2 */
 1441               	.L__stack_usage = 2
 491:ServerLLDN.c  **** 		msgReq.dstAddr				= 0;
 1442               		.loc 6 491 0
 1443 0714 1092 0000 		sts msgReq+5+1,__zero_reg__
 1444 0718 1092 0000 		sts msgReq+5,__zero_reg__
 492:ServerLLDN.c  **** 		msgReq.dstEndpoint			= APP_COMMAND_ENDPOINT;
 1445               		.loc 6 492 0
 1446 071c 83E0      		ldi r24,lo8(3)
 1447 071e 8093 0000 		sts msgReq+7,r24
 493:ServerLLDN.c  **** 		msgReq.srcEndpoint			= APP_COMMAND_ENDPOINT;
 1448               		.loc 6 493 0
 1449 0722 83E0      		ldi r24,lo8(3)
 1450 0724 8093 0000 		sts msgReq+8,r24
 494:ServerLLDN.c  **** 		msgReq.options				= NWK_OPT_MAC_COMMAND;
 1451               		.loc 6 494 0
 1452 0728 80E0      		ldi r24,0
 1453 072a 90E8      		ldi r25,lo8(-128)
 1454 072c 9093 0000 		sts msgReq+9+1,r25
 1455 0730 8093 0000 		sts msgReq+9,r24
 495:ServerLLDN.c  **** 		msgReq.data					= (uint8_t*)&msgConfigStatus;
 1456               		.loc 6 495 0
 1457 0734 80E0      		ldi r24,lo8(msgConfigStatus)
 1458 0736 90E0      		ldi r25,hi8(msgConfigStatus)
 1459 0738 9093 0000 		sts msgReq+13+1,r25
 1460 073c 8093 0000 		sts msgReq+13,r24
 496:ServerLLDN.c  **** 		msgReq.size					= sizeof(msgConfigStatus);
 1461               		.loc 6 496 0
 1462 0740 85E0      		ldi r24,lo8(5)
 1463 0742 8093 0000 		sts msgReq+15,r24
 497:ServerLLDN.c  **** 	}
 1464               		.loc 6 497 0
 1465 0746 0000      		nop
 1466               	/* epilogue start */
 1467 0748 DF91      		pop r29
 1468 074a CF91      		pop r28
 1469 074c 0895      		ret
 1470               		.cfi_endproc
 1471               	.LFE137:
 1473               	.global	appPrepareDataFrame
 1475               	appPrepareDataFrame:
 1476               	.LFB138:
 498:ServerLLDN.c  **** 	
 499:ServerLLDN.c  **** 	void appPrepareDataFrame(void)
 500:ServerLLDN.c  **** 	{
 1477               		.loc 6 500 0
 1478               		.cfi_startproc
 1479 074e CF93      		push r28
 1480               	.LCFI57:
 1481               		.cfi_def_cfa_offset 3
 1482               		.cfi_offset 28, -2
 1483 0750 DF93      		push r29
 1484               	.LCFI58:
 1485               		.cfi_def_cfa_offset 4
 1486               		.cfi_offset 29, -3
 1487 0752 CDB7      		in r28,__SP_L__
 1488 0754 DEB7      		in r29,__SP_H__
 1489               	.LCFI59:
 1490               		.cfi_def_cfa_register 28
 1491               	/* prologue: function */
 1492               	/* frame size = 0 */
 1493               	/* stack size = 2 */
 1494               	.L__stack_usage = 2
 501:ServerLLDN.c  **** 		
 502:ServerLLDN.c  **** 		PHY_SetTdmaMode(false);
 1495               		.loc 6 502 0
 1496 0756 80E0      		ldi r24,0
 1497 0758 0E94 0000 		call PHY_SetTdmaMode
 503:ServerLLDN.c  **** 
 504:ServerLLDN.c  **** 	
 505:ServerLLDN.c  **** 		msgReq.dstAddr				= 0;
 1498               		.loc 6 505 0
 1499 075c 1092 0000 		sts msgReq+5+1,__zero_reg__
 1500 0760 1092 0000 		sts msgReq+5,__zero_reg__
 506:ServerLLDN.c  **** 		msgReq.dstEndpoint			= APP_COMMAND_ENDPOINT;
 1501               		.loc 6 506 0
 1502 0764 83E0      		ldi r24,lo8(3)
 1503 0766 8093 0000 		sts msgReq+7,r24
 507:ServerLLDN.c  **** 		msgReq.srcEndpoint			= APP_COMMAND_ENDPOINT;
 1504               		.loc 6 507 0
 1505 076a 83E0      		ldi r24,lo8(3)
 1506 076c 8093 0000 		sts msgReq+8,r24
 508:ServerLLDN.c  **** 		msgReq.options				= NWK_OPT_LLDN_DATA;
 1507               		.loc 6 508 0
 1508 0770 80E0      		ldi r24,0
 1509 0772 90E2      		ldi r25,lo8(32)
 1510 0774 9093 0000 		sts msgReq+9+1,r25
 1511 0778 8093 0000 		sts msgReq+9,r24
 509:ServerLLDN.c  **** 		msgReq.data					= (uint8_t *)&data_payload;
 1512               		.loc 6 509 0
 1513 077c 80E0      		ldi r24,lo8(data_payload)
 1514 077e 90E0      		ldi r25,hi8(data_payload)
 1515 0780 9093 0000 		sts msgReq+13+1,r25
 1516 0784 8093 0000 		sts msgReq+13,r24
 510:ServerLLDN.c  **** 		msgReq.size					= sizeof(data_payload);
 1517               		.loc 6 510 0
 1518 0788 81E0      		ldi r24,lo8(1)
 1519 078a 8093 0000 		sts msgReq+15,r24
 511:ServerLLDN.c  **** 	}
 1520               		.loc 6 511 0
 1521 078e 0000      		nop
 1522               	/* epilogue start */
 1523 0790 DF91      		pop r29
 1524 0792 CF91      		pop r28
 1525 0794 0895      		ret
 1526               		.cfi_endproc
 1527               	.LFE138:
 1530               	appInit:
 1531               	.LFB139:
 512:ServerLLDN.c  **** 	
 513:ServerLLDN.c  **** 	
 514:ServerLLDN.c  **** #endif // APP_COORDINATOR
 515:ServerLLDN.c  **** 
 516:ServerLLDN.c  **** static void appInit(void)
 517:ServerLLDN.c  **** {
 1532               		.loc 6 517 0
 1533               		.cfi_startproc
 1534 0796 CF93      		push r28
 1535               	.LCFI60:
 1536               		.cfi_def_cfa_offset 3
 1537               		.cfi_offset 28, -2
 1538 0798 DF93      		push r29
 1539               	.LCFI61:
 1540               		.cfi_def_cfa_offset 4
 1541               		.cfi_offset 29, -3
 1542 079a CDB7      		in r28,__SP_L__
 1543 079c DEB7      		in r29,__SP_H__
 1544               	.LCFI62:
 1545               		.cfi_def_cfa_register 28
 1546               	/* prologue: function */
 1547               	/* frame size = 0 */
 1548               	/* stack size = 2 */
 1549               	.L__stack_usage = 2
 518:ServerLLDN.c  **** 	NWK_SetAddr(APP_ADDR);
 1550               		.loc 6 518 0
 1551 079e 81E0      		ldi r24,lo8(1)
 1552 07a0 90E0      		ldi r25,0
 1553 07a2 0E94 0000 		call NWK_SetAddr
 519:ServerLLDN.c  **** 	PHY_SetChannel(APP_CHANNEL);
 1554               		.loc 6 519 0
 1555 07a6 8FE0      		ldi r24,lo8(15)
 1556 07a8 0E94 0000 		call PHY_SetChannel
 520:ServerLLDN.c  **** 	PHY_SetRxState(true);
 1557               		.loc 6 520 0
 1558 07ac 81E0      		ldi r24,lo8(1)
 1559 07ae 0E94 0000 		call PHY_SetRxState
 521:ServerLLDN.c  **** 		
 522:ServerLLDN.c  **** 	#if APP_COORDINATOR	 
 523:ServerLLDN.c  **** 		/* Timer used for delay between messages */
 524:ServerLLDN.c  **** 		tmrDelay.interval = 2;
 525:ServerLLDN.c  **** 		tmrDelay.mode = SYS_TIMER_INTERVAL_MODE;
 526:ServerLLDN.c  **** 		tmrDelay.handler = tmrDelayHandler;
 527:ServerLLDN.c  **** 	  
 528:ServerLLDN.c  **** 		/* 
 529:ServerLLDN.c  **** 		* Disable CSMA/CA
 530:ServerLLDN.c  **** 		* Disable auto ACK
 531:ServerLLDN.c  **** 		*/
 532:ServerLLDN.c  **** 		NWK_SetPanId(APP_PANID);
 533:ServerLLDN.c  **** 		PanId = APP_PANID;
 534:ServerLLDN.c  **** 		ACKFrame.sourceId = APP_PANID;
 535:ServerLLDN.c  **** 		PHY_SetTdmaMode(true);
 536:ServerLLDN.c  **** 	NWK_OpenEndpoint(APP_COMMAND_ENDPOINT, appCommandInd);
 537:ServerLLDN.c  **** 	#else
 538:ServerLLDN.c  **** 		/*
 539:ServerLLDN.c  **** 		 * Enable CSMA/CA
 540:ServerLLDN.c  **** 		 * Enable Random CSMA seed generator
 541:ServerLLDN.c  **** 		 */
 542:ServerLLDN.c  **** 		PHY_SetTdmaMode(false);
 1560               		.loc 6 542 0
 1561 07b2 80E0      		ldi r24,0
 1562 07b4 0E94 0000 		call PHY_SetTdmaMode
 543:ServerLLDN.c  **** 		// PHY_SetOptimizedCSMAValues();
 544:ServerLLDN.c  **** 		
 545:ServerLLDN.c  **** 		payloadSize = 127;
 1563               		.loc 6 545 0
 1564 07b8 8FE7      		ldi r24,lo8(127)
 1565 07ba 8093 0000 		sts payloadSize,r24
 546:ServerLLDN.c  **** 		NWK_OpenEndpoint(APP_BEACON_ENDPOINT, appBeaconInd);
 1566               		.loc 6 546 0
 1567 07be 60E0      		ldi r22,lo8(gs(appBeaconInd))
 1568 07c0 70E0      		ldi r23,hi8(gs(appBeaconInd))
 1569 07c2 80E0      		ldi r24,0
 1570 07c4 0E94 0000 		call NWK_OpenEndpoint
 547:ServerLLDN.c  **** 		NWK_OpenEndpoint(APP_ACK_ENDPOINT, appAckInd);
 1571               		.loc 6 547 0
 1572 07c8 60E0      		ldi r22,lo8(gs(appAckInd))
 1573 07ca 70E0      		ldi r23,hi8(gs(appAckInd))
 1574 07cc 84E0      		ldi r24,lo8(4)
 1575 07ce 0E94 0000 		call NWK_OpenEndpoint
 548:ServerLLDN.c  **** 		NWK_OpenEndpoint(APP_COMMAND_ENDPOINT, appCommandInd);
 1576               		.loc 6 548 0
 1577 07d2 60E0      		ldi r22,lo8(gs(appCommandInd))
 1578 07d4 70E0      		ldi r23,hi8(gs(appCommandInd))
 1579 07d6 83E0      		ldi r24,lo8(3)
 1580 07d8 0E94 0000 		call NWK_OpenEndpoint
 549:ServerLLDN.c  **** 		/*
 550:ServerLLDN.c  **** 		* Configure interrupts callback functions
 551:ServerLLDN.c  **** 		*/
 552:ServerLLDN.c  **** 		
 553:ServerLLDN.c  **** 	#endif // APP_COORDENATOR
 554:ServerLLDN.c  **** 	PHY_SetPromiscuousMode(true);
 1581               		.loc 6 554 0
 1582 07dc 81E0      		ldi r24,lo8(1)
 1583 07de 0E94 0000 		call PHY_SetPromiscuousMode
 555:ServerLLDN.c  **** 
 556:ServerLLDN.c  **** }
 1584               		.loc 6 556 0
 1585 07e2 0000      		nop
 1586               	/* epilogue start */
 1587 07e4 DF91      		pop r29
 1588 07e6 CF91      		pop r28
 1589 07e8 0895      		ret
 1590               		.cfi_endproc
 1591               	.LFE139:
 1594               	APP_TaskHandler:
 1595               	.LFB140:
 557:ServerLLDN.c  **** 
 558:ServerLLDN.c  **** static void APP_TaskHandler(void)
 559:ServerLLDN.c  **** {
 1596               		.loc 6 559 0
 1597               		.cfi_startproc
 1598 07ea CF93      		push r28
 1599               	.LCFI63:
 1600               		.cfi_def_cfa_offset 3
 1601               		.cfi_offset 28, -2
 1602 07ec DF93      		push r29
 1603               	.LCFI64:
 1604               		.cfi_def_cfa_offset 4
 1605               		.cfi_offset 29, -3
 1606 07ee CDB7      		in r28,__SP_L__
 1607 07f0 DEB7      		in r29,__SP_H__
 1608               	.LCFI65:
 1609               		.cfi_def_cfa_register 28
 1610               	/* prologue: function */
 1611               	/* frame size = 0 */
 1612               	/* stack size = 2 */
 1613               	.L__stack_usage = 2
 560:ServerLLDN.c  **** 	switch (appState){
 1614               		.loc 6 560 0
 1615 07f2 8091 0000 		lds r24,appState
 1616 07f6 882F      		mov r24,r24
 1617 07f8 90E0      		ldi r25,0
 1618 07fa 8430      		cpi r24,4
 1619 07fc 9105      		cpc r25,__zero_reg__
 1620 07fe 01F0      		breq .L41
 1621 0800 8530      		cpi r24,5
 1622 0802 9105      		cpc r25,__zero_reg__
 1623 0804 04F4      		brge .L42
 1624 0806 0097      		sbiw r24,0
 1625 0808 01F0      		breq .L43
 1626 080a 0297      		sbiw r24,2
 1627 080c 01F0      		breq .L44
 561:ServerLLDN.c  **** 		case APP_STATE_INITIAL:
 562:ServerLLDN.c  **** 		{
 563:ServerLLDN.c  **** 			appInit();
 564:ServerLLDN.c  **** 			#if APP_COORDINATOR
 565:ServerLLDN.c  **** 				appState = APP_STATE_ATT_PAN_STATE;
 566:ServerLLDN.c  **** 			#else
 567:ServerLLDN.c  **** 				appState = APP_STATE_IDLE;
 568:ServerLLDN.c  **** 			#endif
 569:ServerLLDN.c  **** 			break;
 570:ServerLLDN.c  **** 		}
 571:ServerLLDN.c  **** 		case APP_STATE_SEND:
 572:ServerLLDN.c  **** 		{
 573:ServerLLDN.c  **** 			appSendData();
 574:ServerLLDN.c  **** 			#if APP_COORDINATOR
 575:ServerLLDN.c  **** 				/* Every time a message is send updates coordinator to prepare next message */
 576:ServerLLDN.c  **** 				appState = APP_STATE_ATT_PAN_STATE;
 577:ServerLLDN.c  **** 			#else
 578:ServerLLDN.c  **** 				appState = APP_STATE_IDLE;
 579:ServerLLDN.c  **** 			#endif
 580:ServerLLDN.c  **** 			break;
 581:ServerLLDN.c  **** 		}
 582:ServerLLDN.c  **** 		#if APP_COORDINATOR // COORDINATOR SPECIFIC STATE MACHINE
 583:ServerLLDN.c  **** 		case APP_STATE_ATT_PAN_STATE:
 584:ServerLLDN.c  **** 		{
 585:ServerLLDN.c  **** 			switch(appPanState)
 586:ServerLLDN.c  **** 			{
 587:ServerLLDN.c  **** 				/* Prepare beacon to desassociate all nodes */
 588:ServerLLDN.c  **** 				case APP_PAN_STATE_RESET:
 589:ServerLLDN.c  **** 				{
 590:ServerLLDN.c  **** 					appPanReset();
 591:ServerLLDN.c  **** 					appPanState = APP_PAN_STATE_DISC_INITIAL;
 592:ServerLLDN.c  **** 					appState	= APP_STATE_SEND;
 593:ServerLLDN.c  **** 					cycles_counter = 0;
 594:ServerLLDN.c  **** 					break;
 595:ServerLLDN.c  **** 				}
 596:ServerLLDN.c  **** 				/* Prepare first Beacon of Discovery */
 597:ServerLLDN.c  **** 				case APP_PAN_STATE_DISC_INITIAL:
 598:ServerLLDN.c  **** 				{
 599:ServerLLDN.c  **** 					/* if nodes associated is equal to expected number of associated nodes stop association proces
 600:ServerLLDN.c  **** 					 * this implementation was done as is to be used in tests, for real network functionality 
 601:ServerLLDN.c  **** 					 * the number of max association processes must be done through macLLDNdiscoveryModeTimeout
 602:ServerLLDN.c  **** 					 */
 603:ServerLLDN.c  **** 					if(counter_associados == NODOS_ASSOCIADOS_ESPERADOS || cycles_counter >= 2)
 604:ServerLLDN.c  **** 					{	
 605:ServerLLDN.c  **** 						printf("\n%d, %d", cycles_counter, counter_associados);
 606:ServerLLDN.c  **** 						counter_associados = 0;
 607:ServerLLDN.c  **** 						/* if all nodes expected where associated stop beacon generation interruptions */
 608:ServerLLDN.c  **** 						// macsc_disable_cmp_int(MACSC_CC1);
 609:ServerLLDN.c  **** 						macsc_disable_cmp_int(MACSC_CC2);
 610:ServerLLDN.c  **** 						msgReq.options = 0;
 611:ServerLLDN.c  **** 						/* set coordinator node to idle further implementation of online state must be done */
 612:ServerLLDN.c  **** 						appState = APP_STATE_IDLE;
 613:ServerLLDN.c  **** 						appPanState = APP_PAN_STATE_ONLINE_INITIAL; // APP_PAN_STATE_ONLINE_INIT
 614:ServerLLDN.c  **** 						
 615:ServerLLDN.c  **** 					}
 616:ServerLLDN.c  **** 					/* if not all nodes expected where associated run through association process again */
 617:ServerLLDN.c  **** 					else 
 618:ServerLLDN.c  **** 					{
 619:ServerLLDN.c  **** 						/* prepare beacon message and start timers for beacon */
 620:ServerLLDN.c  **** 						appPanDiscInit();
 621:ServerLLDN.c  **** 						appState	= APP_STATE_IDLE;
 622:ServerLLDN.c  **** 						appPanState = APP_PAN_STATE_DISC_SECOND_BE;
 623:ServerLLDN.c  **** 					}
 624:ServerLLDN.c  **** 					break;
 625:ServerLLDN.c  **** 				}
 626:ServerLLDN.c  **** 				case APP_PAN_STATE_DISC_SECOND_BE:
 627:ServerLLDN.c  **** 				{
 628:ServerLLDN.c  **** 					/* Prepares message as: Discovery Beacon and Second Beacon */
 629:ServerLLDN.c  **** 					msgReq.options = NWK_OPT_LLDN_BEACON | NWK_OPT_DISCOVERY_STATE | NWK_OPT_SECOND_BEACON ;
 630:ServerLLDN.c  **** 					msgReq.data = NULL;
 631:ServerLLDN.c  **** 					msgReq.size = 0;
 632:ServerLLDN.c  **** 					
 633:ServerLLDN.c  **** 					appState	= APP_PAN_STATE_DISC_PREPARE_ACK;
 634:ServerLLDN.c  **** 					appPanState = APP_PAN_STATE_DISC_PREPARE_ACK;
 635:ServerLLDN.c  **** 					break;
 636:ServerLLDN.c  **** 				}
 637:ServerLLDN.c  **** 				case APP_PAN_STATE_DISC_PREPARE_ACK:
 638:ServerLLDN.c  **** 				{
 639:ServerLLDN.c  **** 					/* This timer implements a delay between messages, 
 640:ServerLLDN.c  **** 					 * if not used the nodes are not able to receive the message
 641:ServerLLDN.c  **** 					 */
 642:ServerLLDN.c  **** 					appPanPrepareACK();
 643:ServerLLDN.c  **** 					SYS_TimerStart(&tmrDelay);
 644:ServerLLDN.c  **** 					
 645:ServerLLDN.c  **** 					appPanState = APP_PAN_STATE_CONFIG_INITIAL; 
 646:ServerLLDN.c  **** 					appState = APP_STATE_IDLE;
 647:ServerLLDN.c  **** 					break;
 648:ServerLLDN.c  **** 				}
 649:ServerLLDN.c  **** 				case APP_PAN_STATE_CONFIG_INITIAL:
 650:ServerLLDN.c  **** 				{
 651:ServerLLDN.c  **** 					/* Prepares the message as: Configuration Beacon and First State Beacon */
 652:ServerLLDN.c  **** 					msgReq.options = NWK_OPT_LLDN_BEACON | NWK_OPT_CONFIG_STATE;
 653:ServerLLDN.c  **** 					msgReq.data = NULL;
 654:ServerLLDN.c  **** 					msgReq.size = 0;
 655:ServerLLDN.c  **** 					
 656:ServerLLDN.c  **** 					appState	= APP_STATE_IDLE;
 657:ServerLLDN.c  **** 					appPanState = APP_PAN_STATE_CONFIG_SECOND_BEACON;
 658:ServerLLDN.c  **** 					break;
 659:ServerLLDN.c  **** 
 660:ServerLLDN.c  **** 				}
 661:ServerLLDN.c  **** 				case APP_PAN_STATE_CONFIG_SECOND_BEACON:
 662:ServerLLDN.c  **** 				{
 663:ServerLLDN.c  **** 					/* Prepares the message as: Configuration Beacon and Second State Beacon */
 664:ServerLLDN.c  **** 					msgReq.options = NWK_OPT_LLDN_BEACON | NWK_OPT_CONFIG_STATE | NWK_OPT_SECOND_BEACON;
 665:ServerLLDN.c  **** 					msgReq.data = NULL;
 666:ServerLLDN.c  **** 					msgReq.size = 0;
 667:ServerLLDN.c  **** 					
 668:ServerLLDN.c  **** 					appState	= APP_STATE_IDLE;
 669:ServerLLDN.c  **** 					appPanState = APP_PAN_STATE_SEND_CONF_REQUEST;
 670:ServerLLDN.c  **** 					break;
 671:ServerLLDN.c  **** 				}
 672:ServerLLDN.c  **** 				case APP_PAN_STATE_SEND_CONF_REQUEST:
 673:ServerLLDN.c  **** 				{
 674:ServerLLDN.c  **** 
 675:ServerLLDN.c  **** 					if(conf_req_list != NULL)
 676:ServerLLDN.c  **** 					{
 677:ServerLLDN.c  **** 						CopyToConfigRequest();
 678:ServerLLDN.c  **** 						msgReq.options		= NWK_OPT_MAC_COMMAND;
 679:ServerLLDN.c  **** 						msgReq.data			= (uint8_t*)&config_request_frame;
 680:ServerLLDN.c  **** 						msgReq.size			= sizeof(NWK_ConfigRequest_t);
 681:ServerLLDN.c  **** 						appState	= APP_STATE_IDLE;
 682:ServerLLDN.c  **** 						appPanState = APP_PAN_STATE_SEND_CONF_REQUEST;
 683:ServerLLDN.c  **** 						
 684:ServerLLDN.c  **** 						counter_associados++;
 685:ServerLLDN.c  **** 						SYS_TimerStart(&tmrDelay);
 686:ServerLLDN.c  **** 					}
 687:ServerLLDN.c  **** 					else
 688:ServerLLDN.c  **** 					{
 689:ServerLLDN.c  **** 						appPanState = APP_PAN_STATE_CONFIG_THIRD_BEACON;
 690:ServerLLDN.c  **** 					}
 691:ServerLLDN.c  **** 					break;
 692:ServerLLDN.c  **** 				}
 693:ServerLLDN.c  **** 				case APP_PAN_STATE_CONFIG_THIRD_BEACON:
 694:ServerLLDN.c  **** 				{
 695:ServerLLDN.c  **** 					msgReq.options = NWK_OPT_LLDN_BEACON | NWK_OPT_CONFIG_STATE | NWK_OPT_THIRD_BEACON;
 696:ServerLLDN.c  **** 					msgReq.data = NULL;
 697:ServerLLDN.c  **** 					msgReq.size = 0;
 698:ServerLLDN.c  **** 					
 699:ServerLLDN.c  **** 					appState	= APP_STATE_IDLE;
 700:ServerLLDN.c  **** 					appPanState = APP_PAN_STATE_DISC_INITIAL;
 701:ServerLLDN.c  **** 					cycles_counter++;	
 702:ServerLLDN.c  **** 					
 703:ServerLLDN.c  **** 					break;
 704:ServerLLDN.c  **** 				}
 705:ServerLLDN.c  **** 				case APP_PAN_STATE_ONLINE_INITIAL:
 706:ServerLLDN.c  **** 				{
 707:ServerLLDN.c  **** 					appPanOnlineInit();
 708:ServerLLDN.c  **** 					appState = APP_STATE_SEND;
 709:ServerLLDN.c  **** 					appPanState = APP_PAN_STATE_CHECK_TS;
 710:ServerLLDN.c  **** 
 711:ServerLLDN.c  **** 					break;
 712:ServerLLDN.c  **** 				}
 713:ServerLLDN.c  **** 				case APP_PAN_STATE_CHECK_TS:
 714:ServerLLDN.c  **** 				{
 715:ServerLLDN.c  **** 					if(timeslot_counter >= assTimeSlot)
 716:ServerLLDN.c  **** 					{
 717:ServerLLDN.c  **** 						printf("\nFim de um Perodo");
 718:ServerLLDN.c  **** 						macsc_disable_cmp_int(MACSC_CC1);
 719:ServerLLDN.c  **** 						macsc_disable_cmp_int(MACSC_CC2);
 720:ServerLLDN.c  **** 						appState = APP_STATE_IDLE;
 721:ServerLLDN.c  **** 						appPanState = APP_PAN_STATE_IDLE;
 722:ServerLLDN.c  **** 					}
 723:ServerLLDN.c  **** 					else
 724:ServerLLDN.c  **** 					{
 725:ServerLLDN.c  **** 						printf("\n------- slot %d --------", timeslot_counter);
 726:ServerLLDN.c  **** 						appState = APP_STATE_IDLE;
 727:ServerLLDN.c  **** 						timeslot_counter++;
 728:ServerLLDN.c  **** 					}
 729:ServerLLDN.c  **** 					break;
 730:ServerLLDN.c  **** 				}
 731:ServerLLDN.c  **** 				case APP_PAN_STATE_ONLINE_END_BE:
 732:ServerLLDN.c  **** 				{
 733:ServerLLDN.c  **** 					if(0)
 734:ServerLLDN.c  **** 					{
 735:ServerLLDN.c  **** 						// implementar as condies para entrar no processo de associao
 736:ServerLLDN.c  **** 					}
 737:ServerLLDN.c  **** 					else
 738:ServerLLDN.c  **** 					{
 739:ServerLLDN.c  **** 						// posso calcular esse valor no onlineinit, o tTS precisa ser recalculado, o seu valor muda n
 740:ServerLLDN.c  **** 						// pode voltar pro state_online_initial porque precisa reconfigurar os timers
 741:ServerLLDN.c  **** 						// precisa revisar o macsc_enable_manual_bts()
 742:ServerLLDN.c  **** 						/*
 743:ServerLLDN.c  **** 						int idle_time =  2 * numBaseTimeSlotperMgmt * (tTS) * 5 / (SYMBOL_TIME); // 5 is the total of
 744:ServerLLDN.c  **** 						macsc_set_cmp1_int_cb(lldn_server_beacon); // esta funo pode s mandar o beacon do online, 
 745:ServerLLDN.c  **** 						macsc_enable_manual_bts();
 746:ServerLLDN.c  **** 						macsc_enable_cmp_int(MACSC_CC1);
 747:ServerLLDN.c  **** 						macsc_use_cmp(MACSC_RELATIVE_CMP, idle_time, MACSC_CC1);
 748:ServerLLDN.c  **** 						*/
 749:ServerLLDN.c  **** 					}
 750:ServerLLDN.c  **** 					break;
 751:ServerLLDN.c  **** 				}
 752:ServerLLDN.c  **** 				case APP_PAN_STATE_IDLE:
 753:ServerLLDN.c  **** 				{
 754:ServerLLDN.c  **** 					msgReq.options = 0;
 755:ServerLLDN.c  **** 					appState = APP_STATE_IDLE;
 756:ServerLLDN.c  **** 					break;
 757:ServerLLDN.c  **** 				}
 758:ServerLLDN.c  **** 			}
 759:ServerLLDN.c  **** 			break;	
 760:ServerLLDN.c  **** 		}
 761:ServerLLDN.c  **** 		#else // NODES SPECIFIC STATE MACHINE
 762:ServerLLDN.c  **** 		case APP_STATE_PREP_DISC_REPONSE:
 763:ServerLLDN.c  **** 		{
 764:ServerLLDN.c  **** 			appPrepareDiscoverResponse();
 765:ServerLLDN.c  **** 			appState = APP_STATE_IDLE;	
 766:ServerLLDN.c  **** 			break;
 767:ServerLLDN.c  **** 		}
 768:ServerLLDN.c  **** 		
 769:ServerLLDN.c  **** 		case APP_STATE_PREP_CONFIG_STATUS:
 770:ServerLLDN.c  **** 		{
 771:ServerLLDN.c  **** 			// se o nodo recebeu ack na fase do discovery prepara a mensagem de configuration status
 772:ServerLLDN.c  **** 			if(ack_received && rec_beacon->confSeqNumber == 0 && associated == 0) {
 773:ServerLLDN.c  **** 				appPrepareConfigurationStatus();
 774:ServerLLDN.c  **** 			}
 775:ServerLLDN.c  **** 			// se o nodo no recebeu desativa o timer e fica em idle
 776:ServerLLDN.c  **** 			else {
 777:ServerLLDN.c  **** 				#if MASTER_MACSC
 778:ServerLLDN.c  **** 				macsc_disable_cmp_int(MACSC_CC1);
 779:ServerLLDN.c  **** 				#else
 780:ServerLLDN.c  **** 				timer_stop();
 781:ServerLLDN.c  **** 				#endif
 782:ServerLLDN.c  **** 			}
 783:ServerLLDN.c  **** 			ack_received = 0;
 784:ServerLLDN.c  **** 			appState = APP_STATE_IDLE;
 785:ServerLLDN.c  **** 			break;
 786:ServerLLDN.c  **** 		}
 787:ServerLLDN.c  **** 		case APP_STATE_PREP_DATA_FRAME:
 788:ServerLLDN.c  **** 		{
 789:ServerLLDN.c  **** 			appPrepareDataFrame();
 790:ServerLLDN.c  **** 			appState = APP_STATE_IDLE;
 791:ServerLLDN.c  **** 		}
 792:ServerLLDN.c  **** 		#endif
 793:ServerLLDN.c  **** 		default:
 794:ServerLLDN.c  **** 		{
 795:ServerLLDN.c  **** 			break;
 1628               		.loc 6 795 0
 1629 080e 00C0      		rjmp .L50
 1630               	.L42:
 560:ServerLLDN.c  **** 	switch (appState){
 1631               		.loc 6 560 0
 1632 0810 8530      		cpi r24,5
 1633 0812 9105      		cpc r25,__zero_reg__
 1634 0814 01F0      		breq .L45
 1635 0816 0697      		sbiw r24,6
 1636 0818 01F0      		breq .L46
 1637               		.loc 6 795 0
 1638 081a 00C0      		rjmp .L50
 1639               	.L43:
 563:ServerLLDN.c  **** 			#if APP_COORDINATOR
 1640               		.loc 6 563 0
 1641 081c 0E94 0000 		call appInit
 567:ServerLLDN.c  **** 			#endif
 1642               		.loc 6 567 0
 1643 0820 81E0      		ldi r24,lo8(1)
 1644 0822 8093 0000 		sts appState,r24
 569:ServerLLDN.c  **** 		}
 1645               		.loc 6 569 0
 1646 0826 00C0      		rjmp .L47
 1647               	.L44:
 573:ServerLLDN.c  **** 			#if APP_COORDINATOR
 1648               		.loc 6 573 0
 1649 0828 0E94 0000 		call appSendData
 578:ServerLLDN.c  **** 			#endif
 1650               		.loc 6 578 0
 1651 082c 81E0      		ldi r24,lo8(1)
 1652 082e 8093 0000 		sts appState,r24
 580:ServerLLDN.c  **** 		}
 1653               		.loc 6 580 0
 1654 0832 00C0      		rjmp .L47
 1655               	.L41:
 764:ServerLLDN.c  **** 			appState = APP_STATE_IDLE;	
 1656               		.loc 6 764 0
 1657 0834 0E94 0000 		call appPrepareDiscoverResponse
 765:ServerLLDN.c  **** 			break;
 1658               		.loc 6 765 0
 1659 0838 81E0      		ldi r24,lo8(1)
 1660 083a 8093 0000 		sts appState,r24
 766:ServerLLDN.c  **** 		}
 1661               		.loc 6 766 0
 1662 083e 00C0      		rjmp .L47
 1663               	.L45:
 772:ServerLLDN.c  **** 				appPrepareConfigurationStatus();
 1664               		.loc 6 772 0
 1665 0840 8091 0000 		lds r24,ack_received
 1666 0844 8823      		tst r24
 1667 0846 01F0      		breq .L48
 772:ServerLLDN.c  **** 				appPrepareConfigurationStatus();
 1668               		.loc 6 772 0 is_stmt 0 discriminator 1
 1669 0848 8091 0000 		lds r24,rec_beacon
 1670 084c 9091 0000 		lds r25,rec_beacon+1
 1671 0850 FC01      		movw r30,r24
 1672 0852 8581      		ldd r24,Z+5
 1673 0854 8823      		tst r24
 1674 0856 01F4      		brne .L48
 772:ServerLLDN.c  **** 				appPrepareConfigurationStatus();
 1675               		.loc 6 772 0 discriminator 2
 1676 0858 9091 0000 		lds r25,associated
 1677 085c 81E0      		ldi r24,lo8(1)
 1678 085e 8927      		eor r24,r25
 1679 0860 8823      		tst r24
 1680 0862 01F0      		breq .L48
 773:ServerLLDN.c  **** 			}
 1681               		.loc 6 773 0 is_stmt 1
 1682 0864 0E94 0000 		call appPrepareConfigurationStatus
 1683 0868 00C0      		rjmp .L49
 1684               	.L48:
 778:ServerLLDN.c  **** 				#else
 1685               		.loc 6 778 0
 1686 086a 81E0      		ldi r24,lo8(1)
 1687 086c 0E94 0000 		call macsc_disable_cmp_int
 1688               	.L49:
 783:ServerLLDN.c  **** 			appState = APP_STATE_IDLE;
 1689               		.loc 6 783 0
 1690 0870 1092 0000 		sts ack_received,__zero_reg__
 784:ServerLLDN.c  **** 			break;
 1691               		.loc 6 784 0
 1692 0874 81E0      		ldi r24,lo8(1)
 1693 0876 8093 0000 		sts appState,r24
 785:ServerLLDN.c  **** 		}
 1694               		.loc 6 785 0
 1695 087a 00C0      		rjmp .L47
 1696               	.L46:
 789:ServerLLDN.c  **** 			appState = APP_STATE_IDLE;
 1697               		.loc 6 789 0
 1698 087c 0E94 0000 		call appPrepareDataFrame
 790:ServerLLDN.c  **** 		}
 1699               		.loc 6 790 0
 1700 0880 81E0      		ldi r24,lo8(1)
 1701 0882 8093 0000 		sts appState,r24
 1702               	.L50:
 1703               		.loc 6 795 0
 1704 0886 0000      		nop
 1705               	.L47:
 796:ServerLLDN.c  **** 		}
 797:ServerLLDN.c  **** 	}
 798:ServerLLDN.c  **** }
 1706               		.loc 6 798 0
 1707 0888 0000      		nop
 1708               	/* epilogue start */
 1709 088a DF91      		pop r29
 1710 088c CF91      		pop r28
 1711 088e 0895      		ret
 1712               		.cfi_endproc
 1713               	.LFE140:
 1715               		.section	.rodata
 1716               	.LC0:
 1717 005e 00        		.byte	0
 1718 005f C2        		.byte	-62
 1719 0060 01        		.byte	1
 1720 0061 00        		.byte	0
 1721 0062 03        		.byte	3
 1722 0063 00        		.byte	0
 1723 0064 00        		.byte	0
 1724               		.text
 1725               	.global	main
 1727               	main:
 1728               	.LFB141:
 799:ServerLLDN.c  **** 
 800:ServerLLDN.c  **** 	/*****************************************************************************
 801:ServerLLDN.c  **** 	*****************************************************************************/
 802:ServerLLDN.c  **** 	int main(void)
 803:ServerLLDN.c  **** 	{
 1729               		.loc 6 803 0
 1730               		.cfi_startproc
 1731 0890 0F93      		push r16
 1732               	.LCFI66:
 1733               		.cfi_def_cfa_offset 3
 1734               		.cfi_offset 16, -2
 1735 0892 1F93      		push r17
 1736               	.LCFI67:
 1737               		.cfi_def_cfa_offset 4
 1738               		.cfi_offset 17, -3
 1739 0894 CF93      		push r28
 1740               	.LCFI68:
 1741               		.cfi_def_cfa_offset 5
 1742               		.cfi_offset 28, -4
 1743 0896 DF93      		push r29
 1744               	.LCFI69:
 1745               		.cfi_def_cfa_offset 6
 1746               		.cfi_offset 29, -5
 1747 0898 CDB7      		in r28,__SP_L__
 1748 089a DEB7      		in r29,__SP_H__
 1749               	.LCFI70:
 1750               		.cfi_def_cfa_register 28
 1751 089c 2797      		sbiw r28,7
 1752               	.LCFI71:
 1753               		.cfi_def_cfa_offset 13
 1754 089e 0FB6      		in __tmp_reg__,__SREG__
 1755 08a0 F894      		cli
 1756 08a2 DEBF      		out __SP_H__,r29
 1757 08a4 0FBE      		out __SREG__,__tmp_reg__
 1758 08a6 CDBF      		out __SP_L__,r28
 1759               	/* prologue: function */
 1760               	/* frame size = 7 */
 1761               	/* stack size = 11 */
 1762               	.L__stack_usage = 11
 804:ServerLLDN.c  **** 		sysclk_init();
 1763               		.loc 6 804 0
 1764 08a8 0E94 0000 		call sysclk_init
 805:ServerLLDN.c  **** 		board_init();
 1765               		.loc 6 805 0
 1766 08ac 0E94 0000 		call board_init
 806:ServerLLDN.c  **** 
 807:ServerLLDN.c  **** 		SYS_Init();
 1767               		.loc 6 807 0
 1768 08b0 0E94 0000 		call SYS_Init
 808:ServerLLDN.c  **** 		/* Disable CSMA/CA
 809:ServerLLDN.c  **** 		 * Disable auto ACK
 810:ServerLLDN.c  **** 		 * Enable Rx of LLDN Frame Type as described in 802.15.4e - 2012 
 811:ServerLLDN.c  **** 		 */
 812:ServerLLDN.c  **** 
 813:ServerLLDN.c  **** 		sm_init();
 1769               		.loc 6 813 0
 1770 08b4 0E94 0000 		call sm_init
 814:ServerLLDN.c  **** 
 815:ServerLLDN.c  **** 		// Initialize interrupt vector table support.
 816:ServerLLDN.c  **** 	#if (SIO2HOST_CHANNEL == SIO_USB)
 817:ServerLLDN.c  **** 		irq_initialize_vectors();
 818:ServerLLDN.c  **** 	#endif
 819:ServerLLDN.c  **** 		cpu_irq_enable();
 1771               		.loc 6 819 0
 1772               	/* #APP */
 1773               	 ;  819 "ServerLLDN.c" 1
 1774 08b8 7894      		sei
 1775               	 ;  0 "" 2
 820:ServerLLDN.c  **** 
 821:ServerLLDN.c  **** 	#if 1
 822:ServerLLDN.c  **** 	#if (SIO2HOST_CHANNEL == SIO_USB)
 823:ServerLLDN.c  **** 		stdio_usb_init();
 824:ServerLLDN.c  **** 	#else
 825:ServerLLDN.c  **** 		const usart_serial_options_t usart_serial_options =
 1776               		.loc 6 825 0
 1777               	/* #NOAPP */
 1778 08ba 27E0      		ldi r18,lo8(7)
 1779 08bc E0E0      		ldi r30,lo8(.LC0)
 1780 08be F0E0      		ldi r31,hi8(.LC0)
 1781 08c0 CE01      		movw r24,r28
 1782 08c2 0196      		adiw r24,1
 1783 08c4 DC01      		movw r26,r24
 1784               		0:
 1785 08c6 0190      		ld r0,Z+
 1786 08c8 0D92      		st X+,r0
 1787 08ca 2A95      		dec r18
 1788 08cc 01F4      		brne 0b
 826:ServerLLDN.c  **** 		{
 827:ServerLLDN.c  **** 			.baudrate     = USART_HOST_BAUDRATE,
 828:ServerLLDN.c  **** 			.charlength   = USART_HOST_CHAR_LENGTH,
 829:ServerLLDN.c  **** 			.paritytype   = USART_HOST_PARITY,
 830:ServerLLDN.c  **** 			.stopbits     = USART_HOST_STOP_BITS
 831:ServerLLDN.c  **** 		};
 832:ServerLLDN.c  **** 
 833:ServerLLDN.c  **** 		stdio_serial_init(USART_HOST, &usart_serial_options);
 1789               		.loc 6 833 0
 1790 08ce CE01      		movw r24,r28
 1791 08d0 0196      		adiw r24,1
 1792 08d2 BC01      		movw r22,r24
 1793 08d4 80EC      		ldi r24,lo8(-64)
 1794 08d6 90E0      		ldi r25,0
 1795 08d8 0E94 0000 		call stdio_serial_init
 834:ServerLLDN.c  **** 		usart_double_baud_enable(USART_HOST);
 1796               		.loc 6 834 0
 1797 08dc 80EC      		ldi r24,lo8(-64)
 1798 08de 90E0      		ldi r25,0
 1799 08e0 0E94 0000 		call usart_double_baud_enable
 835:ServerLLDN.c  **** 		usart_set_baudrate_precalculated(USART_HOST, USART_HOST_BAUDRATE, sysclk_get_source_clock_hz());
 1800               		.loc 6 835 0
 1801 08e4 0E94 0000 		call sysclk_get_source_clock_hz
 1802 08e8 DC01      		movw r26,r24
 1803 08ea CB01      		movw r24,r22
 1804 08ec 8C01      		movw r16,r24
 1805 08ee 9D01      		movw r18,r26
 1806 08f0 40E0      		ldi r20,0
 1807 08f2 52EC      		ldi r21,lo8(-62)
 1808 08f4 61E0      		ldi r22,lo8(1)
 1809 08f6 70E0      		ldi r23,0
 1810 08f8 80EC      		ldi r24,lo8(-64)
 1811 08fa 90E0      		ldi r25,0
 1812 08fc 0E94 0000 		call usart_set_baudrate_precalculated
 1813               	.L52:
 836:ServerLLDN.c  **** 
 837:ServerLLDN.c  **** 	#endif
 838:ServerLLDN.c  **** 	#endif
 839:ServerLLDN.c  **** 		for(;;)
 840:ServerLLDN.c  **** 		{
 841:ServerLLDN.c  **** 			SYS_TaskHandler();
 1814               		.loc 6 841 0 discriminator 1
 1815 0900 0E94 0000 		call SYS_TaskHandler
 842:ServerLLDN.c  **** 			APP_TaskHandler();
 1816               		.loc 6 842 0 discriminator 1
 1817 0904 0E94 0000 		call APP_TaskHandler
 843:ServerLLDN.c  **** 		}
 1818               		.loc 6 843 0 discriminator 1
 1819 0908 00C0      		rjmp .L52
 1820               		.cfi_endproc
 1821               	.LFE141:
 1823               	.Letext0:
 1824               		.file 7 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\in
 1825               		.file 8 "../../../stack/LwMesh/TDMA/nwk/inc/nwkFrame.h"
 1826               		.file 9 "../../../stack/LwMesh/TDMA/nwk/inc/nwkRx.h"
 1827               		.file 10 "../../../stack/LwMesh/TDMA/nwk/inc/nwkDataReq.h"
 1828               		.file 11 "lldn.h"
 1829               		.file 12 "../../../platform/mega_rf/drivers/sleep/sleep.h"
 1830               		.file 13 "../../../platform/mega_rf/utils/status_codes.h"
 1831               		.file 14 "config/config.h"
 1832               		.file 15 "../../../platform/common/services/sleepmgr/mega_rf/sleepmgr.h"
DEFINED SYMBOLS
                            *ABS*:00000000 ServerLLDN.c
C:\Users\GUILHE~1\AppData\Local\Temp\ccswYePf.s:2      *ABS*:0000003e __SP_H__
C:\Users\GUILHE~1\AppData\Local\Temp\ccswYePf.s:3      *ABS*:0000003d __SP_L__
C:\Users\GUILHE~1\AppData\Local\Temp\ccswYePf.s:4      *ABS*:0000003f __SREG__
C:\Users\GUILHE~1\AppData\Local\Temp\ccswYePf.s:5      *ABS*:0000003b __RAMPZ__
C:\Users\GUILHE~1\AppData\Local\Temp\ccswYePf.s:6      *ABS*:00000000 __tmp_reg__
C:\Users\GUILHE~1\AppData\Local\Temp\ccswYePf.s:7      *ABS*:00000001 __zero_reg__
C:\Users\GUILHE~1\AppData\Local\Temp\ccswYePf.s:15     .bss.n:00000000 n
                            *COM*:00000004 tTS
C:\Users\GUILHE~1\AppData\Local\Temp\ccswYePf.s:20     .text:00000000 sysclk_get_main_hz
C:\Users\GUILHE~1\AppData\Local\Temp\ccswYePf.s:57     .text:0000001a sysclk_get_source_clock_hz
C:\Users\GUILHE~1\AppData\Local\Temp\ccswYePf.s:94     .progmem.data.baudctrl_1mhz:00000000 baudctrl_1mhz
C:\Users\GUILHE~1\AppData\Local\Temp\ccswYePf.s:106    .progmem.data.baudctrl_8mhz:00000000 baudctrl_8mhz
C:\Users\GUILHE~1\AppData\Local\Temp\ccswYePf.s:118    .progmem.data.baudctrl_16mhz:00000000 baudctrl_16mhz
C:\Users\GUILHE~1\AppData\Local\Temp\ccswYePf.s:129    .text:00000034 usart_double_baud_enable
C:\Users\GUILHE~1\AppData\Local\Temp\ccswYePf.s:178    .text:00000062 usart_serial_init
C:\Users\GUILHE~1\AppData\Local\Temp\ccswYePf.s:273    .text:000000de usart_serial_putchar
C:\Users\GUILHE~1\AppData\Local\Temp\ccswYePf.s:317    .text:00000106 usart_serial_getchar
C:\Users\GUILHE~1\AppData\Local\Temp\ccswYePf.s:368    .text:0000013c stdio_serial_init
C:\Users\GUILHE~1\AppData\Local\Temp\ccswYePf.s:439    .text:0000019e macsc_enable_manual_bts
C:\Users\GUILHE~1\AppData\Local\Temp\ccswYePf.s:493    .bss.appState:00000000 appState
C:\Users\GUILHE~1\AppData\Local\Temp\ccswYePf.s:498    .bss.msgReq:00000000 msgReq
C:\Users\GUILHE~1\AppData\Local\Temp\ccswYePf.s:503    .bss.PanId:00000000 PanId
C:\Users\GUILHE~1\AppData\Local\Temp\ccswYePf.s:511    .text:000001d2 appSendData
C:\Users\GUILHE~1\AppData\Local\Temp\ccswYePf.s:573    .data.payloadSize:00000000 payloadSize
C:\Users\GUILHE~1\AppData\Local\Temp\ccswYePf.s:579    .data.assTimeSlot:00000000 assTimeSlot
C:\Users\GUILHE~1\AppData\Local\Temp\ccswYePf.s:584    .bss.rec_beacon:00000000 rec_beacon
C:\Users\GUILHE~1\AppData\Local\Temp\ccswYePf.s:589    .data.msgDiscResponse:00000000 msgDiscResponse
C:\Users\GUILHE~1\AppData\Local\Temp\ccswYePf.s:596    .data.msgConfigStatus:00000000 msgConfigStatus
C:\Users\GUILHE~1\AppData\Local\Temp\ccswYePf.s:606    .data.data_payload:00000000 data_payload
C:\Users\GUILHE~1\AppData\Local\Temp\ccswYePf.s:611    .bss.ack_received:00000000 ack_received
C:\Users\GUILHE~1\AppData\Local\Temp\ccswYePf.s:617    .bss.MacLLDNMgmtTS:00000000 MacLLDNMgmtTS
C:\Users\GUILHE~1\AppData\Local\Temp\ccswYePf.s:623    .bss.associated:00000000 associated
C:\Users\GUILHE~1\AppData\Local\Temp\ccswYePf.s:630    .text:0000021e send_message_timeHandler
C:\Users\GUILHE~1\AppData\Local\Temp\ccswYePf.s:674    .text:0000024a start_timer
C:\Users\GUILHE~1\AppData\Local\Temp\ccswYePf.s:744    .text:00000292 appBeaconInd
C:\Users\GUILHE~1\AppData\Local\Temp\ccswYePf.s:1136   .text:00000584 appAckInd
C:\Users\GUILHE~1\AppData\Local\Temp\ccswYePf.s:1252   .text:00000620 appCommandInd
C:\Users\GUILHE~1\AppData\Local\Temp\ccswYePf.s:1369   .text:000006ca appPrepareDiscoverResponse
C:\Users\GUILHE~1\AppData\Local\Temp\ccswYePf.s:1422   .text:0000070c appPrepareConfigurationStatus
C:\Users\GUILHE~1\AppData\Local\Temp\ccswYePf.s:1475   .text:0000074e appPrepareDataFrame
C:\Users\GUILHE~1\AppData\Local\Temp\ccswYePf.s:1530   .text:00000796 appInit
C:\Users\GUILHE~1\AppData\Local\Temp\ccswYePf.s:1594   .text:000007ea APP_TaskHandler
C:\Users\GUILHE~1\AppData\Local\Temp\ccswYePf.s:1727   .text:00000890 main

UNDEFINED SYMBOLS
usart_init_rs232
usart_putchar
usart_getchar
stdio_base
ptr_put
ptr_get
_read
_write
fdevopen
printf
NWK_DataReq
macsc_set_cmp1_int_cb
macsc_enable_cmp_int
macsc_use_cmp
__floatsisf
__addsf3
__divsf3
__fixsfsi
PHY_SetChannel
NWK_SetPanId
PHY_SetTdmaMode
NWK_SetAddr
PHY_SetRxState
NWK_OpenEndpoint
PHY_SetPromiscuousMode
macsc_disable_cmp_int
sysclk_init
board_init
SYS_Init
sm_init
usart_set_baudrate_precalculated
SYS_TaskHandler
__do_copy_data
__do_clear_bss
