   1               		.file	"ServerLLDN.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__RAMPZ__ = 0x3b
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.text
   9               	.Ltext0:
  10               		.cfi_sections	.debug_frame
  11               	.global	n
  12               		.section	.bss.n,"aw",@nobits
  15               	n:
  16 0000 00        		.zero	1
  17               		.comm	tTS,4,1
  18               		.comm	macLLDNnumTimeSlots,2,1
  19               		.comm	macLLDNnumUplinkTS,2,1
  20               		.comm	macLLDNRetransmitTS,2,1
  21               		.text
  23               	sysclk_get_main_hz:
  24               	.LFB67:
  25               		.file 1 "../../../platform/common/services/clock/mega/sysclk.h"
   1:../../../platform/common/services/clock/mega/sysclk.h **** /**
   2:../../../platform/common/services/clock/mega/sysclk.h ****  * \file
   3:../../../platform/common/services/clock/mega/sysclk.h ****  *
   4:../../../platform/common/services/clock/mega/sysclk.h ****  * \brief Chip-specific system clock management functions
   5:../../../platform/common/services/clock/mega/sysclk.h ****  *
   6:../../../platform/common/services/clock/mega/sysclk.h ****  * Copyright (c) 2012 Atmel Corporation. All rights reserved.
   7:../../../platform/common/services/clock/mega/sysclk.h ****  *
   8:../../../platform/common/services/clock/mega/sysclk.h ****  * \asf_license_start
   9:../../../platform/common/services/clock/mega/sysclk.h ****  *
  10:../../../platform/common/services/clock/mega/sysclk.h ****  * \page License
  11:../../../platform/common/services/clock/mega/sysclk.h ****  *
  12:../../../platform/common/services/clock/mega/sysclk.h ****  * Redistribution and use in source and binary forms, with or without
  13:../../../platform/common/services/clock/mega/sysclk.h ****  * modification, are permitted provided that the following conditions are met:
  14:../../../platform/common/services/clock/mega/sysclk.h ****  *
  15:../../../platform/common/services/clock/mega/sysclk.h ****  * 1. Redistributions of source code must retain the above copyright notice,
  16:../../../platform/common/services/clock/mega/sysclk.h ****  *    this list of conditions and the following disclaimer.
  17:../../../platform/common/services/clock/mega/sysclk.h ****  *
  18:../../../platform/common/services/clock/mega/sysclk.h ****  * 2. Redistributions in binary form must reproduce the above copyright notice,
  19:../../../platform/common/services/clock/mega/sysclk.h ****  *    this list of conditions and the following disclaimer in the documentation
  20:../../../platform/common/services/clock/mega/sysclk.h ****  *    and/or other materials provided with the distribution.
  21:../../../platform/common/services/clock/mega/sysclk.h ****  *
  22:../../../platform/common/services/clock/mega/sysclk.h ****  * 3. The name of Atmel may not be used to endorse or promote products derived
  23:../../../platform/common/services/clock/mega/sysclk.h ****  *    from this software without specific prior written permission.
  24:../../../platform/common/services/clock/mega/sysclk.h ****  *
  25:../../../platform/common/services/clock/mega/sysclk.h ****  * 4. This software may only be redistributed and used in connection with an
  26:../../../platform/common/services/clock/mega/sysclk.h ****  *    Atmel microcontroller product.
  27:../../../platform/common/services/clock/mega/sysclk.h ****  *
  28:../../../platform/common/services/clock/mega/sysclk.h ****  * THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR IMPLIED
  29:../../../platform/common/services/clock/mega/sysclk.h ****  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
  30:../../../platform/common/services/clock/mega/sysclk.h ****  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
  31:../../../platform/common/services/clock/mega/sysclk.h ****  * EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR
  32:../../../platform/common/services/clock/mega/sysclk.h ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  33:../../../platform/common/services/clock/mega/sysclk.h ****  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
  34:../../../platform/common/services/clock/mega/sysclk.h ****  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  35:../../../platform/common/services/clock/mega/sysclk.h ****  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
  36:../../../platform/common/services/clock/mega/sysclk.h ****  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  37:../../../platform/common/services/clock/mega/sysclk.h ****  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  38:../../../platform/common/services/clock/mega/sysclk.h ****  * POSSIBILITY OF SUCH DAMAGE.
  39:../../../platform/common/services/clock/mega/sysclk.h ****  *
  40:../../../platform/common/services/clock/mega/sysclk.h ****  * \asf_license_stop
  41:../../../platform/common/services/clock/mega/sysclk.h ****  *
  42:../../../platform/common/services/clock/mega/sysclk.h ****  */
  43:../../../platform/common/services/clock/mega/sysclk.h **** #ifndef MEGA_SYSCLK_H_INCLUDED
  44:../../../platform/common/services/clock/mega/sysclk.h **** #define MEGA_SYSCLK_H_INCLUDED
  45:../../../platform/common/services/clock/mega/sysclk.h **** 
  46:../../../platform/common/services/clock/mega/sysclk.h **** #include <board.h>
  47:../../../platform/common/services/clock/mega/sysclk.h **** #include <compiler.h>
  48:../../../platform/common/services/clock/mega/sysclk.h **** #include <parts.h>
  49:../../../platform/common/services/clock/mega/sysclk.h **** 
  50:../../../platform/common/services/clock/mega/sysclk.h **** /* Include clock configuration for the project. */
  51:../../../platform/common/services/clock/mega/sysclk.h **** #include <conf_clock.h>
  52:../../../platform/common/services/clock/mega/sysclk.h **** 
  53:../../../platform/common/services/clock/mega/sysclk.h **** #ifdef __cplusplus
  54:../../../platform/common/services/clock/mega/sysclk.h **** extern "C" {
  55:../../../platform/common/services/clock/mega/sysclk.h **** #endif
  56:../../../platform/common/services/clock/mega/sysclk.h **** #define ASM __asm__
  57:../../../platform/common/services/clock/mega/sysclk.h **** 
  58:../../../platform/common/services/clock/mega/sysclk.h **** /* CONFIG_SYSCLK_PSDIV  to use default if not defined*/
  59:../../../platform/common/services/clock/mega/sysclk.h **** #ifndef CONFIG_SYSCLK_PSDIV
  60:../../../platform/common/services/clock/mega/sysclk.h **** # define CONFIG_SYSCLK_PSDIV    SYSCLK_PSDIV_8
  61:../../../platform/common/services/clock/mega/sysclk.h **** #endif
  62:../../../platform/common/services/clock/mega/sysclk.h **** 
  63:../../../platform/common/services/clock/mega/sysclk.h **** /* ! \name Prescaler Setting (relative to CLKsys) */
  64:../../../platform/common/services/clock/mega/sysclk.h **** /* @{ */
  65:../../../platform/common/services/clock/mega/sysclk.h **** #define SYSCLK_PSDIV_1      0   /* !< Do not prescale */
  66:../../../platform/common/services/clock/mega/sysclk.h **** #define SYSCLK_PSDIV_2      1   /* !< Prescale CLKper4 by 2 */
  67:../../../platform/common/services/clock/mega/sysclk.h **** #define SYSCLK_PSDIV_4      2   /* !< Prescale CLKper4 by 4 */
  68:../../../platform/common/services/clock/mega/sysclk.h **** #define SYSCLK_PSDIV_8      3   /* !< Prescale CLKper4 by 8 */
  69:../../../platform/common/services/clock/mega/sysclk.h **** #define SYSCLK_PSDIV_16     4   /* !< Prescale CLKper4 by 16 */
  70:../../../platform/common/services/clock/mega/sysclk.h **** #define SYSCLK_PSDIV_32     5   /* !< Prescale CLKper4 by 32 */
  71:../../../platform/common/services/clock/mega/sysclk.h **** #define SYSCLK_PSDIV_64     6   /* !< Prescale CLKper4 by 64 */
  72:../../../platform/common/services/clock/mega/sysclk.h **** #define SYSCLK_PSDIV_128    7   /* !< Prescale CLKper4 by 128 */
  73:../../../platform/common/services/clock/mega/sysclk.h **** #define SYSCLK_PSDIV_256    8   /* !< Prescale CLKper4 by 256 */
  74:../../../platform/common/services/clock/mega/sysclk.h **** 
  75:../../../platform/common/services/clock/mega/sysclk.h **** /* @} */
  76:../../../platform/common/services/clock/mega/sysclk.h **** 
  77:../../../platform/common/services/clock/mega/sysclk.h **** #if MEGA_RF || MEGA_XX0_1 || MEGA_XX4 || MEGA_XX4_A
  78:../../../platform/common/services/clock/mega/sysclk.h **** 
  79:../../../platform/common/services/clock/mega/sysclk.h **** #define NUMBER_OF_POWER_REG       2
  80:../../../platform/common/services/clock/mega/sysclk.h **** /*Starting Address for power reduction*/
  81:../../../platform/common/services/clock/mega/sysclk.h **** #define POWER_REG_ADD             PRR0
  82:../../../platform/common/services/clock/mega/sysclk.h **** 
  83:../../../platform/common/services/clock/mega/sysclk.h **** /* ! \name Power Reduction  Clock Port Numbers */
  84:../../../platform/common/services/clock/mega/sysclk.h **** enum power_red_id {
  85:../../../platform/common/services/clock/mega/sysclk.h **** 	POWER_RED_REG0,     /* !< Devices on PRR0 */
  86:../../../platform/common/services/clock/mega/sysclk.h **** #if !MEGA_XX4 || !MEGA_XX4_A || MEGA_XX0_1
  87:../../../platform/common/services/clock/mega/sysclk.h **** 	POWER_RED_REG1,     /* !< Devices on PRR1 */
  88:../../../platform/common/services/clock/mega/sysclk.h **** #endif
  89:../../../platform/common/services/clock/mega/sysclk.h **** };
  90:../../../platform/common/services/clock/mega/sysclk.h **** #endif
  91:../../../platform/common/services/clock/mega/sysclk.h **** 
  92:../../../platform/common/services/clock/mega/sysclk.h **** /****************************************************
  93:../../../platform/common/services/clock/mega/sysclk.h ****  * Given a dummy type but not used for these groups
  94:../../../platform/common/services/clock/mega/sysclk.h ****  * to support for otherthen megaRF device.
  95:../../../platform/common/services/clock/mega/sysclk.h ****  **************************************************/
  96:../../../platform/common/services/clock/mega/sysclk.h **** #if MEGA_XX8 || MEGA_XX8_A || MEGA_UNSPECIFIED
  97:../../../platform/common/services/clock/mega/sysclk.h **** #define NUMBER_OF_POWER_REG       1
  98:../../../platform/common/services/clock/mega/sysclk.h **** /*Starting Address for power reduction*/
  99:../../../platform/common/services/clock/mega/sysclk.h **** #define POWER_REG_ADD             PRR
 100:../../../platform/common/services/clock/mega/sysclk.h **** 
 101:../../../platform/common/services/clock/mega/sysclk.h **** /* ! \name Power Reduction  Clock Port Numbers */
 102:../../../platform/common/services/clock/mega/sysclk.h **** enum power_red_id {
 103:../../../platform/common/services/clock/mega/sysclk.h **** 	POWER_RED_REG0,     /* !< Devices on PRR */
 104:../../../platform/common/services/clock/mega/sysclk.h **** };
 105:../../../platform/common/services/clock/mega/sysclk.h **** #endif
 106:../../../platform/common/services/clock/mega/sysclk.h **** 
 107:../../../platform/common/services/clock/mega/sysclk.h **** /* Bit mask for the power reduction register based on */
 108:../../../platform/common/services/clock/mega/sysclk.h **** /*   MCU ARCH.                                        */
 109:../../../platform/common/services/clock/mega/sysclk.h **** #if MEGA_RF
 110:../../../platform/common/services/clock/mega/sysclk.h **** /*Bit mask for PRR2 */
 111:../../../platform/common/services/clock/mega/sysclk.h **** 
 112:../../../platform/common/services/clock/mega/sysclk.h **** #define PRRAM0_bm                       1 << PRRAM0
 113:../../../platform/common/services/clock/mega/sysclk.h **** #define PRRAM1_bm                       1 << PRRAM1
 114:../../../platform/common/services/clock/mega/sysclk.h **** #define PRRAM2_bm                       1 << PRRAM2
 115:../../../platform/common/services/clock/mega/sysclk.h **** #define PRRAM3_bm                       1 << PRRAM3
 116:../../../platform/common/services/clock/mega/sysclk.h **** #endif
 117:../../../platform/common/services/clock/mega/sysclk.h **** 
 118:../../../platform/common/services/clock/mega/sysclk.h **** /*Bit mask for the power reduction 0 or PRR*/
 119:../../../platform/common/services/clock/mega/sysclk.h **** #if !MEGA_XX_UN0 && !MEGA_XX_UN0
 120:../../../platform/common/services/clock/mega/sysclk.h **** #define PRADC_bm                        1 << PRADC
 121:../../../platform/common/services/clock/mega/sysclk.h **** #define PRUSART0_bm                     1 << PRUSART0
 122:../../../platform/common/services/clock/mega/sysclk.h **** #define PRSPI_bm                        1 << PRSPI
 123:../../../platform/common/services/clock/mega/sysclk.h **** #define PRTIM1_bm                       1 << PRTIM1
 124:../../../platform/common/services/clock/mega/sysclk.h **** #endif
 125:../../../platform/common/services/clock/mega/sysclk.h **** 
 126:../../../platform/common/services/clock/mega/sysclk.h **** #if MEGA_RF
 127:../../../platform/common/services/clock/mega/sysclk.h **** #define PRPGA_bm                        1 << PRPGA
 128:../../../platform/common/services/clock/mega/sysclk.h **** #endif
 129:../../../platform/common/services/clock/mega/sysclk.h **** 
 130:../../../platform/common/services/clock/mega/sysclk.h **** #if !MEGA_UNSPECIFIED
 131:../../../platform/common/services/clock/mega/sysclk.h **** #define PRTIM0_bm                       1 << PRTIM0
 132:../../../platform/common/services/clock/mega/sysclk.h **** #define PRTIM2_bm                       1 << PRTIM2
 133:../../../platform/common/services/clock/mega/sysclk.h **** #define PRTWI_bm                        1 << PRTWI
 134:../../../platform/common/services/clock/mega/sysclk.h **** #endif
 135:../../../platform/common/services/clock/mega/sysclk.h **** 
 136:../../../platform/common/services/clock/mega/sysclk.h **** #if MEGA_XX_UN2
 137:../../../platform/common/services/clock/mega/sysclk.h **** #define PRLCD_bm                        1 << PRLCD
 138:../../../platform/common/services/clock/mega/sysclk.h **** #endif
 139:../../../platform/common/services/clock/mega/sysclk.h **** 
 140:../../../platform/common/services/clock/mega/sysclk.h **** /*Bit mask for  PRR1  */
 141:../../../platform/common/services/clock/mega/sysclk.h **** #ifdef PRR1
 142:../../../platform/common/services/clock/mega/sysclk.h **** #if (MEGA_XX4 || MEGA_XX4_A)
 143:../../../platform/common/services/clock/mega/sysclk.h **** #define PRTIM3_bm                       1 << PRTIM3
 144:../../../platform/common/services/clock/mega/sysclk.h **** #endif
 145:../../../platform/common/services/clock/mega/sysclk.h **** #endif
 146:../../../platform/common/services/clock/mega/sysclk.h **** 
 147:../../../platform/common/services/clock/mega/sysclk.h **** #if MEGA_RF || MEGA_XX4 || MEGA_XX4_A
 148:../../../platform/common/services/clock/mega/sysclk.h **** #define PRUSART1_bm                     1 << PRUSART1
 149:../../../platform/common/services/clock/mega/sysclk.h **** #define PRUSART2_bm                     1 << PRUSART2
 150:../../../platform/common/services/clock/mega/sysclk.h **** #define PRUSART3_bm                     1 << PRUSART3
 151:../../../platform/common/services/clock/mega/sysclk.h **** #define PRTIM3_bm                       1 << PRTIM3
 152:../../../platform/common/services/clock/mega/sysclk.h **** #define PRTIM4_bm                       1 << PRTIM4
 153:../../../platform/common/services/clock/mega/sysclk.h **** #define PRTIM5_bm                       1 << PRTIM5
 154:../../../platform/common/services/clock/mega/sysclk.h **** #endif
 155:../../../platform/common/services/clock/mega/sysclk.h **** 
 156:../../../platform/common/services/clock/mega/sysclk.h **** #if MEGA_RF
 157:../../../platform/common/services/clock/mega/sysclk.h **** #define PRTRX24_bm                      1 << PRTRX24
 158:../../../platform/common/services/clock/mega/sysclk.h **** #endif
 159:../../../platform/common/services/clock/mega/sysclk.h **** 
 160:../../../platform/common/services/clock/mega/sysclk.h **** /**
 161:../../../platform/common/services/clock/mega/sysclk.h ****  * \name Querying the system clock and its derived clocks
 162:../../../platform/common/services/clock/mega/sysclk.h ****  */
 163:../../../platform/common/services/clock/mega/sysclk.h **** /* @{ */
 164:../../../platform/common/services/clock/mega/sysclk.h **** 
 165:../../../platform/common/services/clock/mega/sysclk.h **** /**
 166:../../../platform/common/services/clock/mega/sysclk.h ****  * \brief Return the current rate in Hz of the main system clock
 167:../../../platform/common/services/clock/mega/sysclk.h ****  * To know the clock value at what frequency the main clock is running
 168:../../../platform/common/services/clock/mega/sysclk.h ****  * \return Frequency of the main system clock, in Hz.
 169:../../../platform/common/services/clock/mega/sysclk.h ****  * \todo : please initialize the SYSCLK_SOURCE in conf_clock.h file for
 170:../../../platform/common/services/clock/mega/sysclk.h ****  * configured source clock using fuses.
 171:../../../platform/common/services/clock/mega/sysclk.h ****  * \eg. #define SYSCLK_SOURCE SYSCLK_SRC_RC16MHZ to use internal RC
 172:../../../platform/common/services/clock/mega/sysclk.h ****  * oscillator for clock source.
 173:../../../platform/common/services/clock/mega/sysclk.h ****  */
 174:../../../platform/common/services/clock/mega/sysclk.h **** static inline uint32_t sysclk_get_main_hz(void)
 175:../../../platform/common/services/clock/mega/sysclk.h **** {
  26               		.loc 1 175 0
  27               		.cfi_startproc
  28 0000 CF93      		push r28
  29               	.LCFI0:
  30               		.cfi_def_cfa_offset 3
  31               		.cfi_offset 28, -2
  32 0002 DF93      		push r29
  33               	.LCFI1:
  34               		.cfi_def_cfa_offset 4
  35               		.cfi_offset 29, -3
  36 0004 CDB7      		in r28,__SP_L__
  37 0006 DEB7      		in r29,__SP_H__
  38               	.LCFI2:
  39               		.cfi_def_cfa_register 28
  40               	/* prologue: function */
  41               	/* frame size = 0 */
  42               	/* stack size = 2 */
  43               	.L__stack_usage = 2
 176:../../../platform/common/services/clock/mega/sysclk.h **** 	switch (SYSCLK_SOURCE) {
 177:../../../platform/common/services/clock/mega/sysclk.h **** 	case SYSCLK_SRC_RC16MHZ:
 178:../../../platform/common/services/clock/mega/sysclk.h **** 		return 16000000UL;
 179:../../../platform/common/services/clock/mega/sysclk.h **** 
 180:../../../platform/common/services/clock/mega/sysclk.h **** 	case SYSCLK_SRC_RC128KHZ:
 181:../../../platform/common/services/clock/mega/sysclk.h **** 		return 128000UL;
 182:../../../platform/common/services/clock/mega/sysclk.h **** 
 183:../../../platform/common/services/clock/mega/sysclk.h **** #if MEGA_RF
 184:../../../platform/common/services/clock/mega/sysclk.h **** 	case SYSCLK_SRC_TRS16MHZ:
 185:../../../platform/common/services/clock/mega/sysclk.h **** 		return 16000000UL;
  44               		.loc 1 185 0
  45 0008 80E0      		ldi r24,0
  46 000a 94E2      		ldi r25,lo8(36)
  47 000c A4EF      		ldi r26,lo8(-12)
  48 000e B0E0      		ldi r27,0
 186:../../../platform/common/services/clock/mega/sysclk.h **** #endif
 187:../../../platform/common/services/clock/mega/sysclk.h **** #ifdef BOARD_EXTERNAL_CLK
 188:../../../platform/common/services/clock/mega/sysclk.h **** 	case SYSCLK_SRC_EXTERNAL:
 189:../../../platform/common/services/clock/mega/sysclk.h **** 		return BOARD_EXTERNAL_CLK;
 190:../../../platform/common/services/clock/mega/sysclk.h **** #endif
 191:../../../platform/common/services/clock/mega/sysclk.h **** 	default:
 192:../../../platform/common/services/clock/mega/sysclk.h **** 
 193:../../../platform/common/services/clock/mega/sysclk.h **** 		return 1000000UL;
 194:../../../platform/common/services/clock/mega/sysclk.h **** 	}
 195:../../../platform/common/services/clock/mega/sysclk.h **** }
  49               		.loc 1 195 0
  50 0010 BC01      		movw r22,r24
  51 0012 CD01      		movw r24,r26
  52               	/* epilogue start */
  53 0014 DF91      		pop r29
  54 0016 CF91      		pop r28
  55 0018 0895      		ret
  56               		.cfi_endproc
  57               	.LFE67:
  60               	sysclk_get_source_clock_hz:
  61               	.LFB68:
 196:../../../platform/common/services/clock/mega/sysclk.h **** 
 197:../../../platform/common/services/clock/mega/sysclk.h **** /**
 198:../../../platform/common/services/clock/mega/sysclk.h ****  * \brief Return the current rate in Hz of source clock in Hz.
 199:../../../platform/common/services/clock/mega/sysclk.h ****  *
 200:../../../platform/common/services/clock/mega/sysclk.h ****  * This clock always runs at the same rate as the CPU clock unless the divider
 201:../../../platform/common/services/clock/mega/sysclk.h ****  * is set.
 202:../../../platform/common/services/clock/mega/sysclk.h ****  *
 203:../../../platform/common/services/clock/mega/sysclk.h ****  * \return Frequency of the system clock, in Hz.
 204:../../../platform/common/services/clock/mega/sysclk.h ****  */
 205:../../../platform/common/services/clock/mega/sysclk.h **** static inline uint32_t sysclk_get_source_clock_hz(void)
 206:../../../platform/common/services/clock/mega/sysclk.h **** {
  62               		.loc 1 206 0
  63               		.cfi_startproc
  64 001a CF93      		push r28
  65               	.LCFI3:
  66               		.cfi_def_cfa_offset 3
  67               		.cfi_offset 28, -2
  68 001c DF93      		push r29
  69               	.LCFI4:
  70               		.cfi_def_cfa_offset 4
  71               		.cfi_offset 29, -3
  72 001e CDB7      		in r28,__SP_L__
  73 0020 DEB7      		in r29,__SP_H__
  74               	.LCFI5:
  75               		.cfi_def_cfa_register 28
  76               	/* prologue: function */
  77               	/* frame size = 0 */
  78               	/* stack size = 2 */
  79               	.L__stack_usage = 2
 207:../../../platform/common/services/clock/mega/sysclk.h **** 	switch (CONFIG_SYSCLK_PSDIV) {
 208:../../../platform/common/services/clock/mega/sysclk.h **** 	case SYSCLK_PSDIV_1: /* Fall through */
 209:../../../platform/common/services/clock/mega/sysclk.h **** 		if (SYSCLK_SOURCE == SYSCLK_SRC_RC16MHZ ||
 210:../../../platform/common/services/clock/mega/sysclk.h **** 				SYSCLK_SOURCE == SYSCLK_SRC_RC128KHZ) {
 211:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 2;
 212:../../../platform/common/services/clock/mega/sysclk.h **** 		} else {
 213:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz();
  80               		.loc 1 213 0
  81 0022 0E94 0000 		call sysclk_get_main_hz
  82 0026 DC01      		movw r26,r24
  83 0028 CB01      		movw r24,r22
 214:../../../platform/common/services/clock/mega/sysclk.h **** 		}
 215:../../../platform/common/services/clock/mega/sysclk.h **** 
 216:../../../platform/common/services/clock/mega/sysclk.h **** 	case SYSCLK_PSDIV_2:
 217:../../../platform/common/services/clock/mega/sysclk.h **** 		if (SYSCLK_SOURCE == SYSCLK_SRC_RC16MHZ ||
 218:../../../platform/common/services/clock/mega/sysclk.h **** 				SYSCLK_SOURCE == SYSCLK_SRC_RC128KHZ) {
 219:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 4;
 220:../../../platform/common/services/clock/mega/sysclk.h **** 		} else {
 221:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 2;
 222:../../../platform/common/services/clock/mega/sysclk.h **** 		}
 223:../../../platform/common/services/clock/mega/sysclk.h **** 
 224:../../../platform/common/services/clock/mega/sysclk.h **** 	case SYSCLK_PSDIV_4:
 225:../../../platform/common/services/clock/mega/sysclk.h **** 		if (SYSCLK_SOURCE == SYSCLK_SRC_RC16MHZ ||
 226:../../../platform/common/services/clock/mega/sysclk.h **** 				SYSCLK_SOURCE == SYSCLK_SRC_RC128KHZ) {
 227:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 8;
 228:../../../platform/common/services/clock/mega/sysclk.h **** 		} else {
 229:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 4;
 230:../../../platform/common/services/clock/mega/sysclk.h **** 		}
 231:../../../platform/common/services/clock/mega/sysclk.h **** 
 232:../../../platform/common/services/clock/mega/sysclk.h **** 	case SYSCLK_PSDIV_8:
 233:../../../platform/common/services/clock/mega/sysclk.h **** 		if (SYSCLK_SOURCE == SYSCLK_SRC_RC16MHZ ||
 234:../../../platform/common/services/clock/mega/sysclk.h **** 				SYSCLK_SOURCE == SYSCLK_SRC_RC128KHZ) {
 235:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 16;
 236:../../../platform/common/services/clock/mega/sysclk.h **** 		} else {
 237:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 8;
 238:../../../platform/common/services/clock/mega/sysclk.h **** 		}
 239:../../../platform/common/services/clock/mega/sysclk.h **** 
 240:../../../platform/common/services/clock/mega/sysclk.h **** 	case SYSCLK_PSDIV_16:
 241:../../../platform/common/services/clock/mega/sysclk.h **** 		if (SYSCLK_SOURCE == SYSCLK_SRC_RC16MHZ ||
 242:../../../platform/common/services/clock/mega/sysclk.h **** 				SYSCLK_SOURCE == SYSCLK_SRC_RC128KHZ) {
 243:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 32;
 244:../../../platform/common/services/clock/mega/sysclk.h **** 		} else {
 245:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 16;
 246:../../../platform/common/services/clock/mega/sysclk.h **** 		}
 247:../../../platform/common/services/clock/mega/sysclk.h **** 
 248:../../../platform/common/services/clock/mega/sysclk.h **** 	case SYSCLK_PSDIV_32:
 249:../../../platform/common/services/clock/mega/sysclk.h **** 		if (SYSCLK_SOURCE == SYSCLK_SRC_RC16MHZ ||
 250:../../../platform/common/services/clock/mega/sysclk.h **** 				SYSCLK_SOURCE == SYSCLK_SRC_RC128KHZ) {
 251:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 64;
 252:../../../platform/common/services/clock/mega/sysclk.h **** 		} else {
 253:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 32;
 254:../../../platform/common/services/clock/mega/sysclk.h **** 		}
 255:../../../platform/common/services/clock/mega/sysclk.h **** 
 256:../../../platform/common/services/clock/mega/sysclk.h **** 	case SYSCLK_PSDIV_64:
 257:../../../platform/common/services/clock/mega/sysclk.h **** 		if (SYSCLK_SOURCE == SYSCLK_SRC_RC16MHZ ||
 258:../../../platform/common/services/clock/mega/sysclk.h **** 				SYSCLK_SOURCE == SYSCLK_SRC_RC128KHZ) {
 259:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 128;
 260:../../../platform/common/services/clock/mega/sysclk.h **** 		} else {
 261:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 64;
 262:../../../platform/common/services/clock/mega/sysclk.h **** 		}
 263:../../../platform/common/services/clock/mega/sysclk.h **** 
 264:../../../platform/common/services/clock/mega/sysclk.h **** 	case SYSCLK_PSDIV_128:
 265:../../../platform/common/services/clock/mega/sysclk.h **** 		if (SYSCLK_SOURCE == SYSCLK_SRC_RC16MHZ ||
 266:../../../platform/common/services/clock/mega/sysclk.h **** 				SYSCLK_SOURCE == SYSCLK_SRC_RC128KHZ) {
 267:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 256;
 268:../../../platform/common/services/clock/mega/sysclk.h **** 		} else {
 269:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 128;
 270:../../../platform/common/services/clock/mega/sysclk.h **** 		}
 271:../../../platform/common/services/clock/mega/sysclk.h **** 
 272:../../../platform/common/services/clock/mega/sysclk.h **** 	case SYSCLK_PSDIV_256:
 273:../../../platform/common/services/clock/mega/sysclk.h **** 		if (SYSCLK_SOURCE == SYSCLK_SRC_RC16MHZ ||
 274:../../../platform/common/services/clock/mega/sysclk.h **** 				SYSCLK_SOURCE == SYSCLK_SRC_RC128KHZ) {
 275:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 512;
 276:../../../platform/common/services/clock/mega/sysclk.h **** 		} else {
 277:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 256;
 278:../../../platform/common/services/clock/mega/sysclk.h **** 		}
 279:../../../platform/common/services/clock/mega/sysclk.h **** 
 280:../../../platform/common/services/clock/mega/sysclk.h **** 	default:
 281:../../../platform/common/services/clock/mega/sysclk.h **** 		/*Invalide case*/
 282:../../../platform/common/services/clock/mega/sysclk.h **** 		return 0;
 283:../../../platform/common/services/clock/mega/sysclk.h **** 	}
 284:../../../platform/common/services/clock/mega/sysclk.h **** }
  84               		.loc 1 284 0
  85 002a BC01      		movw r22,r24
  86 002c CD01      		movw r24,r26
  87               	/* epilogue start */
  88 002e DF91      		pop r29
  89 0030 CF91      		pop r28
  90 0032 0895      		ret
  91               		.cfi_endproc
  92               	.LFE68:
  94               		.section	.progmem.data.baudctrl_1mhz,"a",@progbits
  97               	baudctrl_1mhz:
  98 0000 3300      		.word	51
  99 0002 1900      		.word	25
 100 0004 0C00      		.word	12
 101 0006 0600      		.word	6
 102 0008 0300      		.word	3
 103 000a 0200      		.word	2
 104 000c 0100      		.word	1
 105 000e FF00      		.word	255
 106               		.section	.progmem.data.baudctrl_8mhz,"a",@progbits
 109               	baudctrl_8mhz:
 110 0000 A001      		.word	416
 111 0002 CF00      		.word	207
 112 0004 6700      		.word	103
 113 0006 3300      		.word	51
 114 0008 1900      		.word	25
 115 000a 0C00      		.word	12
 116 000c 0700      		.word	7
 117 000e 0800      		.word	8
 118               		.section	.progmem.data.baudctrl_16mhz,"a",@progbits
 121               	baudctrl_16mhz:
 122 0000 4003      		.word	832
 123 0002 A001      		.word	416
 124 0004 CF00      		.word	207
 125 0006 6700      		.word	103
 126 0008 3300      		.word	51
 127 000a 1900      		.word	25
 128 000c 1000      		.word	16
 129 000e 1000      		.word	16
 130               		.text
 132               	usart_double_baud_enable:
 133               	.LFB101:
 134               		.file 2 "../../../platform/mega_rf/drivers/usart/usart_megarf.h"
   1:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
   2:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \file
   3:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
   4:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief USART driver for AVR MEGARF.
   5:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
   6:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * This file contains basic functions for the AVR MEGA USART, with support for
   7:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * all modes, settings and clock speeds.
   8:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
   9:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * Copyright (c) 2013-2015 Atmel Corporation. All rights reserved.
  10:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
  11:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \asf_license_start
  12:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
  13:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \page License
  14:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
  15:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * Redistribution and use in source and binary forms, with or without
  16:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * modification, are permitted provided that the following conditions are met:
  17:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
  18:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * 1. Redistributions of source code must retain the above copyright notice,
  19:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *    this list of conditions and the following disclaimer.
  20:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
  21:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * 2. Redistributions in binary form must reproduce the above copyright notice,
  22:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *    this list of conditions and the following disclaimer in the documentation
  23:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *    and/or other materials provided with the distribution.
  24:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
  25:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * 3. The name of Atmel may not be used to endorse or promote products derived
  26:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *    from this software without specific prior written permission.
  27:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
  28:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * 4. This software may only be redistributed and used in connection with an
  29:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *    Atmel microcontroller product.
  30:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
  31:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR IMPLIED
  32:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
  33:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
  34:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR
  35:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  36:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
  37:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  38:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
  39:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  40:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  41:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * POSSIBILITY OF SUCH DAMAGE.
  42:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
  43:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \asf_license_stop
  44:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
  45:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
  46:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #ifndef _USART_MEGARF_H_
  47:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define _USART_MEGARF_H_
  48:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
  49:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #ifdef __cplusplus
  50:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** extern "C" {
  51:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #endif
  52:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
  53:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #include "compiler.h"
  54:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #include "status_codes.h"
  55:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
  56:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
  57:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \defgroup megarf_usart_group USART module (USART)
  58:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
  59:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * See \ref megarf_usart_quickstart.
  60:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
  61:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * This is a driver for configuring, enabling, disabling and use of the on-chip
  62:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * USART.
  63:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
  64:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \section dependencies Dependencies
  65:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
  66:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * The USART module depends on the following modules:
  67:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *  - \ref sysclk_group for peripheral clock control.
  68:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *  - \ref port_driver_group for peripheral io port control.
  69:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
  70:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * @{
  71:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
  72:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
  73:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* ! Offset in lookup table for baudrate 1200 */
  74:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_BAUD_1200      0x00
  75:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* ! Offset in lookup table for baudrate 2400 */
  76:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_BAUD_2400      0x01
  77:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* ! Offset in lookup table for baudrate 4800 */
  78:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_BAUD_4800      0x02
  79:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* ! Offset in lookup table for baudrate 9600 */
  80:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_BAUD_9600      0x03
  81:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* ! Offset in lookup table for baudrate 19200 */
  82:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_BAUD_19200     0x04
  83:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* ! Offset in lookup table for baudrate 38400 */
  84:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_BAUD_38400     0x05
  85:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* ! Offset in lookup table for baudrate 57600 */
  86:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_BAUD_57600     0x06
  87:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* ! Offset in lookup table for baudrate 115200 */
  88:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_BAUD_115200    0x07
  89:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* ! Baudrate not in lookup table */
  90:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_BAUD_UNDEFINED 0xFF
  91:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
  92:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** typedef volatile uint8_t register8_t;
  93:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** typedef volatile uint16_t register16_t;
  94:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* Universal Synchronous/Asynchronous Receiver/Transmitter */
  95:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** typedef struct USART_struct {
  96:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	register8_t UCSRnA;  /* Control Register A */
  97:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	register8_t UCSRnB;  /* Control Register B */
  98:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	register8_t UCSRnC;  /* Control Register C */
  99:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	register8_t reserved;
 100:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	register16_t UBRR;  /* Baud Rate Register Value */
 101:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	register8_t UDR;  /* I/O Data Register */
 102:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** } USART_t;
 103:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 104:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USARTA0    (*(USART_t *)0xC0)   /* Universal Asynchronous
 105:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	                                 * Receiver-Transmitter A0 */
 106:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USARTA1    (*(USART_t *)0XC8)   /* Universal Asynchronous
 107:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	                                 * Receiver-Transmitter A1 */
 108:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 109:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* USART.UCSRxA  bit masks and bit positions */
 110:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_RXC_bm  0x80 /* RX complete bit mask.*/
 111:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_RXC_bp  7 /* RX complete bit position.*/
 112:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 113:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_TXC_bm  0x40 /* TX complete bit mask.*/
 114:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_TXC_bp  6 /* TX complete bit position.*/
 115:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 116:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_DRE_bm  0x20 /* DATA Register Empty Bit mask.*/
 117:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_DRE_bp  5 /*  DATA Register Empty bit position.*/
 118:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 119:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_FE_bm   0x10 /* Frame Error bit mask.*/
 120:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_FE_bp   4 /*Frame error bit position.*/
 121:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 122:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_DOR_bm  0x08 /* Data Over Run bit mask.*/
 123:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_DOR_bp  3 /* Data Over Run bit position.*/
 124:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 125:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_UPE_bm  0x04 /* Parity error bit mask.*/
 126:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_UPE_bp  2 /* Parity error bit position.*/
 127:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 128:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_U2X_bm  0x02 /* Double TX speed bit mask.*/
 129:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_U2X_bp  1 /* Double TX speed bit position.*/
 130:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 131:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_MPCM_bm  0x01 /* Multi Processor bit mask.*/
 132:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_MPMC_bp  0 /* Multi processor bit position.*/
 133:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 134:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* USART.UCSRxB  bit masks and bit positions */
 135:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_RXCIE_bm  0x80 /* RX complete interrupt Enable bit mask.*/
 136:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_RXCIE_bp  7 /* RX complete interrupt Enable bit position.*/
 137:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 138:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_TXCIE_bm  0x40 /* TX complete interrupt Enable bit mask.*/
 139:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_TXCIE_bp  6 /* TX complete interrupt Enable bit position.*/
 140:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 141:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_DRIE_bm  0x20 /* Data register empty interrupt Enable bit mask.*/
 142:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_DRIE_bp  5 /* Data register empty interrupt Enable bit position.*/
 143:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 144:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_RXEN_bm  0x10  /* Receiver Enable bit mask. */
 145:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_RXEN_bp  4  /* Receiver Enable bit position. */
 146:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 147:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_TXEN_bm  0x08  /* Transmitter Enable bit mask. */
 148:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_TXEN_bp  3  /* Transmitter Enable bit position. */
 149:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 150:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_CHSIZE2_bm  0x04  /* Character Size bit mask. */
 151:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_CHSIZE2_bp  2 /* Character Size bit position. */
 152:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 153:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_RXB8_bm  0x02  /* Transmit bit 8 bit mask. */
 154:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_RXB8_bp  1  /* Transmit bit 8 bit position. */
 155:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 156:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_TXB8_bm  0x01  /* Transmit bit 8 bit mask. */
 157:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_TXB8_bp  0  /* Transmit bit 8 bit position. */
 158:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 159:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* USART.UCSRxC  bit masks and bit positions */
 160:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_UMSEL01_gm  0xC0 /* USART Mode Select 01 grp mask.*/
 161:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_UMSEL01_gp  6 /* USART Mode Select 01 grp position.*/
 162:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 163:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_UMSEL01_bm  0x80 /* USART Mode Select 01 bit mask.*/
 164:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_UMSEL01_bp  7 /* USART Mode Select 01 bit position.*/
 165:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 166:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_UMSEL00_bm  0x40 /* USART Mode Select 00 bit mask.*/
 167:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_UMSEL00_bp  6 /* USART Mode Select 00 bit position.*/
 168:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 169:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_PMODE_gm  0x30 /* USART Parity Mode Select grp mask.*/
 170:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_PMODE_gp  4 /* USART Parity Mode Select grp position.*/
 171:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 172:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_PMODE01_bm  0x20 /* USART Parity Mode Select 01 bit mask.*/
 173:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_PMODE01_bp  5 /* USART Parity Mode Select 01 bit position.*/
 174:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 175:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_PMODE00_bm  0x10 /* USART Parity Mode Select 00 bit mask.*/
 176:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_PMODE00_bp  4 /* USART Parity Mode Select 00 bit position.*/
 177:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 178:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_STOPB_bm  0x08 /* USART stop bit mask.*/
 179:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_STOPB_bp  3 /* USART stop bit Position.*/
 180:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 181:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_CHSIZE01C_gm  0x06  /* Character Size 10 bit 1 mask. */
 182:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_CHSIZE01C_gp  1 /* Character Size 10 bit position. */
 183:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 184:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_CHSIZE01_bm  0x04  /* Character Size 10 bit 1 mask. */
 185:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_CHSIZE01_bp  2 /* Character Size 10 bit position. */
 186:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 187:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_CHSIZE00_bm  0x02  /* Character Size 00 bit 1 mask. */
 188:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_CHSIZE00_bp  1 /* Character Size bit 00 position. */
 189:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 190:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_UCPOL_bm  0x01  /* Sync mode Pol bit 1 mask. */
 191:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_UCPOL_bp  0 /*Sync mode Pol bit 0 position */
 192:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 193:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_UCPHA_bm 0x02 /* Clock Phase bit mask. */
 194:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_UCPHA_bp 1 /* Clock Phase bit position. */
 195:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 196:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_DORD_bm 0x04 /* Data order bit mask. */
 197:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_DORD_bp 2 /* Data order bit position. */
 198:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 199:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* Character Size */
 200:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** typedef enum USART_CHSIZE_enum {
 201:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	USART_CHSIZE_5BIT_gc = (0x00),  /* Character size: 5 bit */
 202:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	USART_CHSIZE_6BIT_gc = (0x01),  /* Character size: 6 bit */
 203:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	USART_CHSIZE_7BIT_gc = (0x02),  /* Character size: 7 bit */
 204:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	USART_CHSIZE_8BIT_gc = (0x03),  /* Character size: 8 bit */
 205:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	USART_CHSIZE_9BIT_gc = (0x07),  /* Character size: 9 bit */
 206:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** } USART_CHSIZE_t;
 207:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 208:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* Communication Mode */
 209:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** typedef enum USART_CMODE_enum {
 210:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	USART_CMODE_ASYNCHRONOUS_gc = (0x00 << USART_UMSEL01_gp),  /*
 211:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	                                                            *
 212:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	                                                            *
 213:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	                                                            *Asynchronous
 214:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	                                                            * Mode */
 215:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	USART_CMODE_SYNCHRONOUS_gc = (0x01 << USART_UMSEL01_gp),  /* Synchronous
 216:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	                                                           * Mode */
 217:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	USART_CMODE_IRDA_gc = (0x02 << USART_UMSEL01_gp),  /* IrDA Mode */
 218:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	USART_CMODE_MSPI_gc = (0x03 << USART_UMSEL01_gp),  /* Master SPI Mode */
 219:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** } USART_CMODE_t;
 220:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 221:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* Parity Mode */
 222:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** typedef enum USART_PMODE_enum {
 223:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	USART_PMODE_DISABLED_gc = (0x00 << USART_PMODE_gp),  /* No Parity */
 224:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	USART_PMODE_EVEN_gc = (0x02 << USART_PMODE_gp),  /* Even Parity */
 225:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	USART_PMODE_ODD_gc = (0x03 << USART_PMODE_gp),  /* Odd Parity */
 226:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** } USART_PMODE_t;
 227:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 228:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* ! Lookup table containing baudctrl values for CPU frequency 1 Mhz */
 229:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static PROGMEM_DECLARE(uint16_t, baudctrl_1mhz[]) = {
 230:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0033, /* Baud: 1200 */
 231:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0019, /* Baud: 2400 */
 232:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x000C, /* Baud: 4800 */
 233:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0006, /* Baud: 9600 */
 234:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0003, /* Baud: 19200 */
 235:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0002, /* Baud: 38400 */
 236:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0001, /* Baud: 57600 */
 237:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	USART_BAUD_UNDEFINED, /* Baud: 115200 */
 238:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** };
 239:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 240:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* ! Lookup table containing baudctrl values for CPU frequency 8 Mhz */
 241:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static PROGMEM_DECLARE(uint16_t, baudctrl_8mhz[]) = {
 242:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x01A0, /* Baud: 1200 */
 243:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x00CF, /* Baud: 2400 */
 244:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0067, /* Baud: 4800 */
 245:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0033, /* Baud: 9600 */
 246:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0019, /* Baud: 19200 */
 247:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x000C, /* Baud: 38400 */
 248:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0007, /* Baud: 57600 */
 249:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0008, /* Baud: 115200 */
 250:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** };
 251:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 252:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* ! Lookup table containing baudctrl values for CPU frequency 16 Mhz */
 253:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static PROGMEM_DECLARE(uint16_t, baudctrl_16mhz[]) = {
 254:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0340, /* Baud: 1200 */
 255:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x01A0, /* Baud: 2400 */
 256:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x00CF, /* Baud: 4800 */
 257:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0067, /* Baud: 9600 */
 258:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0033, /* Baud: 19200 */
 259:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0019, /* Baud: 38400 */
 260:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0010, /* Baud: 57600 */
 261:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0010, /* Baud: 115200 */
 262:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** };
 263:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 264:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 265:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* ! Input parameters when initializing RS232 and similar modes. */
 266:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** typedef struct usart_rs232_options {
 267:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	/* ! Set baud rate of the USART (unused in slave modes). */
 268:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	uint32_t baudrate;
 269:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 270:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	/* ! Number of bits to transmit as a character (5 to 9). */
 271:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	USART_CHSIZE_t charlength;
 272:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 273:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	/* ! Parity type: USART_PMODE_DISABLED_gc, USART_PMODE_EVEN_gc, */
 274:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	/* ! USART_PMODE_ODD_gc. */
 275:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	USART_PMODE_t paritytype;
 276:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 277:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	/* ! Number of stop bits between two characters: */
 278:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	/* ! true: 2 stop bits */
 279:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	/* ! false: 1 stop bit */
 280:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	bool stopbits;
 281:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** } usart_rs232_options_t;
 282:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 283:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* ! Input parameters when initializing SPI master mode. */
 284:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** typedef struct usart_spi_options {
 285:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	/* ! Set baud rate of the USART in SPI mode. */
 286:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	uint32_t baudrate;
 287:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 288:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	/* ! SPI transmission mode. */
 289:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	uint8_t spimode;
 290:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 291:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	uint8_t data_order;
 292:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** } usart_spi_options_t;
 293:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 294:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 295:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 296:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Enable USART receiver.
 297:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 298:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart Pointer to the USART module
 299:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 300:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline void usart_rx_enable(USART_t *usart)
 301:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 302:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	(usart)->UCSRnB |= USART_RXEN_bm;
 303:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 304:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 305:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 306:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Disable USART receiver.
 307:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 308:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart Pointer to the USART module.
 309:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 310:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline void usart_rx_disable(USART_t *usart)
 311:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 312:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	(usart)->UCSRnB &= ~USART_RXEN_bm;
 313:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 314:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 315:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 316:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief  Configure the USART frame format.
 317:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 318:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *  Sets the frame format, Frame Size, parity mode and number of stop bits.
 319:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 320:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *  \param usart Pointer to the USART module
 321:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *  \param charSize The character size. Use USART_CHSIZE_t type.
 322:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *  \param parityMode The parity Mode. Use USART_PMODE_t type.
 323:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *  \param twoStopBits Enable two stop bit mode. Use bool type.
 324:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 325:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline void usart_format_set(USART_t *usart, USART_CHSIZE_t charSize,
 326:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 		USART_PMODE_t parityMode, bool twoStopBits)
 327:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 328:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	(usart)->UCSRnC
 329:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 		= ((usart)->UCSRnC &
 330:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 			(~USART_CHSIZE01C_gm)) | ((charSize & 0x03)
 331:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 			<< USART_CHSIZE01C_gp);
 332:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	(usart)->UCSRnB
 333:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 		= ((usart)->UCSRnB &
 334:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 			(~USART_CHSIZE2_bm)) | ((charSize & 0x04)
 335:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 			<< USART_CHSIZE2_bp);
 336:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 337:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	(usart)->UCSRnC = ((usart)->UCSRnC & (~USART_PMODE_gm)) | parityMode;
 338:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 339:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	(usart)->UCSRnC = ((usart)->UCSRnC & (~USART_STOPB_bm)) | (twoStopBits
 340:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 			<< USART_STOPB_bp);
 341:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 342:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 343:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 344:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Enable USART transmitter.
 345:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 346:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart Pointer to the USART module.
 347:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 348:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline void usart_tx_enable(USART_t *usart)
 349:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 350:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	(usart)->UCSRnB |= USART_TXEN_bm;
 351:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 352:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 353:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 354:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Disable USART transmitter.
 355:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 356:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart Pointer to the USART module.
 357:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 358:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline void usart_tx_disable(USART_t *usart)
 359:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 360:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	(usart)->UCSRnB &= ~USART_TXEN_bm;
 361:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 362:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 363:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 364:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Enable USART transmit complete interrupt.
 365:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 366:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart Pointer to the USART module.
 367:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 368:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline void usart_tx_complete_interrupt_enable(USART_t *usart)
 369:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 370:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	(usart)->UCSRnB |= USART_TXC_bm;
 371:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 372:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 373:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 374:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Enable USART receive complete interrupt.
 375:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 376:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart Pointer to the USART module.
 377:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 378:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline void usart_rx_complete_interrupt_enable(USART_t *usart)
 379:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 380:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	(usart)->UCSRnB |= USART_RXC_bm;
 381:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 382:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 383:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 384:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Enable USART data register empty interrupt.
 385:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 386:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart Pointer to the USART module.
 387:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 388:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline void usart_data_empty_interrupt_enable(USART_t *usart)
 389:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 390:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	(usart)->UCSRnB |= USART_DRIE_bm;
 391:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 392:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 393:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 394:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Disable USART transmit complete interrupt.
 395:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 396:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart Pointer to the USART module.
 397:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 398:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline void usart_tx_complete_interrupt_disable(USART_t *usart)
 399:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 400:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	(usart)->UCSRnB &= ~USART_TXC_bm;
 401:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 402:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 403:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 404:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Disable USART receive complete interrupt.
 405:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 406:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart Pointer to the USART module.
 407:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 408:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline void usart_rx_complete_interrupt_disable(USART_t *usart)
 409:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 410:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	(usart)->UCSRnB &= ~USART_RXC_bm;
 411:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 412:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 413:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 414:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Disable USART data register empty interrupt.
 415:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 416:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart Pointer to the USART module.
 417:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 418:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline void usart_data_empty_interrupt_disable(USART_t *usart)
 419:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 420:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	(usart)->UCSRnB &= ~USART_DRIE_bm;
 421:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 422:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 423:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 424:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Set the mode the USART run in.
 425:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 426:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * Set the mode the USART run in. The default mode is asynchronous mode.
 427:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 428:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart Pointer to the USART module register section.
 429:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usartmode Selects the USART mode. Use USART_CMODE_t type.
 430:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 431:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * USART modes:
 432:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * - 0x0        : Asynchronous mode.
 433:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * - 0x1        : Synchronous mode.
 434:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * - 0x2        : IrDA mode.
 435:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * - 0x3        : Master SPI mode.
 436:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 437:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline void usart_set_mode(USART_t *usart, USART_CMODE_t usartmode)
 438:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 439:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	(usart)->UCSRnC = ((usart)->UCSRnC & (~USART_UMSEL01_gm)) | usartmode;
 440:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 441:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 442:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 443:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Check if data register empty flag is set.
 444:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 445:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart The USART module.
 446:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 447:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline bool usart_data_register_is_empty(USART_t *usart)
 448:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 449:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	return (usart)->UCSRnA & USART_DRE_bm;
 450:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 451:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 452:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 453:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Checks if the RX complete interrupt flag is set.
 454:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 455:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * Checks if the RX complete interrupt flag is set.
 456:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 457:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart The USART module.
 458:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 459:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline bool usart_rx_is_complete(USART_t *usart)
 460:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 461:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	return (usart)->UCSRnA & USART_RXC_bm;
 462:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 463:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 464:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 465:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Checks if the TX complete interrupt flag is set.
 466:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 467:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * Checks if the TX complete interrupt flag is set.
 468:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 469:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart The USART module.
 470:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 471:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline bool usart_tx_is_complete(USART_t *usart)
 472:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 473:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	return (usart)->UCSRnA & USART_TXC_bm;
 474:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 475:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 476:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 477:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Clear TX complete interrupt flag.
 478:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * TX flag is clear after complete transmission, automatically.
 479:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart The USART module.
 480:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 481:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline void usart_clear_tx_complete(USART_t *usart)
 482:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 483:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****          usart->UCSRnA |=  USART_TXC_bm;
 484:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 485:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 486:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 487:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Write a data to the USART data register.
 488:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 489:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart The USART module.
 490:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param txdata The data to be transmitted.
 491:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 492:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline void usart_put(USART_t *usart, uint8_t txdata)
 493:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 494:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	(usart)->UDR = txdata;
 495:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 496:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 497:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 498:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief  Read a data to the USART data register.
 499:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 500:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart The USART module.
 501:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 502:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \return The received data
 503:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 504:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline uint8_t usart_get(USART_t *usart)
 505:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 506:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	return (usart)->UDR;
 507:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 508:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 509:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 510:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Double the USART transmission speed.
 511:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 512:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart The USART module.
 513:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 514:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline void usart_double_baud_enable(USART_t *usart)
 515:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 135               		.loc 2 515 0
 136               		.cfi_startproc
 137 0034 CF93      		push r28
 138               	.LCFI6:
 139               		.cfi_def_cfa_offset 3
 140               		.cfi_offset 28, -2
 141 0036 DF93      		push r29
 142               	.LCFI7:
 143               		.cfi_def_cfa_offset 4
 144               		.cfi_offset 29, -3
 145 0038 00D0      		rcall .
 146               	.LCFI8:
 147               		.cfi_def_cfa_offset 6
 148 003a CDB7      		in r28,__SP_L__
 149 003c DEB7      		in r29,__SP_H__
 150               	.LCFI9:
 151               		.cfi_def_cfa_register 28
 152               	/* prologue: function */
 153               	/* frame size = 2 */
 154               	/* stack size = 4 */
 155               	.L__stack_usage = 4
 156 003e 9A83      		std Y+2,r25
 157 0040 8983      		std Y+1,r24
 516:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	usart->UCSRnA |=  USART_U2X_bm;
 158               		.loc 2 516 0
 159 0042 8981      		ldd r24,Y+1
 160 0044 9A81      		ldd r25,Y+2
 161 0046 FC01      		movw r30,r24
 162 0048 8081      		ld r24,Z
 163 004a 282F      		mov r18,r24
 164 004c 2260      		ori r18,lo8(2)
 165 004e 8981      		ldd r24,Y+1
 166 0050 9A81      		ldd r25,Y+2
 167 0052 FC01      		movw r30,r24
 168 0054 2083      		st Z,r18
 517:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 169               		.loc 2 517 0
 170 0056 0000      		nop
 171               	/* epilogue start */
 172 0058 0F90      		pop __tmp_reg__
 173 005a 0F90      		pop __tmp_reg__
 174 005c DF91      		pop r29
 175 005e CF91      		pop r28
 176 0060 0895      		ret
 177               		.cfi_endproc
 178               	.LFE101:
 181               	usart_serial_init:
 182               	.LFB104:
 183               		.file 3 "../../../platform/common/services/serial/megarf_usart/usart_serial.h"
   1:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** /**
   2:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * \file
   3:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
   4:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * \brief This file defines a useful set of functions for the Serial interface on 
   5:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * AVR MEGARF devices.
   6:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
   7:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * Copyright (c) 2013 Atmel Corporation. All rights reserved.
   8:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
   9:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * \asf_license_start
  10:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
  11:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * \page License
  12:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
  13:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * Redistribution and use in source and binary forms, with or without
  14:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * modification, are permitted provided that the following conditions are met:
  15:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
  16:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * 1. Redistributions of source code must retain the above copyright notice,
  17:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *    this list of conditions and the following disclaimer.
  18:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
  19:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * 2. Redistributions in binary form must reproduce the above copyright notice,
  20:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *    this list of conditions and the following disclaimer in the documentation
  21:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *    and/or other materials provided with the distribution.
  22:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
  23:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * 3. The name of Atmel may not be used to endorse or promote products derived
  24:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *    from this software without specific prior written permission.
  25:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
  26:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * 4. This software may only be redistributed and used in connection with an
  27:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *    Atmel microcontroller product.
  28:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
  29:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR IMPLIED
  30:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
  31:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
  32:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR
  33:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  34:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
  35:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  36:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
  37:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  38:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  39:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * POSSIBILITY OF SUCH DAMAGE.
  40:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
  41:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * \asf_license_stop
  42:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
  43:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  */
  44:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** #ifndef _USART_SERIAL_H_
  45:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** #define _USART_SERIAL_H_
  46:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 
  47:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** #ifdef __cplusplus
  48:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** extern "C" {
  49:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** #endif
  50:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 
  51:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** #include "compiler.h"
  52:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** #include "sysclk.h"
  53:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** #include "status_codes.h"
  54:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** #include "usart_megarf.h"
  55:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 
  56:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** /*! \name Serial Management Configuration
  57:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  */
  58:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** /* ! @{ */
  59:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** #include "conf_usart_serial.h"
  60:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** /* ! @} */
  61:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 
  62:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** typedef usart_rs232_options_t usart_serial_options_t;
  63:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 
  64:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** typedef USART_t *usart_if;
  65:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 
  66:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** /*! \brief Initializes the Usart in master mode.
  67:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
  68:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * \param usart       Base address of the USART instance.
  69:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * \param options     Options needed to set up RS232 communication (see \ref
  70:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * usart_serial_options_t).
  71:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
  72:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * \retval true if the initialization was successful
  73:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * \retval false if initialization failed (error in baud rate calculation)
  74:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  */
  75:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** static inline bool usart_serial_init(usart_if usart, const
  76:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 		usart_serial_options_t *options)
  77:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** {
 184               		.loc 3 77 0
 185               		.cfi_startproc
 186 0062 CF93      		push r28
 187               	.LCFI10:
 188               		.cfi_def_cfa_offset 3
 189               		.cfi_offset 28, -2
 190 0064 DF93      		push r29
 191               	.LCFI11:
 192               		.cfi_def_cfa_offset 4
 193               		.cfi_offset 29, -3
 194 0066 CDB7      		in r28,__SP_L__
 195 0068 DEB7      		in r29,__SP_H__
 196               	.LCFI12:
 197               		.cfi_def_cfa_register 28
 198 006a 2B97      		sbiw r28,11
 199               	.LCFI13:
 200               		.cfi_def_cfa_offset 15
 201 006c 0FB6      		in __tmp_reg__,__SREG__
 202 006e F894      		cli
 203 0070 DEBF      		out __SP_H__,r29
 204 0072 0FBE      		out __SREG__,__tmp_reg__
 205 0074 CDBF      		out __SP_L__,r28
 206               	/* prologue: function */
 207               	/* frame size = 11 */
 208               	/* stack size = 13 */
 209               	.L__stack_usage = 13
 210 0076 9987      		std Y+9,r25
 211 0078 8887      		std Y+8,r24
 212 007a 7B87      		std Y+11,r23
 213 007c 6A87      		std Y+10,r22
  78:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 	/* USART options. */
  79:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 	usart_rs232_options_t usart_rs232_options;
  80:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 	usart_rs232_options.charlength   = options->charlength;
 214               		.loc 3 80 0
 215 007e 8A85      		ldd r24,Y+10
 216 0080 9B85      		ldd r25,Y+11
 217 0082 FC01      		movw r30,r24
 218 0084 8481      		ldd r24,Z+4
 219 0086 8D83      		std Y+5,r24
  81:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 	usart_rs232_options.paritytype   = options->paritytype;
 220               		.loc 3 81 0
 221 0088 8A85      		ldd r24,Y+10
 222 008a 9B85      		ldd r25,Y+11
 223 008c FC01      		movw r30,r24
 224 008e 8581      		ldd r24,Z+5
 225 0090 8E83      		std Y+6,r24
  82:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 	usart_rs232_options.stopbits     = options->stopbits;
 226               		.loc 3 82 0
 227 0092 8A85      		ldd r24,Y+10
 228 0094 9B85      		ldd r25,Y+11
 229 0096 FC01      		movw r30,r24
 230 0098 8681      		ldd r24,Z+6
 231 009a 8F83      		std Y+7,r24
  83:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 	usart_rs232_options.baudrate     = options->baudrate;
 232               		.loc 3 83 0
 233 009c 8A85      		ldd r24,Y+10
 234 009e 9B85      		ldd r25,Y+11
 235 00a0 FC01      		movw r30,r24
 236 00a2 8081      		ld r24,Z
 237 00a4 9181      		ldd r25,Z+1
 238 00a6 A281      		ldd r26,Z+2
 239 00a8 B381      		ldd r27,Z+3
 240 00aa 8983      		std Y+1,r24
 241 00ac 9A83      		std Y+2,r25
 242 00ae AB83      		std Y+3,r26
 243 00b0 BC83      		std Y+4,r27
  84:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 
  85:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 	if (usart_init_rs232(usart, &usart_rs232_options)) {
 244               		.loc 3 85 0
 245 00b2 8885      		ldd r24,Y+8
 246 00b4 9985      		ldd r25,Y+9
 247 00b6 9E01      		movw r18,r28
 248 00b8 2F5F      		subi r18,-1
 249 00ba 3F4F      		sbci r19,-1
 250 00bc B901      		movw r22,r18
 251 00be 0E94 0000 		call usart_init_rs232
 252 00c2 8823      		tst r24
 253 00c4 01F0      		breq .L7
  86:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 		return true;
 254               		.loc 3 86 0
 255 00c6 81E0      		ldi r24,lo8(1)
 256 00c8 00C0      		rjmp .L9
 257               	.L7:
  87:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 	} else {
  88:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 		return false;
 258               		.loc 3 88 0
 259 00ca 80E0      		ldi r24,0
 260               	.L9:
 261               	/* epilogue start */
  89:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 	}
  90:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** }
 262               		.loc 3 90 0 discriminator 1
 263 00cc 2B96      		adiw r28,11
 264 00ce 0FB6      		in __tmp_reg__,__SREG__
 265 00d0 F894      		cli
 266 00d2 DEBF      		out __SP_H__,r29
 267 00d4 0FBE      		out __SREG__,__tmp_reg__
 268 00d6 CDBF      		out __SP_L__,r28
 269 00d8 DF91      		pop r29
 270 00da CF91      		pop r28
 271 00dc 0895      		ret
 272               		.cfi_endproc
 273               	.LFE104:
 276               	usart_serial_putchar:
 277               	.LFB105:
  91:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 
  92:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** /*! \brief Sends a character with the USART.
  93:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
  94:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * \param usart   Base address of the USART instance.
  95:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * \param c       Character to write.
  96:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
  97:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * \return Status code
  98:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  */
  99:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** static inline status_code_t usart_serial_putchar(usart_if usart, uint8_t c)
 100:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** {
 278               		.loc 3 100 0
 279               		.cfi_startproc
 280 00de CF93      		push r28
 281               	.LCFI14:
 282               		.cfi_def_cfa_offset 3
 283               		.cfi_offset 28, -2
 284 00e0 DF93      		push r29
 285               	.LCFI15:
 286               		.cfi_def_cfa_offset 4
 287               		.cfi_offset 29, -3
 288 00e2 00D0      		rcall .
 289 00e4 1F92      		push __zero_reg__
 290               	.LCFI16:
 291               		.cfi_def_cfa_offset 7
 292 00e6 CDB7      		in r28,__SP_L__
 293 00e8 DEB7      		in r29,__SP_H__
 294               	.LCFI17:
 295               		.cfi_def_cfa_register 28
 296               	/* prologue: function */
 297               	/* frame size = 3 */
 298               	/* stack size = 5 */
 299               	.L__stack_usage = 5
 300 00ea 9A83      		std Y+2,r25
 301 00ec 8983      		std Y+1,r24
 302 00ee 6B83      		std Y+3,r22
 101:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 	return usart_putchar(usart, c);
 303               		.loc 3 101 0
 304 00f0 8981      		ldd r24,Y+1
 305 00f2 9A81      		ldd r25,Y+2
 306 00f4 6B81      		ldd r22,Y+3
 307 00f6 0E94 0000 		call usart_putchar
 308               	/* epilogue start */
 102:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** }
 309               		.loc 3 102 0
 310 00fa 0F90      		pop __tmp_reg__
 311 00fc 0F90      		pop __tmp_reg__
 312 00fe 0F90      		pop __tmp_reg__
 313 0100 DF91      		pop r29
 314 0102 CF91      		pop r28
 315 0104 0895      		ret
 316               		.cfi_endproc
 317               	.LFE105:
 320               	usart_serial_getchar:
 321               	.LFB106:
 103:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 
 104:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** /*! \brief Waits until a character is received, and returns it.
 105:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
 106:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * \param usart   Base address of the USART instance.
 107:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * \param data   Data to read
 108:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
 109:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  */
 110:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** static inline void usart_serial_getchar(usart_if usart, uint8_t *data)
 111:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** {
 322               		.loc 3 111 0
 323               		.cfi_startproc
 324 0106 CF93      		push r28
 325               	.LCFI18:
 326               		.cfi_def_cfa_offset 3
 327               		.cfi_offset 28, -2
 328 0108 DF93      		push r29
 329               	.LCFI19:
 330               		.cfi_def_cfa_offset 4
 331               		.cfi_offset 29, -3
 332 010a 00D0      		rcall .
 333 010c 00D0      		rcall .
 334               	.LCFI20:
 335               		.cfi_def_cfa_offset 8
 336 010e CDB7      		in r28,__SP_L__
 337 0110 DEB7      		in r29,__SP_H__
 338               	.LCFI21:
 339               		.cfi_def_cfa_register 28
 340               	/* prologue: function */
 341               	/* frame size = 4 */
 342               	/* stack size = 6 */
 343               	.L__stack_usage = 6
 344 0112 9A83      		std Y+2,r25
 345 0114 8983      		std Y+1,r24
 346 0116 7C83      		std Y+4,r23
 347 0118 6B83      		std Y+3,r22
 112:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 	*data = usart_getchar(usart);
 348               		.loc 3 112 0
 349 011a 8981      		ldd r24,Y+1
 350 011c 9A81      		ldd r25,Y+2
 351 011e 0E94 0000 		call usart_getchar
 352 0122 282F      		mov r18,r24
 353 0124 8B81      		ldd r24,Y+3
 354 0126 9C81      		ldd r25,Y+4
 355 0128 FC01      		movw r30,r24
 356 012a 2083      		st Z,r18
 113:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** }
 357               		.loc 3 113 0
 358 012c 0000      		nop
 359               	/* epilogue start */
 360 012e 0F90      		pop __tmp_reg__
 361 0130 0F90      		pop __tmp_reg__
 362 0132 0F90      		pop __tmp_reg__
 363 0134 0F90      		pop __tmp_reg__
 364 0136 DF91      		pop r29
 365 0138 CF91      		pop r28
 366 013a 0895      		ret
 367               		.cfi_endproc
 368               	.LFE106:
 371               	stdio_serial_init:
 372               	.LFB107:
 373               		.file 4 "../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h"
   1:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** /**
   2:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
   3:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * \file
   4:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
   5:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * \brief Common Standard I/O Serial Management.
   6:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
   7:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * This file defines a useful set of functions for the Stdio Serial interface on AVR
   8:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * and SAM devices.
   9:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
  10:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * Copyright (c) 2009-2013 Atmel Corporation. All rights reserved.
  11:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
  12:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * \asf_license_start
  13:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
  14:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * \page License
  15:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
  16:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * Redistribution and use in source and binary forms, with or without
  17:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * modification, are permitted provided that the following conditions are met:
  18:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
  19:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * 1. Redistributions of source code must retain the above copyright notice,
  20:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *    this list of conditions and the following disclaimer.
  21:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
  22:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * 2. Redistributions in binary form must reproduce the above copyright notice,
  23:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *    this list of conditions and the following disclaimer in the documentation
  24:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *    and/or other materials provided with the distribution.
  25:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
  26:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * 3. The name of Atmel may not be used to endorse or promote products derived
  27:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *    from this software without specific prior written permission.
  28:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
  29:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * 4. This software may only be redistributed and used in connection with an
  30:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *    Atmel microcontroller product.
  31:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
  32:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR IMPLIED
  33:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
  34:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
  35:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR
  36:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  37:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
  38:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  39:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
  40:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  41:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  42:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * POSSIBILITY OF SUCH DAMAGE.
  43:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
  44:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * \asf_license_stop
  45:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
  46:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  ******************************************************************************/
  47:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 
  48:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 
  49:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** #ifndef _STDIO_SERIAL_H_
  50:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** #define _STDIO_SERIAL_H_
  51:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 
  52:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** /**
  53:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * \defgroup group_common_utils_stdio_stdio_serial Standard serial I/O (stdio)
  54:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * \ingroup group_common_utils_stdio
  55:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
  56:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * Common standard serial I/O management driver that
  57:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * implements a stdio serial interface on AVR and SAM devices.
  58:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
  59:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * \{
  60:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  */
  61:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 
  62:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** #include <stdio.h>
  63:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** #include "compiler.h"
  64:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** #ifndef SAMD20
  65:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** # include "sysclk.h"
  66:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** #endif
  67:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** #include "serial.h"
  68:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 
  69:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** #if (XMEGA || MEGA_RF) && defined(__GNUC__)
  70:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	extern int _write (char c, int *f);
  71:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	extern int _read (int *f);
  72:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** #endif
  73:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 
  74:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 
  75:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** //! Pointer to the base of the USART module instance to use for stdio.
  76:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** extern volatile void *volatile stdio_base;
  77:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** //! Pointer to the external low level write function.
  78:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** extern int (*ptr_put)(void volatile*, char);
  79:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 
  80:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** //! Pointer to the external low level read function.
  81:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** extern void (*ptr_get)(void volatile*, char*);
  82:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 
  83:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** /*! \brief Initializes the stdio in Serial Mode.
  84:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
  85:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * \param usart       Base address of the USART instance.
  86:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * \param opt         Options needed to set up RS232 communication (see \ref usart_options_t).
  87:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
  88:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  */
  89:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** static inline void stdio_serial_init(volatile void *usart, const usart_serial_options_t *opt)
  90:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** {
 374               		.loc 4 90 0
 375               		.cfi_startproc
 376 013c CF93      		push r28
 377               	.LCFI22:
 378               		.cfi_def_cfa_offset 3
 379               		.cfi_offset 28, -2
 380 013e DF93      		push r29
 381               	.LCFI23:
 382               		.cfi_def_cfa_offset 4
 383               		.cfi_offset 29, -3
 384 0140 00D0      		rcall .
 385 0142 00D0      		rcall .
 386               	.LCFI24:
 387               		.cfi_def_cfa_offset 8
 388 0144 CDB7      		in r28,__SP_L__
 389 0146 DEB7      		in r29,__SP_H__
 390               	.LCFI25:
 391               		.cfi_def_cfa_register 28
 392               	/* prologue: function */
 393               	/* frame size = 4 */
 394               	/* stack size = 6 */
 395               	.L__stack_usage = 6
 396 0148 9A83      		std Y+2,r25
 397 014a 8983      		std Y+1,r24
 398 014c 7C83      		std Y+4,r23
 399 014e 6B83      		std Y+3,r22
  91:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	stdio_base = (void *)usart;
 400               		.loc 4 91 0
 401 0150 8981      		ldd r24,Y+1
 402 0152 9A81      		ldd r25,Y+2
 403 0154 9093 0000 		sts stdio_base+1,r25
 404 0158 8093 0000 		sts stdio_base,r24
  92:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	ptr_put = (int (*)(void volatile*,char))&usart_serial_putchar;
 405               		.loc 4 92 0
 406 015c 80E0      		ldi r24,lo8(gs(usart_serial_putchar))
 407 015e 90E0      		ldi r25,hi8(gs(usart_serial_putchar))
 408 0160 9093 0000 		sts ptr_put+1,r25
 409 0164 8093 0000 		sts ptr_put,r24
  93:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	ptr_get = (void (*)(void volatile*,char*))&usart_serial_getchar;
 410               		.loc 4 93 0
 411 0168 80E0      		ldi r24,lo8(gs(usart_serial_getchar))
 412 016a 90E0      		ldi r25,hi8(gs(usart_serial_getchar))
 413 016c 9093 0000 		sts ptr_get+1,r25
 414 0170 8093 0000 		sts ptr_get,r24
  94:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** # if (XMEGA || MEGA_RF)
  95:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	usart_serial_init((USART_t *)usart,opt);
 415               		.loc 4 95 0
 416 0174 2B81      		ldd r18,Y+3
 417 0176 3C81      		ldd r19,Y+4
 418 0178 8981      		ldd r24,Y+1
 419 017a 9A81      		ldd r25,Y+2
 420 017c B901      		movw r22,r18
 421 017e 0E94 0000 		call usart_serial_init
  96:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** # elif UC3
  97:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	usart_serial_init(usart,(usart_serial_options_t *)opt);
  98:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** # elif SAM
  99:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	usart_serial_init((Usart *)usart,(usart_serial_options_t *)opt);
 100:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** # else
 101:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** #  error Unsupported chip type
 102:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** # endif
 103:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 
 104:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** # if defined(__GNUC__)
 105:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** #  if (XMEGA || MEGA_RF)
 106:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	// For AVR GCC libc print redirection uses fdevopen.
 107:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	fdevopen((int (*)(char, FILE*))(_write),(int (*)(FILE*))(_read));
 422               		.loc 4 107 0
 423 0182 60E0      		ldi r22,lo8(gs(_read))
 424 0184 70E0      		ldi r23,hi8(gs(_read))
 425 0186 80E0      		ldi r24,lo8(gs(_write))
 426 0188 90E0      		ldi r25,hi8(gs(_write))
 427 018a 0E94 0000 		call fdevopen
 108:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** #  endif
 109:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** #  if UC3 || SAM
 110:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	// For AVR32 and SAM GCC
 111:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	// Specify that stdout and stdin should not be buffered.
 112:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	setbuf(stdout, NULL);
 113:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	setbuf(stdin, NULL);
 114:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	// Note: Already the case in IAR's Normal DLIB default configuration
 115:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	// and AVR GCC library:
 116:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	// - printf() emits one character at a time.
 117:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	// - getchar() requests only 1 byte to exit.
 118:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** #  endif
 119:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** # endif
 120:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** }
 428               		.loc 4 120 0
 429 018e 0000      		nop
 430               	/* epilogue start */
 431 0190 0F90      		pop __tmp_reg__
 432 0192 0F90      		pop __tmp_reg__
 433 0194 0F90      		pop __tmp_reg__
 434 0196 0F90      		pop __tmp_reg__
 435 0198 DF91      		pop r29
 436 019a CF91      		pop r28
 437 019c 0895      		ret
 438               		.cfi_endproc
 439               	.LFE107:
 442               	macsc_read32:
 443               	.LFB108:
 444               		.file 5 "../../../platform/mega_rf/drivers/macsc/macsc_megarf.h"
   1:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
   2:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \file
   3:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
   4:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief AVR MEGARF MAC Symbol Counter Driver Definitions
   5:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
   6:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * Copyright (c) 2013 Atmel Corporation. All rights reserved.
   7:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
   8:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \asf_license_start
   9:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  10:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \page License
  11:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  12:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * Redistribution and use in source and binary forms, with or without
  13:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * modification, are permitted provided that the following conditions are met:
  14:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  15:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * 1. Redistributions of source code must retain the above copyright notice,
  16:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *    this list of conditions and the following disclaimer.
  17:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  18:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * 2. Redistributions in binary form must reproduce the above copyright notice,
  19:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *    this list of conditions and the following disclaimer in the documentation
  20:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *    and/or other materials provided with the distribution.
  21:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  22:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * 3. The name of Atmel may not be used to endorse or promote products derived
  23:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *    from this software without specific prior written permission.
  24:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  25:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * 4. This software may only be redistributed and used in connection with an
  26:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *    Atmel microcontroller product.
  27:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  28:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR IMPLIED
  29:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
  30:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
  31:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR
  32:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  33:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
  34:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  35:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
  36:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  37:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  38:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * POSSIBILITY OF SUCH DAMAGE.
  39:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  40:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \asf_license_stop
  41:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  42:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
  43:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** #ifndef MACSC_MEGARF_H
  44:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** #define MACSC_MEGARF_H
  45:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
  46:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** #include <compiler.h>
  47:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** #include <parts.h>
  48:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** #include "status_codes.h"
  49:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
  50:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** #ifdef __cplusplus
  51:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** extern "C" {
  52:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** #endif
  53:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
  54:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
  55:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \defgroup macsc_group MAC Symbol Counter Driver(MACSC)
  56:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  57:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * See \ref megarf_macsc_quickstart
  58:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  59:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * This is a driver for the AVR MEGARF MAC Symbol Counter Driver(MACSC).
  60:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * It provides functions for enabling, disabling and configuring the module.
  61:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  62:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \section dependencies Dependencies
  63:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * This driver depends on the following modules:
  64:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * - \ref interrupt_group for ISR definition and disabling interrupts during
  65:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * critical code sections.
  66:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * @{
  67:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
  68:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
  69:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
  70:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Interrupt event callback function type
  71:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  72:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * The interrupt handler can be configured to do a function callback,
  73:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * the callback function must match the macsc_callback_t type.
  74:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  75:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
  76:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** typedef void (*macsc_callback_t)(void);
  77:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
  78:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /* ! MAC symbol counter compare Channel index */
  79:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** enum macsc_cc_channel {
  80:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	/* ! Channel 1 */
  81:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	MACSC_CC1 = 1,
  82:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	/* ! Channel 2 */
  83:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	MACSC_CC2 = 2,
  84:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	/* ! Channel 3 */
  85:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	MACSC_CC3 = 3,
  86:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** };
  87:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
  88:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief MAC SC clock source select
  89:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  90:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * uses the SCCKSEL bit in SSCR register to select macsc clk src
  91:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  92:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * If the bit is one,the RTC clock from TOSC1 is selected, otherwise the symbol
  93:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * counter operates with the clock from XTAL1.
  94:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * During transceiver sleep modes the clock falls back to the RTC clock source,
  95:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * regardless of the selected clock. After wakeup, it switches back to the
  96:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * previosly
  97:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * selected clock source.
  98:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
  99:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 100:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** enum macsc_xtal {
 101:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	/* ! 16MHz as macsc clock */
 102:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	MACSC_16MHz = 0,
 103:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	MACSC_32KHz = 1,
 104:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** };
 105:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 106:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 107:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * @brief Reads the 32-bit timer register in the required order of bytes
 108:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 109:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * @param hh hh octet of 32-bit register
 110:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * @param hl hl octet of 32-bit register
 111:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * @param lh lh octet of 32-bit register
 112:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * @param ll ll octet of 32-bit register
 113:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 114:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * @returns uint32_t Value of timer register
 115:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 116:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** static inline uint32_t macsc_read32(volatile uint8_t *hh,
 117:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		volatile uint8_t *hl,
 118:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		volatile uint8_t *lh,
 119:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		volatile uint8_t *ll)
 120:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** {
 445               		.loc 5 120 0
 446               		.cfi_startproc
 447 019e CF93      		push r28
 448               	.LCFI26:
 449               		.cfi_def_cfa_offset 3
 450               		.cfi_offset 28, -2
 451 01a0 DF93      		push r29
 452               	.LCFI27:
 453               		.cfi_def_cfa_offset 4
 454               		.cfi_offset 29, -3
 455 01a2 CDB7      		in r28,__SP_L__
 456 01a4 DEB7      		in r29,__SP_H__
 457               	.LCFI28:
 458               		.cfi_def_cfa_register 28
 459 01a6 2C97      		sbiw r28,12
 460               	.LCFI29:
 461               		.cfi_def_cfa_offset 16
 462 01a8 0FB6      		in __tmp_reg__,__SREG__
 463 01aa F894      		cli
 464 01ac DEBF      		out __SP_H__,r29
 465 01ae 0FBE      		out __SREG__,__tmp_reg__
 466 01b0 CDBF      		out __SP_L__,r28
 467               	/* prologue: function */
 468               	/* frame size = 12 */
 469               	/* stack size = 14 */
 470               	.L__stack_usage = 14
 471 01b2 9E83      		std Y+6,r25
 472 01b4 8D83      		std Y+5,r24
 473 01b6 7887      		std Y+8,r23
 474 01b8 6F83      		std Y+7,r22
 475 01ba 5A87      		std Y+10,r21
 476 01bc 4987      		std Y+9,r20
 477 01be 3C87      		std Y+12,r19
 478 01c0 2B87      		std Y+11,r18
 121:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	union {
 122:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		uint8_t a[4];
 123:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		uint32_t rv;
 124:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	}
 125:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	x;
 126:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 127:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	x.a[0] = *ll;
 479               		.loc 5 127 0
 480 01c2 8B85      		ldd r24,Y+11
 481 01c4 9C85      		ldd r25,Y+12
 482 01c6 FC01      		movw r30,r24
 483 01c8 8081      		ld r24,Z
 484 01ca 8983      		std Y+1,r24
 128:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	x.a[1] = *lh;
 485               		.loc 5 128 0
 486 01cc 8985      		ldd r24,Y+9
 487 01ce 9A85      		ldd r25,Y+10
 488 01d0 FC01      		movw r30,r24
 489 01d2 8081      		ld r24,Z
 490 01d4 8A83      		std Y+2,r24
 129:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	x.a[2] = *hl;
 491               		.loc 5 129 0
 492 01d6 8F81      		ldd r24,Y+7
 493 01d8 9885      		ldd r25,Y+8
 494 01da FC01      		movw r30,r24
 495 01dc 8081      		ld r24,Z
 496 01de 8B83      		std Y+3,r24
 130:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	x.a[3] = *hh;
 497               		.loc 5 130 0
 498 01e0 8D81      		ldd r24,Y+5
 499 01e2 9E81      		ldd r25,Y+6
 500 01e4 FC01      		movw r30,r24
 501 01e6 8081      		ld r24,Z
 502 01e8 8C83      		std Y+4,r24
 131:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 132:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	return x.rv;
 503               		.loc 5 132 0
 504 01ea 8981      		ldd r24,Y+1
 505 01ec 9A81      		ldd r25,Y+2
 506 01ee AB81      		ldd r26,Y+3
 507 01f0 BC81      		ldd r27,Y+4
 133:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** }
 508               		.loc 5 133 0
 509 01f2 BC01      		movw r22,r24
 510 01f4 CD01      		movw r24,r26
 511               	/* epilogue start */
 512 01f6 2C96      		adiw r28,12
 513 01f8 0FB6      		in __tmp_reg__,__SREG__
 514 01fa F894      		cli
 515 01fc DEBF      		out __SP_H__,r29
 516 01fe 0FBE      		out __SREG__,__tmp_reg__
 517 0200 CDBF      		out __SP_L__,r28
 518 0202 DF91      		pop r29
 519 0204 CF91      		pop r28
 520 0206 0895      		ret
 521               		.cfi_endproc
 522               	.LFE108:
 525               	macsc_read_count:
 526               	.LFB114:
 134:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 135:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /* ! compare modes */
 136:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** #define MACSC_ABSOLUTE_CMP 0
 137:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** #define MACSC_RELATIVE_CMP 1
 138:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 139:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /** String concatenation by preprocessor used to create proper register names.
 140:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  **/
 141:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** #define CONCAT(a, b) a ## b
 142:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 143:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /** Creates proper subregister names and reads the corresponding values. */
 144:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** #define MACSC_READ32(reg)                  macsc_read32(&CONCAT(reg, HH), \
 145:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		&CONCAT(reg, HL), \
 146:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		&CONCAT(reg, LH), \
 147:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		&CONCAT(reg, LL))
 148:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 149:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** #define MACSC_WRITE32(reg, val)	\
 150:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	do { \
 151:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		union { uint8_t a[4]; uint32_t v; } \
 152:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		x; \
 153:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		x.v = val; \
 154:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		CONCAT(reg, HH) = x.a[3]; \
 155:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		CONCAT(reg, HL) = x.a[2]; \
 156:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		CONCAT(reg, LH) = x.a[1]; \
 157:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		CONCAT(reg, LL) = x.a[0]; \
 158:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	} \
 159:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	while (0)
 160:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 161:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 162:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Enable MAC SC
 163:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 164:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * Enables the SC
 165:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 166:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param clk_src selection of clk source,avalable options in macsc_xtal,fixed
 167:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *  prescalar
 168:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param sleep_enable enable RTC as clock source during sleep
 169:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param auto_ts enable automatic timestamping
 170:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 171:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 172:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** void macsc_enable(void);
 173:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 174:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 175:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Check if MACSC is enabled
 176:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 177:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * check if the MACSC is enabled.
 178:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 179:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param none
 180:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 181:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 182:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** bool is_macsc_enable(void);
 183:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 184:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 185:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Disable MAC SC
 186:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 187:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * Disables the MAC SC
 188:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 189:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param none
 190:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 191:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 192:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** void macsc_disable(void);
 193:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 194:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 195:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Check if back-off slot counter is enabled
 196:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 197:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * check if the back-off slot counter is enabled.
 198:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 199:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param none
 200:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 201:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 202:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** bool is_macsc_backoff_enable(void);
 203:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 204:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 205:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Enables compare interrupts of the MACSC
 206:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 207:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param channel Compare channel
 208:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 209:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** void macsc_enable_cmp_int(enum macsc_cc_channel channel);
 210:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 211:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 212:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Disables compare interrupts of the MACSC
 213:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 214:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param channel Compare channel
 215:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */void macsc_disable_cmp_int(enum macsc_cc_channel channel);
 216:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 217:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 218:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Usage of Absolute compare mode of the MACSC
 219:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 220:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param abs_rel  0 for absoulte cmp;1 for relative cmp
 221:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param cmp compare value for SCOCRx register
 222:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param channel Compare channel
 223:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 224:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** void macsc_use_cmp(bool abs_rel, uint32_t cmp,enum macsc_cc_channel channel);
 225:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 226:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 227:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \ingroup macsc_group
 228:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \defgroup macsc_interrupt_group MAC Symbol Counter (MACSC) interrupt
 229:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * management
 230:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * This group provides functions to configure MACSC module interrupts
 231:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 232:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * @{
 233:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 234:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 235:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 236:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Set MACSC overflow interrupt callback function
 237:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 238:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * This function allows the caller to set and change the interrupt callback
 239:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * function. Without setting a callback function the interrupt handler in the
 240:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * driver will only clear the interrupt flags.
 241:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 242:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param callback Reference to a callback function
 243:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 244:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** void macsc_set_ovf_int_cb(macsc_callback_t callback);
 245:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 246:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 247:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Set MACSC Compare Channel 1 interrupt callback function
 248:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 249:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * This function allows the caller to set and change the interrupt callback
 250:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * function. Without setting a callback function the interrupt handler in the
 251:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * driver will only clear the interrupt flags.
 252:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 253:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param callback Reference to a callback function
 254:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 255:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** void macsc_set_cmp1_int_cb(macsc_callback_t callback);
 256:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 257:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 258:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Set MACSC Compare Channel 2 interrupt callback function
 259:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 260:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * This function allows the caller to set and change the interrupt callback
 261:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * function. Without setting a callback function the interrupt handler in the
 262:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * driver will only clear the interrupt flags.
 263:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 264:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param callback Reference to a callback function
 265:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 266:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** void macsc_set_cmp2_int_cb(macsc_callback_t callback);
 267:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 268:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 269:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Set MACSC Compare Channel 3 interrupt callback function
 270:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 271:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * This function allows the caller to set and change the interrupt callback
 272:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * function. Without setting a callback function the interrupt handler in the
 273:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * driver will only clear the interrupt flags.
 274:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 275:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param callback Reference to a callback function
 276:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 277:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** void macsc_set_cmp3_int_cb(macsc_callback_t callback);
 278:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 279:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 280:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Set MACSC backoff slot counter interrupt callback function
 281:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 282:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * This function allows the caller to set and change the interrupt callback
 283:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * function. Without setting a callback function the interrupt handler in the
 284:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * driver will only clear the interrupt flags.
 285:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 286:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param callback Reference to a callback function
 287:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 288:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** void macsc_set_backoff_slot_cntr_int_cb(macsc_callback_t callback);
 289:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** //@}
 290:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 291:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 292:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Enable 32.768KHz clk using timer 2 async register
 293:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 294:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param none
 295:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 296:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 297:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** static inline void macsc_sleep_clk_enable(void)
 298:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** {
 299:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	ASSR |= (1 << AS2);
 300:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** }
 301:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 302:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 303:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Disable 32.768KHz clk using timer 2 async register
 304:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 305:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param none
 306:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 307:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** static inline void macsc_sleep_clk_disable(void)
 308:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** {
 309:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	ASSR &= ~(1 << AS2);
 310:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** }
 311:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 312:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /* @} */
 313:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 314:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 315:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Configure MAC Symbol Counter Clock Source
 316:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 317:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param macsc macsc clk src
 318:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 319:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** static inline void macsc_write_clock_source(enum macsc_xtal source)
 320:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** {
 321:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	if (source == MACSC_16MHz) {
 322:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		SCCR0 |= (source << SCCKSEL);
 323:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	} else if (source == MACSC_32KHz) {
 324:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		SCCR0 &= ~(1 << SCCKSEL);
 325:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	}
 326:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** }
 327:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 328:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 329:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Read MAC SC Clock Source
 330:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 331:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param none
 332:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \return macsc_xtal enum Clock source selection
 333:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 334:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** static inline enum macsc_xtal macsc_read_clock_source(void)
 335:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** {
 336:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	return (enum macsc_xtal)(SCCR0 & (1 << SCCKSEL));
 337:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** }
 338:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 339:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 340:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Write the Counter value of the MAC Symbol counter
 341:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 342:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param cnt_value Counter value
 343:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 344:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** static inline void macsc_write_count(uint32_t cnt_value)
 345:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** {
 346:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	MACSC_WRITE32(SCCNT, cnt_value);
 347:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** }
 348:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 349:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 350:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Reads the Counter value of the MAC Symbol counter
 351:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 352:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \note Output the Counter value
 353:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 354:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** static inline uint32_t macsc_read_count(void)
 355:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** {
 527               		.loc 5 355 0
 528               		.cfi_startproc
 529 0208 CF93      		push r28
 530               	.LCFI30:
 531               		.cfi_def_cfa_offset 3
 532               		.cfi_offset 28, -2
 533 020a DF93      		push r29
 534               	.LCFI31:
 535               		.cfi_def_cfa_offset 4
 536               		.cfi_offset 29, -3
 537 020c CDB7      		in r28,__SP_L__
 538 020e DEB7      		in r29,__SP_H__
 539               	.LCFI32:
 540               		.cfi_def_cfa_register 28
 541               	/* prologue: function */
 542               	/* frame size = 0 */
 543               	/* stack size = 2 */
 544               	.L__stack_usage = 2
 356:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	return (MACSC_READ32(SCCNT));
 545               		.loc 5 356 0
 546 0210 21EE      		ldi r18,lo8(-31)
 547 0212 30E0      		ldi r19,0
 548 0214 42EE      		ldi r20,lo8(-30)
 549 0216 50E0      		ldi r21,0
 550 0218 63EE      		ldi r22,lo8(-29)
 551 021a 70E0      		ldi r23,0
 552 021c 84EE      		ldi r24,lo8(-28)
 553 021e 90E0      		ldi r25,0
 554 0220 0E94 0000 		call macsc_read32
 555 0224 DC01      		movw r26,r24
 556 0226 CB01      		movw r24,r22
 357:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** }
 557               		.loc 5 357 0
 558 0228 BC01      		movw r22,r24
 559 022a CD01      		movw r24,r26
 560               	/* epilogue start */
 561 022c DF91      		pop r29
 562 022e CF91      		pop r28
 563 0230 0895      		ret
 564               		.cfi_endproc
 565               	.LFE114:
 568               	macsc_enable_manual_bts:
 569               	.LFB121:
 358:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 359:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 360:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief enable back-off slot counter
 361:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 362:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param none
 363:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \note  Enables interrupt as well	.
 364:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \note This counter works only if transceiver clock is running.So check Trx
 365:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * state in app before using this function in IEEE802.15.4 applications.
 366:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 367:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** static inline bool macsc_backoff_slot_cnt_enable(void)
 368:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** {
 369:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	if (!(PRR1 & (1 << PRTRX24))) {
 370:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		SCCR1 = (1 << SCENBO);
 371:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		SCIRQS |= (1 << IRQSBO);
 372:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		SCIRQM |= (1 << IRQMBO);
 373:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		return true;
 374:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	}
 375:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	else return false;
 376:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** }
 377:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 378:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 379:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Disable back-off slot counter
 380:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 381:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param none
 382:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \note    Disables interrupt as well	.
 383:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \note This counter works only if transceiver clock is running.So check Trx
 384:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * state in app before using this function in IEEE802.15.4 applications.
 385:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 386:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** static inline void macsc_backoff_slot_cnt_disable(void)
 387:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** {
 388:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	SCCR1 &= ~(1 << SCENBO);
 389:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	SCIRQM &= ~(1 << IRQMBO);
 390:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** }
 391:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 392:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 393:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Tests if the Backoff slot cntr interrupt flag is set
 394:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 395:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \return  backoff slot cntr interrupt has occurred or not : IRQSBO
 396:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 397:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** static inline bool macsc_is_slot_cntr_interrupt_flag_set(void)
 398:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** {
 399:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	return (SCIRQS & (1 << IRQSBO));
 400:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** }
 401:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 402:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 403:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Clears the Backoff Slot cntr interrupt flag
 404:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 405:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \note  IRQSBO is cleared
 406:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 407:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** static inline void macsc_clear_slot_cntr_interrupt_flag(void)
 408:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** {
 409:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	SCIRQS |= (1 << IRQSBO);
 410:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** }
 411:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 412:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 413:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Reads the SFD Timestamp register
 414:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 415:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \return Timestamp of last received frame :SCTSR(read-only register)
 416:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 417:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** static inline uint32_t macsc_read_ts(void)
 418:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** {
 419:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	return (MACSC_READ32(SCTSR));
 420:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** }
 421:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 422:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 423:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Reads the Beacon Timestamp register
 424:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 425:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \return Timestamp of last received beacon frame :SCBTSR
 426:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 427:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** static inline uint32_t macsc_read_bts(void)
 428:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** {
 429:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	return (MACSC_READ32(SCBTSR));
 430:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** }
 431:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 432:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 433:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Write the Beacon Timestamp register of the MAC Symbol counter
 434:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * The manual beacon timestamping can be used in conjunction with the
 435:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * relative compare mode of the three compare units to generate compare match
 436:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * interrupts without having a beacon frame received
 437:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 438:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * If set to 1, the current symbol counter value is stored into the beacon
 439:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * timestamp register.
 440:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * The bit is cleared afterwards.
 441:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 442:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 443:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** static inline void macsc_enable_manual_bts(void)
 444:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** {
 570               		.loc 5 444 0
 571               		.cfi_startproc
 572 0232 CF93      		push r28
 573               	.LCFI33:
 574               		.cfi_def_cfa_offset 3
 575               		.cfi_offset 28, -2
 576 0234 DF93      		push r29
 577               	.LCFI34:
 578               		.cfi_def_cfa_offset 4
 579               		.cfi_offset 29, -3
 580 0236 CDB7      		in r28,__SP_L__
 581 0238 DEB7      		in r29,__SP_H__
 582               	.LCFI35:
 583               		.cfi_def_cfa_register 28
 584               	/* prologue: function */
 585               	/* frame size = 0 */
 586               	/* stack size = 2 */
 587               	.L__stack_usage = 2
 445:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	SCCR0 |= (1 << SCMBTS);
 588               		.loc 5 445 0
 589 023a 8CED      		ldi r24,lo8(-36)
 590 023c 90E0      		ldi r25,0
 591 023e 2CED      		ldi r18,lo8(-36)
 592 0240 30E0      		ldi r19,0
 593 0242 F901      		movw r30,r18
 594 0244 2081      		ld r18,Z
 595 0246 2064      		ori r18,lo8(64)
 596 0248 FC01      		movw r30,r24
 597 024a 2083      		st Z,r18
 446:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	SCCR0 &= ~(1 << SCTSE);
 598               		.loc 5 446 0
 599 024c 8CED      		ldi r24,lo8(-36)
 600 024e 90E0      		ldi r25,0
 601 0250 2CED      		ldi r18,lo8(-36)
 602 0252 30E0      		ldi r19,0
 603 0254 F901      		movw r30,r18
 604 0256 2081      		ld r18,Z
 605 0258 277F      		andi r18,lo8(-9)
 606 025a FC01      		movw r30,r24
 607 025c 2083      		st Z,r18
 447:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** }
 608               		.loc 5 447 0
 609 025e 0000      		nop
 610               	/* epilogue start */
 611 0260 DF91      		pop r29
 612 0262 CF91      		pop r28
 613 0264 0895      		ret
 614               		.cfi_endproc
 615               	.LFE121:
 617               	.global	appState
 618               		.section	.bss.appState,"aw",@nobits
 621               	appState:
 622 0000 00        		.zero	1
 623               		.section	.bss.msgReq,"aw",@nobits
 626               	msgReq:
 627 0000 0000 0000 		.zero	20
 627      0000 0000 
 627      0000 0000 
 627      0000 0000 
 627      0000 0000 
 628               		.section	.bss.PanId,"aw",@nobits
 631               	PanId:
 632 0000 00        		.zero	1
 633               		.section	.rodata
 634               	.LC1:
 635 0000 0A20 2042 		.string	"\n  BEACON "
 635      4541 434F 
 635      4E20 00
 636               		.text
 637               	.global	appSendData
 639               	appSendData:
 640               	.LFB130:
 641               		.file 6 "ServerLLDN.c"
   1:ServerLLDN.c  **** /*
   2:ServerLLDN.c  **** 	* ServerLLDN.c
   3:ServerLLDN.c  **** 	*
   4:ServerLLDN.c  **** 	* Created: 10/18/2019 5:15:37 PM
   5:ServerLLDN.c  **** 	*  Author: guilherme
   6:ServerLLDN.c  **** 	*/ 
   7:ServerLLDN.c  **** 
   8:ServerLLDN.c  **** #include <stdlib.h>
   9:ServerLLDN.c  **** #include <stdio.h>
  10:ServerLLDN.c  **** #include <string.h>
  11:ServerLLDN.c  **** #include <inttypes.h>
  12:ServerLLDN.c  **** #include "config.h"
  13:ServerLLDN.c  **** #include "sys.h"
  14:ServerLLDN.c  **** #include "phy.h"
  15:ServerLLDN.c  **** #include "sys.h"
  16:ServerLLDN.c  **** #include "nwk.h"
  17:ServerLLDN.c  **** #include "sysclk.h"
  18:ServerLLDN.c  **** #include "sysTimer.h"
  19:ServerLLDN.c  **** #include "sleep_mgr.h"
  20:ServerLLDN.c  **** #include "sleepmgr.h"
  21:ServerLLDN.c  **** #include "led.h"
  22:ServerLLDN.c  **** #include "ioport.h"
  23:ServerLLDN.c  **** #include "conf_sleepmgr.h"
  24:ServerLLDN.c  **** #include "board.h"
  25:ServerLLDN.c  **** #include "platform.h"
  26:ServerLLDN.c  **** 
  27:ServerLLDN.c  **** #include "lldn.h"
  28:ServerLLDN.c  **** 
  29:ServerLLDN.c  **** #if 1
  30:ServerLLDN.c  **** #if (SIO2HOST_CHANNEL == SIO_USB)
  31:ServerLLDN.c  **** /* Only ARM */
  32:ServerLLDN.c  **** #include "hw_timer_lldn.h"
  33:ServerLLDN.c  **** #include "stdio_usb.h"
  34:ServerLLDN.c  **** #define MASTER_MACSC	0
  35:ServerLLDN.c  **** #else
  36:ServerLLDN.c  **** /* Only megarf series */
  37:ServerLLDN.c  **** #include "conf_sio2host.h"
  38:ServerLLDN.c  **** #define MASTER_MACSC	1
  39:ServerLLDN.c  **** #endif
  40:ServerLLDN.c  **** #else
  41:ServerLLDN.c  **** /* Only megarf series */
  42:ServerLLDN.c  **** #define MASTER_MACSC		1
  43:ServerLLDN.c  **** #endif
  44:ServerLLDN.c  **** 
  45:ServerLLDN.c  **** #define HUMAM_READABLE			1
  46:ServerLLDN.c  **** 
  47:ServerLLDN.c  **** #if (MASTER_MACSC == 1)
  48:ServerLLDN.c  **** #include "macsc_megarf.h"
  49:ServerLLDN.c  **** #define TIMESLOT_TIMER 0
  50:ServerLLDN.c  **** #else
  51:ServerLLDN.c  **** static SYS_Timer_t				tmrBeaconInterval;			// Beacon
  52:ServerLLDN.c  **** static SYS_Timer_t				tmrComputeData;				// Compute data
  53:ServerLLDN.c  **** #endif
  54:ServerLLDN.c  **** 
  55:ServerLLDN.c  **** #define PRINT 1
  56:ServerLLDN.c  **** 
  57:ServerLLDN.c  **** 	
  58:ServerLLDN.c  **** // equation for tTS gives time in seconds, the division by SYMBOL_TIME changes to symbols for count
  59:ServerLLDN.c  **** AppState_t	appState = APP_STATE_INITIAL;
  60:ServerLLDN.c  **** static NWK_DataReq_t msgReq;
  61:ServerLLDN.c  **** static uint8_t PanId;
  62:ServerLLDN.c  **** 
  63:ServerLLDN.c  ****  void appSendData(void)
  64:ServerLLDN.c  **** {
 642               		.loc 6 64 0
 643               		.cfi_startproc
 644 0266 CF93      		push r28
 645               	.LCFI36:
 646               		.cfi_def_cfa_offset 3
 647               		.cfi_offset 28, -2
 648 0268 DF93      		push r29
 649               	.LCFI37:
 650               		.cfi_def_cfa_offset 4
 651               		.cfi_offset 29, -3
 652 026a CDB7      		in r28,__SP_L__
 653 026c DEB7      		in r29,__SP_H__
 654               	.LCFI38:
 655               		.cfi_def_cfa_register 28
 656               	/* prologue: function */
 657               	/* frame size = 0 */
 658               	/* stack size = 2 */
 659               	.L__stack_usage = 2
  65:ServerLLDN.c  **** 	if(msgReq.options != 0)
 660               		.loc 6 65 0
 661 026e 8091 0000 		lds r24,msgReq+9
 662 0272 9091 0000 		lds r25,msgReq+9+1
 663 0276 892B      		or r24,r25
 664 0278 01F0      		breq .L22
  66:ServerLLDN.c  **** 	{
  67:ServerLLDN.c  **** 		NWK_DataReq(&msgReq);
 665               		.loc 6 67 0
 666 027a 80E0      		ldi r24,lo8(msgReq)
 667 027c 90E0      		ldi r25,hi8(msgReq)
 668 027e 0E94 0000 		call NWK_DataReq
  68:ServerLLDN.c  **** 		#if PRINT
  69:ServerLLDN.c  **** 		if(msgReq.options & NWK_OPT_ONLINE_STATE)
 669               		.loc 6 69 0
 670 0282 8091 0000 		lds r24,msgReq+9
 671 0286 9091 0000 		lds r25,msgReq+9+1
 672 028a 8078      		andi r24,128
 673 028c 9927      		clr r25
 674 028e 892B      		or r24,r25
 675 0290 01F0      		breq .L21
  70:ServerLLDN.c  **** 			printf("\n  BEACON ");
 676               		.loc 6 70 0
 677 0292 80E0      		ldi r24,lo8(.LC1)
 678 0294 90E0      		ldi r25,hi8(.LC1)
 679 0296 892F      		mov r24,r25
 680 0298 8F93      		push r24
 681 029a 80E0      		ldi r24,lo8(.LC1)
 682 029c 90E0      		ldi r25,hi8(.LC1)
 683 029e 8F93      		push r24
 684 02a0 0E94 0000 		call printf
 685 02a4 0F90      		pop __tmp_reg__
 686 02a6 0F90      		pop __tmp_reg__
 687               	.L21:
  71:ServerLLDN.c  **** 		//printf("\nREQ %d",msgReq.options);
  72:ServerLLDN.c  **** 		#endif
  73:ServerLLDN.c  **** 	#if !APP_COORDINATOR
  74:ServerLLDN.c  **** 			macsc_set_cmp2_int_cb(0);
 688               		.loc 6 74 0
 689 02a8 80E0      		ldi r24,0
 690 02aa 90E0      		ldi r25,0
 691 02ac 0E94 0000 		call macsc_set_cmp2_int_cb
 692               	.L22:
  75:ServerLLDN.c  **** 	#endif
  76:ServerLLDN.c  **** 	}
  77:ServerLLDN.c  **** }
 693               		.loc 6 77 0
 694 02b0 0000      		nop
 695               	/* epilogue start */
 696 02b2 DF91      		pop r29
 697 02b4 CF91      		pop r28
 698 02b6 0895      		ret
 699               		.cfi_endproc
 700               	.LFE130:
 702               	.global	payloadSize
 703               		.section	.data.payloadSize,"aw",@progbits
 706               	payloadSize:
 707 0000 32        		.byte	50
 708               	.global	assTimeSlot
 709               		.section	.data.assTimeSlot,"aw",@progbits
 712               	assTimeSlot:
 713 0000 FF        		.byte	-1
 714               	.global	data_payload
 715               		.section	.data.data_payload,"aw",@progbits
 718               	data_payload:
 719 0000 01        		.byte	1
 720               		.comm	rec_beacon,8,1
 721               		.comm	ackframe,2,1
 722               		.section	.data.msgDiscResponse,"aw",@progbits
 725               	msgDiscResponse:
 726 0000 0D        		.byte	13
 727 0001 01        		.byte	1
 728 0002 B2        		.byte	178
 729               		.section	.data.msgConfigStatus,"aw",@progbits
 732               	msgConfigStatus:
 733 0000 0E        		.byte	14
 734 0001 01        		.byte	1
 735 0002 FF        		.byte	-1
 736 0003 01        		.byte	1
 737 0004 B2        		.byte	178
 738               		.section	.data.msgReqDiscResponse,"aw",@progbits
 741               	msgReqDiscResponse:
 742 0000 0000 0000 		.zero	5
 742      00
 743 0005 0000      		.word	0
 744 0007 03        		.byte	3
 745 0008 03        		.byte	3
 746 0009 0080      		.word	-32768
 747 000b 0000      		.zero	2
 748 000d 0000      		.word	msgDiscResponse
 749 000f 03        		.byte	3
 750 0010 0000 0000 		.zero	4
 751               		.section	.data.msgReqConfigStatus,"aw",@progbits
 754               	msgReqConfigStatus:
 755 0000 0000 0000 		.zero	5
 755      00
 756 0005 0000      		.word	0
 757 0007 03        		.byte	3
 758 0008 03        		.byte	3
 759 0009 0080      		.word	-32768
 760 000b 0000      		.zero	2
 761 000d 0000      		.word	msgConfigStatus
 762 000f 05        		.byte	5
 763 0010 0000 0000 		.zero	4
 764               		.section	.data.msgReqData,"aw",@progbits
 767               	msgReqData:
 768 0000 0000 0000 		.zero	5
 768      00
 769 0005 0000      		.word	0
 770 0007 03        		.byte	3
 771 0008 03        		.byte	3
 772 0009 0020      		.word	8192
 773 000b 0000      		.zero	2
 774 000d 0000      		.word	data_payload
 775 000f 01        		.byte	1
 776 0010 0000 0000 		.zero	4
 777               		.section	.bss.ack_received,"aw",@nobits
 780               	ack_received:
 781 0000 00        		.zero	1
 782               	.global	MacLLDNMgmtTS
 783               		.section	.bss.MacLLDNMgmtTS,"aw",@nobits
 786               	MacLLDNMgmtTS:
 787 0000 00        		.zero	1
 788               	.global	associated
 789               		.section	.bss.associated,"aw",@nobits
 792               	associated:
 793 0000 00        		.zero	1
 794               		.comm	ts_time,2,1
 795               	.global	STATE
 796               		.section	.data.STATE,"aw",@progbits
 799               	STATE:
 800 0000 04        		.byte	4
 801               	.global	tmr_error
 802               		.section	.bss.tmr_error,"aw",@nobits
 805               	tmr_error:
 806 0000 0000      		.zero	2
 807               	.global	delta_error
 808               		.section	.bss.delta_error,"aw",@nobits
 811               	delta_error:
 812 0000 0000 0000 		.zero	4
 813               	.global	beacon_tmr
 814               		.section	.bss.beacon_tmr,"aw",@nobits
 817               	beacon_tmr:
 818 0000 00        		.zero	1
 819               	.global	be_read
 820               		.section	.bss.be_read,"aw",@nobits
 823               	be_read:
 824 0000 0000 0000 		.zero	4
 825               	.global	tmr_read
 826               		.section	.bss.tmr_read,"aw",@nobits
 829               	tmr_read:
 830 0000 0000 0000 		.zero	4
 831               		.comm	msg_wait_time,2,1
 832               	.global	ok_seq
 833               		.section	.data.ok_seq,"aw",@progbits
 836               	ok_seq:
 837 0000 FFFF      		.word	-1
 838               		.text
 840               	send_message_timeHandler:
 841               	.LFB131:
  78:ServerLLDN.c  **** 
  79:ServerLLDN.c  **** #if APP_COORDINATOR
  80:ServerLLDN.c  **** 
  81:ServerLLDN.c  **** 	#define NODOS_ASSOCIADOS_ESPERADOS 12
  82:ServerLLDN.c  **** 	int accepting_requests = 1;
  83:ServerLLDN.c  **** 	AppPanState_t appPanState = APP_PAN_STATE_RESET; // Initial state of PAN node
  84:ServerLLDN.c  **** 	
  85:ServerLLDN.c  **** 	/* Configuration Request Frames */
  86:ServerLLDN.c  **** 	/* Da pra mudar o envio do confrequest pra ja usar essa array com as informas dos nodos */	
  87:ServerLLDN.c  **** 	nodes_info_t nodes_info_arr[50]; // Array for Configure Request messages, one position per node, 2
  88:ServerLLDN.c  **** 	NWK_ConfigRequest_t config_request_frame = { .id = LL_CONFIGURATION_REQUEST,
  89:ServerLLDN.c  **** 												 .s_macAddr = APP_ADDR,
  90:ServerLLDN.c  **** 												 .tx_channel = APP_CHANNEL,
  91:ServerLLDN.c  **** 												 .conf.macLLDNmgmtTS = MacLLDNMgmtTS };
  92:ServerLLDN.c  **** 
  93:ServerLLDN.c  **** 
  94:ServerLLDN.c  **** 
  95:ServerLLDN.c  **** 	nodes_info_list_t *conf_req_list = NULL;
  96:ServerLLDN.c  **** 	uint8_t stack_conf_req[20];
  97:ServerLLDN.c  **** 	
  98:ServerLLDN.c  **** 	/* Acknowledge Frame and Array */
  99:ServerLLDN.c  **** 	NWK_ACKFormat_t ACKFrame;	
 100:ServerLLDN.c  **** 	NWK_ACKFormat_t ACKFrame_aux;
 101:ServerLLDN.c  **** 	
 102:ServerLLDN.c  **** 	int ACKFrame_size = 0;
 103:ServerLLDN.c  **** 	
 104:ServerLLDN.c  **** 
 105:ServerLLDN.c  **** 	float beaconInterval = 0; // no precisa ser global
 106:ServerLLDN.c  **** 	float beaconInterval_association = 0;
 107:ServerLLDN.c  **** 	
 108:ServerLLDN.c  **** 	/* This timer implements a delay between messages, 
 109:ServerLLDN.c  **** 	 * if not used the nodes are not able to receive the message
 110:ServerLLDN.c  **** 	 */
 111:ServerLLDN.c  **** 	static SYS_Timer_t tmrDelay;	
 112:ServerLLDN.c  **** 	
 113:ServerLLDN.c  **** 	/*  Control variables for testing */	
 114:ServerLLDN.c  **** 	int assTimeSlot = 0;
 115:ServerLLDN.c  **** 
 116:ServerLLDN.c  **** 	int counter_associados = 0;		// Associated nodes counter
 117:ServerLLDN.c  **** 	uint8_t cycles_counter = macLLDNdiscoveryModeTimeout;
 118:ServerLLDN.c  **** 
 119:ServerLLDN.c  **** 	bool association_request = false;
 120:ServerLLDN.c  **** 
 121:ServerLLDN.c  **** 	/* data related variables */
 122:ServerLLDN.c  **** 	msg_info_t msg_info_array[50]; // size of array limited by hardware
 123:ServerLLDN.c  **** 	unsigned int size_msg_info = 0;
 124:ServerLLDN.c  **** 	bool data_received = false;	
 125:ServerLLDN.c  **** 	float PLR = 0;
 126:ServerLLDN.c  **** 	float PER = 0;
 127:ServerLLDN.c  **** 	uint8_t retransmit_ts_array[32];
 128:ServerLLDN.c  **** 	int retransmit_ts_array_counter = 0;
 129:ServerLLDN.c  **** 	
 130:ServerLLDN.c  **** 	int counter_delay_msg = 0;
 131:ServerLLDN.c  **** 	uint32_t cmp_value_start_superframe = 0;
 132:ServerLLDN.c  **** 	
 133:ServerLLDN.c  **** 	static NWK_DataReq_t msgReqGACK = { .dstAddr = 0,
 134:ServerLLDN.c  **** 										.dstEndpoint = APP_BEACON_ENDPOINT,
 135:ServerLLDN.c  **** 										.srcEndpoint = APP_BEACON_ENDPOINT,
 136:ServerLLDN.c  **** 										.options = NWK_OPT_LLDN_ACK,
 137:ServerLLDN.c  **** 										.data = (uint8_t*)&ACKFrame};
 138:ServerLLDN.c  **** 
 139:ServerLLDN.c  **** 	
 140:ServerLLDN.c  **** 	static void tmrDelayHandler(SYS_Timer_t *timer)
 141:ServerLLDN.c  **** 	{
 142:ServerLLDN.c  **** 		#if PRINT
 143:ServerLLDN.c  **** 		// printf("\ndelay handler");
 144:ServerLLDN.c  **** 		#endif
 145:ServerLLDN.c  **** 		appState = APP_STATE_SEND;
 146:ServerLLDN.c  **** 	}
 147:ServerLLDN.c  **** 	
 148:ServerLLDN.c  **** 	static void lldn_server_beacon(void)
 149:ServerLLDN.c  **** 	{
 150:ServerLLDN.c  **** 		macsc_enable_manual_bts();
 151:ServerLLDN.c  **** 		appState = APP_STATE_SEND;
 152:ServerLLDN.c  **** 	}
 153:ServerLLDN.c  **** 	
 154:ServerLLDN.c  **** 
 155:ServerLLDN.c  **** 	static void downlink_delay_handler(void)
 156:ServerLLDN.c  **** 	{
 157:ServerLLDN.c  **** 		if(msgReq.options == NWK_OPT_MAC_COMMAND)
 158:ServerLLDN.c  **** 		{
 159:ServerLLDN.c  **** 			counter_delay_msg++;
 160:ServerLLDN.c  **** 			appState = APP_STATE_SEND;
 161:ServerLLDN.c  **** 		}
 162:ServerLLDN.c  **** 	}
 163:ServerLLDN.c  **** 
 164:ServerLLDN.c  **** 	static void end_of_association_delay_handler(void)
 165:ServerLLDN.c  **** 	{
 166:ServerLLDN.c  **** 		appState = APP_STATE_ATT_PAN_STATE;
 167:ServerLLDN.c  **** 		appPanState = APP_PAN_STATE_ONLINE_INITIAL;
 168:ServerLLDN.c  **** 	}
 169:ServerLLDN.c  **** 	
 170:ServerLLDN.c  **** 	#if TIMESLOT_TIMER
 171:ServerLLDN.c  **** 	static void teste_handler(void)
 172:ServerLLDN.c  **** 	{
 173:ServerLLDN.c  **** 		if(msgReq.options)
 174:ServerLLDN.c  **** 			// printf("\n***TIMESLOT****");
 175:ServerLLDN.c  **** 		macsc_disable_cmp_int(MACSC_CC3);
 176:ServerLLDN.c  **** 	}
 177:ServerLLDN.c  **** 	#endif
 178:ServerLLDN.c  **** 	
 179:ServerLLDN.c  **** 	static bool addToAckArray(uint8_t addres)
 180:ServerLLDN.c  **** 	{	
 181:ServerLLDN.c  **** 		int pos,bit_shift;
 182:ServerLLDN.c  **** 		if(addres == 8)
 183:ServerLLDN.c  **** 		{
 184:ServerLLDN.c  **** 			pos = 0;
 185:ServerLLDN.c  **** 			bit_shift = 0;
 186:ServerLLDN.c  **** 		}
 187:ServerLLDN.c  **** 		else
 188:ServerLLDN.c  **** 		{
 189:ServerLLDN.c  **** 			pos =  addres / 8;
 190:ServerLLDN.c  **** 			bit_shift = 8 - addres % 8;
 191:ServerLLDN.c  **** 		}
 192:ServerLLDN.c  **** 		if(ACKFrame.ackFlags[pos] & 1 << bit_shift)
 193:ServerLLDN.c  **** 		{
 194:ServerLLDN.c  **** 			// printf("\nAddr rep %d", addres);
 195:ServerLLDN.c  **** 			return false;
 196:ServerLLDN.c  **** 		}
 197:ServerLLDN.c  **** 		ACKFrame.ackFlags[pos] |= 1 << bit_shift;
 198:ServerLLDN.c  **** 		if (pos + 1 > ACKFrame_size)
 199:ServerLLDN.c  **** 			ACKFrame_size = pos + 1;
 200:ServerLLDN.c  **** 		// printf("ACK, %hhx", ACKFrame.ackFlags[pos]);
 201:ServerLLDN.c  **** 		return true;
 202:ServerLLDN.c  **** 	}
 203:ServerLLDN.c  **** 
 204:ServerLLDN.c  **** 	static void addConfRequestArray(NWK_ConfigStatus_t *node)
 205:ServerLLDN.c  **** 	{
 206:ServerLLDN.c  **** 
 207:ServerLLDN.c  **** 		uint8_t i;
 208:ServerLLDN.c  **** 		for (int j = 0; j <= assTimeSlot ; j++)
 209:ServerLLDN.c  **** 		{
 210:ServerLLDN.c  **** 			if (nodes_info_arr[j].mac_addr == node->macAddr)
 211:ServerLLDN.c  **** 			{	
 212:ServerLLDN.c  **** 				return false;
 213:ServerLLDN.c  **** 			}
 214:ServerLLDN.c  **** 		}
 215:ServerLLDN.c  **** 		for (i= 0;i < 256 && nodes_info_arr[i].mac_addr != 0; i++);
 216:ServerLLDN.c  **** 		
 217:ServerLLDN.c  **** 		assTimeSlot++;
 218:ServerLLDN.c  **** 	
 219:ServerLLDN.c  **** 		if(node->ts_dir.tsDuration > config_request_frame.conf.tsDuration)
 220:ServerLLDN.c  **** 			config_request_frame.conf.tsDuration =  node->ts_dir.tsDuration;
 221:ServerLLDN.c  **** 		
 222:ServerLLDN.c  **** 		nodes_info_arr[i].req_timeslot_duration = node->ts_dir.tsDuration;
 223:ServerLLDN.c  **** 		nodes_info_arr[i].mac_addr = node->macAddr;
 224:ServerLLDN.c  **** 		nodes_info_arr[i].assigned_time_slot = (uint8_t)i;
 225:ServerLLDN.c  **** 		
 226:ServerLLDN.c  **** // 		stack_conf_req
 227:ServerLLDN.c  **** 		if(conf_req_list != NULL)
 228:ServerLLDN.c  **** 		{
 229:ServerLLDN.c  **** 			nodes_info_list_t *tmp = (nodes_info_list_t*)malloc(sizeof(nodes_info_list_t));
 230:ServerLLDN.c  **** 			tmp->node = &nodes_info_arr[i];
 231:ServerLLDN.c  **** 			tmp->next = conf_req_list;
 232:ServerLLDN.c  **** 			conf_req_list = tmp;
 233:ServerLLDN.c  **** 		}
 234:ServerLLDN.c  **** 		else
 235:ServerLLDN.c  **** 		{
 236:ServerLLDN.c  **** 			conf_req_list = (nodes_info_list_t*)malloc(sizeof(nodes_info_list_t));
 237:ServerLLDN.c  **** 			conf_req_list->node = &nodes_info_arr[i];
 238:ServerLLDN.c  **** 			conf_req_list->next = NULL;
 239:ServerLLDN.c  **** 		}
 240:ServerLLDN.c  **** 	}
 241:ServerLLDN.c  **** 
 242:ServerLLDN.c  **** 	static bool CopyToConfigRequest()
 243:ServerLLDN.c  **** 	{
 244:ServerLLDN.c  **** 		if(conf_req_list->node == NULL)
 245:ServerLLDN.c  **** 			return false;
 246:ServerLLDN.c  **** 		config_request_frame.assTimeSlot = conf_req_list->node->assigned_time_slot;
 247:ServerLLDN.c  **** 		config_request_frame.macAddr = conf_req_list->node->mac_addr;
 248:ServerLLDN.c  **** 		nodes_info_list_t *tmp = conf_req_list;
 249:ServerLLDN.c  **** 		conf_req_list = conf_req_list->next;
 250:ServerLLDN.c  **** 		tmp->node = NULL;
 251:ServerLLDN.c  **** 		tmp->next = NULL;
 252:ServerLLDN.c  **** 		free(tmp);
 253:ServerLLDN.c  **** 		return true;
 254:ServerLLDN.c  **** 	}
 255:ServerLLDN.c  **** 
 256:ServerLLDN.c  **** 
 257:ServerLLDN.c  **** 	static bool appCommandInd(NWK_DataInd_t *ind)
 258:ServerLLDN.c  **** 	{
 259:ServerLLDN.c  **** 		if(!accepting_requests) return false;
 260:ServerLLDN.c  **** 		// if(n <127) return false;
 261:ServerLLDN.c  **** 		if(ind->data[0] == LL_DISCOVER_RESPONSE)
 262:ServerLLDN.c  **** 		{
 263:ServerLLDN.c  **** 			NWK_DiscoverResponse_t *msg = (NWK_DiscoverResponse_t*)ind->data;
 264:ServerLLDN.c  **** 			addToAckArray(msg->macAddr);	
 265:ServerLLDN.c  **** 					
 266:ServerLLDN.c  **** 			#if PRINT
 267:ServerLLDN.c  **** 			uint32_t tmp = macsc_read_count();
 268:ServerLLDN.c  **** // 			printf("\n%" PRIu32 " ", tmp);			
 269:ServerLLDN.c  ****  			// printf(" DISC %hhx", msg->macAddr);	
 270:ServerLLDN.c  **** 			#endif
 271:ServerLLDN.c  **** 		}
 272:ServerLLDN.c  **** 		else if(ind->data[0] == LL_CONFIGURATION_STATUS)
 273:ServerLLDN.c  **** 		{
 274:ServerLLDN.c  **** 			NWK_ConfigStatus_t *msg = (NWK_ConfigStatus_t*)ind->data;
 275:ServerLLDN.c  **** 			addConfRequestArray(msg);
 276:ServerLLDN.c  **** 			#if PRINT
 277:ServerLLDN.c  **** 			// printf("\nCONF %d", msg->macAddr);	
 278:ServerLLDN.c  **** 			#endif
 279:ServerLLDN.c  **** 		}
 280:ServerLLDN.c  **** 		else return false;			
 281:ServerLLDN.c  **** 		return true;
 282:ServerLLDN.c  **** 	}
 283:ServerLLDN.c  **** 	
 284:ServerLLDN.c  **** 	bool check_ack_pan(int addr)
 285:ServerLLDN.c  **** 	{
 286:ServerLLDN.c  **** 		int pos,bit_shift;
 287:ServerLLDN.c  **** 		if(addr == 8)
 288:ServerLLDN.c  **** 		{
 289:ServerLLDN.c  **** 			pos = 0;
 290:ServerLLDN.c  **** 			bit_shift = 0;
 291:ServerLLDN.c  **** 		}
 292:ServerLLDN.c  **** 		else
 293:ServerLLDN.c  **** 		{
 294:ServerLLDN.c  **** 			pos =  addr / 8;
 295:ServerLLDN.c  **** 			bit_shift = 8 - addr % 8;
 296:ServerLLDN.c  **** 		}
 297:ServerLLDN.c  **** 		if( ACKFrame.ackFlags[pos] & 1 << bit_shift)
 298:ServerLLDN.c  **** 		{
 299:ServerLLDN.c  **** 			return true;
 300:ServerLLDN.c  **** 		}
 301:ServerLLDN.c  **** 		else
 302:ServerLLDN.c  **** 			return false;
 303:ServerLLDN.c  **** 	}
 304:ServerLLDN.c  **** 	
 305:ServerLLDN.c  **** 	bool check_ack_aux(int addr)
 306:ServerLLDN.c  **** 	{
 307:ServerLLDN.c  **** 		int pos,bit_shift;
 308:ServerLLDN.c  **** 		if(addr == 8)
 309:ServerLLDN.c  **** 		{
 310:ServerLLDN.c  **** 			pos = 0;
 311:ServerLLDN.c  **** 			bit_shift = 0;
 312:ServerLLDN.c  **** 		}
 313:ServerLLDN.c  **** 		else
 314:ServerLLDN.c  **** 		{
 315:ServerLLDN.c  **** 			pos =  addr / 8;
 316:ServerLLDN.c  **** 			bit_shift = 8 - addr % 8;
 317:ServerLLDN.c  **** 		}
 318:ServerLLDN.c  **** 		if( ACKFrame_aux.ackFlags[pos] & 1 << bit_shift)
 319:ServerLLDN.c  **** 		{
 320:ServerLLDN.c  **** 			return true;
 321:ServerLLDN.c  **** 		}
 322:ServerLLDN.c  **** 		else
 323:ServerLLDN.c  **** 		return false;
 324:ServerLLDN.c  **** 	}
 325:ServerLLDN.c  **** 	
 326:ServerLLDN.c  **** 	static bool appDataInd(NWK_DataInd_t *ind)
 327:ServerLLDN.c  **** 	{
 328:ServerLLDN.c  **** 		uint32_t cmp_value = macsc_read_count();
 329:ServerLLDN.c  **** 		int relative_cmp =  cmp_value - cmp_value_start_superframe - 40;
 330:ServerLLDN.c  **** 		
 331:ServerLLDN.c  **** 
 332:ServerLLDN.c  **** 		int curr_up_ts = (relative_cmp)/(tTS / (SYMBOL_TIME)) - 2*MacLLDNMgmtTS*numBaseTimeSlotperMgmt_on
 333:ServerLLDN.c  **** 		if(curr_up_ts > assTimeSlot)
 334:ServerLLDN.c  **** 		{
 335:ServerLLDN.c  **** 			
 336:ServerLLDN.c  **** 			int i;
 337:ServerLLDN.c  **** 			curr_up_ts -= assTimeSlot+1;
 338:ServerLLDN.c  **** 			for (i = 0; i < assTimeSlot && curr_up_ts > 0; ++i)
 339:ServerLLDN.c  **** 			{
 340:ServerLLDN.c  **** 				if(!check_ack_aux(i+1))
 341:ServerLLDN.c  **** 				{
 342:ServerLLDN.c  **** 					curr_up_ts--;
 343:ServerLLDN.c  **** 				}
 344:ServerLLDN.c  **** 			}
 345:ServerLLDN.c  **** 			curr_up_ts = i-1*(i!=0);
 346:ServerLLDN.c  **** 		}
 347:ServerLLDN.c  **** 	
 348:ServerLLDN.c  **** 		if(nodes_info_arr[curr_up_ts].mac_addr != ind->data[0])
 349:ServerLLDN.c  **** 			return false;
 350:ServerLLDN.c  **** 		nodes_info_arr[curr_up_ts].rssi = ind->rssi;
 351:ServerLLDN.c  **** 		nodes_info_arr[curr_up_ts].average_rssi = (nodes_info_arr[curr_up_ts].rssi + nodes_info_arr[curr_
 352:ServerLLDN.c  **** 																				/(nodes_info_arr[curr_up_ts].msg_rec + 1);
 353:ServerLLDN.c  **** 		nodes_info_arr[curr_up_ts].msg_rec++;
 354:ServerLLDN.c  **** 
 355:ServerLLDN.c  **** 		addToAckArray(curr_up_ts+1);
 356:ServerLLDN.c  **** 		#if PRINT
 357:ServerLLDN.c  ****  		printf("\n[%d] Data: ", curr_up_ts);
 358:ServerLLDN.c  **** 		#endif
 359:ServerLLDN.c  **** 		for (int i = 0; i < ind->size; i++)
 360:ServerLLDN.c  **** 		{
 361:ServerLLDN.c  **** 			msg_info_array[curr_up_ts].data_payload[i] = ind->data[i];
 362:ServerLLDN.c  **** 			#if PRINT
 363:ServerLLDN.c  ****  			printf("%hhx", msg_info_array[curr_up_ts].data_payload[i]);
 364:ServerLLDN.c  **** 			#endif
 365:ServerLLDN.c  **** 		}		
 366:ServerLLDN.c  **** // 		printf(" cmp %d", relative_cmp);
 367:ServerLLDN.c  **** 	}
 368:ServerLLDN.c  **** 	
 369:ServerLLDN.c  **** 	static void appPanPrepareACK(void)
 370:ServerLLDN.c  **** 	{
 371:ServerLLDN.c  **** 		msgReq.dstAddr		= 0;
 372:ServerLLDN.c  **** 		msgReq.dstEndpoint	= APP_BEACON_ENDPOINT;
 373:ServerLLDN.c  **** 		msgReq.srcEndpoint	= APP_BEACON_ENDPOINT;
 374:ServerLLDN.c  **** 		msgReq.options		= NWK_OPT_LLDN_ACK;
 375:ServerLLDN.c  **** 		msgReq.data	= (uint8_t *)&ACKFrame;
 376:ServerLLDN.c  **** 		msgReq.size	= sizeof(uint8_t)*(ACKFrame_size + 1);
 377:ServerLLDN.c  **** 
 378:ServerLLDN.c  **** 	}
 379:ServerLLDN.c  **** 
 380:ServerLLDN.c  **** 	static void appPanReset(void)
 381:ServerLLDN.c  **** 	{
 382:ServerLLDN.c  **** 		// prepare beacon reset message
 383:ServerLLDN.c  **** 		msgReq.dstAddr		= 0;
 384:ServerLLDN.c  **** 		msgReq.dstEndpoint	= APP_BEACON_ENDPOINT;
 385:ServerLLDN.c  **** 		msgReq.srcEndpoint	= APP_BEACON_ENDPOINT;
 386:ServerLLDN.c  **** 		msgReq.options		= NWK_OPT_LLDN_BEACON | NWK_OPT_RESET_STATE;
 387:ServerLLDN.c  **** 		msgReq.data			= NULL;
 388:ServerLLDN.c  **** 		msgReq.size			= 0;
 389:ServerLLDN.c  **** 
 390:ServerLLDN.c  **** 		for(int i = 0; i < 32; i++)
 391:ServerLLDN.c  **** 			ACKFrame.ackFlags[i] = 0;
 392:ServerLLDN.c  **** 			
 393:ServerLLDN.c  **** 		for (int i = 0; i < 50; i++)
 394:ServerLLDN.c  **** 		{
 395:ServerLLDN.c  **** 			nodes_info_arr[i].mac_addr = 0;
 396:ServerLLDN.c  **** 			nodes_info_arr[i].msg_rec = 0;
 397:ServerLLDN.c  **** 
 398:ServerLLDN.c  **** 			
 399:ServerLLDN.c  **** 			msg_info_array[i].mac_addr = 0;
 400:ServerLLDN.c  **** 			msg_info_array[i].coop_addr = 0;
 401:ServerLLDN.c  **** 			for (int j = 0; j < 50; j++)
 402:ServerLLDN.c  **** 				nodes_info_arr[i].neighbors[j] = 0;
 403:ServerLLDN.c  **** 		}
 404:ServerLLDN.c  **** 		ACKFrame_size = 0;
 405:ServerLLDN.c  **** 		counter_associados = 0;
 406:ServerLLDN.c  **** 		macLLDNnumUplinkTS = 0;
 407:ServerLLDN.c  **** 		n = 0;
 408:ServerLLDN.c  **** 	}
 409:ServerLLDN.c  **** 
 410:ServerLLDN.c  **** 	static void appPanDiscInit(void)
 411:ServerLLDN.c  **** 	{	
 412:ServerLLDN.c  **** 		/* clearray of previous discovery state */
 413:ServerLLDN.c  **** 
 414:ServerLLDN.c  **** 		/* Prepare Beacon Message as first beacon in discovery state */		
 415:ServerLLDN.c  **** 		msgReq.dstAddr				= 0;
 416:ServerLLDN.c  **** 		msgReq.dstEndpoint			= APP_BEACON_ENDPOINT;
 417:ServerLLDN.c  **** 		msgReq.srcEndpoint			= APP_BEACON_ENDPOINT;
 418:ServerLLDN.c  **** 		msgReq.options				= NWK_OPT_LLDN_BEACON | NWK_OPT_DISCOVERY_STATE;
 419:ServerLLDN.c  **** 		msgReq.data					= NULL;
 420:ServerLLDN.c  **** 		msgReq.size					= 0;
 421:ServerLLDN.c  **** 		
 422:ServerLLDN.c  **** 		macLLDNnumTimeSlots = 2;
 423:ServerLLDN.c  **** 		accepting_requests = 1;
 424:ServerLLDN.c  **** 		/* Only start timers if it is the first association process */
 425:ServerLLDN.c  **** 		if(cycles_counter == 0) 
 426:ServerLLDN.c  **** 		{
 427:ServerLLDN.c  **** 		for(int i = 0; i < 32; i++)
 428:ServerLLDN.c  **** 		ACKFrame.ackFlags[i] = 0;
 429:ServerLLDN.c  **** 		ACKFrame_size = 0;
 430:ServerLLDN.c  **** 		/* Calculates Beacon Intervals according to 802.15.4e - 2012 p. 70 */
 431:ServerLLDN.c  **** 		n = 127; 
 432:ServerLLDN.c  **** 		tTS =  ((p_var*sp + (m+n)*sm + macMinLIFSPeriod)/v_var);
 433:ServerLLDN.c  **** 		#if (MASTER_MACSC == 1)
 434:ServerLLDN.c  **** 		
 435:ServerLLDN.c  **** 			beaconInterval_association = 2 * numBaseTimeSlotperMgmt_association * (tTS) / (SYMBOL_TIME);
 436:ServerLLDN.c  **** 			#if PRINT
 437:ServerLLDN.c  **** // 			printf("\n Beacon interval %f", beaconInterval_association);
 438:ServerLLDN.c  **** 			#endif
 439:ServerLLDN.c  **** 			/*
 440:ServerLLDN.c  **** 			* Configure interrupts callback functions
 441:ServerLLDN.c  **** 			* overflow interrupt, compare 1,2,3 interrupts
 442:ServerLLDN.c  **** 			*/
 443:ServerLLDN.c  **** 			macsc_set_cmp1_int_cb(lldn_server_beacon);
 444:ServerLLDN.c  **** 			/*
 445:ServerLLDN.c  **** 			* Configure MACSC to generate compare interrupts from channels 1,2,3
 446:ServerLLDN.c  **** 			* Set compare mode to absolute, set compare value.
 447:ServerLLDN.c  **** 			*/
 448:ServerLLDN.c  **** 			macsc_enable_manual_bts();
 449:ServerLLDN.c  **** 			macsc_enable_cmp_int(MACSC_CC1);
 450:ServerLLDN.c  **** 
 451:ServerLLDN.c  **** 			macsc_use_cmp(MACSC_RELATIVE_CMP, beaconInterval_association , MACSC_CC1);
 452:ServerLLDN.c  **** 			
 453:ServerLLDN.c  **** 			/* Timer used in testing */
 454:ServerLLDN.c  **** 			#if TIMESLOT_TIMER
 455:ServerLLDN.c  **** 			macsc_set_cmp2_int_cb(teste_handler);	
 456:ServerLLDN.c  **** 			macsc_enable_cmp_int(MACSC_CC2);
 457:ServerLLDN.c  **** 			macsc_use_cmp(MACSC_RELATIVE_CMP, beaconInterval_association / 2, MACSC_CC2);
 458:ServerLLDN.c  **** 			#endif
 459:ServerLLDN.c  **** 			
 460:ServerLLDN.c  **** 		#endif
 461:ServerLLDN.c  **** 		}
 462:ServerLLDN.c  **** 	}
 463:ServerLLDN.c  **** 	
 464:ServerLLDN.c  **** 	static void end_of_superframe_Online(void)
 465:ServerLLDN.c  **** 	{
 466:ServerLLDN.c  **** 		appPanState = APP_PAN_STATE_ONLINE_INITIAL;
 467:ServerLLDN.c  **** 		if(cycles_counter>0)
 468:ServerLLDN.c  **** 			appState = APP_STATE_SEND;
 469:ServerLLDN.c  **** 		else
 470:ServerLLDN.c  **** 		appState = APP_STATE_ATT_PAN_STATE;
 471:ServerLLDN.c  **** 
 472:ServerLLDN.c  **** 	}
 473:ServerLLDN.c  **** 	
 474:ServerLLDN.c  **** 	static void send_gack(void)
 475:ServerLLDN.c  **** 	{
 476:ServerLLDN.c  **** 		msgReqGACK.size = sizeof(uint8_t)*(macLLDNRetransmitTS + 1);
 477:ServerLLDN.c  **** 		NWK_DataReq(&msgReqGACK);
 478:ServerLLDN.c  **** 		ACKFrame_aux = ACKFrame;
 479:ServerLLDN.c  **** 		#if PRINT
 480:ServerLLDN.c  **** // 		printf("\n%hhx ", ACKFrame.ackFlags[0]);
 481:ServerLLDN.c  **** 		#endif
 482:ServerLLDN.c  **** 		if(cycles_counter<NUMERO_CICLOS_ONLINE-1)
 483:ServerLLDN.c  **** 		{
 484:ServerLLDN.c  **** 			for (int i  = 0; i < assTimeSlot;i++)
 485:ServerLLDN.c  **** 				if(!check_ack_pan(i+1))
 486:ServerLLDN.c  **** 				{
 487:ServerLLDN.c  **** 					nodes_info_arr[i].msg_not_rec++;
 488:ServerLLDN.c  **** 			}
 489:ServerLLDN.c  **** 		}
 490:ServerLLDN.c  **** 	}
 491:ServerLLDN.c  **** 
 492:ServerLLDN.c  **** 	static void appPanOnlineInit()
 493:ServerLLDN.c  **** 	{
 494:ServerLLDN.c  **** 			
 495:ServerLLDN.c  **** 			macLLDNnumUplinkTS = (assTimeSlot) * 2 + 1;
 496:ServerLLDN.c  **** 			macLLDNRetransmitTS = assTimeSlot;
 497:ServerLLDN.c  **** 			macLLDNnumTimeSlots = macLLDNnumUplinkTS + 2 *MacLLDNMgmtTS;			
 498:ServerLLDN.c  **** 			
 499:ServerLLDN.c  **** // 			printf("\nmacLLDNnumUplinkTS : %d\nmacLLDNRetransmitTS : %d\nmacLLDNnumTimeSlots : %d",macLLD
 500:ServerLLDN.c  **** 			
 501:ServerLLDN.c  **** 			config_request_frame.conf.tsDuration = 75;
 502:ServerLLDN.c  **** 			
 503:ServerLLDN.c  **** 			tTS =  ((p_var*sp + (m+ config_request_frame.conf.tsDuration )*sm + macMinLIFSPeriod)/v_var);
 504:ServerLLDN.c  **** 				
 505:ServerLLDN.c  **** 			n = config_request_frame.conf.tsDuration;
 506:ServerLLDN.c  **** 			
 507:ServerLLDN.c  **** 
 508:ServerLLDN.c  **** 			msgReq.dstAddr				= 0;
 509:ServerLLDN.c  **** 			msgReq.dstEndpoint			= APP_BEACON_ENDPOINT;
 510:ServerLLDN.c  **** 			msgReq.srcEndpoint			= APP_BEACON_ENDPOINT;
 511:ServerLLDN.c  **** 			msgReq.options				= NWK_OPT_LLDN_BEACON | NWK_OPT_ONLINE_STATE;
 512:ServerLLDN.c  **** 			msgReq.data					= NULL;
 513:ServerLLDN.c  **** 			msgReq.size					= 0;
 514:ServerLLDN.c  **** 			
 515:ServerLLDN.c  **** 			beaconInterval= (macLLDNnumUplinkTS + 2*MacLLDNMgmtTS*numBaseTimeSlotperMgmt_online) * tTS / (SY
 516:ServerLLDN.c  **** 			float GACK_tTS = (assTimeSlot + 0.2 + 2*MacLLDNMgmtTS*numBaseTimeSlotperMgmt_online) * tTS / (SY
 517:ServerLLDN.c  **** 			macsc_write_count(0);
 518:ServerLLDN.c  **** 			macsc_set_cmp1_int_cb(end_of_superframe_Online);
 519:ServerLLDN.c  **** 			macsc_enable_cmp_int(MACSC_CC1);
 520:ServerLLDN.c  **** 
 521:ServerLLDN.c  **** 			macsc_set_cmp2_int_cb(send_gack);
 522:ServerLLDN.c  **** 			if(cycles_counter != NUMERO_CICLOS_ONLINE)
 523:ServerLLDN.c  **** 				macsc_enable_cmp_int(MACSC_CC2);
 524:ServerLLDN.c  **** 
 525:ServerLLDN.c  **** 			macsc_use_cmp(MACSC_RELATIVE_CMP, beaconInterval, MACSC_CC1);
 526:ServerLLDN.c  **** 			macsc_use_cmp(MACSC_RELATIVE_CMP, GACK_tTS, MACSC_CC2);
 527:ServerLLDN.c  **** 			macsc_enable_manual_bts();
 528:ServerLLDN.c  **** 			
 529:ServerLLDN.c  **** 			cmp_value_start_superframe = macsc_read_count();
 530:ServerLLDN.c  **** 
 531:ServerLLDN.c  **** 
 532:ServerLLDN.c  **** 			for(int i = 0; i < 32; i++)
 533:ServerLLDN.c  **** 			{
 534:ServerLLDN.c  **** 				ACKFrame.ackFlags[i] = 0;
 535:ServerLLDN.c  **** 				retransmit_ts_array[i] = 0;
 536:ServerLLDN.c  **** 			}
 537:ServerLLDN.c  **** 			retransmit_ts_array_counter = 0;
 538:ServerLLDN.c  **** 			ACKFrame_size = 0;
 539:ServerLLDN.c  **** 			
 540:ServerLLDN.c  **** 			NWK_OpenEndpoint(APP_DATA_ENDPOINT, appDataInd);
 541:ServerLLDN.c  **** 	}
 542:ServerLLDN.c  **** 
 543:ServerLLDN.c  **** #else 
 544:ServerLLDN.c  **** 	uint8_t payloadSize = 50;
 545:ServerLLDN.c  **** 	uint8_t assTimeSlot = 0xFF;
 546:ServerLLDN.c  **** 	uint8_t n = 0;
 547:ServerLLDN.c  **** 	uint8_t data_payload = APP_ADDR;
 548:ServerLLDN.c  **** 
 549:ServerLLDN.c  **** 
 550:ServerLLDN.c  **** 	
 551:ServerLLDN.c  **** 	NwkFrameBeaconHeaderLLDN_t rec_beacon;
 552:ServerLLDN.c  **** 	NWK_ACKFormat_t *ackframe;
 553:ServerLLDN.c  **** 	static NWK_DiscoverResponse_t msgDiscResponse = { .id = LL_DISCOVER_RESPONSE,
 554:ServerLLDN.c  **** 													 .macAddr = APP_ADDR,
 555:ServerLLDN.c  **** 													 .ts_dir.tsDuration = 50,
 556:ServerLLDN.c  **** 													 .ts_dir.dirIndicator = 0b1 };
 557:ServerLLDN.c  **** 	static NWK_ConfigStatus_t msgConfigStatus = { .id = LL_CONFIGURATION_STATUS,
 558:ServerLLDN.c  **** 												 .macAddr = APP_ADDR,
 559:ServerLLDN.c  **** 												 .s_macAddr = APP_ADDR,
 560:ServerLLDN.c  **** 												 .ts_dir.tsDuration = 50,
 561:ServerLLDN.c  **** 												 .ts_dir.dirIndicator = 1,
 562:ServerLLDN.c  **** 												 .assTimeSlot = 0xff };
 563:ServerLLDN.c  **** 												 
 564:ServerLLDN.c  **** 	static NWK_DataReq_t msgReqDiscResponse = { .dstAddr = 0,
 565:ServerLLDN.c  **** 									.dstEndpoint = APP_COMMAND_ENDPOINT,
 566:ServerLLDN.c  **** 									.srcEndpoint = APP_COMMAND_ENDPOINT,
 567:ServerLLDN.c  **** 									.options = NWK_OPT_MAC_COMMAND,
 568:ServerLLDN.c  **** 									.data = (uint8_t*)&msgDiscResponse,
 569:ServerLLDN.c  **** 									.size = sizeof(msgDiscResponse)};
 570:ServerLLDN.c  **** 	
 571:ServerLLDN.c  **** 	static NWK_DataReq_t msgReqConfigStatus = { .dstAddr =0,
 572:ServerLLDN.c  **** 									.dstEndpoint = APP_COMMAND_ENDPOINT,
 573:ServerLLDN.c  **** 									.srcEndpoint = APP_COMMAND_ENDPOINT,
 574:ServerLLDN.c  **** 									.options = NWK_OPT_MAC_COMMAND,
 575:ServerLLDN.c  **** 									.data = (uint8_t*)&msgConfigStatus,
 576:ServerLLDN.c  **** 									.size = sizeof(msgConfigStatus)};
 577:ServerLLDN.c  **** 		
 578:ServerLLDN.c  **** 	static NWK_DataReq_t msgReqData = { .dstAddr =0,
 579:ServerLLDN.c  **** 									.dstEndpoint = APP_COMMAND_ENDPOINT,
 580:ServerLLDN.c  **** 									.srcEndpoint = APP_COMMAND_ENDPOINT,
 581:ServerLLDN.c  **** 									.options = NWK_OPT_LLDN_DATA,
 582:ServerLLDN.c  **** 									.data = (uint8_t*)&data_payload,
 583:ServerLLDN.c  **** 									.size = sizeof(data_payload)};
 584:ServerLLDN.c  **** 
 585:ServerLLDN.c  **** 	static bool ack_received = false;
 586:ServerLLDN.c  **** 	bool MacLLDNMgmtTS = 0; 
 587:ServerLLDN.c  **** 	bool associated = 0;
 588:ServerLLDN.c  **** 	int ts_time;
 589:ServerLLDN.c  **** 	uint8_t STATE = DISC_MODE;
 590:ServerLLDN.c  **** 	int tmr_error = 0;
 591:ServerLLDN.c  **** 	float delta_error = 0;
 592:ServerLLDN.c  **** 	bool beacon_tmr = false;
 593:ServerLLDN.c  **** 	uint32_t be_read = 0;
 594:ServerLLDN.c  **** 	uint32_t tmr_read= 0;
 595:ServerLLDN.c  **** 	int msg_wait_time;
 596:ServerLLDN.c  **** 	int ok_seq = -1;
 597:ServerLLDN.c  **** 	static void send_message_timeHandler(void)
 598:ServerLLDN.c  **** 	{
 842               		.loc 6 598 0
 843               		.cfi_startproc
 844 02b8 CF93      		push r28
 845               	.LCFI39:
 846               		.cfi_def_cfa_offset 3
 847               		.cfi_offset 28, -2
 848 02ba DF93      		push r29
 849               	.LCFI40:
 850               		.cfi_def_cfa_offset 4
 851               		.cfi_offset 29, -3
 852 02bc CDB7      		in r28,__SP_L__
 853 02be DEB7      		in r29,__SP_H__
 854               	.LCFI41:
 855               		.cfi_def_cfa_register 28
 856               	/* prologue: function */
 857               	/* frame size = 0 */
 858               	/* stack size = 2 */
 859               	.L__stack_usage = 2
 599:ServerLLDN.c  **** 		appSendData();
 860               		.loc 6 599 0
 861 02c0 0E94 0000 		call appSendData
 600:ServerLLDN.c  **** 		#if MASTER_MACSC == 0
 601:ServerLLDN.c  **** 			timer_stop();
 602:ServerLLDN.c  **** 		#else 
 603:ServerLLDN.c  **** 		macsc_disable_cmp_int(MACSC_CC1);
 862               		.loc 6 603 0
 863 02c4 81E0      		ldi r24,lo8(1)
 864 02c6 0E94 0000 		call macsc_disable_cmp_int
 604:ServerLLDN.c  **** 		#endif
 605:ServerLLDN.c  **** 	
 606:ServerLLDN.c  **** 	}
 865               		.loc 6 606 0
 866 02ca 0000      		nop
 867               	/* epilogue start */
 868 02cc DF91      		pop r29
 869 02ce CF91      		pop r28
 870 02d0 0895      		ret
 871               		.cfi_endproc
 872               	.LFE131:
 875               	node_time_handler:
 876               	.LFB132:
 607:ServerLLDN.c  **** 
 608:ServerLLDN.c  **** 	static void node_time_handler(void)
 609:ServerLLDN.c  **** 	{
 877               		.loc 6 609 0
 878               		.cfi_startproc
 879 02d2 CF93      		push r28
 880               	.LCFI42:
 881               		.cfi_def_cfa_offset 3
 882               		.cfi_offset 28, -2
 883 02d4 DF93      		push r29
 884               	.LCFI43:
 885               		.cfi_def_cfa_offset 4
 886               		.cfi_offset 29, -3
 887 02d6 CDB7      		in r28,__SP_L__
 888 02d8 DEB7      		in r29,__SP_H__
 889               	.LCFI44:
 890               		.cfi_def_cfa_register 28
 891               	/* prologue: function */
 892               	/* frame size = 0 */
 893               	/* stack size = 2 */
 894               	.L__stack_usage = 2
 610:ServerLLDN.c  **** 		beacon_tmr = true;
 895               		.loc 6 610 0
 896 02da 81E0      		ldi r24,lo8(1)
 897 02dc 8093 0000 		sts beacon_tmr,r24
 611:ServerLLDN.c  **** 		tmr_read = macsc_read_count();
 898               		.loc 6 611 0
 899 02e0 0E94 0000 		call macsc_read_count
 900 02e4 DC01      		movw r26,r24
 901 02e6 CB01      		movw r24,r22
 902 02e8 8093 0000 		sts tmr_read,r24
 903 02ec 9093 0000 		sts tmr_read+1,r25
 904 02f0 A093 0000 		sts tmr_read+2,r26
 905 02f4 B093 0000 		sts tmr_read+3,r27
 612:ServerLLDN.c  **** 		return;
 906               		.loc 6 612 0
 907 02f8 0000      		nop
 908               	/* epilogue start */
 613:ServerLLDN.c  **** 	}
 909               		.loc 6 613 0
 910 02fa DF91      		pop r29
 911 02fc CF91      		pop r28
 912 02fe 0895      		ret
 913               		.cfi_endproc
 914               	.LFE132:
 916               		.section	.rodata
 917               	.LC2:
 918 000b 0A44 6973 		.string	"\nDisc"
 918      6300 
 919               		.text
 921               	disc_time_hndlr:
 922               	.LFB133:
 614:ServerLLDN.c  **** 	
 615:ServerLLDN.c  **** 	
 616:ServerLLDN.c  **** 	static void disc_time_hndlr(void)
 617:ServerLLDN.c  **** 	{
 923               		.loc 6 617 0
 924               		.cfi_startproc
 925 0300 CF93      		push r28
 926               	.LCFI45:
 927               		.cfi_def_cfa_offset 3
 928               		.cfi_offset 28, -2
 929 0302 DF93      		push r29
 930               	.LCFI46:
 931               		.cfi_def_cfa_offset 4
 932               		.cfi_offset 29, -3
 933 0304 CDB7      		in r28,__SP_L__
 934 0306 DEB7      		in r29,__SP_H__
 935               	.LCFI47:
 936               		.cfi_def_cfa_register 28
 937               	/* prologue: function */
 938               	/* frame size = 0 */
 939               	/* stack size = 2 */
 940               	.L__stack_usage = 2
 618:ServerLLDN.c  **** 		printf("\nDisc");
 941               		.loc 6 618 0
 942 0308 80E0      		ldi r24,lo8(.LC2)
 943 030a 90E0      		ldi r25,hi8(.LC2)
 944 030c 892F      		mov r24,r25
 945 030e 8F93      		push r24
 946 0310 80E0      		ldi r24,lo8(.LC2)
 947 0312 90E0      		ldi r25,hi8(.LC2)
 948 0314 8F93      		push r24
 949 0316 0E94 0000 		call printf
 950 031a 0F90      		pop __tmp_reg__
 951 031c 0F90      		pop __tmp_reg__
 619:ServerLLDN.c  **** 			NWK_DataReq(&msgReqDiscResponse);
 952               		.loc 6 619 0
 953 031e 80E0      		ldi r24,lo8(msgReqDiscResponse)
 954 0320 90E0      		ldi r25,hi8(msgReqDiscResponse)
 955 0322 0E94 0000 		call NWK_DataReq
 620:ServerLLDN.c  **** 		macsc_set_cmp1_int_cb(0);
 956               		.loc 6 620 0
 957 0326 80E0      		ldi r24,0
 958 0328 90E0      		ldi r25,0
 959 032a 0E94 0000 		call macsc_set_cmp1_int_cb
 621:ServerLLDN.c  **** 		
 622:ServerLLDN.c  **** 	}
 960               		.loc 6 622 0
 961 032e 0000      		nop
 962               	/* epilogue start */
 963 0330 DF91      		pop r29
 964 0332 CF91      		pop r28
 965 0334 0895      		ret
 966               		.cfi_endproc
 967               	.LFE133:
 970               	config_time_hndlr:
 971               	.LFB134:
 623:ServerLLDN.c  **** 	
 624:ServerLLDN.c  **** 	static void config_time_hndlr(void)
 625:ServerLLDN.c  **** 	{
 972               		.loc 6 625 0
 973               		.cfi_startproc
 974 0336 CF93      		push r28
 975               	.LCFI48:
 976               		.cfi_def_cfa_offset 3
 977               		.cfi_offset 28, -2
 978 0338 DF93      		push r29
 979               	.LCFI49:
 980               		.cfi_def_cfa_offset 4
 981               		.cfi_offset 29, -3
 982 033a CDB7      		in r28,__SP_L__
 983 033c DEB7      		in r29,__SP_H__
 984               	.LCFI50:
 985               		.cfi_def_cfa_register 28
 986               	/* prologue: function */
 987               	/* frame size = 0 */
 988               	/* stack size = 2 */
 989               	.L__stack_usage = 2
 626:ServerLLDN.c  **** 		if(ack_received)
 990               		.loc 6 626 0
 991 033e 8091 0000 		lds r24,ack_received
 992 0342 8823      		tst r24
 993 0344 01F0      		breq .L28
 627:ServerLLDN.c  **** 		{
 628:ServerLLDN.c  **** 			NWK_DataReq(&msgReqConfigStatus);
 994               		.loc 6 628 0
 995 0346 80E0      		ldi r24,lo8(msgReqConfigStatus)
 996 0348 90E0      		ldi r25,hi8(msgReqConfigStatus)
 997 034a 0E94 0000 		call NWK_DataReq
 629:ServerLLDN.c  **** 			ack_received = false;
 998               		.loc 6 629 0
 999 034e 1092 0000 		sts ack_received,__zero_reg__
 1000               	.L28:
 630:ServerLLDN.c  **** 		}
 631:ServerLLDN.c  **** 		macsc_set_cmp1_int_cb(0);
 1001               		.loc 6 631 0
 1002 0352 80E0      		ldi r24,0
 1003 0354 90E0      		ldi r25,0
 1004 0356 0E94 0000 		call macsc_set_cmp1_int_cb
 632:ServerLLDN.c  **** 		
 633:ServerLLDN.c  **** 	}
 1005               		.loc 6 633 0
 1006 035a 0000      		nop
 1007               	/* epilogue start */
 1008 035c DF91      		pop r29
 1009 035e CF91      		pop r28
 1010 0360 0895      		ret
 1011               		.cfi_endproc
 1012               	.LFE134:
 1014               		.section	.rodata
 1015               	.LC3:
 1016 0011 0A64 6174 		.string	"\ndata_msg"
 1016      615F 6D73 
 1016      6700 
 1017               		.text
 1019               	online_time_hndlr:
 1020               	.LFB135:
 634:ServerLLDN.c  **** 	
 635:ServerLLDN.c  **** 		
 636:ServerLLDN.c  **** 	static void online_time_hndlr(void)
 637:ServerLLDN.c  **** 	{
 1021               		.loc 6 637 0
 1022               		.cfi_startproc
 1023 0362 CF93      		push r28
 1024               	.LCFI51:
 1025               		.cfi_def_cfa_offset 3
 1026               		.cfi_offset 28, -2
 1027 0364 DF93      		push r29
 1028               	.LCFI52:
 1029               		.cfi_def_cfa_offset 4
 1030               		.cfi_offset 29, -3
 1031 0366 CDB7      		in r28,__SP_L__
 1032 0368 DEB7      		in r29,__SP_H__
 1033               	.LCFI53:
 1034               		.cfi_def_cfa_register 28
 1035               	/* prologue: function */
 1036               	/* frame size = 0 */
 1037               	/* stack size = 2 */
 1038               	.L__stack_usage = 2
 638:ServerLLDN.c  **** 		printf("\ndata_msg");
 1039               		.loc 6 638 0
 1040 036a 80E0      		ldi r24,lo8(.LC3)
 1041 036c 90E0      		ldi r25,hi8(.LC3)
 1042 036e 892F      		mov r24,r25
 1043 0370 8F93      		push r24
 1044 0372 80E0      		ldi r24,lo8(.LC3)
 1045 0374 90E0      		ldi r25,hi8(.LC3)
 1046 0376 8F93      		push r24
 1047 0378 0E94 0000 		call printf
 1048 037c 0F90      		pop __tmp_reg__
 1049 037e 0F90      		pop __tmp_reg__
 639:ServerLLDN.c  **** 		NWK_DataReq(&msgReqData);
 1050               		.loc 6 639 0
 1051 0380 80E0      		ldi r24,lo8(msgReqData)
 1052 0382 90E0      		ldi r25,hi8(msgReqData)
 1053 0384 0E94 0000 		call NWK_DataReq
 640:ServerLLDN.c  **** 		macsc_set_cmp1_int_cb(0);		
 1054               		.loc 6 640 0
 1055 0388 80E0      		ldi r24,0
 1056 038a 90E0      		ldi r25,0
 1057 038c 0E94 0000 		call macsc_set_cmp1_int_cb
 641:ServerLLDN.c  **** 	}
 1058               		.loc 6 641 0
 1059 0390 0000      		nop
 1060               	/* epilogue start */
 1061 0392 DF91      		pop r29
 1062 0394 CF91      		pop r28
 1063 0396 0895      		ret
 1064               		.cfi_endproc
 1065               	.LFE135:
 1067               	.global	__floatsisf
 1068               	.global	__addsf3
 1069               	.global	__divsf3
 1070               		.section	.rodata
 1071               	.LC4:
 1072 001b 0A42 4520 		.string	"\nBE %f"
 1072      2566 00
 1073               	.global	__mulsf3
 1074               	.global	__fixsfsi
 1075               	.LC5:
 1076 0022 6D73 675F 		.string	"msg_wait %d"
 1076      7761 6974 
 1076      2025 6400 
 1077               		.text
 1079               	appBeaconInd:
 1080               	.LFB136:
 642:ServerLLDN.c  **** 	
 643:ServerLLDN.c  **** 	static bool appBeaconInd(NWK_DataInd_t *ind)
 644:ServerLLDN.c  **** 	{
 1081               		.loc 6 644 0
 1082               		.cfi_startproc
 1083 0398 EF92      		push r14
 1084               	.LCFI54:
 1085               		.cfi_def_cfa_offset 3
 1086               		.cfi_offset 14, -2
 1087 039a FF92      		push r15
 1088               	.LCFI55:
 1089               		.cfi_def_cfa_offset 4
 1090               		.cfi_offset 15, -3
 1091 039c 0F93      		push r16
 1092               	.LCFI56:
 1093               		.cfi_def_cfa_offset 5
 1094               		.cfi_offset 16, -4
 1095 039e 1F93      		push r17
 1096               	.LCFI57:
 1097               		.cfi_def_cfa_offset 6
 1098               		.cfi_offset 17, -5
 1099 03a0 CF93      		push r28
 1100               	.LCFI58:
 1101               		.cfi_def_cfa_offset 7
 1102               		.cfi_offset 28, -6
 1103 03a2 DF93      		push r29
 1104               	.LCFI59:
 1105               		.cfi_def_cfa_offset 8
 1106               		.cfi_offset 29, -7
 1107 03a4 00D0      		rcall .
 1108 03a6 00D0      		rcall .
 1109               	.LCFI60:
 1110               		.cfi_def_cfa_offset 12
 1111 03a8 CDB7      		in r28,__SP_L__
 1112 03aa DEB7      		in r29,__SP_H__
 1113               	.LCFI61:
 1114               		.cfi_def_cfa_register 28
 1115               	/* prologue: function */
 1116               	/* frame size = 4 */
 1117               	/* stack size = 10 */
 1118               	.L__stack_usage = 10
 1119 03ac 9C83      		std Y+4,r25
 1120 03ae 8B83      		std Y+3,r24
 645:ServerLLDN.c  **** 		NwkFrameBeaconHeaderLLDN_t *tmp_beacon = (NwkFrameBeaconHeaderLLDN_t*)ind->data;
 1121               		.loc 6 645 0
 1122 03b0 8B81      		ldd r24,Y+3
 1123 03b2 9C81      		ldd r25,Y+4
 1124 03b4 FC01      		movw r30,r24
 1125 03b6 8085      		ldd r24,Z+8
 1126 03b8 9185      		ldd r25,Z+9
 1127 03ba 9A83      		std Y+2,r25
 1128 03bc 8983      		std Y+1,r24
 646:ServerLLDN.c  **** 		rec_beacon = *tmp_beacon;
 1129               		.loc 6 646 0
 1130 03be 8981      		ldd r24,Y+1
 1131 03c0 9A81      		ldd r25,Y+2
 1132 03c2 28E0      		ldi r18,lo8(8)
 1133 03c4 FC01      		movw r30,r24
 1134 03c6 A0E0      		ldi r26,lo8(rec_beacon)
 1135 03c8 B0E0      		ldi r27,hi8(rec_beacon)
 1136               		0:
 1137 03ca 0190      		ld r0,Z+
 1138 03cc 0D92      		st X+,r0
 1139 03ce 2A95      		dec r18
 1140 03d0 01F4      		brne 0b
 647:ServerLLDN.c  **** 		PanId = tmp_beacon->PanId;
 1141               		.loc 6 647 0
 1142 03d2 8981      		ldd r24,Y+1
 1143 03d4 9A81      		ldd r25,Y+2
 1144 03d6 FC01      		movw r30,r24
 1145 03d8 8481      		ldd r24,Z+4
 1146 03da 8093 0000 		sts PanId,r24
 648:ServerLLDN.c  **** 		tTS =  ((p_var*sp + (m+ tmp_beacon->TimeSlotSize )*sm + macMinLIFSPeriod)/v_var)  / (SYMBOL_TIME)
 1147               		.loc 6 648 0
 1148 03de 8981      		ldd r24,Y+1
 1149 03e0 9A81      		ldd r25,Y+2
 1150 03e2 FC01      		movw r30,r24
 1151 03e4 8681      		ldd r24,Z+6
 1152 03e6 882F      		mov r24,r24
 1153 03e8 90E0      		ldi r25,0
 1154 03ea 0396      		adiw r24,3
 1155 03ec 880F      		lsl r24
 1156 03ee 991F      		rol r25
 1157 03f0 092E      		mov __tmp_reg__,r25
 1158 03f2 000C      		lsl r0
 1159 03f4 AA0B      		sbc r26,r26
 1160 03f6 BB0B      		sbc r27,r27
 1161 03f8 BC01      		movw r22,r24
 1162 03fa CD01      		movw r24,r26
 1163 03fc 0E94 0000 		call __floatsisf
 1164 0400 DC01      		movw r26,r24
 1165 0402 CB01      		movw r24,r22
 1166 0404 20E0      		ldi r18,0
 1167 0406 30E0      		ldi r19,0
 1168 0408 40E4      		ldi r20,lo8(64)
 1169 040a 51E4      		ldi r21,lo8(65)
 1170 040c BC01      		movw r22,r24
 1171 040e CD01      		movw r24,r26
 1172 0410 0E94 0000 		call __addsf3
 1173 0414 DC01      		movw r26,r24
 1174 0416 CB01      		movw r24,r22
 1175 0418 20E0      		ldi r18,0
 1176 041a 30E0      		ldi r19,0
 1177 041c 40E2      		ldi r20,lo8(32)
 1178 041e 52E4      		ldi r21,lo8(66)
 1179 0420 BC01      		movw r22,r24
 1180 0422 CD01      		movw r24,r26
 1181 0424 0E94 0000 		call __addsf3
 1182 0428 DC01      		movw r26,r24
 1183 042a CB01      		movw r24,r22
 1184 042c 20E0      		ldi r18,0
 1185 042e 34E2      		ldi r19,lo8(36)
 1186 0430 44E7      		ldi r20,lo8(116)
 1187 0432 57E4      		ldi r21,lo8(71)
 1188 0434 BC01      		movw r22,r24
 1189 0436 CD01      		movw r24,r26
 1190 0438 0E94 0000 		call __divsf3
 1191 043c DC01      		movw r26,r24
 1192 043e CB01      		movw r24,r22
 1193 0440 2DEB      		ldi r18,lo8(-67)
 1194 0442 37E3      		ldi r19,lo8(55)
 1195 0444 46E8      		ldi r20,lo8(-122)
 1196 0446 57E3      		ldi r21,lo8(55)
 1197 0448 BC01      		movw r22,r24
 1198 044a CD01      		movw r24,r26
 1199 044c 0E94 0000 		call __divsf3
 1200 0450 DC01      		movw r26,r24
 1201 0452 CB01      		movw r24,r22
 1202 0454 8093 0000 		sts tTS,r24
 1203 0458 9093 0000 		sts tTS+1,r25
 1204 045c A093 0000 		sts tTS+2,r26
 1205 0460 B093 0000 		sts tTS+3,r27
 649:ServerLLDN.c  **** 		printf("\nBE %f", tTS);
 1206               		.loc 6 649 0
 1207 0464 8091 0000 		lds r24,tTS
 1208 0468 9091 0000 		lds r25,tTS+1
 1209 046c A091 0000 		lds r26,tTS+2
 1210 0470 B091 0000 		lds r27,tTS+3
 1211 0474 2B2F      		mov r18,r27
 1212 0476 2F93      		push r18
 1213 0478 2A2F      		mov r18,r26
 1214 047a 2F93      		push r18
 1215 047c 292F      		mov r18,r25
 1216 047e 2F93      		push r18
 1217 0480 8F93      		push r24
 1218 0482 80E0      		ldi r24,lo8(.LC4)
 1219 0484 90E0      		ldi r25,hi8(.LC4)
 1220 0486 892F      		mov r24,r25
 1221 0488 8F93      		push r24
 1222 048a 80E0      		ldi r24,lo8(.LC4)
 1223 048c 90E0      		ldi r25,hi8(.LC4)
 1224 048e 8F93      		push r24
 1225 0490 0E94 0000 		call printf
 1226 0494 0F90      		pop __tmp_reg__
 1227 0496 0F90      		pop __tmp_reg__
 1228 0498 0F90      		pop __tmp_reg__
 1229 049a 0F90      		pop __tmp_reg__
 1230 049c 0F90      		pop __tmp_reg__
 1231 049e 0F90      		pop __tmp_reg__
 650:ServerLLDN.c  **** 		if(rec_beacon.Flags.txState == STATE && rec_beacon.confSeqNumber == 0)
 1232               		.loc 6 650 0
 1233 04a0 8091 0000 		lds r24,rec_beacon+3
 1234 04a4 8770      		andi r24,lo8(7)
 1235 04a6 282F      		mov r18,r24
 1236 04a8 30E0      		ldi r19,0
 1237 04aa 8091 0000 		lds r24,STATE
 1238 04ae 882F      		mov r24,r24
 1239 04b0 90E0      		ldi r25,0
 1240 04b2 2817      		cp r18,r24
 1241 04b4 3907      		cpc r19,r25
 1242 04b6 01F0      		breq .+2
 1243 04b8 00C0      		rjmp .L31
 1244               		.loc 6 650 0 is_stmt 0 discriminator 1
 1245 04ba 8091 0000 		lds r24,rec_beacon+5
 1246 04be 8823      		tst r24
 1247 04c0 01F0      		breq .+2
 1248 04c2 00C0      		rjmp .L31
 651:ServerLLDN.c  **** 		{
 652:ServerLLDN.c  **** 			if(STATE == DISC_MODE) 
 1249               		.loc 6 652 0 is_stmt 1
 1250 04c4 8091 0000 		lds r24,STATE
 1251 04c8 8430      		cpi r24,lo8(4)
 1252 04ca 01F4      		brne .L32
 653:ServerLLDN.c  **** 				macsc_set_cmp1_int_cb(disc_time_hndlr);
 1253               		.loc 6 653 0
 1254 04cc 80E0      		ldi r24,lo8(gs(disc_time_hndlr))
 1255 04ce 90E0      		ldi r25,hi8(gs(disc_time_hndlr))
 1256 04d0 0E94 0000 		call macsc_set_cmp1_int_cb
 1257 04d4 00C0      		rjmp .L33
 1258               	.L32:
 654:ServerLLDN.c  **** 			else if(STATE == CONFIG_MODE)
 1259               		.loc 6 654 0
 1260 04d6 8091 0000 		lds r24,STATE
 1261 04da 8630      		cpi r24,lo8(6)
 1262 04dc 01F4      		brne .L34
 655:ServerLLDN.c  **** 				macsc_set_cmp1_int_cb(config_time_hndlr);
 1263               		.loc 6 655 0
 1264 04de 80E0      		ldi r24,lo8(gs(config_time_hndlr))
 1265 04e0 90E0      		ldi r25,hi8(gs(config_time_hndlr))
 1266 04e2 0E94 0000 		call macsc_set_cmp1_int_cb
 1267 04e6 00C0      		rjmp .L33
 1268               	.L34:
 656:ServerLLDN.c  **** 			else if(STATE == ONLINE_MODE)
 1269               		.loc 6 656 0
 1270 04e8 8091 0000 		lds r24,STATE
 1271 04ec 8823      		tst r24
 1272 04ee 01F4      		brne .L33
 657:ServerLLDN.c  **** 				macsc_set_cmp1_int_cb(online_time_hndlr);
 1273               		.loc 6 657 0
 1274 04f0 80E0      		ldi r24,lo8(gs(online_time_hndlr))
 1275 04f2 90E0      		ldi r25,hi8(gs(online_time_hndlr))
 1276 04f4 0E94 0000 		call macsc_set_cmp1_int_cb
 1277               	.L33:
 658:ServerLLDN.c  **** 					
 659:ServerLLDN.c  **** 			
 660:ServerLLDN.c  **** 			
 661:ServerLLDN.c  **** 			if(STATE == ONLINE_MODE)
 1278               		.loc 6 661 0
 1279 04f8 8091 0000 		lds r24,STATE
 1280 04fc 8823      		tst r24
 1281 04fe 01F0      		breq .+2
 1282 0500 00C0      		rjmp .L35
 662:ServerLLDN.c  **** 			{
 663:ServerLLDN.c  **** 				msg_wait_time = (2*rec_beacon.Flags.numBaseMgmtTimeslots + assTimeSlot) * tTS /*+ 80 + 45*assTi
 1283               		.loc 6 663 0
 1284 0502 8091 0000 		lds r24,rec_beacon+3
 1285 0506 8295      		swap r24
 1286 0508 8695      		lsr r24
 1287 050a 8770      		andi r24,lo8(7)
 1288 050c 882F      		mov r24,r24
 1289 050e 90E0      		ldi r25,0
 1290 0510 9C01      		movw r18,r24
 1291 0512 220F      		lsl r18
 1292 0514 331F      		rol r19
 1293 0516 8091 0000 		lds r24,assTimeSlot
 1294 051a 882F      		mov r24,r24
 1295 051c 90E0      		ldi r25,0
 1296 051e 820F      		add r24,r18
 1297 0520 931F      		adc r25,r19
 1298 0522 092E      		mov __tmp_reg__,r25
 1299 0524 000C      		lsl r0
 1300 0526 AA0B      		sbc r26,r26
 1301 0528 BB0B      		sbc r27,r27
 1302 052a BC01      		movw r22,r24
 1303 052c CD01      		movw r24,r26
 1304 052e 0E94 0000 		call __floatsisf
 1305 0532 7B01      		movw r14,r22
 1306 0534 8C01      		movw r16,r24
 1307 0536 8091 0000 		lds r24,tTS
 1308 053a 9091 0000 		lds r25,tTS+1
 1309 053e A091 0000 		lds r26,tTS+2
 1310 0542 B091 0000 		lds r27,tTS+3
 1311 0546 9C01      		movw r18,r24
 1312 0548 AD01      		movw r20,r26
 1313 054a C801      		movw r24,r16
 1314 054c B701      		movw r22,r14
 1315 054e 0E94 0000 		call __mulsf3
 1316 0552 DC01      		movw r26,r24
 1317 0554 CB01      		movw r24,r22
 1318 0556 BC01      		movw r22,r24
 1319 0558 CD01      		movw r24,r26
 1320 055a 0E94 0000 		call __fixsfsi
 1321 055e DC01      		movw r26,r24
 1322 0560 CB01      		movw r24,r22
 1323 0562 9093 0000 		sts msg_wait_time+1,r25
 1324 0566 8093 0000 		sts msg_wait_time,r24
 664:ServerLLDN.c  **** 				printf("msg_wait %d", msg_wait_time);
 1325               		.loc 6 664 0
 1326 056a 8091 0000 		lds r24,msg_wait_time
 1327 056e 9091 0000 		lds r25,msg_wait_time+1
 1328 0572 292F      		mov r18,r25
 1329 0574 2F93      		push r18
 1330 0576 8F93      		push r24
 1331 0578 80E0      		ldi r24,lo8(.LC5)
 1332 057a 90E0      		ldi r25,hi8(.LC5)
 1333 057c 892F      		mov r24,r25
 1334 057e 8F93      		push r24
 1335 0580 80E0      		ldi r24,lo8(.LC5)
 1336 0582 90E0      		ldi r25,hi8(.LC5)
 1337 0584 8F93      		push r24
 1338 0586 0E94 0000 		call printf
 1339 058a 0F90      		pop __tmp_reg__
 1340 058c 0F90      		pop __tmp_reg__
 1341 058e 0F90      		pop __tmp_reg__
 1342 0590 0F90      		pop __tmp_reg__
 1343 0592 00C0      		rjmp .L36
 1344               	.L35:
 665:ServerLLDN.c  **** 			}
 666:ServerLLDN.c  **** 			else	
 667:ServerLLDN.c  **** 				msg_wait_time = tTS * rec_beacon.Flags.numBaseMgmtTimeslots; 
 1345               		.loc 6 667 0
 1346 0594 8091 0000 		lds r24,rec_beacon+3
 1347 0598 8295      		swap r24
 1348 059a 8695      		lsr r24
 1349 059c 8770      		andi r24,lo8(7)
 1350 059e 882F      		mov r24,r24
 1351 05a0 90E0      		ldi r25,0
 1352 05a2 092E      		mov __tmp_reg__,r25
 1353 05a4 000C      		lsl r0
 1354 05a6 AA0B      		sbc r26,r26
 1355 05a8 BB0B      		sbc r27,r27
 1356 05aa BC01      		movw r22,r24
 1357 05ac CD01      		movw r24,r26
 1358 05ae 0E94 0000 		call __floatsisf
 1359 05b2 7B01      		movw r14,r22
 1360 05b4 8C01      		movw r16,r24
 1361 05b6 8091 0000 		lds r24,tTS
 1362 05ba 9091 0000 		lds r25,tTS+1
 1363 05be A091 0000 		lds r26,tTS+2
 1364 05c2 B091 0000 		lds r27,tTS+3
 1365 05c6 9C01      		movw r18,r24
 1366 05c8 AD01      		movw r20,r26
 1367 05ca C801      		movw r24,r16
 1368 05cc B701      		movw r22,r14
 1369 05ce 0E94 0000 		call __mulsf3
 1370 05d2 DC01      		movw r26,r24
 1371 05d4 CB01      		movw r24,r22
 1372 05d6 BC01      		movw r22,r24
 1373 05d8 CD01      		movw r24,r26
 1374 05da 0E94 0000 		call __fixsfsi
 1375 05de DC01      		movw r26,r24
 1376 05e0 CB01      		movw r24,r22
 1377 05e2 9093 0000 		sts msg_wait_time+1,r25
 1378 05e6 8093 0000 		sts msg_wait_time,r24
 1379               	.L36:
 668:ServerLLDN.c  **** 			macsc_enable_cmp_int(MACSC_CC1);
 1380               		.loc 6 668 0
 1381 05ea 81E0      		ldi r24,lo8(1)
 1382 05ec 0E94 0000 		call macsc_enable_cmp_int
 669:ServerLLDN.c  **** 			macsc_use_cmp(MACSC_RELATIVE_CMP, msg_wait_time - 150, MACSC_CC1);
 1383               		.loc 6 669 0
 1384 05f0 8091 0000 		lds r24,msg_wait_time
 1385 05f4 9091 0000 		lds r25,msg_wait_time+1
 1386 05f8 8659      		subi r24,-106
 1387 05fa 9109      		sbc r25,__zero_reg__
 1388 05fc 092E      		mov __tmp_reg__,r25
 1389 05fe 000C      		lsl r0
 1390 0600 AA0B      		sbc r26,r26
 1391 0602 BB0B      		sbc r27,r27
 1392 0604 21E0      		ldi r18,lo8(1)
 1393 0606 AC01      		movw r20,r24
 1394 0608 BD01      		movw r22,r26
 1395 060a 81E0      		ldi r24,lo8(1)
 1396 060c 0E94 0000 		call macsc_use_cmp
 670:ServerLLDN.c  ****  			macsc_enable_manual_bts();
 1397               		.loc 6 670 0
 1398 0610 0E94 0000 		call macsc_enable_manual_bts
 1399 0614 00C0      		rjmp .L37
 1400               	.L31:
 671:ServerLLDN.c  **** 			
 672:ServerLLDN.c  **** 		}
 673:ServerLLDN.c  **** 
 674:ServerLLDN.c  **** 		else if (rec_beacon.Flags.txState == RESET_MODE)
 1401               		.loc 6 674 0
 1402 0616 8091 0000 		lds r24,rec_beacon+3
 1403 061a 8770      		andi r24,lo8(7)
 1404 061c 8730      		cpi r24,lo8(7)
 1405 061e 01F4      		brne .L37
 675:ServerLLDN.c  **** 		{
 676:ServerLLDN.c  **** 			PHY_SetTdmaMode(false);
 1406               		.loc 6 676 0
 1407 0620 80E0      		ldi r24,0
 1408 0622 0E94 0000 		call PHY_SetTdmaMode
 677:ServerLLDN.c  **** 			ack_received = 0;
 1409               		.loc 6 677 0
 1410 0626 1092 0000 		sts ack_received,__zero_reg__
 678:ServerLLDN.c  **** 			STATE = DISC_MODE;
 1411               		.loc 6 678 0
 1412 062a 84E0      		ldi r24,lo8(4)
 1413 062c 8093 0000 		sts STATE,r24
 1414               	.L37:
 679:ServerLLDN.c  **** 		}
 680:ServerLLDN.c  **** 		return true;
 1415               		.loc 6 680 0
 1416 0630 81E0      		ldi r24,lo8(1)
 1417               	/* epilogue start */
 681:ServerLLDN.c  **** 	}
 1418               		.loc 6 681 0
 1419 0632 0F90      		pop __tmp_reg__
 1420 0634 0F90      		pop __tmp_reg__
 1421 0636 0F90      		pop __tmp_reg__
 1422 0638 0F90      		pop __tmp_reg__
 1423 063a DF91      		pop r29
 1424 063c CF91      		pop r28
 1425 063e 1F91      		pop r17
 1426 0640 0F91      		pop r16
 1427 0642 FF90      		pop r15
 1428 0644 EF90      		pop r14
 1429 0646 0895      		ret
 1430               		.cfi_endproc
 1431               	.LFE136:
 1433               		.section	.rodata
 1434               	.LC6:
 1435 002e 0A20 6163 		.string	"\n ack rec %hhx "
 1435      6B20 7265 
 1435      6320 2568 
 1435      6878 2000 
 1436               		.text
 1437               	.global	check_ack
 1439               	check_ack:
 1440               	.LFB137:
 682:ServerLLDN.c  **** 	
 683:ServerLLDN.c  **** 	bool check_ack(int addr)
 684:ServerLLDN.c  **** 	{
 1441               		.loc 6 684 0
 1442               		.cfi_startproc
 1443 0648 CF93      		push r28
 1444               	.LCFI62:
 1445               		.cfi_def_cfa_offset 3
 1446               		.cfi_offset 28, -2
 1447 064a DF93      		push r29
 1448               	.LCFI63:
 1449               		.cfi_def_cfa_offset 4
 1450               		.cfi_offset 29, -3
 1451 064c 00D0      		rcall .
 1452 064e 00D0      		rcall .
 1453 0650 00D0      		rcall .
 1454               	.LCFI64:
 1455               		.cfi_def_cfa_offset 10
 1456 0652 CDB7      		in r28,__SP_L__
 1457 0654 DEB7      		in r29,__SP_H__
 1458               	.LCFI65:
 1459               		.cfi_def_cfa_register 28
 1460               	/* prologue: function */
 1461               	/* frame size = 6 */
 1462               	/* stack size = 8 */
 1463               	.L__stack_usage = 8
 1464 0656 9E83      		std Y+6,r25
 1465 0658 8D83      		std Y+5,r24
 685:ServerLLDN.c  **** 		int pos,bit_shift;
 686:ServerLLDN.c  **** 		if(addr == 8)
 1466               		.loc 6 686 0
 1467 065a 8D81      		ldd r24,Y+5
 1468 065c 9E81      		ldd r25,Y+6
 1469 065e 0897      		sbiw r24,8
 1470 0660 01F4      		brne .L40
 687:ServerLLDN.c  **** 		{
 688:ServerLLDN.c  **** 			pos = 0;
 1471               		.loc 6 688 0
 1472 0662 1A82      		std Y+2,__zero_reg__
 1473 0664 1982      		std Y+1,__zero_reg__
 689:ServerLLDN.c  **** 			bit_shift = 0;
 1474               		.loc 6 689 0
 1475 0666 1C82      		std Y+4,__zero_reg__
 1476 0668 1B82      		std Y+3,__zero_reg__
 1477 066a 00C0      		rjmp .L41
 1478               	.L40:
 690:ServerLLDN.c  **** 		}
 691:ServerLLDN.c  **** 		else
 692:ServerLLDN.c  **** 		{
 693:ServerLLDN.c  **** 			pos =  addr / 8;
 1479               		.loc 6 693 0
 1480 066c 8D81      		ldd r24,Y+5
 1481 066e 9E81      		ldd r25,Y+6
 1482 0670 9923      		tst r25
 1483 0672 04F4      		brge .L42
 1484 0674 0796      		adiw r24,7
 1485               	.L42:
 1486 0676 9595      		asr r25
 1487 0678 8795      		ror r24
 1488 067a 9595      		asr r25
 1489 067c 8795      		ror r24
 1490 067e 9595      		asr r25
 1491 0680 8795      		ror r24
 1492 0682 9A83      		std Y+2,r25
 1493 0684 8983      		std Y+1,r24
 694:ServerLLDN.c  **** 			bit_shift = 8 - addr % 8;
 1494               		.loc 6 694 0
 1495 0686 8D81      		ldd r24,Y+5
 1496 0688 9E81      		ldd r25,Y+6
 1497 068a 8770      		andi r24,7
 1498 068c 9078      		andi r25,128
 1499 068e 9923      		tst r25
 1500 0690 04F4      		brge .L43
 1501 0692 0197      		sbiw r24,1
 1502 0694 886F      		ori r24,248
 1503 0696 9F6F      		ori r25,255
 1504 0698 0196      		adiw r24,1
 1505               	.L43:
 1506 069a 9C01      		movw r18,r24
 1507 069c 88E0      		ldi r24,lo8(8)
 1508 069e 90E0      		ldi r25,0
 1509 06a0 821B      		sub r24,r18
 1510 06a2 930B      		sbc r25,r19
 1511 06a4 9C83      		std Y+4,r25
 1512 06a6 8B83      		std Y+3,r24
 1513               	.L41:
 695:ServerLLDN.c  **** 		}
 696:ServerLLDN.c  **** 		printf("\n ack rec %hhx ", ackframe->ackFlags[pos]);
 1514               		.loc 6 696 0
 1515 06a8 2091 0000 		lds r18,ackframe
 1516 06ac 3091 0000 		lds r19,ackframe+1
 1517 06b0 8981      		ldd r24,Y+1
 1518 06b2 9A81      		ldd r25,Y+2
 1519 06b4 820F      		add r24,r18
 1520 06b6 931F      		adc r25,r19
 1521 06b8 0196      		adiw r24,1
 1522 06ba FC01      		movw r30,r24
 1523 06bc 8081      		ld r24,Z
 1524 06be 882F      		mov r24,r24
 1525 06c0 90E0      		ldi r25,0
 1526 06c2 292F      		mov r18,r25
 1527 06c4 2F93      		push r18
 1528 06c6 8F93      		push r24
 1529 06c8 80E0      		ldi r24,lo8(.LC6)
 1530 06ca 90E0      		ldi r25,hi8(.LC6)
 1531 06cc 892F      		mov r24,r25
 1532 06ce 8F93      		push r24
 1533 06d0 80E0      		ldi r24,lo8(.LC6)
 1534 06d2 90E0      		ldi r25,hi8(.LC6)
 1535 06d4 8F93      		push r24
 1536 06d6 0E94 0000 		call printf
 1537 06da 0F90      		pop __tmp_reg__
 1538 06dc 0F90      		pop __tmp_reg__
 1539 06de 0F90      		pop __tmp_reg__
 1540 06e0 0F90      		pop __tmp_reg__
 697:ServerLLDN.c  **** 		if( ackframe->ackFlags[pos] & 1 << bit_shift)
 1541               		.loc 6 697 0
 1542 06e2 2091 0000 		lds r18,ackframe
 1543 06e6 3091 0000 		lds r19,ackframe+1
 1544 06ea 8981      		ldd r24,Y+1
 1545 06ec 9A81      		ldd r25,Y+2
 1546 06ee 820F      		add r24,r18
 1547 06f0 931F      		adc r25,r19
 1548 06f2 0196      		adiw r24,1
 1549 06f4 FC01      		movw r30,r24
 1550 06f6 8081      		ld r24,Z
 1551 06f8 882F      		mov r24,r24
 1552 06fa 90E0      		ldi r25,0
 1553 06fc 0B80      		ldd r0,Y+3
 1554 06fe 00C0      		rjmp 2f
 1555               		1:
 1556 0700 9595      		asr r25
 1557 0702 8795      		ror r24
 1558               		2:
 1559 0704 0A94      		dec r0
 1560 0706 02F4      		brpl 1b
 1561 0708 8170      		andi r24,1
 1562 070a 9927      		clr r25
 1563 070c 892B      		or r24,r25
 1564 070e 01F0      		breq .L44
 698:ServerLLDN.c  **** 		{
 699:ServerLLDN.c  **** 			return true;
 1565               		.loc 6 699 0
 1566 0710 81E0      		ldi r24,lo8(1)
 1567 0712 00C0      		rjmp .L45
 1568               	.L44:
 700:ServerLLDN.c  **** 		}
 701:ServerLLDN.c  **** 		else
 702:ServerLLDN.c  **** 			return false;
 1569               		.loc 6 702 0
 1570 0714 80E0      		ldi r24,0
 1571               	.L45:
 1572               	/* epilogue start */
 703:ServerLLDN.c  **** 	}
 1573               		.loc 6 703 0
 1574 0716 2696      		adiw r28,6
 1575 0718 0FB6      		in __tmp_reg__,__SREG__
 1576 071a F894      		cli
 1577 071c DEBF      		out __SP_H__,r29
 1578 071e 0FBE      		out __SREG__,__tmp_reg__
 1579 0720 CDBF      		out __SP_L__,r28
 1580 0722 DF91      		pop r29
 1581 0724 CF91      		pop r28
 1582 0726 0895      		ret
 1583               		.cfi_endproc
 1584               	.LFE137:
 1586               	.global	__subsf3
 1587               	.global	__fixunssfsi
 1588               		.section	.rodata
 1589               	.LC7:
 1590 003e 0A72 6574 		.string	"\nretransmition_slot %d , %f"
 1590      7261 6E73 
 1590      6D69 7469 
 1590      6F6E 5F73 
 1590      6C6F 7420 
 1591               		.text
 1593               	appAckInd:
 1594               	.LFB138:
 704:ServerLLDN.c  **** 	
 705:ServerLLDN.c  **** 	static bool appAckInd(NWK_DataInd_t *ind)
 706:ServerLLDN.c  **** 	{
 1595               		.loc 6 706 0
 1596               		.cfi_startproc
 1597 0728 EF92      		push r14
 1598               	.LCFI66:
 1599               		.cfi_def_cfa_offset 3
 1600               		.cfi_offset 14, -2
 1601 072a FF92      		push r15
 1602               	.LCFI67:
 1603               		.cfi_def_cfa_offset 4
 1604               		.cfi_offset 15, -3
 1605 072c 0F93      		push r16
 1606               	.LCFI68:
 1607               		.cfi_def_cfa_offset 5
 1608               		.cfi_offset 16, -4
 1609 072e 1F93      		push r17
 1610               	.LCFI69:
 1611               		.cfi_def_cfa_offset 6
 1612               		.cfi_offset 17, -5
 1613 0730 CF93      		push r28
 1614               	.LCFI70:
 1615               		.cfi_def_cfa_offset 7
 1616               		.cfi_offset 28, -6
 1617 0732 DF93      		push r29
 1618               	.LCFI71:
 1619               		.cfi_def_cfa_offset 8
 1620               		.cfi_offset 29, -7
 1621 0734 00D0      		rcall .
 1622 0736 00D0      		rcall .
 1623 0738 00D0      		rcall .
 1624               	.LCFI72:
 1625               		.cfi_def_cfa_offset 14
 1626 073a CDB7      		in r28,__SP_L__
 1627 073c DEB7      		in r29,__SP_H__
 1628               	.LCFI73:
 1629               		.cfi_def_cfa_register 28
 1630               	/* prologue: function */
 1631               	/* frame size = 6 */
 1632               	/* stack size = 12 */
 1633               	.L__stack_usage = 12
 1634 073e 9E83      		std Y+6,r25
 1635 0740 8D83      		std Y+5,r24
 707:ServerLLDN.c  **** 		#if !MASTER_MACSC
 708:ServerLLDN.c  **** 		ind->data = ind->data - (uint8_t) 1;
 709:ServerLLDN.c  **** 		#endif
 710:ServerLLDN.c  **** 		ackframe = (NWK_ACKFormat_t*)ind->data;
 1636               		.loc 6 710 0
 1637 0742 8D81      		ldd r24,Y+5
 1638 0744 9E81      		ldd r25,Y+6
 1639 0746 FC01      		movw r30,r24
 1640 0748 8085      		ldd r24,Z+8
 1641 074a 9185      		ldd r25,Z+9
 1642 074c 9093 0000 		sts ackframe+1,r25
 1643 0750 8093 0000 		sts ackframe,r24
 711:ServerLLDN.c  **** 
 712:ServerLLDN.c  **** 		if(PanId == ackframe->sourceId)
 1644               		.loc 6 712 0
 1645 0754 8091 0000 		lds r24,ackframe
 1646 0758 9091 0000 		lds r25,ackframe+1
 1647 075c FC01      		movw r30,r24
 1648 075e 9081      		ld r25,Z
 1649 0760 8091 0000 		lds r24,PanId
 1650 0764 9817      		cp r25,r24
 1651 0766 01F0      		breq .+2
 1652 0768 00C0      		rjmp .L47
 713:ServerLLDN.c  **** 		{
 714:ServerLLDN.c  **** 			if(STATE == ONLINE_MODE && rec_beacon.Flags.txState == ONLINE_MODE)
 1653               		.loc 6 714 0
 1654 076a 8091 0000 		lds r24,STATE
 1655 076e 8823      		tst r24
 1656 0770 01F0      		breq .+2
 1657 0772 00C0      		rjmp .L48
 1658               		.loc 6 714 0 is_stmt 0 discriminator 1
 1659 0774 8091 0000 		lds r24,rec_beacon+3
 1660 0778 8770      		andi r24,lo8(7)
 1661 077a 8823      		tst r24
 1662 077c 01F0      		breq .+2
 1663 077e 00C0      		rjmp .L48
 715:ServerLLDN.c  **** 			{
 716:ServerLLDN.c  **** 				ack_received = check_ack(assTimeSlot + 1);
 1664               		.loc 6 716 0 is_stmt 1
 1665 0780 8091 0000 		lds r24,assTimeSlot
 1666 0784 882F      		mov r24,r24
 1667 0786 90E0      		ldi r25,0
 1668 0788 0196      		adiw r24,1
 1669 078a 0E94 0000 		call check_ack
 1670 078e 8093 0000 		sts ack_received,r24
 717:ServerLLDN.c  **** 				if(!ack_received)
 1671               		.loc 6 717 0
 1672 0792 9091 0000 		lds r25,ack_received
 1673 0796 81E0      		ldi r24,lo8(1)
 1674 0798 8927      		eor r24,r25
 1675 079a 8823      		tst r24
 1676 079c 01F4      		brne .+2
 1677 079e 00C0      		rjmp .L47
 1678               	.LBB2:
 718:ServerLLDN.c  **** 				{
 719:ServerLLDN.c  **** 				
 720:ServerLLDN.c  **** 					int retransmition_slot = 0;
 1679               		.loc 6 720 0
 1680 07a0 1A82      		std Y+2,__zero_reg__
 1681 07a2 1982      		std Y+1,__zero_reg__
 1682               	.LBB3:
 721:ServerLLDN.c  **** 					
 722:ServerLLDN.c  **** 
 723:ServerLLDN.c  **** 					for(int i = 0; i < assTimeSlot && i < (rec_beacon.NumberOfBaseTimeslotsinSuperframe - 3)/2; i+
 1683               		.loc 6 723 0
 1684 07a4 1C82      		std Y+4,__zero_reg__
 1685 07a6 1B82      		std Y+3,__zero_reg__
 1686 07a8 00C0      		rjmp .L50
 1687               	.L54:
 724:ServerLLDN.c  **** 						if( !check_ack(i+1) )
 1688               		.loc 6 724 0
 1689 07aa 8B81      		ldd r24,Y+3
 1690 07ac 9C81      		ldd r25,Y+4
 1691 07ae 0196      		adiw r24,1
 1692 07b0 0E94 0000 		call check_ack
 1693 07b4 982F      		mov r25,r24
 1694 07b6 81E0      		ldi r24,lo8(1)
 1695 07b8 8927      		eor r24,r25
 1696 07ba 8823      		tst r24
 1697 07bc 01F0      		breq .L51
 725:ServerLLDN.c  **** 							retransmition_slot++;
 1698               		.loc 6 725 0
 1699 07be 8981      		ldd r24,Y+1
 1700 07c0 9A81      		ldd r25,Y+2
 1701 07c2 0196      		adiw r24,1
 1702 07c4 9A83      		std Y+2,r25
 1703 07c6 8983      		std Y+1,r24
 1704               	.L51:
 723:ServerLLDN.c  **** 						if( !check_ack(i+1) )
 1705               		.loc 6 723 0 discriminator 2
 1706 07c8 8B81      		ldd r24,Y+3
 1707 07ca 9C81      		ldd r25,Y+4
 1708 07cc 0196      		adiw r24,1
 1709 07ce 9C83      		std Y+4,r25
 1710 07d0 8B83      		std Y+3,r24
 1711               	.L50:
 723:ServerLLDN.c  **** 						if( !check_ack(i+1) )
 1712               		.loc 6 723 0 is_stmt 0 discriminator 1
 1713 07d2 8091 0000 		lds r24,assTimeSlot
 1714 07d6 282F      		mov r18,r24
 1715 07d8 30E0      		ldi r19,0
 1716 07da 8B81      		ldd r24,Y+3
 1717 07dc 9C81      		ldd r25,Y+4
 1718 07de 8217      		cp r24,r18
 1719 07e0 9307      		cpc r25,r19
 1720 07e2 04F4      		brge .L52
 723:ServerLLDN.c  **** 						if( !check_ack(i+1) )
 1721               		.loc 6 723 0 discriminator 3
 1722 07e4 8091 0000 		lds r24,rec_beacon+7
 1723 07e8 882F      		mov r24,r24
 1724 07ea 90E0      		ldi r25,0
 1725 07ec 0397      		sbiw r24,3
 1726 07ee 9923      		tst r25
 1727 07f0 04F4      		brge .L53
 1728 07f2 0196      		adiw r24,1
 1729               	.L53:
 1730 07f4 9595      		asr r25
 1731 07f6 8795      		ror r24
 1732 07f8 9C01      		movw r18,r24
 1733 07fa 8B81      		ldd r24,Y+3
 1734 07fc 9C81      		ldd r25,Y+4
 1735 07fe 8217      		cp r24,r18
 1736 0800 9307      		cpc r25,r19
 1737 0802 04F0      		brlt .L54
 1738               	.L52:
 1739               	.LBE3:
 726:ServerLLDN.c  **** 					
 727:ServerLLDN.c  **** 					
 728:ServerLLDN.c  **** // 					if( retransmition_slot > (rec_beacon.NumberOfBaseTimeslotsinSuperframe - 3)/2 - 1)
 729:ServerLLDN.c  **** // 						return false;
 730:ServerLLDN.c  **** 										
 731:ServerLLDN.c  **** 					
 732:ServerLLDN.c  **** 					if(retransmition_slot == 0)
 1740               		.loc 6 732 0 is_stmt 1
 1741 0804 8981      		ldd r24,Y+1
 1742 0806 9A81      		ldd r25,Y+2
 1743 0808 892B      		or r24,r25
 1744 080a 01F4      		brne .L55
 733:ServerLLDN.c  **** 					{
 734:ServerLLDN.c  **** 						NWK_DataReq(&msgReqData);
 1745               		.loc 6 734 0
 1746 080c 80E0      		ldi r24,lo8(msgReqData)
 1747 080e 90E0      		ldi r25,hi8(msgReqData)
 1748 0810 0E94 0000 		call NWK_DataReq
 1749 0814 00C0      		rjmp .L56
 1750               	.L55:
 735:ServerLLDN.c  **** 					}
 736:ServerLLDN.c  **** 					else
 737:ServerLLDN.c  **** 					{
 738:ServerLLDN.c  **** 						#if MASTER_MACSC
 739:ServerLLDN.c  **** 						macsc_enable_manual_bts();
 1751               		.loc 6 739 0
 1752 0816 0E94 0000 		call macsc_enable_manual_bts
 740:ServerLLDN.c  **** 						macsc_set_cmp1_int_cb(online_time_hndlr);
 1753               		.loc 6 740 0
 1754 081a 80E0      		ldi r24,lo8(gs(online_time_hndlr))
 1755 081c 90E0      		ldi r25,hi8(gs(online_time_hndlr))
 1756 081e 0E94 0000 		call macsc_set_cmp1_int_cb
 741:ServerLLDN.c  **** 						macsc_enable_cmp_int(MACSC_CC1);
 1757               		.loc 6 741 0
 1758 0822 81E0      		ldi r24,lo8(1)
 1759 0824 0E94 0000 		call macsc_enable_cmp_int
 742:ServerLLDN.c  **** 						macsc_use_cmp(MACSC_RELATIVE_CMP, tTS * retransmition_slot - 40, MACSC_CC1);
 1760               		.loc 6 742 0
 1761 0828 8981      		ldd r24,Y+1
 1762 082a 9A81      		ldd r25,Y+2
 1763 082c 092E      		mov __tmp_reg__,r25
 1764 082e 000C      		lsl r0
 1765 0830 AA0B      		sbc r26,r26
 1766 0832 BB0B      		sbc r27,r27
 1767 0834 BC01      		movw r22,r24
 1768 0836 CD01      		movw r24,r26
 1769 0838 0E94 0000 		call __floatsisf
 1770 083c 7B01      		movw r14,r22
 1771 083e 8C01      		movw r16,r24
 1772 0840 8091 0000 		lds r24,tTS
 1773 0844 9091 0000 		lds r25,tTS+1
 1774 0848 A091 0000 		lds r26,tTS+2
 1775 084c B091 0000 		lds r27,tTS+3
 1776 0850 9C01      		movw r18,r24
 1777 0852 AD01      		movw r20,r26
 1778 0854 C801      		movw r24,r16
 1779 0856 B701      		movw r22,r14
 1780 0858 0E94 0000 		call __mulsf3
 1781 085c DC01      		movw r26,r24
 1782 085e CB01      		movw r24,r22
 1783 0860 20E0      		ldi r18,0
 1784 0862 30E0      		ldi r19,0
 1785 0864 40E2      		ldi r20,lo8(32)
 1786 0866 52E4      		ldi r21,lo8(66)
 1787 0868 BC01      		movw r22,r24
 1788 086a CD01      		movw r24,r26
 1789 086c 0E94 0000 		call __subsf3
 1790 0870 DC01      		movw r26,r24
 1791 0872 CB01      		movw r24,r22
 1792 0874 BC01      		movw r22,r24
 1793 0876 CD01      		movw r24,r26
 1794 0878 0E94 0000 		call __fixunssfsi
 1795 087c DC01      		movw r26,r24
 1796 087e CB01      		movw r24,r22
 1797 0880 21E0      		ldi r18,lo8(1)
 1798 0882 AC01      		movw r20,r24
 1799 0884 BD01      		movw r22,r26
 1800 0886 81E0      		ldi r24,lo8(1)
 1801 0888 0E94 0000 		call macsc_use_cmp
 1802               	.L56:
 743:ServerLLDN.c  **** 						#endif
 744:ServerLLDN.c  **** 					}					
 745:ServerLLDN.c  **** 					printf("\nretransmition_slot %d , %f", retransmition_slot, tTS);
 1803               		.loc 6 745 0
 1804 088c 8091 0000 		lds r24,tTS
 1805 0890 9091 0000 		lds r25,tTS+1
 1806 0894 A091 0000 		lds r26,tTS+2
 1807 0898 B091 0000 		lds r27,tTS+3
 1808 089c 2B2F      		mov r18,r27
 1809 089e 2F93      		push r18
 1810 08a0 2A2F      		mov r18,r26
 1811 08a2 2F93      		push r18
 1812 08a4 292F      		mov r18,r25
 1813 08a6 2F93      		push r18
 1814 08a8 8F93      		push r24
 1815 08aa 8A81      		ldd r24,Y+2
 1816 08ac 8F93      		push r24
 1817 08ae 8981      		ldd r24,Y+1
 1818 08b0 8F93      		push r24
 1819 08b2 80E0      		ldi r24,lo8(.LC7)
 1820 08b4 90E0      		ldi r25,hi8(.LC7)
 1821 08b6 892F      		mov r24,r25
 1822 08b8 8F93      		push r24
 1823 08ba 80E0      		ldi r24,lo8(.LC7)
 1824 08bc 90E0      		ldi r25,hi8(.LC7)
 1825 08be 8F93      		push r24
 1826 08c0 0E94 0000 		call printf
 1827 08c4 8DB7      		in r24,__SP_L__
 1828 08c6 9EB7      		in r25,__SP_H__
 1829 08c8 0896      		adiw r24,8
 1830 08ca 0FB6      		in __tmp_reg__,__SREG__
 1831 08cc F894      		cli
 1832 08ce DEBF      		out __SP_H__,r29
 1833 08d0 0FBE      		out __SREG__,__tmp_reg__
 1834 08d2 CDBF      		out __SP_L__,r28
 1835               	.LBE2:
 717:ServerLLDN.c  **** 				{
 1836               		.loc 6 717 0
 1837 08d4 00C0      		rjmp .L47
 1838               	.L48:
 746:ServerLLDN.c  **** 
 747:ServerLLDN.c  **** 				}				
 748:ServerLLDN.c  **** 			}
 749:ServerLLDN.c  **** 			else
 750:ServerLLDN.c  **** 			{
 751:ServerLLDN.c  **** 				ack_received = check_ack(APP_ADDR);								
 1839               		.loc 6 751 0
 1840 08d6 81E0      		ldi r24,lo8(1)
 1841 08d8 90E0      		ldi r25,0
 1842 08da 0E94 0000 		call check_ack
 1843 08de 8093 0000 		sts ack_received,r24
 752:ServerLLDN.c  **** 				if(STATE == DISC_MODE && ack_received)
 1844               		.loc 6 752 0
 1845 08e2 8091 0000 		lds r24,STATE
 1846 08e6 8430      		cpi r24,lo8(4)
 1847 08e8 01F4      		brne .L47
 1848               		.loc 6 752 0 is_stmt 0 discriminator 1
 1849 08ea 8091 0000 		lds r24,ack_received
 1850 08ee 8823      		tst r24
 1851 08f0 01F0      		breq .L47
 753:ServerLLDN.c  **** 					STATE = CONFIG_MODE;
 1852               		.loc 6 753 0 is_stmt 1
 1853 08f2 86E0      		ldi r24,lo8(6)
 1854 08f4 8093 0000 		sts STATE,r24
 1855               	.L47:
 754:ServerLLDN.c  **** 			}
 755:ServerLLDN.c  **** 		}
 756:ServerLLDN.c  **** 		return true;
 1856               		.loc 6 756 0
 1857 08f8 81E0      		ldi r24,lo8(1)
 1858               	/* epilogue start */
 757:ServerLLDN.c  **** 	}
 1859               		.loc 6 757 0
 1860 08fa 2696      		adiw r28,6
 1861 08fc 0FB6      		in __tmp_reg__,__SREG__
 1862 08fe F894      		cli
 1863 0900 DEBF      		out __SP_H__,r29
 1864 0902 0FBE      		out __SREG__,__tmp_reg__
 1865 0904 CDBF      		out __SP_L__,r28
 1866 0906 DF91      		pop r29
 1867 0908 CF91      		pop r28
 1868 090a 1F91      		pop r17
 1869 090c 0F91      		pop r16
 1870 090e FF90      		pop r15
 1871 0910 EF90      		pop r14
 1872 0912 0895      		ret
 1873               		.cfi_endproc
 1874               	.LFE138:
 1876               		.section	.rodata
 1877               	.LC8:
 1878 005a 0A20 6173 		.string	"\n asstimeslot %d, tsDuration %hhx"
 1878      7374 696D 
 1878      6573 6C6F 
 1878      7420 2564 
 1878      2C20 7473 
 1879               		.text
 1881               	appCommandInd:
 1882               	.LFB139:
 758:ServerLLDN.c  **** 	
 759:ServerLLDN.c  **** 	static bool appCommandInd(NWK_DataInd_t *ind)
 760:ServerLLDN.c  **** 	{
 1883               		.loc 6 760 0
 1884               		.cfi_startproc
 1885 0914 CF93      		push r28
 1886               	.LCFI74:
 1887               		.cfi_def_cfa_offset 3
 1888               		.cfi_offset 28, -2
 1889 0916 DF93      		push r29
 1890               	.LCFI75:
 1891               		.cfi_def_cfa_offset 4
 1892               		.cfi_offset 29, -3
 1893 0918 00D0      		rcall .
 1894 091a 00D0      		rcall .
 1895               	.LCFI76:
 1896               		.cfi_def_cfa_offset 8
 1897 091c CDB7      		in r28,__SP_L__
 1898 091e DEB7      		in r29,__SP_H__
 1899               	.LCFI77:
 1900               		.cfi_def_cfa_register 28
 1901               	/* prologue: function */
 1902               	/* frame size = 4 */
 1903               	/* stack size = 6 */
 1904               	.L__stack_usage = 6
 1905 0920 9C83      		std Y+4,r25
 1906 0922 8B83      		std Y+3,r24
 761:ServerLLDN.c  **** 		#if !MASTER_MACSC
 762:ServerLLDN.c  **** 		ind->data = ind->data - (uint8_t) 1;
 763:ServerLLDN.c  **** 		#endif
 764:ServerLLDN.c  **** 		
 765:ServerLLDN.c  **** 		if(ind->data[0] == LL_CONFIGURATION_REQUEST)
 1907               		.loc 6 765 0
 1908 0924 8B81      		ldd r24,Y+3
 1909 0926 9C81      		ldd r25,Y+4
 1910 0928 FC01      		movw r30,r24
 1911 092a 8085      		ldd r24,Z+8
 1912 092c 9185      		ldd r25,Z+9
 1913 092e FC01      		movw r30,r24
 1914 0930 8081      		ld r24,Z
 1915 0932 8F30      		cpi r24,lo8(15)
 1916 0934 01F0      		breq .+2
 1917 0936 00C0      		rjmp .L59
 1918               	.LBB4:
 766:ServerLLDN.c  **** 		{
 767:ServerLLDN.c  **** 			NWK_ConfigRequest_t *msg = (NWK_ConfigRequest_t*)ind->data;
 1919               		.loc 6 767 0
 1920 0938 8B81      		ldd r24,Y+3
 1921 093a 9C81      		ldd r25,Y+4
 1922 093c FC01      		movw r30,r24
 1923 093e 8085      		ldd r24,Z+8
 1924 0940 9185      		ldd r25,Z+9
 1925 0942 9A83      		std Y+2,r25
 1926 0944 8983      		std Y+1,r24
 768:ServerLLDN.c  **** 			if(msg->macAddr == APP_ADDR)
 1927               		.loc 6 768 0
 1928 0946 8981      		ldd r24,Y+1
 1929 0948 9A81      		ldd r25,Y+2
 1930 094a FC01      		movw r30,r24
 1931 094c 8481      		ldd r24,Z+4
 1932 094e 8130      		cpi r24,lo8(1)
 1933 0950 01F0      		breq .+2
 1934 0952 00C0      		rjmp .L59
 769:ServerLLDN.c  **** 			{
 770:ServerLLDN.c  **** 				PHY_SetChannel(msg->tx_channel);
 1935               		.loc 6 770 0
 1936 0954 8981      		ldd r24,Y+1
 1937 0956 9A81      		ldd r25,Y+2
 1938 0958 FC01      		movw r30,r24
 1939 095a 8281      		ldd r24,Z+2
 1940 095c 0E94 0000 		call PHY_SetChannel
 771:ServerLLDN.c  **** 				NWK_SetPanId(msg->s_macAddr);
 1941               		.loc 6 771 0
 1942 0960 8981      		ldd r24,Y+1
 1943 0962 9A81      		ldd r25,Y+2
 1944 0964 FC01      		movw r30,r24
 1945 0966 8181      		ldd r24,Z+1
 1946 0968 882F      		mov r24,r24
 1947 096a 90E0      		ldi r25,0
 1948 096c 0E94 0000 		call NWK_SetPanId
 772:ServerLLDN.c  **** 				PanId = msg->s_macAddr;
 1949               		.loc 6 772 0
 1950 0970 8981      		ldd r24,Y+1
 1951 0972 9A81      		ldd r25,Y+2
 1952 0974 FC01      		movw r30,r24
 1953 0976 8181      		ldd r24,Z+1
 1954 0978 8093 0000 		sts PanId,r24
 773:ServerLLDN.c  **** 				assTimeSlot = msg->assTimeSlot;
 1955               		.loc 6 773 0
 1956 097c 8981      		ldd r24,Y+1
 1957 097e 9A81      		ldd r25,Y+2
 1958 0980 FC01      		movw r30,r24
 1959 0982 8381      		ldd r24,Z+3
 1960 0984 8093 0000 		sts assTimeSlot,r24
 774:ServerLLDN.c  **** 				n = msg->conf.tsDuration;
 1961               		.loc 6 774 0
 1962 0988 8981      		ldd r24,Y+1
 1963 098a 9A81      		ldd r25,Y+2
 1964 098c FC01      		movw r30,r24
 1965 098e 8581      		ldd r24,Z+5
 1966 0990 8F77      		andi r24,lo8(127)
 1967 0992 8093 0000 		sts n,r24
 775:ServerLLDN.c  **** 				associated = 1;
 1968               		.loc 6 775 0
 1969 0996 81E0      		ldi r24,lo8(1)
 1970 0998 8093 0000 		sts associated,r24
 776:ServerLLDN.c  **** 				STATE = ONLINE_MODE;
 1971               		.loc 6 776 0
 1972 099c 1092 0000 		sts STATE,__zero_reg__
 777:ServerLLDN.c  **** 				PHY_SetTdmaMode(true);
 1973               		.loc 6 777 0
 1974 09a0 81E0      		ldi r24,lo8(1)
 1975 09a2 0E94 0000 		call PHY_SetTdmaMode
 778:ServerLLDN.c  **** 				printf("\n asstimeslot %d, tsDuration %hhx", assTimeSlot, n);
 1976               		.loc 6 778 0
 1977 09a6 8091 0000 		lds r24,n
 1978 09aa 282F      		mov r18,r24
 1979 09ac 30E0      		ldi r19,0
 1980 09ae 8091 0000 		lds r24,assTimeSlot
 1981 09b2 882F      		mov r24,r24
 1982 09b4 90E0      		ldi r25,0
 1983 09b6 432F      		mov r20,r19
 1984 09b8 4F93      		push r20
 1985 09ba 2F93      		push r18
 1986 09bc 292F      		mov r18,r25
 1987 09be 2F93      		push r18
 1988 09c0 8F93      		push r24
 1989 09c2 80E0      		ldi r24,lo8(.LC8)
 1990 09c4 90E0      		ldi r25,hi8(.LC8)
 1991 09c6 892F      		mov r24,r25
 1992 09c8 8F93      		push r24
 1993 09ca 80E0      		ldi r24,lo8(.LC8)
 1994 09cc 90E0      		ldi r25,hi8(.LC8)
 1995 09ce 8F93      		push r24
 1996 09d0 0E94 0000 		call printf
 1997 09d4 0F90      		pop __tmp_reg__
 1998 09d6 0F90      		pop __tmp_reg__
 1999 09d8 0F90      		pop __tmp_reg__
 2000 09da 0F90      		pop __tmp_reg__
 2001 09dc 0F90      		pop __tmp_reg__
 2002 09de 0F90      		pop __tmp_reg__
 2003               	.L59:
 2004               	.LBE4:
 779:ServerLLDN.c  **** 			}
 780:ServerLLDN.c  **** 		}
 781:ServerLLDN.c  **** 		return true;
 2005               		.loc 6 781 0
 2006 09e0 81E0      		ldi r24,lo8(1)
 2007               	/* epilogue start */
 782:ServerLLDN.c  **** 	}
 2008               		.loc 6 782 0
 2009 09e2 0F90      		pop __tmp_reg__
 2010 09e4 0F90      		pop __tmp_reg__
 2011 09e6 0F90      		pop __tmp_reg__
 2012 09e8 0F90      		pop __tmp_reg__
 2013 09ea DF91      		pop r29
 2014 09ec CF91      		pop r28
 2015 09ee 0895      		ret
 2016               		.cfi_endproc
 2017               	.LFE139:
 2019               	.global	appPrepareDiscoverResponse
 2021               	appPrepareDiscoverResponse:
 2022               	.LFB140:
 783:ServerLLDN.c  **** 
 784:ServerLLDN.c  **** 	void appPrepareDiscoverResponse()
 785:ServerLLDN.c  **** 	{
 2023               		.loc 6 785 0
 2024               		.cfi_startproc
 2025 09f0 CF93      		push r28
 2026               	.LCFI78:
 2027               		.cfi_def_cfa_offset 3
 2028               		.cfi_offset 28, -2
 2029 09f2 DF93      		push r29
 2030               	.LCFI79:
 2031               		.cfi_def_cfa_offset 4
 2032               		.cfi_offset 29, -3
 2033 09f4 CDB7      		in r28,__SP_L__
 2034 09f6 DEB7      		in r29,__SP_H__
 2035               	.LCFI80:
 2036               		.cfi_def_cfa_register 28
 2037               	/* prologue: function */
 2038               	/* frame size = 0 */
 2039               	/* stack size = 2 */
 2040               	.L__stack_usage = 2
 786:ServerLLDN.c  **** 		msgReq.dstAddr				= 0;
 2041               		.loc 6 786 0
 2042 09f8 1092 0000 		sts msgReq+5+1,__zero_reg__
 2043 09fc 1092 0000 		sts msgReq+5,__zero_reg__
 787:ServerLLDN.c  **** 		msgReq.dstEndpoint			= APP_COMMAND_ENDPOINT;
 2044               		.loc 6 787 0
 2045 0a00 83E0      		ldi r24,lo8(3)
 2046 0a02 8093 0000 		sts msgReq+7,r24
 788:ServerLLDN.c  **** 		msgReq.srcEndpoint			= APP_COMMAND_ENDPOINT;
 2047               		.loc 6 788 0
 2048 0a06 83E0      		ldi r24,lo8(3)
 2049 0a08 8093 0000 		sts msgReq+8,r24
 789:ServerLLDN.c  **** 		msgReq.options				= NWK_OPT_MAC_COMMAND;
 2050               		.loc 6 789 0
 2051 0a0c 80E0      		ldi r24,0
 2052 0a0e 90E8      		ldi r25,lo8(-128)
 2053 0a10 9093 0000 		sts msgReq+9+1,r25
 2054 0a14 8093 0000 		sts msgReq+9,r24
 790:ServerLLDN.c  **** 		msgReq.data					= (uint8_t*)&msgDiscResponse;
 2055               		.loc 6 790 0
 2056 0a18 80E0      		ldi r24,lo8(msgDiscResponse)
 2057 0a1a 90E0      		ldi r25,hi8(msgDiscResponse)
 2058 0a1c 9093 0000 		sts msgReq+13+1,r25
 2059 0a20 8093 0000 		sts msgReq+13,r24
 791:ServerLLDN.c  **** 		msgReq.size					= sizeof(msgDiscResponse);
 2060               		.loc 6 791 0
 2061 0a24 83E0      		ldi r24,lo8(3)
 2062 0a26 8093 0000 		sts msgReq+15,r24
 792:ServerLLDN.c  **** 	}
 2063               		.loc 6 792 0
 2064 0a2a 0000      		nop
 2065               	/* epilogue start */
 2066 0a2c DF91      		pop r29
 2067 0a2e CF91      		pop r28
 2068 0a30 0895      		ret
 2069               		.cfi_endproc
 2070               	.LFE140:
 2072               	.global	appPrepareConfigurationStatus
 2074               	appPrepareConfigurationStatus:
 2075               	.LFB141:
 793:ServerLLDN.c  **** 	
 794:ServerLLDN.c  **** 	void appPrepareConfigurationStatus()
 795:ServerLLDN.c  **** 	{		
 2076               		.loc 6 795 0
 2077               		.cfi_startproc
 2078 0a32 CF93      		push r28
 2079               	.LCFI81:
 2080               		.cfi_def_cfa_offset 3
 2081               		.cfi_offset 28, -2
 2082 0a34 DF93      		push r29
 2083               	.LCFI82:
 2084               		.cfi_def_cfa_offset 4
 2085               		.cfi_offset 29, -3
 2086 0a36 CDB7      		in r28,__SP_L__
 2087 0a38 DEB7      		in r29,__SP_H__
 2088               	.LCFI83:
 2089               		.cfi_def_cfa_register 28
 2090               	/* prologue: function */
 2091               	/* frame size = 0 */
 2092               	/* stack size = 2 */
 2093               	.L__stack_usage = 2
 796:ServerLLDN.c  **** 		msgReq.dstAddr				= 0;
 2094               		.loc 6 796 0
 2095 0a3a 1092 0000 		sts msgReq+5+1,__zero_reg__
 2096 0a3e 1092 0000 		sts msgReq+5,__zero_reg__
 797:ServerLLDN.c  **** 		msgReq.dstEndpoint			= APP_COMMAND_ENDPOINT;
 2097               		.loc 6 797 0
 2098 0a42 83E0      		ldi r24,lo8(3)
 2099 0a44 8093 0000 		sts msgReq+7,r24
 798:ServerLLDN.c  **** 		msgReq.srcEndpoint			= APP_COMMAND_ENDPOINT;
 2100               		.loc 6 798 0
 2101 0a48 83E0      		ldi r24,lo8(3)
 2102 0a4a 8093 0000 		sts msgReq+8,r24
 799:ServerLLDN.c  **** 		msgReq.options				= NWK_OPT_MAC_COMMAND;
 2103               		.loc 6 799 0
 2104 0a4e 80E0      		ldi r24,0
 2105 0a50 90E8      		ldi r25,lo8(-128)
 2106 0a52 9093 0000 		sts msgReq+9+1,r25
 2107 0a56 8093 0000 		sts msgReq+9,r24
 800:ServerLLDN.c  **** 		msgReq.data					= (uint8_t*)&msgConfigStatus;
 2108               		.loc 6 800 0
 2109 0a5a 80E0      		ldi r24,lo8(msgConfigStatus)
 2110 0a5c 90E0      		ldi r25,hi8(msgConfigStatus)
 2111 0a5e 9093 0000 		sts msgReq+13+1,r25
 2112 0a62 8093 0000 		sts msgReq+13,r24
 801:ServerLLDN.c  **** 		msgReq.size					= sizeof(msgConfigStatus);
 2113               		.loc 6 801 0
 2114 0a66 85E0      		ldi r24,lo8(5)
 2115 0a68 8093 0000 		sts msgReq+15,r24
 802:ServerLLDN.c  **** 	}
 2116               		.loc 6 802 0
 2117 0a6c 0000      		nop
 2118               	/* epilogue start */
 2119 0a6e DF91      		pop r29
 2120 0a70 CF91      		pop r28
 2121 0a72 0895      		ret
 2122               		.cfi_endproc
 2123               	.LFE141:
 2125               	.global	appPrepareDataFrame
 2127               	appPrepareDataFrame:
 2128               	.LFB142:
 803:ServerLLDN.c  **** 	
 804:ServerLLDN.c  **** 	void appPrepareDataFrame(void)
 805:ServerLLDN.c  **** 	{
 2129               		.loc 6 805 0
 2130               		.cfi_startproc
 2131 0a74 CF93      		push r28
 2132               	.LCFI84:
 2133               		.cfi_def_cfa_offset 3
 2134               		.cfi_offset 28, -2
 2135 0a76 DF93      		push r29
 2136               	.LCFI85:
 2137               		.cfi_def_cfa_offset 4
 2138               		.cfi_offset 29, -3
 2139 0a78 CDB7      		in r28,__SP_L__
 2140 0a7a DEB7      		in r29,__SP_H__
 2141               	.LCFI86:
 2142               		.cfi_def_cfa_register 28
 2143               	/* prologue: function */
 2144               	/* frame size = 0 */
 2145               	/* stack size = 2 */
 2146               	.L__stack_usage = 2
 806:ServerLLDN.c  **** 		
 807:ServerLLDN.c  **** 		PHY_SetTdmaMode(true);
 2147               		.loc 6 807 0
 2148 0a7c 81E0      		ldi r24,lo8(1)
 2149 0a7e 0E94 0000 		call PHY_SetTdmaMode
 808:ServerLLDN.c  **** 
 809:ServerLLDN.c  **** 	
 810:ServerLLDN.c  **** 		msgReq.dstAddr				= 0;
 2150               		.loc 6 810 0
 2151 0a82 1092 0000 		sts msgReq+5+1,__zero_reg__
 2152 0a86 1092 0000 		sts msgReq+5,__zero_reg__
 811:ServerLLDN.c  **** 		msgReq.dstEndpoint			= APP_COMMAND_ENDPOINT;
 2153               		.loc 6 811 0
 2154 0a8a 83E0      		ldi r24,lo8(3)
 2155 0a8c 8093 0000 		sts msgReq+7,r24
 812:ServerLLDN.c  **** 		msgReq.srcEndpoint			= APP_COMMAND_ENDPOINT;
 2156               		.loc 6 812 0
 2157 0a90 83E0      		ldi r24,lo8(3)
 2158 0a92 8093 0000 		sts msgReq+8,r24
 813:ServerLLDN.c  **** 		msgReq.options				= NWK_OPT_LLDN_DATA;
 2159               		.loc 6 813 0
 2160 0a96 80E0      		ldi r24,0
 2161 0a98 90E2      		ldi r25,lo8(32)
 2162 0a9a 9093 0000 		sts msgReq+9+1,r25
 2163 0a9e 8093 0000 		sts msgReq+9,r24
 814:ServerLLDN.c  **** 		msgReq.data					= (uint8_t *)&data_payload;
 2164               		.loc 6 814 0
 2165 0aa2 80E0      		ldi r24,lo8(data_payload)
 2166 0aa4 90E0      		ldi r25,hi8(data_payload)
 2167 0aa6 9093 0000 		sts msgReq+13+1,r25
 2168 0aaa 8093 0000 		sts msgReq+13,r24
 815:ServerLLDN.c  **** 		msgReq.size					= sizeof(data_payload);
 2169               		.loc 6 815 0
 2170 0aae 81E0      		ldi r24,lo8(1)
 2171 0ab0 8093 0000 		sts msgReq+15,r24
 816:ServerLLDN.c  **** 	}
 2172               		.loc 6 816 0
 2173 0ab4 0000      		nop
 2174               	/* epilogue start */
 2175 0ab6 DF91      		pop r29
 2176 0ab8 CF91      		pop r28
 2177 0aba 0895      		ret
 2178               		.cfi_endproc
 2179               	.LFE142:
 2182               	appInit:
 2183               	.LFB143:
 817:ServerLLDN.c  **** 	
 818:ServerLLDN.c  **** 	
 819:ServerLLDN.c  **** #endif // APP_COORDINATOR
 820:ServerLLDN.c  **** 
 821:ServerLLDN.c  **** static void appInit(void)
 822:ServerLLDN.c  **** {
 2184               		.loc 6 822 0
 2185               		.cfi_startproc
 2186 0abc CF93      		push r28
 2187               	.LCFI87:
 2188               		.cfi_def_cfa_offset 3
 2189               		.cfi_offset 28, -2
 2190 0abe DF93      		push r29
 2191               	.LCFI88:
 2192               		.cfi_def_cfa_offset 4
 2193               		.cfi_offset 29, -3
 2194 0ac0 CDB7      		in r28,__SP_L__
 2195 0ac2 DEB7      		in r29,__SP_H__
 2196               	.LCFI89:
 2197               		.cfi_def_cfa_register 28
 2198               	/* prologue: function */
 2199               	/* frame size = 0 */
 2200               	/* stack size = 2 */
 2201               	.L__stack_usage = 2
 823:ServerLLDN.c  **** 	NWK_SetAddr(APP_ADDR);
 2202               		.loc 6 823 0
 2203 0ac4 81E0      		ldi r24,lo8(1)
 2204 0ac6 90E0      		ldi r25,0
 2205 0ac8 0E94 0000 		call NWK_SetAddr
 824:ServerLLDN.c  **** 	PHY_SetChannel(APP_CHANNEL);
 2206               		.loc 6 824 0
 2207 0acc 8FE0      		ldi r24,lo8(15)
 2208 0ace 0E94 0000 		call PHY_SetChannel
 825:ServerLLDN.c  **** 	PHY_SetRxState(true);
 2209               		.loc 6 825 0
 2210 0ad2 81E0      		ldi r24,lo8(1)
 2211 0ad4 0E94 0000 		call PHY_SetRxState
 826:ServerLLDN.c  **** 		
 827:ServerLLDN.c  **** 	#if APP_COORDINATOR	 
 828:ServerLLDN.c  **** 		/* Timer used for delay between messages */
 829:ServerLLDN.c  **** 		tmrDelay.interval = 1;
 830:ServerLLDN.c  **** 		tmrDelay.mode = SYS_TIMER_INTERVAL_MODE;
 831:ServerLLDN.c  **** 		tmrDelay.handler = tmrDelayHandler;
 832:ServerLLDN.c  **** 	  
 833:ServerLLDN.c  **** 		/* 
 834:ServerLLDN.c  **** 		* Disable CSMA/CA
 835:ServerLLDN.c  **** 		* Disable auto ACK
 836:ServerLLDN.c  **** 		*/
 837:ServerLLDN.c  **** 		NWK_SetPanId(APP_PANID);
 838:ServerLLDN.c  **** 		PanId = APP_PANID;
 839:ServerLLDN.c  **** 		ACKFrame.sourceId = APP_PANID;
 840:ServerLLDN.c  **** 		PHY_SetTdmaMode(true);
 841:ServerLLDN.c  **** 	NWK_OpenEndpoint(APP_COMMAND_ENDPOINT, appCommandInd);
 842:ServerLLDN.c  **** 	#else
 843:ServerLLDN.c  **** 		appPrepareDiscoverResponse();	
 2212               		.loc 6 843 0
 2213 0ad8 0E94 0000 		call appPrepareDiscoverResponse
 844:ServerLLDN.c  **** 		/*
 845:ServerLLDN.c  **** 		 * Enable CSMA/CA
 846:ServerLLDN.c  **** 		 * Enable Random CSMA seed generator
 847:ServerLLDN.c  **** 		 */
 848:ServerLLDN.c  **** 		PHY_SetTdmaMode(false);
 2214               		.loc 6 848 0
 2215 0adc 80E0      		ldi r24,0
 2216 0ade 0E94 0000 		call PHY_SetTdmaMode
 849:ServerLLDN.c  **** 		PHY_SetOptimizedCSMAValues();
 2217               		.loc 6 849 0
 2218 0ae2 0E94 0000 		call PHY_SetOptimizedCSMAValues
 850:ServerLLDN.c  **** 		
 851:ServerLLDN.c  **** 		
 852:ServerLLDN.c  **** 		
 853:ServerLLDN.c  **** 		payloadSize = 127;
 2219               		.loc 6 853 0
 2220 0ae6 8FE7      		ldi r24,lo8(127)
 2221 0ae8 8093 0000 		sts payloadSize,r24
 854:ServerLLDN.c  **** 		NWK_OpenEndpoint(APP_BEACON_ENDPOINT, appBeaconInd);
 2222               		.loc 6 854 0
 2223 0aec 60E0      		ldi r22,lo8(gs(appBeaconInd))
 2224 0aee 70E0      		ldi r23,hi8(gs(appBeaconInd))
 2225 0af0 80E0      		ldi r24,0
 2226 0af2 0E94 0000 		call NWK_OpenEndpoint
 855:ServerLLDN.c  **** 		NWK_OpenEndpoint(APP_ACK_ENDPOINT, appAckInd);
 2227               		.loc 6 855 0
 2228 0af6 60E0      		ldi r22,lo8(gs(appAckInd))
 2229 0af8 70E0      		ldi r23,hi8(gs(appAckInd))
 2230 0afa 84E0      		ldi r24,lo8(4)
 2231 0afc 0E94 0000 		call NWK_OpenEndpoint
 856:ServerLLDN.c  **** 		NWK_OpenEndpoint(APP_COMMAND_ENDPOINT, appCommandInd);
 2232               		.loc 6 856 0
 2233 0b00 60E0      		ldi r22,lo8(gs(appCommandInd))
 2234 0b02 70E0      		ldi r23,hi8(gs(appCommandInd))
 2235 0b04 83E0      		ldi r24,lo8(3)
 2236 0b06 0E94 0000 		call NWK_OpenEndpoint
 857:ServerLLDN.c  **** 		/*
 858:ServerLLDN.c  **** 		* Configure interrupts callback functions
 859:ServerLLDN.c  **** 		*/
 860:ServerLLDN.c  **** 		
 861:ServerLLDN.c  **** 	#endif // APP_COORDENATOR
 862:ServerLLDN.c  **** 	PHY_SetPromiscuousMode(true);
 2237               		.loc 6 862 0
 2238 0b0a 81E0      		ldi r24,lo8(1)
 2239 0b0c 0E94 0000 		call PHY_SetPromiscuousMode
 863:ServerLLDN.c  **** 
 864:ServerLLDN.c  **** }
 2240               		.loc 6 864 0
 2241 0b10 0000      		nop
 2242               	/* epilogue start */
 2243 0b12 DF91      		pop r29
 2244 0b14 CF91      		pop r28
 2245 0b16 0895      		ret
 2246               		.cfi_endproc
 2247               	.LFE143:
 2249               		.section	.rodata
 2250               	.LC9:
 2251 007c 0A72 6574 		.string	"\nretransmition_slot %d"
 2251      7261 6E73 
 2251      6D69 7469 
 2251      6F6E 5F73 
 2251      6C6F 7420 
 2252               		.text
 2254               	APP_TaskHandler:
 2255               	.LFB144:
 865:ServerLLDN.c  **** 
 866:ServerLLDN.c  **** static void APP_TaskHandler(void)
 867:ServerLLDN.c  **** {
 2256               		.loc 6 867 0
 2257               		.cfi_startproc
 2258 0b18 CF93      		push r28
 2259               	.LCFI90:
 2260               		.cfi_def_cfa_offset 3
 2261               		.cfi_offset 28, -2
 2262 0b1a DF93      		push r29
 2263               	.LCFI91:
 2264               		.cfi_def_cfa_offset 4
 2265               		.cfi_offset 29, -3
 2266 0b1c 00D0      		rcall .
 2267 0b1e 00D0      		rcall .
 2268               	.LCFI92:
 2269               		.cfi_def_cfa_offset 8
 2270 0b20 CDB7      		in r28,__SP_L__
 2271 0b22 DEB7      		in r29,__SP_H__
 2272               	.LCFI93:
 2273               		.cfi_def_cfa_register 28
 2274               	/* prologue: function */
 2275               	/* frame size = 4 */
 2276               	/* stack size = 6 */
 2277               	.L__stack_usage = 6
 868:ServerLLDN.c  **** 	switch (appState){
 2278               		.loc 6 868 0
 2279 0b24 8091 0000 		lds r24,appState
 2280 0b28 882F      		mov r24,r24
 2281 0b2a 90E0      		ldi r25,0
 2282 0b2c 8430      		cpi r24,4
 2283 0b2e 9105      		cpc r25,__zero_reg__
 2284 0b30 01F0      		breq .L67
 2285 0b32 8530      		cpi r24,5
 2286 0b34 9105      		cpc r25,__zero_reg__
 2287 0b36 04F4      		brge .L68
 2288 0b38 0097      		sbiw r24,0
 2289 0b3a 01F0      		breq .L69
 2290 0b3c 0297      		sbiw r24,2
 2291 0b3e 01F0      		breq .L70
 869:ServerLLDN.c  **** 		case APP_STATE_INITIAL:
 870:ServerLLDN.c  **** 		{
 871:ServerLLDN.c  **** 			appInit();
 872:ServerLLDN.c  **** 			#if APP_COORDINATOR
 873:ServerLLDN.c  **** 				appState = APP_STATE_ATT_PAN_STATE;
 874:ServerLLDN.c  **** 			#else
 875:ServerLLDN.c  **** 				appState = APP_STATE_IDLE;
 876:ServerLLDN.c  **** 			#endif
 877:ServerLLDN.c  **** 			break;
 878:ServerLLDN.c  **** 		}
 879:ServerLLDN.c  **** 		case APP_STATE_SEND:
 880:ServerLLDN.c  **** 		{
 881:ServerLLDN.c  **** 			appSendData();
 882:ServerLLDN.c  **** 			#if APP_COORDINATOR
 883:ServerLLDN.c  **** 				/* Every time a message is send updates coordinator to prepare next message */
 884:ServerLLDN.c  **** 				appState = APP_STATE_ATT_PAN_STATE;
 885:ServerLLDN.c  **** 			#else
 886:ServerLLDN.c  **** 				appState = APP_STATE_IDLE;
 887:ServerLLDN.c  **** 			#endif
 888:ServerLLDN.c  **** 			break;
 889:ServerLLDN.c  **** 		}
 890:ServerLLDN.c  **** 		#if APP_COORDINATOR // COORDINATOR SPECIFIC STATE MACHINE
 891:ServerLLDN.c  **** 		case APP_STATE_ATT_PAN_STATE:
 892:ServerLLDN.c  **** 		{
 893:ServerLLDN.c  **** 			switch(appPanState)
 894:ServerLLDN.c  **** 			{
 895:ServerLLDN.c  **** 				/* Prepare beacon to desassociate all nodes */
 896:ServerLLDN.c  **** 				case APP_PAN_STATE_RESET:
 897:ServerLLDN.c  **** 				{
 898:ServerLLDN.c  **** 					appPanReset();
 899:ServerLLDN.c  **** 					appPanState = APP_PAN_STATE_DISC_INITIAL;
 900:ServerLLDN.c  **** 					appState	= APP_STATE_SEND;
 901:ServerLLDN.c  **** 					cycles_counter = 0;
 902:ServerLLDN.c  **** 					break;
 903:ServerLLDN.c  **** 				}
 904:ServerLLDN.c  **** 				/* Prepare first Beacon of Discovery */
 905:ServerLLDN.c  **** 				case APP_PAN_STATE_DISC_INITIAL:
 906:ServerLLDN.c  **** 				{
 907:ServerLLDN.c  **** 					/* if nodes associated is equal to expected number of associated nodes stop association proces
 908:ServerLLDN.c  **** 					 * this implementation was done as is to be used in tests, for real network functionality 
 909:ServerLLDN.c  **** 					 * the number of max association processes must be done through macLLDNdiscoveryModeTimeout
 910:ServerLLDN.c  **** 					 */
 911:ServerLLDN.c  **** 					if(counter_associados == NODOS_ASSOCIADOS_ESPERADOS || cycles_counter >= 8)
 912:ServerLLDN.c  **** 					{	
 913:ServerLLDN.c  **** 						printf("\n%d, %d", cycles_counter, counter_associados);
 914:ServerLLDN.c  **** 						counter_associados = 0;
 915:ServerLLDN.c  **** 						/* if all nodes expected where associated stop beacon generation interruptions */
 916:ServerLLDN.c  **** 						macsc_disable_cmp_int(MACSC_CC1);
 917:ServerLLDN.c  **** 						macsc_disable_cmp_int(MACSC_CC2);
 918:ServerLLDN.c  **** 						msgReq.options = 0;
 919:ServerLLDN.c  **** 						
 920:ServerLLDN.c  **** 						/* reseting ack bitmap */
 921:ServerLLDN.c  **** 						for(int i = 0; i < 32; i++)
 922:ServerLLDN.c  **** 						ACKFrame.ackFlags[i] = 0;
 923:ServerLLDN.c  **** 						ACKFrame_size = 0;
 924:ServerLLDN.c  **** 						accepting_requests = 0;
 925:ServerLLDN.c  **** 						appState = APP_STATE_ATT_PAN_STATE;
 926:ServerLLDN.c  **** 						appPanState = APP_PAN_STATE_ONLINE_INITIAL; // APP_PAN_STATE_ONLINE_INIT
 927:ServerLLDN.c  **** 						cycles_counter = NUMERO_CICLOS_ONLINE;
 928:ServerLLDN.c  **** 					}
 929:ServerLLDN.c  **** 					/* if not all nodes expected where associated run through association process again */
 930:ServerLLDN.c  **** 					else 
 931:ServerLLDN.c  **** 					{
 932:ServerLLDN.c  **** 						/* prepare beacon message and start timers for beacon */
 933:ServerLLDN.c  **** 						appPanDiscInit();
 934:ServerLLDN.c  **** 						appState	= APP_STATE_IDLE;
 935:ServerLLDN.c  **** 						appPanState = APP_PAN_STATE_DISC_SECOND_BE;
 936:ServerLLDN.c  **** 					}
 937:ServerLLDN.c  **** 					break;
 938:ServerLLDN.c  **** 				}
 939:ServerLLDN.c  **** 				case APP_PAN_STATE_DISC_SECOND_BE:
 940:ServerLLDN.c  **** 				{
 941:ServerLLDN.c  **** 					/* Prepares message as: Discovery Beacon and Second Beacon */
 942:ServerLLDN.c  **** 					msgReq.options = NWK_OPT_LLDN_BEACON | NWK_OPT_DISCOVERY_STATE | NWK_OPT_SECOND_BEACON ;
 943:ServerLLDN.c  **** 					msgReq.data = NULL;
 944:ServerLLDN.c  **** 					msgReq.size = 0;
 945:ServerLLDN.c  **** 					
 946:ServerLLDN.c  **** 					appState	= APP_STATE_IDLE;
 947:ServerLLDN.c  **** 					appPanState = APP_PAN_STATE_DISC_PREPARE_ACK;
 948:ServerLLDN.c  **** 					break;
 949:ServerLLDN.c  **** 				}
 950:ServerLLDN.c  **** 				case APP_PAN_STATE_DISC_PREPARE_ACK:
 951:ServerLLDN.c  **** 				{
 952:ServerLLDN.c  **** 					/* This timer implements a delay between messages, 
 953:ServerLLDN.c  **** 					 * if not used the nodes are not able to receive the message
 954:ServerLLDN.c  **** 					 */
 955:ServerLLDN.c  **** 					appPanPrepareACK();
 956:ServerLLDN.c  **** 					appState = APP_STATE_SEND;
 957:ServerLLDN.c  **** 					// SYS_TimerStart(&tmrDelay);
 958:ServerLLDN.c  **** 					
 959:ServerLLDN.c  **** 					appPanState = APP_PAN_STATE_CONFIG_INITIAL;
 960:ServerLLDN.c  **** 					appState = APP_STATE_IDLE;
 961:ServerLLDN.c  **** 					break;
 962:ServerLLDN.c  **** 				}
 963:ServerLLDN.c  **** 				case APP_PAN_STATE_CONFIG_INITIAL:
 964:ServerLLDN.c  **** 				{
 965:ServerLLDN.c  **** 					/* Prepares the message as: Configuration Beacon and First State Beacon */
 966:ServerLLDN.c  **** 					msgReq.options = NWK_OPT_LLDN_BEACON | NWK_OPT_CONFIG_STATE;
 967:ServerLLDN.c  **** 					msgReq.data = NULL;
 968:ServerLLDN.c  **** 					msgReq.size = 0;
 969:ServerLLDN.c  **** 					
 970:ServerLLDN.c  **** 					appState	= APP_STATE_IDLE;
 971:ServerLLDN.c  **** 					appPanState = APP_PAN_STATE_CONFIG_SECOND_BEACON;
 972:ServerLLDN.c  **** 					break;
 973:ServerLLDN.c  **** 
 974:ServerLLDN.c  **** 				}
 975:ServerLLDN.c  **** 				case APP_PAN_STATE_CONFIG_SECOND_BEACON:
 976:ServerLLDN.c  **** 				{
 977:ServerLLDN.c  **** 					/* Prepares the message as: Configuration Beacon and Second State Beacon */
 978:ServerLLDN.c  **** 					msgReq.options = NWK_OPT_LLDN_BEACON | NWK_OPT_CONFIG_STATE | NWK_OPT_SECOND_BEACON;
 979:ServerLLDN.c  **** 					msgReq.data = NULL;
 980:ServerLLDN.c  **** 					msgReq.size = 0;
 981:ServerLLDN.c  **** 					
 982:ServerLLDN.c  **** 					counter_delay_msg = 0;
 983:ServerLLDN.c  **** 					
 984:ServerLLDN.c  **** 					appState	= APP_STATE_IDLE;
 985:ServerLLDN.c  **** 					appPanState = APP_PAN_STATE_SEND_CONF_REQUEST;
 986:ServerLLDN.c  **** 					
 987:ServerLLDN.c  **** 					break;
 988:ServerLLDN.c  **** 				}
 989:ServerLLDN.c  **** 				case APP_PAN_STATE_SEND_CONF_REQUEST:
 990:ServerLLDN.c  **** 				{
 991:ServerLLDN.c  **** 					if(conf_req_list != NULL)
 992:ServerLLDN.c  **** 					{
 993:ServerLLDN.c  **** 						if(CopyToConfigRequest())
 994:ServerLLDN.c  **** 						{
 995:ServerLLDN.c  **** 						msgReq.options		= NWK_OPT_MAC_COMMAND;
 996:ServerLLDN.c  **** 						msgReq.data			= (uint8_t*)&config_request_frame;
 997:ServerLLDN.c  **** 						msgReq.size			= sizeof(NWK_ConfigRequest_t);
 998:ServerLLDN.c  **** 						appState	= APP_STATE_IDLE;
 999:ServerLLDN.c  **** 						appPanState = APP_PAN_STATE_SEND_CONF_REQUEST;
1000:ServerLLDN.c  **** // 						printf("  assts %d %hhx",config_request_frame.assTimeSlot,  config_request_frame.macAddr);
1001:ServerLLDN.c  **** 						// Delay between messages
1002:ServerLLDN.c  **** 						}
1003:ServerLLDN.c  **** 						else
1004:ServerLLDN.c  **** 						{
1005:ServerLLDN.c  **** 							msgReq.options = 0;
1006:ServerLLDN.c  **** 						}
1007:ServerLLDN.c  **** 						macsc_set_cmp1_int_cb(downlink_delay_handler);
1008:ServerLLDN.c  **** 						macsc_disable_cmp_int(MACSC_CC1);
1009:ServerLLDN.c  **** 						macsc_enable_manual_bts();
1010:ServerLLDN.c  **** 						macsc_enable_cmp_int(MACSC_CC1);
1011:ServerLLDN.c  **** 						macsc_use_cmp(MACSC_RELATIVE_CMP, DELAY, MACSC_CC1);
1012:ServerLLDN.c  **** 						
1013:ServerLLDN.c  **** 						counter_associados++;
1014:ServerLLDN.c  **** 					}
1015:ServerLLDN.c  **** 					else
1016:ServerLLDN.c  **** 					{
1017:ServerLLDN.c  **** 						msgReq.options = 0;
1018:ServerLLDN.c  **** 
1019:ServerLLDN.c  **** 						if(counter_delay_msg > 0)
1020:ServerLLDN.c  **** 						{
1021:ServerLLDN.c  **** 							macsc_set_cmp1_int_cb(lldn_server_beacon);
1022:ServerLLDN.c  **** 							macsc_disable_cmp_int(MACSC_CC1);
1023:ServerLLDN.c  **** 							macsc_enable_manual_bts();
1024:ServerLLDN.c  **** 							macsc_enable_cmp_int(MACSC_CC1);
1025:ServerLLDN.c  **** 							macsc_use_cmp(MACSC_RELATIVE_CMP,beaconInterval_association - counter_delay_msg * DELAY, MAC
1026:ServerLLDN.c  **** 						}
1027:ServerLLDN.c  **** 						
1028:ServerLLDN.c  **** 						appState	= APP_STATE_ATT_PAN_STATE;
1029:ServerLLDN.c  **** 						appPanState = APP_PAN_STATE_CONFIG_THIRD_BEACON;
1030:ServerLLDN.c  **** 					}
1031:ServerLLDN.c  **** 					break;
1032:ServerLLDN.c  **** 				}
1033:ServerLLDN.c  **** 				case APP_PAN_STATE_CONFIG_THIRD_BEACON:
1034:ServerLLDN.c  **** 				{
1035:ServerLLDN.c  **** 					msgReq.options = NWK_OPT_LLDN_BEACON | NWK_OPT_CONFIG_STATE | NWK_OPT_THIRD_BEACON;
1036:ServerLLDN.c  **** 					msgReq.data = NULL;
1037:ServerLLDN.c  **** 					msgReq.size = 0;
1038:ServerLLDN.c  **** 					
1039:ServerLLDN.c  **** 					appState	= APP_STATE_IDLE;
1040:ServerLLDN.c  **** 					appPanState = APP_PAN_STATE_DISC_INITIAL;
1041:ServerLLDN.c  **** 					cycles_counter++;	
1042:ServerLLDN.c  **** 					
1043:ServerLLDN.c  **** 					break;
1044:ServerLLDN.c  **** 				}
1045:ServerLLDN.c  **** 				case APP_PAN_STATE_ONLINE_INITIAL:
1046:ServerLLDN.c  **** 				{
1047:ServerLLDN.c  **** 
1048:ServerLLDN.c  **** 					if(cycles_counter != 0)
1049:ServerLLDN.c  **** 					{
1050:ServerLLDN.c  **** 						appPanOnlineInit();
1051:ServerLLDN.c  **** 						
1052:ServerLLDN.c  **** 						appState = APP_STATE_IDLE;
1053:ServerLLDN.c  **** 						appPanState = APP_PAN_STATE_IDLE;
1054:ServerLLDN.c  **** 						
1055:ServerLLDN.c  **** 						cycles_counter--;
1056:ServerLLDN.c  **** 					}
1057:ServerLLDN.c  **** 					else
1058:ServerLLDN.c  **** 					{
1059:ServerLLDN.c  **** 						appState = APP_STATE_IDLE;
1060:ServerLLDN.c  **** 						appPanState = APP_PAN_STATE_IDLE;
1061:ServerLLDN.c  **** 						macsc_disable_cmp_int(MACSC_CC1);
1062:ServerLLDN.c  **** 						
1063:ServerLLDN.c  **** 						printf("\n\n Mtricas (%d Ciclos):\n", NUMERO_CICLOS_ONLINE -1);
1064:ServerLLDN.c  **** 						int total_msg = 0;
1065:ServerLLDN.c  **** 						float uplink_lost_packets = 0;
1066:ServerLLDN.c  **** 						float expected_messages = assTimeSlot * (float)(NUMERO_CICLOS_ONLINE - 1);
1067:ServerLLDN.c  **** 						for(int i = 0; nodes_info_arr[i].mac_addr != 0 && assTimeSlot > i; i++)
1068:ServerLLDN.c  **** 						{
1069:ServerLLDN.c  **** 							printf("\nAddrs , %hhx", nodes_info_arr[i].mac_addr);
1070:ServerLLDN.c  **** 							printf("\nPLR ,  %.3f", 1 - nodes_info_arr[i].msg_rec / (float)(NUMERO_CICLOS_ONLINE - 1));
1071:ServerLLDN.c  **** 							printf("\nPER ,  %.3f", nodes_info_arr[i].msg_not_rec / (float)(NUMERO_CICLOS_ONLINE - 1));
1072:ServerLLDN.c  **** 							printf("\nRssi Mdio , %f\n", nodes_info_arr[i].average_rssi);
1073:ServerLLDN.c  **** 							
1074:ServerLLDN.c  **** 							total_msg = total_msg + nodes_info_arr[i].msg_rec;
1075:ServerLLDN.c  **** 							uplink_lost_packets += nodes_info_arr[i].msg_not_rec;
1076:ServerLLDN.c  **** 						}
1077:ServerLLDN.c  **** 						if(assTimeSlot > 0 && total_msg > 0)
1078:ServerLLDN.c  **** 						{
1079:ServerLLDN.c  **** 							PLR = 1 - total_msg / expected_messages;
1080:ServerLLDN.c  **** 							PER = uplink_lost_packets / expected_messages;
1081:ServerLLDN.c  **** 							printf("\nPLR , %.3f\nPER , %.3f, total_de_mensagens %d", PLR, PER, total_msg);
1082:ServerLLDN.c  **** 							
1083:ServerLLDN.c  **** 						}
1084:ServerLLDN.c  **** 					}
1085:ServerLLDN.c  **** 					break;
1086:ServerLLDN.c  **** 				}
1087:ServerLLDN.c  **** 				case APP_PAN_STATE_ONLINE_PREPARE_ACK_GROUP:
1088:ServerLLDN.c  **** 				{
1089:ServerLLDN.c  **** 					for(int i = 0; i < 32; i++)
1090:ServerLLDN.c  **** 					{
1091:ServerLLDN.c  **** 						ACKFrame.ackFlags[i] = 0;
1092:ServerLLDN.c  **** 						retransmit_ts_array[i] = 0;
1093:ServerLLDN.c  **** 					}
1094:ServerLLDN.c  **** 					retransmit_ts_array_counter = 0;
1095:ServerLLDN.c  **** 					ACKFrame_size = 0;
1096:ServerLLDN.c  **** 					
1097:ServerLLDN.c  **** 					msgReq.dstAddr		= 0;
1098:ServerLLDN.c  **** 					msgReq.dstEndpoint	= APP_BEACON_ENDPOINT;
1099:ServerLLDN.c  **** 					msgReq.srcEndpoint	= APP_BEACON_ENDPOINT;
1100:ServerLLDN.c  **** 					msgReq.options		= NWK_OPT_LLDN_ACK;
1101:ServerLLDN.c  **** 					msgReq.data	= (uint8_t *)&ACKFrame;
1102:ServerLLDN.c  **** 					msgReq.size	= sizeof(uint8_t)*(macLLDNRetransmitTS + 1);
1103:ServerLLDN.c  **** 
1104:ServerLLDN.c  **** 					appState = APP_STATE_IDLE;
1105:ServerLLDN.c  **** 					appPanState = APP_PAN_STATE_IDLE;
1106:ServerLLDN.c  **** 					break;
1107:ServerLLDN.c  **** 				}				
1108:ServerLLDN.c  **** 				case APP_PAN_STATE_IDLE:
1109:ServerLLDN.c  **** 				{
1110:ServerLLDN.c  **** 
1111:ServerLLDN.c  **** 					msgReq.options = 0;
1112:ServerLLDN.c  **** 					appState = APP_STATE_IDLE;
1113:ServerLLDN.c  **** 					break;
1114:ServerLLDN.c  **** 				}
1115:ServerLLDN.c  **** 			}
1116:ServerLLDN.c  **** 			break;	
1117:ServerLLDN.c  **** 		}
1118:ServerLLDN.c  **** 		#else // NODES SPECIFIC STATE MACHINE
1119:ServerLLDN.c  **** 		case APP_STATE_PREP_DISC_REPONSE:
1120:ServerLLDN.c  **** 		{
1121:ServerLLDN.c  **** 			appPrepareDiscoverResponse();
1122:ServerLLDN.c  **** 			appState = APP_STATE_IDLE;	
1123:ServerLLDN.c  **** 			break;
1124:ServerLLDN.c  **** 		}
1125:ServerLLDN.c  **** 		
1126:ServerLLDN.c  **** 		case APP_STATE_PREP_CONFIG_STATUS:
1127:ServerLLDN.c  **** 		{
1128:ServerLLDN.c  **** 			// se o nodo recebeu ack na fase do discovery prepara a mensagem de configuration status
1129:ServerLLDN.c  **** 			if(ack_received && rec_beacon.confSeqNumber == 0 && associated == 0 && STATE != ONLINE_MODE) {
1130:ServerLLDN.c  **** 				appPrepareConfigurationStatus();
1131:ServerLLDN.c  **** 			}
1132:ServerLLDN.c  **** 			// se o nodo no recebeu desativa o timer e fica em idle
1133:ServerLLDN.c  **** 			else {
1134:ServerLLDN.c  **** 				#if MASTER_MACSC
1135:ServerLLDN.c  **** 				macsc_disable_cmp_int(MACSC_CC1);
1136:ServerLLDN.c  **** 				#else
1137:ServerLLDN.c  **** 				timer_stop();
1138:ServerLLDN.c  **** 				#endif
1139:ServerLLDN.c  **** 			}
1140:ServerLLDN.c  **** 			ack_received = 0;
1141:ServerLLDN.c  **** 			appState = APP_STATE_IDLE;
1142:ServerLLDN.c  **** 			break;
1143:ServerLLDN.c  **** 		}
1144:ServerLLDN.c  **** 		case APP_STATE_PREP_DATA_FRAME:
1145:ServerLLDN.c  **** 		{
1146:ServerLLDN.c  **** 			appPrepareDataFrame();
1147:ServerLLDN.c  **** 			appState = APP_STATE_IDLE;
1148:ServerLLDN.c  **** 			break;
1149:ServerLLDN.c  **** 		}
1150:ServerLLDN.c  **** 		case APP_STATE_RETRANSMIT_DATA:
1151:ServerLLDN.c  **** 		{
1152:ServerLLDN.c  **** 			if(!ack_received)
1153:ServerLLDN.c  **** 			{
1154:ServerLLDN.c  **** 				appState = APP_STATE_IDLE;
1155:ServerLLDN.c  **** 				
1156:ServerLLDN.c  **** 				int retransmition_slot = 0;
1157:ServerLLDN.c  **** 				
1158:ServerLLDN.c  **** 				
1159:ServerLLDN.c  **** 				for(int i = 0; i < assTimeSlot - 1 && i < (rec_beacon.NumberOfBaseTimeslotsinSuperframe - 3)/2;
1160:ServerLLDN.c  **** 					if( !check_ack(i) )
1161:ServerLLDN.c  **** 						retransmition_slot++;
1162:ServerLLDN.c  **** 					
1163:ServerLLDN.c  **** 				printf("\nretransmition_slot %d", retransmition_slot);
1164:ServerLLDN.c  **** 				
1165:ServerLLDN.c  **** 				if(retransmition_slot == 0)
1166:ServerLLDN.c  **** 				{
1167:ServerLLDN.c  **** 					appSendData();
1168:ServerLLDN.c  **** 					// appState = APP_STATE_SEND;			
1169:ServerLLDN.c  **** 				}
1170:ServerLLDN.c  **** 				else
1171:ServerLLDN.c  **** 				{
1172:ServerLLDN.c  **** 					#if MASTER_MACSC
1173:ServerLLDN.c  **** 					macsc_enable_manual_bts();
1174:ServerLLDN.c  **** 					macsc_set_cmp1_int_cb(send_message_timeHandler);
1175:ServerLLDN.c  **** 					macsc_enable_cmp_int(MACSC_CC1);
1176:ServerLLDN.c  **** 					macsc_use_cmp(MACSC_RELATIVE_CMP, ts_time * retransmition_slot, MACSC_CC1);
1177:ServerLLDN.c  **** 					#endif
1178:ServerLLDN.c  **** 				}
1179:ServerLLDN.c  **** 				
1180:ServerLLDN.c  **** 			}
1181:ServerLLDN.c  **** 			else
1182:ServerLLDN.c  **** 			{
1183:ServerLLDN.c  **** 				appState = APP_STATE_IDLE;
1184:ServerLLDN.c  **** 			}
1185:ServerLLDN.c  **** 			
1186:ServerLLDN.c  **** 			break;
1187:ServerLLDN.c  **** 		}
1188:ServerLLDN.c  **** 		#endif
1189:ServerLLDN.c  **** 		default:
1190:ServerLLDN.c  **** 		{
1191:ServerLLDN.c  **** 			break;
 2292               		.loc 6 1191 0
 2293 0b40 00C0      		rjmp .L74
 2294               	.L68:
 868:ServerLLDN.c  **** 	switch (appState){
 2295               		.loc 6 868 0
 2296 0b42 8630      		cpi r24,6
 2297 0b44 9105      		cpc r25,__zero_reg__
 2298 0b46 01F0      		breq .L71
 2299 0b48 8630      		cpi r24,6
 2300 0b4a 9105      		cpc r25,__zero_reg__
 2301 0b4c 04F0      		brlt .L72
 2302 0b4e 0797      		sbiw r24,7
 2303 0b50 01F0      		breq .L73
 2304               		.loc 6 1191 0
 2305 0b52 00C0      		rjmp .L74
 2306               	.L69:
 871:ServerLLDN.c  **** 			#if APP_COORDINATOR
 2307               		.loc 6 871 0
 2308 0b54 0E94 0000 		call appInit
 875:ServerLLDN.c  **** 			#endif
 2309               		.loc 6 875 0
 2310 0b58 81E0      		ldi r24,lo8(1)
 2311 0b5a 8093 0000 		sts appState,r24
 877:ServerLLDN.c  **** 		}
 2312               		.loc 6 877 0
 2313 0b5e 00C0      		rjmp .L74
 2314               	.L70:
 881:ServerLLDN.c  **** 			#if APP_COORDINATOR
 2315               		.loc 6 881 0
 2316 0b60 0E94 0000 		call appSendData
 886:ServerLLDN.c  **** 			#endif
 2317               		.loc 6 886 0
 2318 0b64 81E0      		ldi r24,lo8(1)
 2319 0b66 8093 0000 		sts appState,r24
 888:ServerLLDN.c  **** 		}
 2320               		.loc 6 888 0
 2321 0b6a 00C0      		rjmp .L74
 2322               	.L67:
1121:ServerLLDN.c  **** 			appState = APP_STATE_IDLE;	
 2323               		.loc 6 1121 0
 2324 0b6c 0E94 0000 		call appPrepareDiscoverResponse
1122:ServerLLDN.c  **** 			break;
 2325               		.loc 6 1122 0
 2326 0b70 81E0      		ldi r24,lo8(1)
 2327 0b72 8093 0000 		sts appState,r24
1123:ServerLLDN.c  **** 		}
 2328               		.loc 6 1123 0
 2329 0b76 00C0      		rjmp .L74
 2330               	.L72:
1129:ServerLLDN.c  **** 				appPrepareConfigurationStatus();
 2331               		.loc 6 1129 0
 2332 0b78 8091 0000 		lds r24,ack_received
 2333 0b7c 8823      		tst r24
 2334 0b7e 01F0      		breq .L75
1129:ServerLLDN.c  **** 				appPrepareConfigurationStatus();
 2335               		.loc 6 1129 0 is_stmt 0 discriminator 1
 2336 0b80 8091 0000 		lds r24,rec_beacon+5
 2337 0b84 8823      		tst r24
 2338 0b86 01F4      		brne .L75
1129:ServerLLDN.c  **** 				appPrepareConfigurationStatus();
 2339               		.loc 6 1129 0 discriminator 2
 2340 0b88 9091 0000 		lds r25,associated
 2341 0b8c 81E0      		ldi r24,lo8(1)
 2342 0b8e 8927      		eor r24,r25
 2343 0b90 8823      		tst r24
 2344 0b92 01F0      		breq .L75
1129:ServerLLDN.c  **** 				appPrepareConfigurationStatus();
 2345               		.loc 6 1129 0 discriminator 3
 2346 0b94 8091 0000 		lds r24,STATE
 2347 0b98 8823      		tst r24
 2348 0b9a 01F0      		breq .L75
1130:ServerLLDN.c  **** 			}
 2349               		.loc 6 1130 0 is_stmt 1
 2350 0b9c 0E94 0000 		call appPrepareConfigurationStatus
 2351 0ba0 00C0      		rjmp .L76
 2352               	.L75:
1135:ServerLLDN.c  **** 				#else
 2353               		.loc 6 1135 0
 2354 0ba2 81E0      		ldi r24,lo8(1)
 2355 0ba4 0E94 0000 		call macsc_disable_cmp_int
 2356               	.L76:
1140:ServerLLDN.c  **** 			appState = APP_STATE_IDLE;
 2357               		.loc 6 1140 0
 2358 0ba8 1092 0000 		sts ack_received,__zero_reg__
1141:ServerLLDN.c  **** 			break;
 2359               		.loc 6 1141 0
 2360 0bac 81E0      		ldi r24,lo8(1)
 2361 0bae 8093 0000 		sts appState,r24
1142:ServerLLDN.c  **** 		}
 2362               		.loc 6 1142 0
 2363 0bb2 00C0      		rjmp .L74
 2364               	.L71:
1146:ServerLLDN.c  **** 			appState = APP_STATE_IDLE;
 2365               		.loc 6 1146 0
 2366 0bb4 0E94 0000 		call appPrepareDataFrame
1147:ServerLLDN.c  **** 			break;
 2367               		.loc 6 1147 0
 2368 0bb8 81E0      		ldi r24,lo8(1)
 2369 0bba 8093 0000 		sts appState,r24
1148:ServerLLDN.c  **** 		}
 2370               		.loc 6 1148 0
 2371 0bbe 00C0      		rjmp .L74
 2372               	.L73:
1152:ServerLLDN.c  **** 			{
 2373               		.loc 6 1152 0
 2374 0bc0 9091 0000 		lds r25,ack_received
 2375 0bc4 81E0      		ldi r24,lo8(1)
 2376 0bc6 8927      		eor r24,r25
 2377 0bc8 8823      		tst r24
 2378 0bca 01F4      		brne .+2
 2379 0bcc 00C0      		rjmp .L77
 2380               	.LBB5:
1154:ServerLLDN.c  **** 				
 2381               		.loc 6 1154 0
 2382 0bce 81E0      		ldi r24,lo8(1)
 2383 0bd0 8093 0000 		sts appState,r24
1156:ServerLLDN.c  **** 				
 2384               		.loc 6 1156 0
 2385 0bd4 1A82      		std Y+2,__zero_reg__
 2386 0bd6 1982      		std Y+1,__zero_reg__
 2387               	.LBB6:
1159:ServerLLDN.c  **** 					if( !check_ack(i) )
 2388               		.loc 6 1159 0
 2389 0bd8 1C82      		std Y+4,__zero_reg__
 2390 0bda 1B82      		std Y+3,__zero_reg__
 2391 0bdc 00C0      		rjmp .L78
 2392               	.L82:
1160:ServerLLDN.c  **** 						retransmition_slot++;
 2393               		.loc 6 1160 0
 2394 0bde 8B81      		ldd r24,Y+3
 2395 0be0 9C81      		ldd r25,Y+4
 2396 0be2 0E94 0000 		call check_ack
 2397 0be6 982F      		mov r25,r24
 2398 0be8 81E0      		ldi r24,lo8(1)
 2399 0bea 8927      		eor r24,r25
 2400 0bec 8823      		tst r24
 2401 0bee 01F0      		breq .L79
1161:ServerLLDN.c  **** 					
 2402               		.loc 6 1161 0
 2403 0bf0 8981      		ldd r24,Y+1
 2404 0bf2 9A81      		ldd r25,Y+2
 2405 0bf4 0196      		adiw r24,1
 2406 0bf6 9A83      		std Y+2,r25
 2407 0bf8 8983      		std Y+1,r24
 2408               	.L79:
1159:ServerLLDN.c  **** 					if( !check_ack(i) )
 2409               		.loc 6 1159 0 discriminator 2
 2410 0bfa 8B81      		ldd r24,Y+3
 2411 0bfc 9C81      		ldd r25,Y+4
 2412 0bfe 0196      		adiw r24,1
 2413 0c00 9C83      		std Y+4,r25
 2414 0c02 8B83      		std Y+3,r24
 2415               	.L78:
1159:ServerLLDN.c  **** 					if( !check_ack(i) )
 2416               		.loc 6 1159 0 is_stmt 0 discriminator 1
 2417 0c04 8091 0000 		lds r24,assTimeSlot
 2418 0c08 882F      		mov r24,r24
 2419 0c0a 90E0      		ldi r25,0
 2420 0c0c 9C01      		movw r18,r24
 2421 0c0e 2150      		subi r18,1
 2422 0c10 3109      		sbc r19,__zero_reg__
 2423 0c12 8B81      		ldd r24,Y+3
 2424 0c14 9C81      		ldd r25,Y+4
 2425 0c16 8217      		cp r24,r18
 2426 0c18 9307      		cpc r25,r19
 2427 0c1a 04F4      		brge .L80
1159:ServerLLDN.c  **** 					if( !check_ack(i) )
 2428               		.loc 6 1159 0 discriminator 3
 2429 0c1c 8091 0000 		lds r24,rec_beacon+7
 2430 0c20 882F      		mov r24,r24
 2431 0c22 90E0      		ldi r25,0
 2432 0c24 0397      		sbiw r24,3
 2433 0c26 9923      		tst r25
 2434 0c28 04F4      		brge .L81
 2435 0c2a 0196      		adiw r24,1
 2436               	.L81:
 2437 0c2c 9595      		asr r25
 2438 0c2e 8795      		ror r24
 2439 0c30 9C01      		movw r18,r24
 2440 0c32 8B81      		ldd r24,Y+3
 2441 0c34 9C81      		ldd r25,Y+4
 2442 0c36 8217      		cp r24,r18
 2443 0c38 9307      		cpc r25,r19
 2444 0c3a 04F0      		brlt .L82
 2445               	.L80:
 2446               	.LBE6:
1163:ServerLLDN.c  **** 				
 2447               		.loc 6 1163 0 is_stmt 1
 2448 0c3c 8A81      		ldd r24,Y+2
 2449 0c3e 8F93      		push r24
 2450 0c40 8981      		ldd r24,Y+1
 2451 0c42 8F93      		push r24
 2452 0c44 80E0      		ldi r24,lo8(.LC9)
 2453 0c46 90E0      		ldi r25,hi8(.LC9)
 2454 0c48 892F      		mov r24,r25
 2455 0c4a 8F93      		push r24
 2456 0c4c 80E0      		ldi r24,lo8(.LC9)
 2457 0c4e 90E0      		ldi r25,hi8(.LC9)
 2458 0c50 8F93      		push r24
 2459 0c52 0E94 0000 		call printf
 2460 0c56 0F90      		pop __tmp_reg__
 2461 0c58 0F90      		pop __tmp_reg__
 2462 0c5a 0F90      		pop __tmp_reg__
 2463 0c5c 0F90      		pop __tmp_reg__
1165:ServerLLDN.c  **** 				{
 2464               		.loc 6 1165 0
 2465 0c5e 8981      		ldd r24,Y+1
 2466 0c60 9A81      		ldd r25,Y+2
 2467 0c62 892B      		or r24,r25
 2468 0c64 01F4      		brne .L83
1167:ServerLLDN.c  **** 					// appState = APP_STATE_SEND;			
 2469               		.loc 6 1167 0
 2470 0c66 0E94 0000 		call appSendData
 2471               	.LBE5:
1186:ServerLLDN.c  **** 		}
 2472               		.loc 6 1186 0
 2473 0c6a 00C0      		rjmp .L86
 2474               	.L83:
 2475               	.LBB7:
1173:ServerLLDN.c  **** 					macsc_set_cmp1_int_cb(send_message_timeHandler);
 2476               		.loc 6 1173 0
 2477 0c6c 0E94 0000 		call macsc_enable_manual_bts
1174:ServerLLDN.c  **** 					macsc_enable_cmp_int(MACSC_CC1);
 2478               		.loc 6 1174 0
 2479 0c70 80E0      		ldi r24,lo8(gs(send_message_timeHandler))
 2480 0c72 90E0      		ldi r25,hi8(gs(send_message_timeHandler))
 2481 0c74 0E94 0000 		call macsc_set_cmp1_int_cb
1175:ServerLLDN.c  **** 					macsc_use_cmp(MACSC_RELATIVE_CMP, ts_time * retransmition_slot, MACSC_CC1);
 2482               		.loc 6 1175 0
 2483 0c78 81E0      		ldi r24,lo8(1)
 2484 0c7a 0E94 0000 		call macsc_enable_cmp_int
1176:ServerLLDN.c  **** 					#endif
 2485               		.loc 6 1176 0
 2486 0c7e 4091 0000 		lds r20,ts_time
 2487 0c82 5091 0000 		lds r21,ts_time+1
 2488 0c86 2981      		ldd r18,Y+1
 2489 0c88 3A81      		ldd r19,Y+2
 2490 0c8a 429F      		mul r20,r18
 2491 0c8c C001      		movw r24,r0
 2492 0c8e 439F      		mul r20,r19
 2493 0c90 900D      		add r25,r0
 2494 0c92 529F      		mul r21,r18
 2495 0c94 900D      		add r25,r0
 2496 0c96 1124      		clr r1
 2497 0c98 092E      		mov __tmp_reg__,r25
 2498 0c9a 000C      		lsl r0
 2499 0c9c AA0B      		sbc r26,r26
 2500 0c9e BB0B      		sbc r27,r27
 2501 0ca0 21E0      		ldi r18,lo8(1)
 2502 0ca2 AC01      		movw r20,r24
 2503 0ca4 BD01      		movw r22,r26
 2504 0ca6 81E0      		ldi r24,lo8(1)
 2505 0ca8 0E94 0000 		call macsc_use_cmp
 2506               	.LBE7:
1186:ServerLLDN.c  **** 		}
 2507               		.loc 6 1186 0
 2508 0cac 00C0      		rjmp .L86
 2509               	.L77:
1183:ServerLLDN.c  **** 			}
 2510               		.loc 6 1183 0
 2511 0cae 81E0      		ldi r24,lo8(1)
 2512 0cb0 8093 0000 		sts appState,r24
 2513               	.L86:
1186:ServerLLDN.c  **** 		}
 2514               		.loc 6 1186 0
 2515 0cb4 0000      		nop
 2516               	.L74:
1192:ServerLLDN.c  **** 		}
1193:ServerLLDN.c  **** 	}
1194:ServerLLDN.c  **** }
 2517               		.loc 6 1194 0
 2518 0cb6 0000      		nop
 2519               	/* epilogue start */
 2520 0cb8 0F90      		pop __tmp_reg__
 2521 0cba 0F90      		pop __tmp_reg__
 2522 0cbc 0F90      		pop __tmp_reg__
 2523 0cbe 0F90      		pop __tmp_reg__
 2524 0cc0 DF91      		pop r29
 2525 0cc2 CF91      		pop r28
 2526 0cc4 0895      		ret
 2527               		.cfi_endproc
 2528               	.LFE144:
 2530               		.section	.rodata
 2531               	.LC0:
 2532 0093 00        		.byte	0
 2533 0094 C2        		.byte	-62
 2534 0095 01        		.byte	1
 2535 0096 00        		.byte	0
 2536 0097 03        		.byte	3
 2537 0098 00        		.byte	0
 2538 0099 00        		.byte	0
 2539               		.text
 2540               	.global	main
 2542               	main:
 2543               	.LFB145:
1195:ServerLLDN.c  **** 
1196:ServerLLDN.c  **** 	/*****************************************************************************
1197:ServerLLDN.c  **** 	*****************************************************************************/
1198:ServerLLDN.c  **** 	int main(void)
1199:ServerLLDN.c  **** 	{
 2544               		.loc 6 1199 0
 2545               		.cfi_startproc
 2546 0cc6 0F93      		push r16
 2547               	.LCFI94:
 2548               		.cfi_def_cfa_offset 3
 2549               		.cfi_offset 16, -2
 2550 0cc8 1F93      		push r17
 2551               	.LCFI95:
 2552               		.cfi_def_cfa_offset 4
 2553               		.cfi_offset 17, -3
 2554 0cca CF93      		push r28
 2555               	.LCFI96:
 2556               		.cfi_def_cfa_offset 5
 2557               		.cfi_offset 28, -4
 2558 0ccc DF93      		push r29
 2559               	.LCFI97:
 2560               		.cfi_def_cfa_offset 6
 2561               		.cfi_offset 29, -5
 2562 0cce CDB7      		in r28,__SP_L__
 2563 0cd0 DEB7      		in r29,__SP_H__
 2564               	.LCFI98:
 2565               		.cfi_def_cfa_register 28
 2566 0cd2 2797      		sbiw r28,7
 2567               	.LCFI99:
 2568               		.cfi_def_cfa_offset 13
 2569 0cd4 0FB6      		in __tmp_reg__,__SREG__
 2570 0cd6 F894      		cli
 2571 0cd8 DEBF      		out __SP_H__,r29
 2572 0cda 0FBE      		out __SREG__,__tmp_reg__
 2573 0cdc CDBF      		out __SP_L__,r28
 2574               	/* prologue: function */
 2575               	/* frame size = 7 */
 2576               	/* stack size = 11 */
 2577               	.L__stack_usage = 11
1200:ServerLLDN.c  **** 		sysclk_init();
 2578               		.loc 6 1200 0
 2579 0cde 0E94 0000 		call sysclk_init
1201:ServerLLDN.c  **** 		board_init();
 2580               		.loc 6 1201 0
 2581 0ce2 0E94 0000 		call board_init
1202:ServerLLDN.c  **** 
1203:ServerLLDN.c  **** 		SYS_Init();
 2582               		.loc 6 1203 0
 2583 0ce6 0E94 0000 		call SYS_Init
1204:ServerLLDN.c  **** 		/* Disable CSMA/CA
1205:ServerLLDN.c  **** 		 * Disable auto ACK
1206:ServerLLDN.c  **** 		 * Enable Rx of LLDN Frame Type as described in 802.15.4e - 2012 
1207:ServerLLDN.c  **** 		 */
1208:ServerLLDN.c  **** 
1209:ServerLLDN.c  **** 		sm_init();
 2584               		.loc 6 1209 0
 2585 0cea 0E94 0000 		call sm_init
1210:ServerLLDN.c  **** 
1211:ServerLLDN.c  **** 		// Initialize interrupt vector table support.
1212:ServerLLDN.c  **** 	#if (SIO2HOST_CHANNEL == SIO_USB)
1213:ServerLLDN.c  **** 		irq_initialize_vectors();
1214:ServerLLDN.c  **** 	#endif
1215:ServerLLDN.c  **** 		cpu_irq_enable();
 2586               		.loc 6 1215 0
 2587               	/* #APP */
 2588               	 ;  1215 "ServerLLDN.c" 1
 2589 0cee 7894      		sei
 2590               	 ;  0 "" 2
1216:ServerLLDN.c  **** 
1217:ServerLLDN.c  **** 	#if 1
1218:ServerLLDN.c  **** 	#if (SIO2HOST_CHANNEL == SIO_USB)
1219:ServerLLDN.c  **** 		stdio_usb_init();
1220:ServerLLDN.c  **** 	#else
1221:ServerLLDN.c  **** 		const usart_serial_options_t usart_serial_options =
 2591               		.loc 6 1221 0
 2592               	/* #NOAPP */
 2593 0cf0 27E0      		ldi r18,lo8(7)
 2594 0cf2 E0E0      		ldi r30,lo8(.LC0)
 2595 0cf4 F0E0      		ldi r31,hi8(.LC0)
 2596 0cf6 CE01      		movw r24,r28
 2597 0cf8 0196      		adiw r24,1
 2598 0cfa DC01      		movw r26,r24
 2599               		0:
 2600 0cfc 0190      		ld r0,Z+
 2601 0cfe 0D92      		st X+,r0
 2602 0d00 2A95      		dec r18
 2603 0d02 01F4      		brne 0b
1222:ServerLLDN.c  **** 		{
1223:ServerLLDN.c  **** 			.baudrate     = USART_HOST_BAUDRATE,
1224:ServerLLDN.c  **** 			.charlength   = USART_HOST_CHAR_LENGTH,
1225:ServerLLDN.c  **** 			.paritytype   = USART_HOST_PARITY,
1226:ServerLLDN.c  **** 			.stopbits     = USART_HOST_STOP_BITS
1227:ServerLLDN.c  **** 		};
1228:ServerLLDN.c  **** 
1229:ServerLLDN.c  **** 		stdio_serial_init(USART_HOST, &usart_serial_options);
 2604               		.loc 6 1229 0
 2605 0d04 CE01      		movw r24,r28
 2606 0d06 0196      		adiw r24,1
 2607 0d08 BC01      		movw r22,r24
 2608 0d0a 80EC      		ldi r24,lo8(-64)
 2609 0d0c 90E0      		ldi r25,0
 2610 0d0e 0E94 0000 		call stdio_serial_init
1230:ServerLLDN.c  **** 		usart_double_baud_enable(USART_HOST);
 2611               		.loc 6 1230 0
 2612 0d12 80EC      		ldi r24,lo8(-64)
 2613 0d14 90E0      		ldi r25,0
 2614 0d16 0E94 0000 		call usart_double_baud_enable
1231:ServerLLDN.c  **** 		usart_set_baudrate_precalculated(USART_HOST, USART_HOST_BAUDRATE, sysclk_get_source_clock_hz());
 2615               		.loc 6 1231 0
 2616 0d1a 0E94 0000 		call sysclk_get_source_clock_hz
 2617 0d1e DC01      		movw r26,r24
 2618 0d20 CB01      		movw r24,r22
 2619 0d22 8C01      		movw r16,r24
 2620 0d24 9D01      		movw r18,r26
 2621 0d26 40E0      		ldi r20,0
 2622 0d28 52EC      		ldi r21,lo8(-62)
 2623 0d2a 61E0      		ldi r22,lo8(1)
 2624 0d2c 70E0      		ldi r23,0
 2625 0d2e 80EC      		ldi r24,lo8(-64)
 2626 0d30 90E0      		ldi r25,0
 2627 0d32 0E94 0000 		call usart_set_baudrate_precalculated
 2628               	.L88:
1232:ServerLLDN.c  **** 
1233:ServerLLDN.c  **** 	#endif
1234:ServerLLDN.c  **** 	#endif
1235:ServerLLDN.c  **** 		for(;;)
1236:ServerLLDN.c  **** 		{
1237:ServerLLDN.c  **** 			SYS_TaskHandler();
 2629               		.loc 6 1237 0 discriminator 1
 2630 0d36 0E94 0000 		call SYS_TaskHandler
1238:ServerLLDN.c  **** 			APP_TaskHandler();
 2631               		.loc 6 1238 0 discriminator 1
 2632 0d3a 0E94 0000 		call APP_TaskHandler
1239:ServerLLDN.c  **** 		}
 2633               		.loc 6 1239 0 discriminator 1
 2634 0d3e 00C0      		rjmp .L88
 2635               		.cfi_endproc
 2636               	.LFE145:
 2638               	.Letext0:
 2639               		.file 7 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\in
 2640               		.file 8 "../../../stack/LwMesh/TDMA/nwk/inc/nwkFrame.h"
 2641               		.file 9 "../../../stack/LwMesh/TDMA/nwk/inc/nwkRx.h"
 2642               		.file 10 "../../../stack/LwMesh/TDMA/nwk/inc/nwkDataReq.h"
 2643               		.file 11 "lldn.h"
 2644               		.file 12 "../../../platform/mega_rf/drivers/sleep/sleep.h"
 2645               		.file 13 "../../../platform/mega_rf/utils/status_codes.h"
 2646               		.file 14 "config/config.h"
 2647               		.file 15 "../../../platform/common/services/sleepmgr/mega_rf/sleepmgr.h"
DEFINED SYMBOLS
                            *ABS*:00000000 ServerLLDN.c
C:\Users\GUILHE~1\AppData\Local\Temp\cciX2Cjz.s:2      *ABS*:0000003e __SP_H__
C:\Users\GUILHE~1\AppData\Local\Temp\cciX2Cjz.s:3      *ABS*:0000003d __SP_L__
C:\Users\GUILHE~1\AppData\Local\Temp\cciX2Cjz.s:4      *ABS*:0000003f __SREG__
C:\Users\GUILHE~1\AppData\Local\Temp\cciX2Cjz.s:5      *ABS*:0000003b __RAMPZ__
C:\Users\GUILHE~1\AppData\Local\Temp\cciX2Cjz.s:6      *ABS*:00000000 __tmp_reg__
C:\Users\GUILHE~1\AppData\Local\Temp\cciX2Cjz.s:7      *ABS*:00000001 __zero_reg__
C:\Users\GUILHE~1\AppData\Local\Temp\cciX2Cjz.s:15     .bss.n:00000000 n
                            *COM*:00000004 tTS
                            *COM*:00000002 macLLDNnumTimeSlots
                            *COM*:00000002 macLLDNnumUplinkTS
                            *COM*:00000002 macLLDNRetransmitTS
C:\Users\GUILHE~1\AppData\Local\Temp\cciX2Cjz.s:23     .text:00000000 sysclk_get_main_hz
C:\Users\GUILHE~1\AppData\Local\Temp\cciX2Cjz.s:60     .text:0000001a sysclk_get_source_clock_hz
C:\Users\GUILHE~1\AppData\Local\Temp\cciX2Cjz.s:97     .progmem.data.baudctrl_1mhz:00000000 baudctrl_1mhz
C:\Users\GUILHE~1\AppData\Local\Temp\cciX2Cjz.s:109    .progmem.data.baudctrl_8mhz:00000000 baudctrl_8mhz
C:\Users\GUILHE~1\AppData\Local\Temp\cciX2Cjz.s:121    .progmem.data.baudctrl_16mhz:00000000 baudctrl_16mhz
C:\Users\GUILHE~1\AppData\Local\Temp\cciX2Cjz.s:132    .text:00000034 usart_double_baud_enable
C:\Users\GUILHE~1\AppData\Local\Temp\cciX2Cjz.s:181    .text:00000062 usart_serial_init
C:\Users\GUILHE~1\AppData\Local\Temp\cciX2Cjz.s:276    .text:000000de usart_serial_putchar
C:\Users\GUILHE~1\AppData\Local\Temp\cciX2Cjz.s:320    .text:00000106 usart_serial_getchar
C:\Users\GUILHE~1\AppData\Local\Temp\cciX2Cjz.s:371    .text:0000013c stdio_serial_init
C:\Users\GUILHE~1\AppData\Local\Temp\cciX2Cjz.s:442    .text:0000019e macsc_read32
C:\Users\GUILHE~1\AppData\Local\Temp\cciX2Cjz.s:525    .text:00000208 macsc_read_count
C:\Users\GUILHE~1\AppData\Local\Temp\cciX2Cjz.s:568    .text:00000232 macsc_enable_manual_bts
C:\Users\GUILHE~1\AppData\Local\Temp\cciX2Cjz.s:621    .bss.appState:00000000 appState
C:\Users\GUILHE~1\AppData\Local\Temp\cciX2Cjz.s:626    .bss.msgReq:00000000 msgReq
C:\Users\GUILHE~1\AppData\Local\Temp\cciX2Cjz.s:631    .bss.PanId:00000000 PanId
C:\Users\GUILHE~1\AppData\Local\Temp\cciX2Cjz.s:639    .text:00000266 appSendData
C:\Users\GUILHE~1\AppData\Local\Temp\cciX2Cjz.s:706    .data.payloadSize:00000000 payloadSize
C:\Users\GUILHE~1\AppData\Local\Temp\cciX2Cjz.s:712    .data.assTimeSlot:00000000 assTimeSlot
C:\Users\GUILHE~1\AppData\Local\Temp\cciX2Cjz.s:718    .data.data_payload:00000000 data_payload
                            *COM*:00000008 rec_beacon
                            *COM*:00000002 ackframe
C:\Users\GUILHE~1\AppData\Local\Temp\cciX2Cjz.s:725    .data.msgDiscResponse:00000000 msgDiscResponse
C:\Users\GUILHE~1\AppData\Local\Temp\cciX2Cjz.s:732    .data.msgConfigStatus:00000000 msgConfigStatus
C:\Users\GUILHE~1\AppData\Local\Temp\cciX2Cjz.s:741    .data.msgReqDiscResponse:00000000 msgReqDiscResponse
C:\Users\GUILHE~1\AppData\Local\Temp\cciX2Cjz.s:754    .data.msgReqConfigStatus:00000000 msgReqConfigStatus
C:\Users\GUILHE~1\AppData\Local\Temp\cciX2Cjz.s:767    .data.msgReqData:00000000 msgReqData
C:\Users\GUILHE~1\AppData\Local\Temp\cciX2Cjz.s:780    .bss.ack_received:00000000 ack_received
C:\Users\GUILHE~1\AppData\Local\Temp\cciX2Cjz.s:786    .bss.MacLLDNMgmtTS:00000000 MacLLDNMgmtTS
C:\Users\GUILHE~1\AppData\Local\Temp\cciX2Cjz.s:792    .bss.associated:00000000 associated
                            *COM*:00000002 ts_time
C:\Users\GUILHE~1\AppData\Local\Temp\cciX2Cjz.s:799    .data.STATE:00000000 STATE
C:\Users\GUILHE~1\AppData\Local\Temp\cciX2Cjz.s:805    .bss.tmr_error:00000000 tmr_error
C:\Users\GUILHE~1\AppData\Local\Temp\cciX2Cjz.s:811    .bss.delta_error:00000000 delta_error
C:\Users\GUILHE~1\AppData\Local\Temp\cciX2Cjz.s:817    .bss.beacon_tmr:00000000 beacon_tmr
C:\Users\GUILHE~1\AppData\Local\Temp\cciX2Cjz.s:823    .bss.be_read:00000000 be_read
C:\Users\GUILHE~1\AppData\Local\Temp\cciX2Cjz.s:829    .bss.tmr_read:00000000 tmr_read
                            *COM*:00000002 msg_wait_time
C:\Users\GUILHE~1\AppData\Local\Temp\cciX2Cjz.s:836    .data.ok_seq:00000000 ok_seq
C:\Users\GUILHE~1\AppData\Local\Temp\cciX2Cjz.s:840    .text:000002b8 send_message_timeHandler
C:\Users\GUILHE~1\AppData\Local\Temp\cciX2Cjz.s:875    .text:000002d2 node_time_handler
C:\Users\GUILHE~1\AppData\Local\Temp\cciX2Cjz.s:921    .text:00000300 disc_time_hndlr
C:\Users\GUILHE~1\AppData\Local\Temp\cciX2Cjz.s:970    .text:00000336 config_time_hndlr
C:\Users\GUILHE~1\AppData\Local\Temp\cciX2Cjz.s:1019   .text:00000362 online_time_hndlr
C:\Users\GUILHE~1\AppData\Local\Temp\cciX2Cjz.s:1079   .text:00000398 appBeaconInd
C:\Users\GUILHE~1\AppData\Local\Temp\cciX2Cjz.s:1439   .text:00000648 check_ack
C:\Users\GUILHE~1\AppData\Local\Temp\cciX2Cjz.s:1593   .text:00000728 appAckInd
C:\Users\GUILHE~1\AppData\Local\Temp\cciX2Cjz.s:1881   .text:00000914 appCommandInd
C:\Users\GUILHE~1\AppData\Local\Temp\cciX2Cjz.s:2021   .text:000009f0 appPrepareDiscoverResponse
C:\Users\GUILHE~1\AppData\Local\Temp\cciX2Cjz.s:2074   .text:00000a32 appPrepareConfigurationStatus
C:\Users\GUILHE~1\AppData\Local\Temp\cciX2Cjz.s:2127   .text:00000a74 appPrepareDataFrame
C:\Users\GUILHE~1\AppData\Local\Temp\cciX2Cjz.s:2182   .text:00000abc appInit
C:\Users\GUILHE~1\AppData\Local\Temp\cciX2Cjz.s:2254   .text:00000b18 APP_TaskHandler
C:\Users\GUILHE~1\AppData\Local\Temp\cciX2Cjz.s:2542   .text:00000cc6 main

UNDEFINED SYMBOLS
usart_init_rs232
usart_putchar
usart_getchar
stdio_base
ptr_put
ptr_get
_read
_write
fdevopen
NWK_DataReq
printf
macsc_set_cmp2_int_cb
macsc_disable_cmp_int
macsc_set_cmp1_int_cb
__floatsisf
__addsf3
__divsf3
__mulsf3
__fixsfsi
macsc_enable_cmp_int
macsc_use_cmp
PHY_SetTdmaMode
__subsf3
__fixunssfsi
PHY_SetChannel
NWK_SetPanId
NWK_SetAddr
PHY_SetRxState
PHY_SetOptimizedCSMAValues
NWK_OpenEndpoint
PHY_SetPromiscuousMode
sysclk_init
board_init
SYS_Init
sm_init
usart_set_baudrate_precalculated
SYS_TaskHandler
__do_copy_data
__do_clear_bss
