   1               		.file	"ServerLLDN.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__RAMPZ__ = 0x3b
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.text
   9               	.Ltext0:
  10               		.cfi_sections	.debug_frame
  11               		.comm	n,1,1
  12               		.section	.bss.tTS,"aw",@nobits
  15               	tTS:
  16 0000 0000 0000 		.zero	4
  17               		.text
  19               	sysclk_get_main_hz:
  20               	.LFB67:
  21               		.file 1 "../../../platform/common/services/clock/mega/sysclk.h"
   1:../../../platform/common/services/clock/mega/sysclk.h **** /**
   2:../../../platform/common/services/clock/mega/sysclk.h ****  * \file
   3:../../../platform/common/services/clock/mega/sysclk.h ****  *
   4:../../../platform/common/services/clock/mega/sysclk.h ****  * \brief Chip-specific system clock management functions
   5:../../../platform/common/services/clock/mega/sysclk.h ****  *
   6:../../../platform/common/services/clock/mega/sysclk.h ****  * Copyright (c) 2012 Atmel Corporation. All rights reserved.
   7:../../../platform/common/services/clock/mega/sysclk.h ****  *
   8:../../../platform/common/services/clock/mega/sysclk.h ****  * \asf_license_start
   9:../../../platform/common/services/clock/mega/sysclk.h ****  *
  10:../../../platform/common/services/clock/mega/sysclk.h ****  * \page License
  11:../../../platform/common/services/clock/mega/sysclk.h ****  *
  12:../../../platform/common/services/clock/mega/sysclk.h ****  * Redistribution and use in source and binary forms, with or without
  13:../../../platform/common/services/clock/mega/sysclk.h ****  * modification, are permitted provided that the following conditions are met:
  14:../../../platform/common/services/clock/mega/sysclk.h ****  *
  15:../../../platform/common/services/clock/mega/sysclk.h ****  * 1. Redistributions of source code must retain the above copyright notice,
  16:../../../platform/common/services/clock/mega/sysclk.h ****  *    this list of conditions and the following disclaimer.
  17:../../../platform/common/services/clock/mega/sysclk.h ****  *
  18:../../../platform/common/services/clock/mega/sysclk.h ****  * 2. Redistributions in binary form must reproduce the above copyright notice,
  19:../../../platform/common/services/clock/mega/sysclk.h ****  *    this list of conditions and the following disclaimer in the documentation
  20:../../../platform/common/services/clock/mega/sysclk.h ****  *    and/or other materials provided with the distribution.
  21:../../../platform/common/services/clock/mega/sysclk.h ****  *
  22:../../../platform/common/services/clock/mega/sysclk.h ****  * 3. The name of Atmel may not be used to endorse or promote products derived
  23:../../../platform/common/services/clock/mega/sysclk.h ****  *    from this software without specific prior written permission.
  24:../../../platform/common/services/clock/mega/sysclk.h ****  *
  25:../../../platform/common/services/clock/mega/sysclk.h ****  * 4. This software may only be redistributed and used in connection with an
  26:../../../platform/common/services/clock/mega/sysclk.h ****  *    Atmel microcontroller product.
  27:../../../platform/common/services/clock/mega/sysclk.h ****  *
  28:../../../platform/common/services/clock/mega/sysclk.h ****  * THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR IMPLIED
  29:../../../platform/common/services/clock/mega/sysclk.h ****  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
  30:../../../platform/common/services/clock/mega/sysclk.h ****  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
  31:../../../platform/common/services/clock/mega/sysclk.h ****  * EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR
  32:../../../platform/common/services/clock/mega/sysclk.h ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  33:../../../platform/common/services/clock/mega/sysclk.h ****  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
  34:../../../platform/common/services/clock/mega/sysclk.h ****  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  35:../../../platform/common/services/clock/mega/sysclk.h ****  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
  36:../../../platform/common/services/clock/mega/sysclk.h ****  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  37:../../../platform/common/services/clock/mega/sysclk.h ****  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  38:../../../platform/common/services/clock/mega/sysclk.h ****  * POSSIBILITY OF SUCH DAMAGE.
  39:../../../platform/common/services/clock/mega/sysclk.h ****  *
  40:../../../platform/common/services/clock/mega/sysclk.h ****  * \asf_license_stop
  41:../../../platform/common/services/clock/mega/sysclk.h ****  *
  42:../../../platform/common/services/clock/mega/sysclk.h ****  */
  43:../../../platform/common/services/clock/mega/sysclk.h **** #ifndef MEGA_SYSCLK_H_INCLUDED
  44:../../../platform/common/services/clock/mega/sysclk.h **** #define MEGA_SYSCLK_H_INCLUDED
  45:../../../platform/common/services/clock/mega/sysclk.h **** 
  46:../../../platform/common/services/clock/mega/sysclk.h **** #include <board.h>
  47:../../../platform/common/services/clock/mega/sysclk.h **** #include <compiler.h>
  48:../../../platform/common/services/clock/mega/sysclk.h **** #include <parts.h>
  49:../../../platform/common/services/clock/mega/sysclk.h **** 
  50:../../../platform/common/services/clock/mega/sysclk.h **** /* Include clock configuration for the project. */
  51:../../../platform/common/services/clock/mega/sysclk.h **** #include <conf_clock.h>
  52:../../../platform/common/services/clock/mega/sysclk.h **** 
  53:../../../platform/common/services/clock/mega/sysclk.h **** #ifdef __cplusplus
  54:../../../platform/common/services/clock/mega/sysclk.h **** extern "C" {
  55:../../../platform/common/services/clock/mega/sysclk.h **** #endif
  56:../../../platform/common/services/clock/mega/sysclk.h **** #define ASM __asm__
  57:../../../platform/common/services/clock/mega/sysclk.h **** 
  58:../../../platform/common/services/clock/mega/sysclk.h **** /* CONFIG_SYSCLK_PSDIV  to use default if not defined*/
  59:../../../platform/common/services/clock/mega/sysclk.h **** #ifndef CONFIG_SYSCLK_PSDIV
  60:../../../platform/common/services/clock/mega/sysclk.h **** # define CONFIG_SYSCLK_PSDIV    SYSCLK_PSDIV_8
  61:../../../platform/common/services/clock/mega/sysclk.h **** #endif
  62:../../../platform/common/services/clock/mega/sysclk.h **** 
  63:../../../platform/common/services/clock/mega/sysclk.h **** /* ! \name Prescaler Setting (relative to CLKsys) */
  64:../../../platform/common/services/clock/mega/sysclk.h **** /* @{ */
  65:../../../platform/common/services/clock/mega/sysclk.h **** #define SYSCLK_PSDIV_1      0   /* !< Do not prescale */
  66:../../../platform/common/services/clock/mega/sysclk.h **** #define SYSCLK_PSDIV_2      1   /* !< Prescale CLKper4 by 2 */
  67:../../../platform/common/services/clock/mega/sysclk.h **** #define SYSCLK_PSDIV_4      2   /* !< Prescale CLKper4 by 4 */
  68:../../../platform/common/services/clock/mega/sysclk.h **** #define SYSCLK_PSDIV_8      3   /* !< Prescale CLKper4 by 8 */
  69:../../../platform/common/services/clock/mega/sysclk.h **** #define SYSCLK_PSDIV_16     4   /* !< Prescale CLKper4 by 16 */
  70:../../../platform/common/services/clock/mega/sysclk.h **** #define SYSCLK_PSDIV_32     5   /* !< Prescale CLKper4 by 32 */
  71:../../../platform/common/services/clock/mega/sysclk.h **** #define SYSCLK_PSDIV_64     6   /* !< Prescale CLKper4 by 64 */
  72:../../../platform/common/services/clock/mega/sysclk.h **** #define SYSCLK_PSDIV_128    7   /* !< Prescale CLKper4 by 128 */
  73:../../../platform/common/services/clock/mega/sysclk.h **** #define SYSCLK_PSDIV_256    8   /* !< Prescale CLKper4 by 256 */
  74:../../../platform/common/services/clock/mega/sysclk.h **** 
  75:../../../platform/common/services/clock/mega/sysclk.h **** /* @} */
  76:../../../platform/common/services/clock/mega/sysclk.h **** 
  77:../../../platform/common/services/clock/mega/sysclk.h **** #if MEGA_RF || MEGA_XX0_1 || MEGA_XX4 || MEGA_XX4_A
  78:../../../platform/common/services/clock/mega/sysclk.h **** 
  79:../../../platform/common/services/clock/mega/sysclk.h **** #define NUMBER_OF_POWER_REG       2
  80:../../../platform/common/services/clock/mega/sysclk.h **** /*Starting Address for power reduction*/
  81:../../../platform/common/services/clock/mega/sysclk.h **** #define POWER_REG_ADD             PRR0
  82:../../../platform/common/services/clock/mega/sysclk.h **** 
  83:../../../platform/common/services/clock/mega/sysclk.h **** /* ! \name Power Reduction  Clock Port Numbers */
  84:../../../platform/common/services/clock/mega/sysclk.h **** enum power_red_id {
  85:../../../platform/common/services/clock/mega/sysclk.h **** 	POWER_RED_REG0,     /* !< Devices on PRR0 */
  86:../../../platform/common/services/clock/mega/sysclk.h **** #if !MEGA_XX4 || !MEGA_XX4_A || MEGA_XX0_1
  87:../../../platform/common/services/clock/mega/sysclk.h **** 	POWER_RED_REG1,     /* !< Devices on PRR1 */
  88:../../../platform/common/services/clock/mega/sysclk.h **** #endif
  89:../../../platform/common/services/clock/mega/sysclk.h **** };
  90:../../../platform/common/services/clock/mega/sysclk.h **** #endif
  91:../../../platform/common/services/clock/mega/sysclk.h **** 
  92:../../../platform/common/services/clock/mega/sysclk.h **** /****************************************************
  93:../../../platform/common/services/clock/mega/sysclk.h ****  * Given a dummy type but not used for these groups
  94:../../../platform/common/services/clock/mega/sysclk.h ****  * to support for otherthen megaRF device.
  95:../../../platform/common/services/clock/mega/sysclk.h ****  **************************************************/
  96:../../../platform/common/services/clock/mega/sysclk.h **** #if MEGA_XX8 || MEGA_XX8_A || MEGA_UNSPECIFIED
  97:../../../platform/common/services/clock/mega/sysclk.h **** #define NUMBER_OF_POWER_REG       1
  98:../../../platform/common/services/clock/mega/sysclk.h **** /*Starting Address for power reduction*/
  99:../../../platform/common/services/clock/mega/sysclk.h **** #define POWER_REG_ADD             PRR
 100:../../../platform/common/services/clock/mega/sysclk.h **** 
 101:../../../platform/common/services/clock/mega/sysclk.h **** /* ! \name Power Reduction  Clock Port Numbers */
 102:../../../platform/common/services/clock/mega/sysclk.h **** enum power_red_id {
 103:../../../platform/common/services/clock/mega/sysclk.h **** 	POWER_RED_REG0,     /* !< Devices on PRR */
 104:../../../platform/common/services/clock/mega/sysclk.h **** };
 105:../../../platform/common/services/clock/mega/sysclk.h **** #endif
 106:../../../platform/common/services/clock/mega/sysclk.h **** 
 107:../../../platform/common/services/clock/mega/sysclk.h **** /* Bit mask for the power reduction register based on */
 108:../../../platform/common/services/clock/mega/sysclk.h **** /*   MCU ARCH.                                        */
 109:../../../platform/common/services/clock/mega/sysclk.h **** #if MEGA_RF
 110:../../../platform/common/services/clock/mega/sysclk.h **** /*Bit mask for PRR2 */
 111:../../../platform/common/services/clock/mega/sysclk.h **** 
 112:../../../platform/common/services/clock/mega/sysclk.h **** #define PRRAM0_bm                       1 << PRRAM0
 113:../../../platform/common/services/clock/mega/sysclk.h **** #define PRRAM1_bm                       1 << PRRAM1
 114:../../../platform/common/services/clock/mega/sysclk.h **** #define PRRAM2_bm                       1 << PRRAM2
 115:../../../platform/common/services/clock/mega/sysclk.h **** #define PRRAM3_bm                       1 << PRRAM3
 116:../../../platform/common/services/clock/mega/sysclk.h **** #endif
 117:../../../platform/common/services/clock/mega/sysclk.h **** 
 118:../../../platform/common/services/clock/mega/sysclk.h **** /*Bit mask for the power reduction 0 or PRR*/
 119:../../../platform/common/services/clock/mega/sysclk.h **** #if !MEGA_XX_UN0 && !MEGA_XX_UN0
 120:../../../platform/common/services/clock/mega/sysclk.h **** #define PRADC_bm                        1 << PRADC
 121:../../../platform/common/services/clock/mega/sysclk.h **** #define PRUSART0_bm                     1 << PRUSART0
 122:../../../platform/common/services/clock/mega/sysclk.h **** #define PRSPI_bm                        1 << PRSPI
 123:../../../platform/common/services/clock/mega/sysclk.h **** #define PRTIM1_bm                       1 << PRTIM1
 124:../../../platform/common/services/clock/mega/sysclk.h **** #endif
 125:../../../platform/common/services/clock/mega/sysclk.h **** 
 126:../../../platform/common/services/clock/mega/sysclk.h **** #if MEGA_RF
 127:../../../platform/common/services/clock/mega/sysclk.h **** #define PRPGA_bm                        1 << PRPGA
 128:../../../platform/common/services/clock/mega/sysclk.h **** #endif
 129:../../../platform/common/services/clock/mega/sysclk.h **** 
 130:../../../platform/common/services/clock/mega/sysclk.h **** #if !MEGA_UNSPECIFIED
 131:../../../platform/common/services/clock/mega/sysclk.h **** #define PRTIM0_bm                       1 << PRTIM0
 132:../../../platform/common/services/clock/mega/sysclk.h **** #define PRTIM2_bm                       1 << PRTIM2
 133:../../../platform/common/services/clock/mega/sysclk.h **** #define PRTWI_bm                        1 << PRTWI
 134:../../../platform/common/services/clock/mega/sysclk.h **** #endif
 135:../../../platform/common/services/clock/mega/sysclk.h **** 
 136:../../../platform/common/services/clock/mega/sysclk.h **** #if MEGA_XX_UN2
 137:../../../platform/common/services/clock/mega/sysclk.h **** #define PRLCD_bm                        1 << PRLCD
 138:../../../platform/common/services/clock/mega/sysclk.h **** #endif
 139:../../../platform/common/services/clock/mega/sysclk.h **** 
 140:../../../platform/common/services/clock/mega/sysclk.h **** /*Bit mask for  PRR1  */
 141:../../../platform/common/services/clock/mega/sysclk.h **** #ifdef PRR1
 142:../../../platform/common/services/clock/mega/sysclk.h **** #if (MEGA_XX4 || MEGA_XX4_A)
 143:../../../platform/common/services/clock/mega/sysclk.h **** #define PRTIM3_bm                       1 << PRTIM3
 144:../../../platform/common/services/clock/mega/sysclk.h **** #endif
 145:../../../platform/common/services/clock/mega/sysclk.h **** #endif
 146:../../../platform/common/services/clock/mega/sysclk.h **** 
 147:../../../platform/common/services/clock/mega/sysclk.h **** #if MEGA_RF || MEGA_XX4 || MEGA_XX4_A
 148:../../../platform/common/services/clock/mega/sysclk.h **** #define PRUSART1_bm                     1 << PRUSART1
 149:../../../platform/common/services/clock/mega/sysclk.h **** #define PRUSART2_bm                     1 << PRUSART2
 150:../../../platform/common/services/clock/mega/sysclk.h **** #define PRUSART3_bm                     1 << PRUSART3
 151:../../../platform/common/services/clock/mega/sysclk.h **** #define PRTIM3_bm                       1 << PRTIM3
 152:../../../platform/common/services/clock/mega/sysclk.h **** #define PRTIM4_bm                       1 << PRTIM4
 153:../../../platform/common/services/clock/mega/sysclk.h **** #define PRTIM5_bm                       1 << PRTIM5
 154:../../../platform/common/services/clock/mega/sysclk.h **** #endif
 155:../../../platform/common/services/clock/mega/sysclk.h **** 
 156:../../../platform/common/services/clock/mega/sysclk.h **** #if MEGA_RF
 157:../../../platform/common/services/clock/mega/sysclk.h **** #define PRTRX24_bm                      1 << PRTRX24
 158:../../../platform/common/services/clock/mega/sysclk.h **** #endif
 159:../../../platform/common/services/clock/mega/sysclk.h **** 
 160:../../../platform/common/services/clock/mega/sysclk.h **** /**
 161:../../../platform/common/services/clock/mega/sysclk.h ****  * \name Querying the system clock and its derived clocks
 162:../../../platform/common/services/clock/mega/sysclk.h ****  */
 163:../../../platform/common/services/clock/mega/sysclk.h **** /* @{ */
 164:../../../platform/common/services/clock/mega/sysclk.h **** 
 165:../../../platform/common/services/clock/mega/sysclk.h **** /**
 166:../../../platform/common/services/clock/mega/sysclk.h ****  * \brief Return the current rate in Hz of the main system clock
 167:../../../platform/common/services/clock/mega/sysclk.h ****  * To know the clock value at what frequency the main clock is running
 168:../../../platform/common/services/clock/mega/sysclk.h ****  * \return Frequency of the main system clock, in Hz.
 169:../../../platform/common/services/clock/mega/sysclk.h ****  * \todo : please initialize the SYSCLK_SOURCE in conf_clock.h file for
 170:../../../platform/common/services/clock/mega/sysclk.h ****  * configured source clock using fuses.
 171:../../../platform/common/services/clock/mega/sysclk.h ****  * \eg. #define SYSCLK_SOURCE SYSCLK_SRC_RC16MHZ to use internal RC
 172:../../../platform/common/services/clock/mega/sysclk.h ****  * oscillator for clock source.
 173:../../../platform/common/services/clock/mega/sysclk.h ****  */
 174:../../../platform/common/services/clock/mega/sysclk.h **** static inline uint32_t sysclk_get_main_hz(void)
 175:../../../platform/common/services/clock/mega/sysclk.h **** {
  22               		.loc 1 175 0
  23               		.cfi_startproc
  24 0000 CF93      		push r28
  25               	.LCFI0:
  26               		.cfi_def_cfa_offset 3
  27               		.cfi_offset 28, -2
  28 0002 DF93      		push r29
  29               	.LCFI1:
  30               		.cfi_def_cfa_offset 4
  31               		.cfi_offset 29, -3
  32 0004 CDB7      		in r28,__SP_L__
  33 0006 DEB7      		in r29,__SP_H__
  34               	.LCFI2:
  35               		.cfi_def_cfa_register 28
  36               	/* prologue: function */
  37               	/* frame size = 0 */
  38               	/* stack size = 2 */
  39               	.L__stack_usage = 2
 176:../../../platform/common/services/clock/mega/sysclk.h **** 	switch (SYSCLK_SOURCE) {
 177:../../../platform/common/services/clock/mega/sysclk.h **** 	case SYSCLK_SRC_RC16MHZ:
 178:../../../platform/common/services/clock/mega/sysclk.h **** 		return 16000000UL;
 179:../../../platform/common/services/clock/mega/sysclk.h **** 
 180:../../../platform/common/services/clock/mega/sysclk.h **** 	case SYSCLK_SRC_RC128KHZ:
 181:../../../platform/common/services/clock/mega/sysclk.h **** 		return 128000UL;
 182:../../../platform/common/services/clock/mega/sysclk.h **** 
 183:../../../platform/common/services/clock/mega/sysclk.h **** #if MEGA_RF
 184:../../../platform/common/services/clock/mega/sysclk.h **** 	case SYSCLK_SRC_TRS16MHZ:
 185:../../../platform/common/services/clock/mega/sysclk.h **** 		return 16000000UL;
  40               		.loc 1 185 0
  41 0008 80E0      		ldi r24,0
  42 000a 94E2      		ldi r25,lo8(36)
  43 000c A4EF      		ldi r26,lo8(-12)
  44 000e B0E0      		ldi r27,0
 186:../../../platform/common/services/clock/mega/sysclk.h **** #endif
 187:../../../platform/common/services/clock/mega/sysclk.h **** #ifdef BOARD_EXTERNAL_CLK
 188:../../../platform/common/services/clock/mega/sysclk.h **** 	case SYSCLK_SRC_EXTERNAL:
 189:../../../platform/common/services/clock/mega/sysclk.h **** 		return BOARD_EXTERNAL_CLK;
 190:../../../platform/common/services/clock/mega/sysclk.h **** #endif
 191:../../../platform/common/services/clock/mega/sysclk.h **** 	default:
 192:../../../platform/common/services/clock/mega/sysclk.h **** 
 193:../../../platform/common/services/clock/mega/sysclk.h **** 		return 1000000UL;
 194:../../../platform/common/services/clock/mega/sysclk.h **** 	}
 195:../../../platform/common/services/clock/mega/sysclk.h **** }
  45               		.loc 1 195 0
  46 0010 BC01      		movw r22,r24
  47 0012 CD01      		movw r24,r26
  48               	/* epilogue start */
  49 0014 DF91      		pop r29
  50 0016 CF91      		pop r28
  51 0018 0895      		ret
  52               		.cfi_endproc
  53               	.LFE67:
  56               	sysclk_get_source_clock_hz:
  57               	.LFB68:
 196:../../../platform/common/services/clock/mega/sysclk.h **** 
 197:../../../platform/common/services/clock/mega/sysclk.h **** /**
 198:../../../platform/common/services/clock/mega/sysclk.h ****  * \brief Return the current rate in Hz of source clock in Hz.
 199:../../../platform/common/services/clock/mega/sysclk.h ****  *
 200:../../../platform/common/services/clock/mega/sysclk.h ****  * This clock always runs at the same rate as the CPU clock unless the divider
 201:../../../platform/common/services/clock/mega/sysclk.h ****  * is set.
 202:../../../platform/common/services/clock/mega/sysclk.h ****  *
 203:../../../platform/common/services/clock/mega/sysclk.h ****  * \return Frequency of the system clock, in Hz.
 204:../../../platform/common/services/clock/mega/sysclk.h ****  */
 205:../../../platform/common/services/clock/mega/sysclk.h **** static inline uint32_t sysclk_get_source_clock_hz(void)
 206:../../../platform/common/services/clock/mega/sysclk.h **** {
  58               		.loc 1 206 0
  59               		.cfi_startproc
  60 001a CF93      		push r28
  61               	.LCFI3:
  62               		.cfi_def_cfa_offset 3
  63               		.cfi_offset 28, -2
  64 001c DF93      		push r29
  65               	.LCFI4:
  66               		.cfi_def_cfa_offset 4
  67               		.cfi_offset 29, -3
  68 001e CDB7      		in r28,__SP_L__
  69 0020 DEB7      		in r29,__SP_H__
  70               	.LCFI5:
  71               		.cfi_def_cfa_register 28
  72               	/* prologue: function */
  73               	/* frame size = 0 */
  74               	/* stack size = 2 */
  75               	.L__stack_usage = 2
 207:../../../platform/common/services/clock/mega/sysclk.h **** 	switch (CONFIG_SYSCLK_PSDIV) {
 208:../../../platform/common/services/clock/mega/sysclk.h **** 	case SYSCLK_PSDIV_1: /* Fall through */
 209:../../../platform/common/services/clock/mega/sysclk.h **** 		if (SYSCLK_SOURCE == SYSCLK_SRC_RC16MHZ ||
 210:../../../platform/common/services/clock/mega/sysclk.h **** 				SYSCLK_SOURCE == SYSCLK_SRC_RC128KHZ) {
 211:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 2;
 212:../../../platform/common/services/clock/mega/sysclk.h **** 		} else {
 213:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz();
  76               		.loc 1 213 0
  77 0022 0E94 0000 		call sysclk_get_main_hz
  78 0026 DC01      		movw r26,r24
  79 0028 CB01      		movw r24,r22
 214:../../../platform/common/services/clock/mega/sysclk.h **** 		}
 215:../../../platform/common/services/clock/mega/sysclk.h **** 
 216:../../../platform/common/services/clock/mega/sysclk.h **** 	case SYSCLK_PSDIV_2:
 217:../../../platform/common/services/clock/mega/sysclk.h **** 		if (SYSCLK_SOURCE == SYSCLK_SRC_RC16MHZ ||
 218:../../../platform/common/services/clock/mega/sysclk.h **** 				SYSCLK_SOURCE == SYSCLK_SRC_RC128KHZ) {
 219:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 4;
 220:../../../platform/common/services/clock/mega/sysclk.h **** 		} else {
 221:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 2;
 222:../../../platform/common/services/clock/mega/sysclk.h **** 		}
 223:../../../platform/common/services/clock/mega/sysclk.h **** 
 224:../../../platform/common/services/clock/mega/sysclk.h **** 	case SYSCLK_PSDIV_4:
 225:../../../platform/common/services/clock/mega/sysclk.h **** 		if (SYSCLK_SOURCE == SYSCLK_SRC_RC16MHZ ||
 226:../../../platform/common/services/clock/mega/sysclk.h **** 				SYSCLK_SOURCE == SYSCLK_SRC_RC128KHZ) {
 227:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 8;
 228:../../../platform/common/services/clock/mega/sysclk.h **** 		} else {
 229:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 4;
 230:../../../platform/common/services/clock/mega/sysclk.h **** 		}
 231:../../../platform/common/services/clock/mega/sysclk.h **** 
 232:../../../platform/common/services/clock/mega/sysclk.h **** 	case SYSCLK_PSDIV_8:
 233:../../../platform/common/services/clock/mega/sysclk.h **** 		if (SYSCLK_SOURCE == SYSCLK_SRC_RC16MHZ ||
 234:../../../platform/common/services/clock/mega/sysclk.h **** 				SYSCLK_SOURCE == SYSCLK_SRC_RC128KHZ) {
 235:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 16;
 236:../../../platform/common/services/clock/mega/sysclk.h **** 		} else {
 237:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 8;
 238:../../../platform/common/services/clock/mega/sysclk.h **** 		}
 239:../../../platform/common/services/clock/mega/sysclk.h **** 
 240:../../../platform/common/services/clock/mega/sysclk.h **** 	case SYSCLK_PSDIV_16:
 241:../../../platform/common/services/clock/mega/sysclk.h **** 		if (SYSCLK_SOURCE == SYSCLK_SRC_RC16MHZ ||
 242:../../../platform/common/services/clock/mega/sysclk.h **** 				SYSCLK_SOURCE == SYSCLK_SRC_RC128KHZ) {
 243:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 32;
 244:../../../platform/common/services/clock/mega/sysclk.h **** 		} else {
 245:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 16;
 246:../../../platform/common/services/clock/mega/sysclk.h **** 		}
 247:../../../platform/common/services/clock/mega/sysclk.h **** 
 248:../../../platform/common/services/clock/mega/sysclk.h **** 	case SYSCLK_PSDIV_32:
 249:../../../platform/common/services/clock/mega/sysclk.h **** 		if (SYSCLK_SOURCE == SYSCLK_SRC_RC16MHZ ||
 250:../../../platform/common/services/clock/mega/sysclk.h **** 				SYSCLK_SOURCE == SYSCLK_SRC_RC128KHZ) {
 251:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 64;
 252:../../../platform/common/services/clock/mega/sysclk.h **** 		} else {
 253:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 32;
 254:../../../platform/common/services/clock/mega/sysclk.h **** 		}
 255:../../../platform/common/services/clock/mega/sysclk.h **** 
 256:../../../platform/common/services/clock/mega/sysclk.h **** 	case SYSCLK_PSDIV_64:
 257:../../../platform/common/services/clock/mega/sysclk.h **** 		if (SYSCLK_SOURCE == SYSCLK_SRC_RC16MHZ ||
 258:../../../platform/common/services/clock/mega/sysclk.h **** 				SYSCLK_SOURCE == SYSCLK_SRC_RC128KHZ) {
 259:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 128;
 260:../../../platform/common/services/clock/mega/sysclk.h **** 		} else {
 261:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 64;
 262:../../../platform/common/services/clock/mega/sysclk.h **** 		}
 263:../../../platform/common/services/clock/mega/sysclk.h **** 
 264:../../../platform/common/services/clock/mega/sysclk.h **** 	case SYSCLK_PSDIV_128:
 265:../../../platform/common/services/clock/mega/sysclk.h **** 		if (SYSCLK_SOURCE == SYSCLK_SRC_RC16MHZ ||
 266:../../../platform/common/services/clock/mega/sysclk.h **** 				SYSCLK_SOURCE == SYSCLK_SRC_RC128KHZ) {
 267:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 256;
 268:../../../platform/common/services/clock/mega/sysclk.h **** 		} else {
 269:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 128;
 270:../../../platform/common/services/clock/mega/sysclk.h **** 		}
 271:../../../platform/common/services/clock/mega/sysclk.h **** 
 272:../../../platform/common/services/clock/mega/sysclk.h **** 	case SYSCLK_PSDIV_256:
 273:../../../platform/common/services/clock/mega/sysclk.h **** 		if (SYSCLK_SOURCE == SYSCLK_SRC_RC16MHZ ||
 274:../../../platform/common/services/clock/mega/sysclk.h **** 				SYSCLK_SOURCE == SYSCLK_SRC_RC128KHZ) {
 275:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 512;
 276:../../../platform/common/services/clock/mega/sysclk.h **** 		} else {
 277:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 256;
 278:../../../platform/common/services/clock/mega/sysclk.h **** 		}
 279:../../../platform/common/services/clock/mega/sysclk.h **** 
 280:../../../platform/common/services/clock/mega/sysclk.h **** 	default:
 281:../../../platform/common/services/clock/mega/sysclk.h **** 		/*Invalide case*/
 282:../../../platform/common/services/clock/mega/sysclk.h **** 		return 0;
 283:../../../platform/common/services/clock/mega/sysclk.h **** 	}
 284:../../../platform/common/services/clock/mega/sysclk.h **** }
  80               		.loc 1 284 0
  81 002a BC01      		movw r22,r24
  82 002c CD01      		movw r24,r26
  83               	/* epilogue start */
  84 002e DF91      		pop r29
  85 0030 CF91      		pop r28
  86 0032 0895      		ret
  87               		.cfi_endproc
  88               	.LFE68:
  90               		.section	.progmem.data.baudctrl_1mhz,"a",@progbits
  93               	baudctrl_1mhz:
  94 0000 3300      		.word	51
  95 0002 1900      		.word	25
  96 0004 0C00      		.word	12
  97 0006 0600      		.word	6
  98 0008 0300      		.word	3
  99 000a 0200      		.word	2
 100 000c 0100      		.word	1
 101 000e FF00      		.word	255
 102               		.section	.progmem.data.baudctrl_8mhz,"a",@progbits
 105               	baudctrl_8mhz:
 106 0000 A001      		.word	416
 107 0002 CF00      		.word	207
 108 0004 6700      		.word	103
 109 0006 3300      		.word	51
 110 0008 1900      		.word	25
 111 000a 0C00      		.word	12
 112 000c 0700      		.word	7
 113 000e 0800      		.word	8
 114               		.section	.progmem.data.baudctrl_16mhz,"a",@progbits
 117               	baudctrl_16mhz:
 118 0000 4003      		.word	832
 119 0002 A001      		.word	416
 120 0004 CF00      		.word	207
 121 0006 6700      		.word	103
 122 0008 3300      		.word	51
 123 000a 1900      		.word	25
 124 000c 1000      		.word	16
 125 000e 1000      		.word	16
 126               		.text
 128               	usart_double_baud_enable:
 129               	.LFB101:
 130               		.file 2 "../../../platform/mega_rf/drivers/usart/usart_megarf.h"
   1:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
   2:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \file
   3:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
   4:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief USART driver for AVR MEGARF.
   5:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
   6:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * This file contains basic functions for the AVR MEGA USART, with support for
   7:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * all modes, settings and clock speeds.
   8:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
   9:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * Copyright (c) 2013-2015 Atmel Corporation. All rights reserved.
  10:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
  11:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \asf_license_start
  12:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
  13:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \page License
  14:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
  15:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * Redistribution and use in source and binary forms, with or without
  16:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * modification, are permitted provided that the following conditions are met:
  17:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
  18:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * 1. Redistributions of source code must retain the above copyright notice,
  19:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *    this list of conditions and the following disclaimer.
  20:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
  21:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * 2. Redistributions in binary form must reproduce the above copyright notice,
  22:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *    this list of conditions and the following disclaimer in the documentation
  23:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *    and/or other materials provided with the distribution.
  24:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
  25:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * 3. The name of Atmel may not be used to endorse or promote products derived
  26:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *    from this software without specific prior written permission.
  27:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
  28:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * 4. This software may only be redistributed and used in connection with an
  29:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *    Atmel microcontroller product.
  30:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
  31:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR IMPLIED
  32:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
  33:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
  34:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR
  35:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  36:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
  37:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  38:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
  39:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  40:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  41:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * POSSIBILITY OF SUCH DAMAGE.
  42:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
  43:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \asf_license_stop
  44:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
  45:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
  46:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #ifndef _USART_MEGARF_H_
  47:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define _USART_MEGARF_H_
  48:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
  49:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #ifdef __cplusplus
  50:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** extern "C" {
  51:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #endif
  52:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
  53:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #include "compiler.h"
  54:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #include "status_codes.h"
  55:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
  56:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
  57:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \defgroup megarf_usart_group USART module (USART)
  58:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
  59:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * See \ref megarf_usart_quickstart.
  60:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
  61:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * This is a driver for configuring, enabling, disabling and use of the on-chip
  62:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * USART.
  63:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
  64:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \section dependencies Dependencies
  65:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
  66:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * The USART module depends on the following modules:
  67:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *  - \ref sysclk_group for peripheral clock control.
  68:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *  - \ref port_driver_group for peripheral io port control.
  69:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
  70:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * @{
  71:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
  72:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
  73:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* ! Offset in lookup table for baudrate 1200 */
  74:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_BAUD_1200      0x00
  75:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* ! Offset in lookup table for baudrate 2400 */
  76:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_BAUD_2400      0x01
  77:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* ! Offset in lookup table for baudrate 4800 */
  78:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_BAUD_4800      0x02
  79:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* ! Offset in lookup table for baudrate 9600 */
  80:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_BAUD_9600      0x03
  81:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* ! Offset in lookup table for baudrate 19200 */
  82:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_BAUD_19200     0x04
  83:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* ! Offset in lookup table for baudrate 38400 */
  84:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_BAUD_38400     0x05
  85:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* ! Offset in lookup table for baudrate 57600 */
  86:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_BAUD_57600     0x06
  87:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* ! Offset in lookup table for baudrate 115200 */
  88:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_BAUD_115200    0x07
  89:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* ! Baudrate not in lookup table */
  90:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_BAUD_UNDEFINED 0xFF
  91:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
  92:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** typedef volatile uint8_t register8_t;
  93:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** typedef volatile uint16_t register16_t;
  94:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* Universal Synchronous/Asynchronous Receiver/Transmitter */
  95:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** typedef struct USART_struct {
  96:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	register8_t UCSRnA;  /* Control Register A */
  97:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	register8_t UCSRnB;  /* Control Register B */
  98:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	register8_t UCSRnC;  /* Control Register C */
  99:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	register8_t reserved;
 100:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	register16_t UBRR;  /* Baud Rate Register Value */
 101:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	register8_t UDR;  /* I/O Data Register */
 102:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** } USART_t;
 103:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 104:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USARTA0    (*(USART_t *)0xC0)   /* Universal Asynchronous
 105:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	                                 * Receiver-Transmitter A0 */
 106:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USARTA1    (*(USART_t *)0XC8)   /* Universal Asynchronous
 107:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	                                 * Receiver-Transmitter A1 */
 108:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 109:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* USART.UCSRxA  bit masks and bit positions */
 110:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_RXC_bm  0x80 /* RX complete bit mask.*/
 111:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_RXC_bp  7 /* RX complete bit position.*/
 112:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 113:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_TXC_bm  0x40 /* TX complete bit mask.*/
 114:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_TXC_bp  6 /* TX complete bit position.*/
 115:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 116:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_DRE_bm  0x20 /* DATA Register Empty Bit mask.*/
 117:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_DRE_bp  5 /*  DATA Register Empty bit position.*/
 118:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 119:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_FE_bm   0x10 /* Frame Error bit mask.*/
 120:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_FE_bp   4 /*Frame error bit position.*/
 121:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 122:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_DOR_bm  0x08 /* Data Over Run bit mask.*/
 123:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_DOR_bp  3 /* Data Over Run bit position.*/
 124:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 125:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_UPE_bm  0x04 /* Parity error bit mask.*/
 126:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_UPE_bp  2 /* Parity error bit position.*/
 127:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 128:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_U2X_bm  0x02 /* Double TX speed bit mask.*/
 129:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_U2X_bp  1 /* Double TX speed bit position.*/
 130:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 131:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_MPCM_bm  0x01 /* Multi Processor bit mask.*/
 132:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_MPMC_bp  0 /* Multi processor bit position.*/
 133:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 134:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* USART.UCSRxB  bit masks and bit positions */
 135:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_RXCIE_bm  0x80 /* RX complete interrupt Enable bit mask.*/
 136:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_RXCIE_bp  7 /* RX complete interrupt Enable bit position.*/
 137:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 138:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_TXCIE_bm  0x40 /* TX complete interrupt Enable bit mask.*/
 139:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_TXCIE_bp  6 /* TX complete interrupt Enable bit position.*/
 140:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 141:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_DRIE_bm  0x20 /* Data register empty interrupt Enable bit mask.*/
 142:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_DRIE_bp  5 /* Data register empty interrupt Enable bit position.*/
 143:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 144:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_RXEN_bm  0x10  /* Receiver Enable bit mask. */
 145:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_RXEN_bp  4  /* Receiver Enable bit position. */
 146:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 147:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_TXEN_bm  0x08  /* Transmitter Enable bit mask. */
 148:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_TXEN_bp  3  /* Transmitter Enable bit position. */
 149:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 150:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_CHSIZE2_bm  0x04  /* Character Size bit mask. */
 151:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_CHSIZE2_bp  2 /* Character Size bit position. */
 152:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 153:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_RXB8_bm  0x02  /* Transmit bit 8 bit mask. */
 154:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_RXB8_bp  1  /* Transmit bit 8 bit position. */
 155:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 156:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_TXB8_bm  0x01  /* Transmit bit 8 bit mask. */
 157:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_TXB8_bp  0  /* Transmit bit 8 bit position. */
 158:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 159:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* USART.UCSRxC  bit masks and bit positions */
 160:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_UMSEL01_gm  0xC0 /* USART Mode Select 01 grp mask.*/
 161:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_UMSEL01_gp  6 /* USART Mode Select 01 grp position.*/
 162:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 163:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_UMSEL01_bm  0x80 /* USART Mode Select 01 bit mask.*/
 164:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_UMSEL01_bp  7 /* USART Mode Select 01 bit position.*/
 165:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 166:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_UMSEL00_bm  0x40 /* USART Mode Select 00 bit mask.*/
 167:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_UMSEL00_bp  6 /* USART Mode Select 00 bit position.*/
 168:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 169:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_PMODE_gm  0x30 /* USART Parity Mode Select grp mask.*/
 170:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_PMODE_gp  4 /* USART Parity Mode Select grp position.*/
 171:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 172:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_PMODE01_bm  0x20 /* USART Parity Mode Select 01 bit mask.*/
 173:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_PMODE01_bp  5 /* USART Parity Mode Select 01 bit position.*/
 174:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 175:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_PMODE00_bm  0x10 /* USART Parity Mode Select 00 bit mask.*/
 176:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_PMODE00_bp  4 /* USART Parity Mode Select 00 bit position.*/
 177:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 178:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_STOPB_bm  0x08 /* USART stop bit mask.*/
 179:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_STOPB_bp  3 /* USART stop bit Position.*/
 180:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 181:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_CHSIZE01C_gm  0x06  /* Character Size 10 bit 1 mask. */
 182:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_CHSIZE01C_gp  1 /* Character Size 10 bit position. */
 183:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 184:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_CHSIZE01_bm  0x04  /* Character Size 10 bit 1 mask. */
 185:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_CHSIZE01_bp  2 /* Character Size 10 bit position. */
 186:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 187:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_CHSIZE00_bm  0x02  /* Character Size 00 bit 1 mask. */
 188:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_CHSIZE00_bp  1 /* Character Size bit 00 position. */
 189:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 190:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_UCPOL_bm  0x01  /* Sync mode Pol bit 1 mask. */
 191:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_UCPOL_bp  0 /*Sync mode Pol bit 0 position */
 192:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 193:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_UCPHA_bm 0x02 /* Clock Phase bit mask. */
 194:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_UCPHA_bp 1 /* Clock Phase bit position. */
 195:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 196:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_DORD_bm 0x04 /* Data order bit mask. */
 197:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_DORD_bp 2 /* Data order bit position. */
 198:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 199:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* Character Size */
 200:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** typedef enum USART_CHSIZE_enum {
 201:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	USART_CHSIZE_5BIT_gc = (0x00),  /* Character size: 5 bit */
 202:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	USART_CHSIZE_6BIT_gc = (0x01),  /* Character size: 6 bit */
 203:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	USART_CHSIZE_7BIT_gc = (0x02),  /* Character size: 7 bit */
 204:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	USART_CHSIZE_8BIT_gc = (0x03),  /* Character size: 8 bit */
 205:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	USART_CHSIZE_9BIT_gc = (0x07),  /* Character size: 9 bit */
 206:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** } USART_CHSIZE_t;
 207:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 208:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* Communication Mode */
 209:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** typedef enum USART_CMODE_enum {
 210:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	USART_CMODE_ASYNCHRONOUS_gc = (0x00 << USART_UMSEL01_gp),  /*
 211:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	                                                            *
 212:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	                                                            *
 213:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	                                                            *Asynchronous
 214:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	                                                            * Mode */
 215:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	USART_CMODE_SYNCHRONOUS_gc = (0x01 << USART_UMSEL01_gp),  /* Synchronous
 216:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	                                                           * Mode */
 217:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	USART_CMODE_IRDA_gc = (0x02 << USART_UMSEL01_gp),  /* IrDA Mode */
 218:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	USART_CMODE_MSPI_gc = (0x03 << USART_UMSEL01_gp),  /* Master SPI Mode */
 219:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** } USART_CMODE_t;
 220:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 221:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* Parity Mode */
 222:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** typedef enum USART_PMODE_enum {
 223:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	USART_PMODE_DISABLED_gc = (0x00 << USART_PMODE_gp),  /* No Parity */
 224:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	USART_PMODE_EVEN_gc = (0x02 << USART_PMODE_gp),  /* Even Parity */
 225:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	USART_PMODE_ODD_gc = (0x03 << USART_PMODE_gp),  /* Odd Parity */
 226:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** } USART_PMODE_t;
 227:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 228:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* ! Lookup table containing baudctrl values for CPU frequency 1 Mhz */
 229:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static PROGMEM_DECLARE(uint16_t, baudctrl_1mhz[]) = {
 230:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0033, /* Baud: 1200 */
 231:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0019, /* Baud: 2400 */
 232:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x000C, /* Baud: 4800 */
 233:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0006, /* Baud: 9600 */
 234:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0003, /* Baud: 19200 */
 235:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0002, /* Baud: 38400 */
 236:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0001, /* Baud: 57600 */
 237:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	USART_BAUD_UNDEFINED, /* Baud: 115200 */
 238:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** };
 239:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 240:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* ! Lookup table containing baudctrl values for CPU frequency 8 Mhz */
 241:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static PROGMEM_DECLARE(uint16_t, baudctrl_8mhz[]) = {
 242:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x01A0, /* Baud: 1200 */
 243:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x00CF, /* Baud: 2400 */
 244:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0067, /* Baud: 4800 */
 245:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0033, /* Baud: 9600 */
 246:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0019, /* Baud: 19200 */
 247:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x000C, /* Baud: 38400 */
 248:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0007, /* Baud: 57600 */
 249:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0008, /* Baud: 115200 */
 250:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** };
 251:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 252:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* ! Lookup table containing baudctrl values for CPU frequency 16 Mhz */
 253:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static PROGMEM_DECLARE(uint16_t, baudctrl_16mhz[]) = {
 254:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0340, /* Baud: 1200 */
 255:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x01A0, /* Baud: 2400 */
 256:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x00CF, /* Baud: 4800 */
 257:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0067, /* Baud: 9600 */
 258:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0033, /* Baud: 19200 */
 259:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0019, /* Baud: 38400 */
 260:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0010, /* Baud: 57600 */
 261:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0010, /* Baud: 115200 */
 262:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** };
 263:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 264:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 265:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* ! Input parameters when initializing RS232 and similar modes. */
 266:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** typedef struct usart_rs232_options {
 267:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	/* ! Set baud rate of the USART (unused in slave modes). */
 268:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	uint32_t baudrate;
 269:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 270:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	/* ! Number of bits to transmit as a character (5 to 9). */
 271:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	USART_CHSIZE_t charlength;
 272:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 273:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	/* ! Parity type: USART_PMODE_DISABLED_gc, USART_PMODE_EVEN_gc, */
 274:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	/* ! USART_PMODE_ODD_gc. */
 275:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	USART_PMODE_t paritytype;
 276:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 277:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	/* ! Number of stop bits between two characters: */
 278:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	/* ! true: 2 stop bits */
 279:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	/* ! false: 1 stop bit */
 280:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	bool stopbits;
 281:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** } usart_rs232_options_t;
 282:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 283:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* ! Input parameters when initializing SPI master mode. */
 284:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** typedef struct usart_spi_options {
 285:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	/* ! Set baud rate of the USART in SPI mode. */
 286:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	uint32_t baudrate;
 287:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 288:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	/* ! SPI transmission mode. */
 289:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	uint8_t spimode;
 290:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 291:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	uint8_t data_order;
 292:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** } usart_spi_options_t;
 293:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 294:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 295:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 296:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Enable USART receiver.
 297:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 298:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart Pointer to the USART module
 299:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 300:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline void usart_rx_enable(USART_t *usart)
 301:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 302:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	(usart)->UCSRnB |= USART_RXEN_bm;
 303:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 304:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 305:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 306:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Disable USART receiver.
 307:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 308:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart Pointer to the USART module.
 309:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 310:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline void usart_rx_disable(USART_t *usart)
 311:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 312:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	(usart)->UCSRnB &= ~USART_RXEN_bm;
 313:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 314:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 315:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 316:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief  Configure the USART frame format.
 317:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 318:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *  Sets the frame format, Frame Size, parity mode and number of stop bits.
 319:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 320:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *  \param usart Pointer to the USART module
 321:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *  \param charSize The character size. Use USART_CHSIZE_t type.
 322:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *  \param parityMode The parity Mode. Use USART_PMODE_t type.
 323:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *  \param twoStopBits Enable two stop bit mode. Use bool type.
 324:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 325:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline void usart_format_set(USART_t *usart, USART_CHSIZE_t charSize,
 326:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 		USART_PMODE_t parityMode, bool twoStopBits)
 327:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 328:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	(usart)->UCSRnC
 329:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 		= ((usart)->UCSRnC &
 330:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 			(~USART_CHSIZE01C_gm)) | ((charSize & 0x03)
 331:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 			<< USART_CHSIZE01C_gp);
 332:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	(usart)->UCSRnB
 333:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 		= ((usart)->UCSRnB &
 334:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 			(~USART_CHSIZE2_bm)) | ((charSize & 0x04)
 335:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 			<< USART_CHSIZE2_bp);
 336:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 337:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	(usart)->UCSRnC = ((usart)->UCSRnC & (~USART_PMODE_gm)) | parityMode;
 338:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 339:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	(usart)->UCSRnC = ((usart)->UCSRnC & (~USART_STOPB_bm)) | (twoStopBits
 340:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 			<< USART_STOPB_bp);
 341:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 342:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 343:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 344:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Enable USART transmitter.
 345:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 346:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart Pointer to the USART module.
 347:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 348:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline void usart_tx_enable(USART_t *usart)
 349:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 350:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	(usart)->UCSRnB |= USART_TXEN_bm;
 351:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 352:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 353:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 354:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Disable USART transmitter.
 355:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 356:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart Pointer to the USART module.
 357:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 358:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline void usart_tx_disable(USART_t *usart)
 359:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 360:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	(usart)->UCSRnB &= ~USART_TXEN_bm;
 361:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 362:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 363:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 364:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Enable USART transmit complete interrupt.
 365:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 366:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart Pointer to the USART module.
 367:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 368:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline void usart_tx_complete_interrupt_enable(USART_t *usart)
 369:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 370:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	(usart)->UCSRnB |= USART_TXC_bm;
 371:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 372:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 373:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 374:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Enable USART receive complete interrupt.
 375:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 376:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart Pointer to the USART module.
 377:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 378:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline void usart_rx_complete_interrupt_enable(USART_t *usart)
 379:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 380:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	(usart)->UCSRnB |= USART_RXC_bm;
 381:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 382:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 383:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 384:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Enable USART data register empty interrupt.
 385:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 386:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart Pointer to the USART module.
 387:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 388:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline void usart_data_empty_interrupt_enable(USART_t *usart)
 389:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 390:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	(usart)->UCSRnB |= USART_DRIE_bm;
 391:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 392:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 393:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 394:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Disable USART transmit complete interrupt.
 395:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 396:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart Pointer to the USART module.
 397:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 398:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline void usart_tx_complete_interrupt_disable(USART_t *usart)
 399:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 400:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	(usart)->UCSRnB &= ~USART_TXC_bm;
 401:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 402:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 403:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 404:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Disable USART receive complete interrupt.
 405:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 406:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart Pointer to the USART module.
 407:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 408:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline void usart_rx_complete_interrupt_disable(USART_t *usart)
 409:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 410:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	(usart)->UCSRnB &= ~USART_RXC_bm;
 411:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 412:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 413:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 414:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Disable USART data register empty interrupt.
 415:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 416:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart Pointer to the USART module.
 417:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 418:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline void usart_data_empty_interrupt_disable(USART_t *usart)
 419:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 420:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	(usart)->UCSRnB &= ~USART_DRIE_bm;
 421:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 422:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 423:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 424:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Set the mode the USART run in.
 425:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 426:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * Set the mode the USART run in. The default mode is asynchronous mode.
 427:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 428:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart Pointer to the USART module register section.
 429:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usartmode Selects the USART mode. Use USART_CMODE_t type.
 430:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 431:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * USART modes:
 432:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * - 0x0        : Asynchronous mode.
 433:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * - 0x1        : Synchronous mode.
 434:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * - 0x2        : IrDA mode.
 435:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * - 0x3        : Master SPI mode.
 436:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 437:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline void usart_set_mode(USART_t *usart, USART_CMODE_t usartmode)
 438:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 439:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	(usart)->UCSRnC = ((usart)->UCSRnC & (~USART_UMSEL01_gm)) | usartmode;
 440:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 441:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 442:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 443:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Check if data register empty flag is set.
 444:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 445:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart The USART module.
 446:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 447:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline bool usart_data_register_is_empty(USART_t *usart)
 448:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 449:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	return (usart)->UCSRnA & USART_DRE_bm;
 450:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 451:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 452:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 453:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Checks if the RX complete interrupt flag is set.
 454:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 455:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * Checks if the RX complete interrupt flag is set.
 456:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 457:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart The USART module.
 458:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 459:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline bool usart_rx_is_complete(USART_t *usart)
 460:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 461:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	return (usart)->UCSRnA & USART_RXC_bm;
 462:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 463:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 464:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 465:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Checks if the TX complete interrupt flag is set.
 466:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 467:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * Checks if the TX complete interrupt flag is set.
 468:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 469:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart The USART module.
 470:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 471:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline bool usart_tx_is_complete(USART_t *usart)
 472:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 473:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	return (usart)->UCSRnA & USART_TXC_bm;
 474:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 475:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 476:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 477:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Clear TX complete interrupt flag.
 478:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * TX flag is clear after complete transmission, automatically.
 479:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart The USART module.
 480:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 481:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline void usart_clear_tx_complete(USART_t *usart)
 482:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 483:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****          usart->UCSRnA |=  USART_TXC_bm;
 484:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 485:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 486:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 487:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Write a data to the USART data register.
 488:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 489:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart The USART module.
 490:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param txdata The data to be transmitted.
 491:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 492:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline void usart_put(USART_t *usart, uint8_t txdata)
 493:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 494:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	(usart)->UDR = txdata;
 495:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 496:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 497:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 498:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief  Read a data to the USART data register.
 499:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 500:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart The USART module.
 501:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 502:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \return The received data
 503:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 504:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline uint8_t usart_get(USART_t *usart)
 505:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 506:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	return (usart)->UDR;
 507:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 508:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 509:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 510:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Double the USART transmission speed.
 511:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 512:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart The USART module.
 513:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 514:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline void usart_double_baud_enable(USART_t *usart)
 515:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 131               		.loc 2 515 0
 132               		.cfi_startproc
 133 0034 CF93      		push r28
 134               	.LCFI6:
 135               		.cfi_def_cfa_offset 3
 136               		.cfi_offset 28, -2
 137 0036 DF93      		push r29
 138               	.LCFI7:
 139               		.cfi_def_cfa_offset 4
 140               		.cfi_offset 29, -3
 141 0038 00D0      		rcall .
 142               	.LCFI8:
 143               		.cfi_def_cfa_offset 6
 144 003a CDB7      		in r28,__SP_L__
 145 003c DEB7      		in r29,__SP_H__
 146               	.LCFI9:
 147               		.cfi_def_cfa_register 28
 148               	/* prologue: function */
 149               	/* frame size = 2 */
 150               	/* stack size = 4 */
 151               	.L__stack_usage = 4
 152 003e 9A83      		std Y+2,r25
 153 0040 8983      		std Y+1,r24
 516:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	usart->UCSRnA |=  USART_U2X_bm;
 154               		.loc 2 516 0
 155 0042 8981      		ldd r24,Y+1
 156 0044 9A81      		ldd r25,Y+2
 157 0046 FC01      		movw r30,r24
 158 0048 8081      		ld r24,Z
 159 004a 282F      		mov r18,r24
 160 004c 2260      		ori r18,lo8(2)
 161 004e 8981      		ldd r24,Y+1
 162 0050 9A81      		ldd r25,Y+2
 163 0052 FC01      		movw r30,r24
 164 0054 2083      		st Z,r18
 517:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 165               		.loc 2 517 0
 166 0056 0000      		nop
 167               	/* epilogue start */
 168 0058 0F90      		pop __tmp_reg__
 169 005a 0F90      		pop __tmp_reg__
 170 005c DF91      		pop r29
 171 005e CF91      		pop r28
 172 0060 0895      		ret
 173               		.cfi_endproc
 174               	.LFE101:
 177               	usart_serial_init:
 178               	.LFB104:
 179               		.file 3 "../../../platform/common/services/serial/megarf_usart/usart_serial.h"
   1:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** /**
   2:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * \file
   3:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
   4:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * \brief This file defines a useful set of functions for the Serial interface on 
   5:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * AVR MEGARF devices.
   6:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
   7:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * Copyright (c) 2013 Atmel Corporation. All rights reserved.
   8:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
   9:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * \asf_license_start
  10:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
  11:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * \page License
  12:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
  13:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * Redistribution and use in source and binary forms, with or without
  14:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * modification, are permitted provided that the following conditions are met:
  15:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
  16:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * 1. Redistributions of source code must retain the above copyright notice,
  17:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *    this list of conditions and the following disclaimer.
  18:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
  19:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * 2. Redistributions in binary form must reproduce the above copyright notice,
  20:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *    this list of conditions and the following disclaimer in the documentation
  21:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *    and/or other materials provided with the distribution.
  22:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
  23:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * 3. The name of Atmel may not be used to endorse or promote products derived
  24:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *    from this software without specific prior written permission.
  25:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
  26:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * 4. This software may only be redistributed and used in connection with an
  27:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *    Atmel microcontroller product.
  28:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
  29:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR IMPLIED
  30:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
  31:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
  32:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR
  33:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  34:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
  35:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  36:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
  37:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  38:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  39:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * POSSIBILITY OF SUCH DAMAGE.
  40:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
  41:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * \asf_license_stop
  42:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
  43:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  */
  44:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** #ifndef _USART_SERIAL_H_
  45:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** #define _USART_SERIAL_H_
  46:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 
  47:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** #ifdef __cplusplus
  48:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** extern "C" {
  49:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** #endif
  50:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 
  51:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** #include "compiler.h"
  52:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** #include "sysclk.h"
  53:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** #include "status_codes.h"
  54:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** #include "usart_megarf.h"
  55:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 
  56:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** /*! \name Serial Management Configuration
  57:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  */
  58:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** /* ! @{ */
  59:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** #include "conf_usart_serial.h"
  60:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** /* ! @} */
  61:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 
  62:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** typedef usart_rs232_options_t usart_serial_options_t;
  63:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 
  64:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** typedef USART_t *usart_if;
  65:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 
  66:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** /*! \brief Initializes the Usart in master mode.
  67:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
  68:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * \param usart       Base address of the USART instance.
  69:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * \param options     Options needed to set up RS232 communication (see \ref
  70:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * usart_serial_options_t).
  71:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
  72:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * \retval true if the initialization was successful
  73:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * \retval false if initialization failed (error in baud rate calculation)
  74:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  */
  75:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** static inline bool usart_serial_init(usart_if usart, const
  76:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 		usart_serial_options_t *options)
  77:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** {
 180               		.loc 3 77 0
 181               		.cfi_startproc
 182 0062 CF93      		push r28
 183               	.LCFI10:
 184               		.cfi_def_cfa_offset 3
 185               		.cfi_offset 28, -2
 186 0064 DF93      		push r29
 187               	.LCFI11:
 188               		.cfi_def_cfa_offset 4
 189               		.cfi_offset 29, -3
 190 0066 CDB7      		in r28,__SP_L__
 191 0068 DEB7      		in r29,__SP_H__
 192               	.LCFI12:
 193               		.cfi_def_cfa_register 28
 194 006a 2B97      		sbiw r28,11
 195               	.LCFI13:
 196               		.cfi_def_cfa_offset 15
 197 006c 0FB6      		in __tmp_reg__,__SREG__
 198 006e F894      		cli
 199 0070 DEBF      		out __SP_H__,r29
 200 0072 0FBE      		out __SREG__,__tmp_reg__
 201 0074 CDBF      		out __SP_L__,r28
 202               	/* prologue: function */
 203               	/* frame size = 11 */
 204               	/* stack size = 13 */
 205               	.L__stack_usage = 13
 206 0076 9987      		std Y+9,r25
 207 0078 8887      		std Y+8,r24
 208 007a 7B87      		std Y+11,r23
 209 007c 6A87      		std Y+10,r22
  78:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 	/* USART options. */
  79:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 	usart_rs232_options_t usart_rs232_options;
  80:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 	usart_rs232_options.charlength   = options->charlength;
 210               		.loc 3 80 0
 211 007e 8A85      		ldd r24,Y+10
 212 0080 9B85      		ldd r25,Y+11
 213 0082 FC01      		movw r30,r24
 214 0084 8481      		ldd r24,Z+4
 215 0086 8D83      		std Y+5,r24
  81:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 	usart_rs232_options.paritytype   = options->paritytype;
 216               		.loc 3 81 0
 217 0088 8A85      		ldd r24,Y+10
 218 008a 9B85      		ldd r25,Y+11
 219 008c FC01      		movw r30,r24
 220 008e 8581      		ldd r24,Z+5
 221 0090 8E83      		std Y+6,r24
  82:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 	usart_rs232_options.stopbits     = options->stopbits;
 222               		.loc 3 82 0
 223 0092 8A85      		ldd r24,Y+10
 224 0094 9B85      		ldd r25,Y+11
 225 0096 FC01      		movw r30,r24
 226 0098 8681      		ldd r24,Z+6
 227 009a 8F83      		std Y+7,r24
  83:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 	usart_rs232_options.baudrate     = options->baudrate;
 228               		.loc 3 83 0
 229 009c 8A85      		ldd r24,Y+10
 230 009e 9B85      		ldd r25,Y+11
 231 00a0 FC01      		movw r30,r24
 232 00a2 8081      		ld r24,Z
 233 00a4 9181      		ldd r25,Z+1
 234 00a6 A281      		ldd r26,Z+2
 235 00a8 B381      		ldd r27,Z+3
 236 00aa 8983      		std Y+1,r24
 237 00ac 9A83      		std Y+2,r25
 238 00ae AB83      		std Y+3,r26
 239 00b0 BC83      		std Y+4,r27
  84:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 
  85:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 	if (usart_init_rs232(usart, &usart_rs232_options)) {
 240               		.loc 3 85 0
 241 00b2 8885      		ldd r24,Y+8
 242 00b4 9985      		ldd r25,Y+9
 243 00b6 9E01      		movw r18,r28
 244 00b8 2F5F      		subi r18,-1
 245 00ba 3F4F      		sbci r19,-1
 246 00bc B901      		movw r22,r18
 247 00be 0E94 0000 		call usart_init_rs232
 248 00c2 8823      		tst r24
 249 00c4 01F0      		breq .L7
  86:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 		return true;
 250               		.loc 3 86 0
 251 00c6 81E0      		ldi r24,lo8(1)
 252 00c8 00C0      		rjmp .L9
 253               	.L7:
  87:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 	} else {
  88:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 		return false;
 254               		.loc 3 88 0
 255 00ca 80E0      		ldi r24,0
 256               	.L9:
 257               	/* epilogue start */
  89:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 	}
  90:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** }
 258               		.loc 3 90 0 discriminator 1
 259 00cc 2B96      		adiw r28,11
 260 00ce 0FB6      		in __tmp_reg__,__SREG__
 261 00d0 F894      		cli
 262 00d2 DEBF      		out __SP_H__,r29
 263 00d4 0FBE      		out __SREG__,__tmp_reg__
 264 00d6 CDBF      		out __SP_L__,r28
 265 00d8 DF91      		pop r29
 266 00da CF91      		pop r28
 267 00dc 0895      		ret
 268               		.cfi_endproc
 269               	.LFE104:
 272               	usart_serial_putchar:
 273               	.LFB105:
  91:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 
  92:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** /*! \brief Sends a character with the USART.
  93:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
  94:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * \param usart   Base address of the USART instance.
  95:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * \param c       Character to write.
  96:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
  97:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * \return Status code
  98:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  */
  99:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** static inline status_code_t usart_serial_putchar(usart_if usart, uint8_t c)
 100:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** {
 274               		.loc 3 100 0
 275               		.cfi_startproc
 276 00de CF93      		push r28
 277               	.LCFI14:
 278               		.cfi_def_cfa_offset 3
 279               		.cfi_offset 28, -2
 280 00e0 DF93      		push r29
 281               	.LCFI15:
 282               		.cfi_def_cfa_offset 4
 283               		.cfi_offset 29, -3
 284 00e2 00D0      		rcall .
 285 00e4 1F92      		push __zero_reg__
 286               	.LCFI16:
 287               		.cfi_def_cfa_offset 7
 288 00e6 CDB7      		in r28,__SP_L__
 289 00e8 DEB7      		in r29,__SP_H__
 290               	.LCFI17:
 291               		.cfi_def_cfa_register 28
 292               	/* prologue: function */
 293               	/* frame size = 3 */
 294               	/* stack size = 5 */
 295               	.L__stack_usage = 5
 296 00ea 9A83      		std Y+2,r25
 297 00ec 8983      		std Y+1,r24
 298 00ee 6B83      		std Y+3,r22
 101:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 	return usart_putchar(usart, c);
 299               		.loc 3 101 0
 300 00f0 8981      		ldd r24,Y+1
 301 00f2 9A81      		ldd r25,Y+2
 302 00f4 6B81      		ldd r22,Y+3
 303 00f6 0E94 0000 		call usart_putchar
 304               	/* epilogue start */
 102:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** }
 305               		.loc 3 102 0
 306 00fa 0F90      		pop __tmp_reg__
 307 00fc 0F90      		pop __tmp_reg__
 308 00fe 0F90      		pop __tmp_reg__
 309 0100 DF91      		pop r29
 310 0102 CF91      		pop r28
 311 0104 0895      		ret
 312               		.cfi_endproc
 313               	.LFE105:
 316               	usart_serial_getchar:
 317               	.LFB106:
 103:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 
 104:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** /*! \brief Waits until a character is received, and returns it.
 105:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
 106:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * \param usart   Base address of the USART instance.
 107:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * \param data   Data to read
 108:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
 109:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  */
 110:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** static inline void usart_serial_getchar(usart_if usart, uint8_t *data)
 111:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** {
 318               		.loc 3 111 0
 319               		.cfi_startproc
 320 0106 CF93      		push r28
 321               	.LCFI18:
 322               		.cfi_def_cfa_offset 3
 323               		.cfi_offset 28, -2
 324 0108 DF93      		push r29
 325               	.LCFI19:
 326               		.cfi_def_cfa_offset 4
 327               		.cfi_offset 29, -3
 328 010a 00D0      		rcall .
 329 010c 00D0      		rcall .
 330               	.LCFI20:
 331               		.cfi_def_cfa_offset 8
 332 010e CDB7      		in r28,__SP_L__
 333 0110 DEB7      		in r29,__SP_H__
 334               	.LCFI21:
 335               		.cfi_def_cfa_register 28
 336               	/* prologue: function */
 337               	/* frame size = 4 */
 338               	/* stack size = 6 */
 339               	.L__stack_usage = 6
 340 0112 9A83      		std Y+2,r25
 341 0114 8983      		std Y+1,r24
 342 0116 7C83      		std Y+4,r23
 343 0118 6B83      		std Y+3,r22
 112:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 	*data = usart_getchar(usart);
 344               		.loc 3 112 0
 345 011a 8981      		ldd r24,Y+1
 346 011c 9A81      		ldd r25,Y+2
 347 011e 0E94 0000 		call usart_getchar
 348 0122 282F      		mov r18,r24
 349 0124 8B81      		ldd r24,Y+3
 350 0126 9C81      		ldd r25,Y+4
 351 0128 FC01      		movw r30,r24
 352 012a 2083      		st Z,r18
 113:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** }
 353               		.loc 3 113 0
 354 012c 0000      		nop
 355               	/* epilogue start */
 356 012e 0F90      		pop __tmp_reg__
 357 0130 0F90      		pop __tmp_reg__
 358 0132 0F90      		pop __tmp_reg__
 359 0134 0F90      		pop __tmp_reg__
 360 0136 DF91      		pop r29
 361 0138 CF91      		pop r28
 362 013a 0895      		ret
 363               		.cfi_endproc
 364               	.LFE106:
 367               	stdio_serial_init:
 368               	.LFB107:
 369               		.file 4 "../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h"
   1:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** /**
   2:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
   3:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * \file
   4:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
   5:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * \brief Common Standard I/O Serial Management.
   6:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
   7:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * This file defines a useful set of functions for the Stdio Serial interface on AVR
   8:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * and SAM devices.
   9:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
  10:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * Copyright (c) 2009-2013 Atmel Corporation. All rights reserved.
  11:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
  12:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * \asf_license_start
  13:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
  14:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * \page License
  15:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
  16:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * Redistribution and use in source and binary forms, with or without
  17:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * modification, are permitted provided that the following conditions are met:
  18:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
  19:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * 1. Redistributions of source code must retain the above copyright notice,
  20:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *    this list of conditions and the following disclaimer.
  21:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
  22:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * 2. Redistributions in binary form must reproduce the above copyright notice,
  23:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *    this list of conditions and the following disclaimer in the documentation
  24:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *    and/or other materials provided with the distribution.
  25:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
  26:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * 3. The name of Atmel may not be used to endorse or promote products derived
  27:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *    from this software without specific prior written permission.
  28:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
  29:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * 4. This software may only be redistributed and used in connection with an
  30:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *    Atmel microcontroller product.
  31:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
  32:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR IMPLIED
  33:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
  34:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
  35:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR
  36:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  37:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
  38:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  39:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
  40:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  41:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  42:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * POSSIBILITY OF SUCH DAMAGE.
  43:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
  44:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * \asf_license_stop
  45:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
  46:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  ******************************************************************************/
  47:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 
  48:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 
  49:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** #ifndef _STDIO_SERIAL_H_
  50:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** #define _STDIO_SERIAL_H_
  51:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 
  52:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** /**
  53:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * \defgroup group_common_utils_stdio_stdio_serial Standard serial I/O (stdio)
  54:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * \ingroup group_common_utils_stdio
  55:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
  56:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * Common standard serial I/O management driver that
  57:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * implements a stdio serial interface on AVR and SAM devices.
  58:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
  59:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * \{
  60:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  */
  61:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 
  62:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** #include <stdio.h>
  63:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** #include "compiler.h"
  64:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** #ifndef SAMD20
  65:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** # include "sysclk.h"
  66:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** #endif
  67:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** #include "serial.h"
  68:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 
  69:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** #if (XMEGA || MEGA_RF) && defined(__GNUC__)
  70:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	extern int _write (char c, int *f);
  71:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	extern int _read (int *f);
  72:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** #endif
  73:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 
  74:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 
  75:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** //! Pointer to the base of the USART module instance to use for stdio.
  76:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** extern volatile void *volatile stdio_base;
  77:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** //! Pointer to the external low level write function.
  78:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** extern int (*ptr_put)(void volatile*, char);
  79:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 
  80:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** //! Pointer to the external low level read function.
  81:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** extern void (*ptr_get)(void volatile*, char*);
  82:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 
  83:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** /*! \brief Initializes the stdio in Serial Mode.
  84:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
  85:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * \param usart       Base address of the USART instance.
  86:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * \param opt         Options needed to set up RS232 communication (see \ref usart_options_t).
  87:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
  88:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  */
  89:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** static inline void stdio_serial_init(volatile void *usart, const usart_serial_options_t *opt)
  90:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** {
 370               		.loc 4 90 0
 371               		.cfi_startproc
 372 013c CF93      		push r28
 373               	.LCFI22:
 374               		.cfi_def_cfa_offset 3
 375               		.cfi_offset 28, -2
 376 013e DF93      		push r29
 377               	.LCFI23:
 378               		.cfi_def_cfa_offset 4
 379               		.cfi_offset 29, -3
 380 0140 00D0      		rcall .
 381 0142 00D0      		rcall .
 382               	.LCFI24:
 383               		.cfi_def_cfa_offset 8
 384 0144 CDB7      		in r28,__SP_L__
 385 0146 DEB7      		in r29,__SP_H__
 386               	.LCFI25:
 387               		.cfi_def_cfa_register 28
 388               	/* prologue: function */
 389               	/* frame size = 4 */
 390               	/* stack size = 6 */
 391               	.L__stack_usage = 6
 392 0148 9A83      		std Y+2,r25
 393 014a 8983      		std Y+1,r24
 394 014c 7C83      		std Y+4,r23
 395 014e 6B83      		std Y+3,r22
  91:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	stdio_base = (void *)usart;
 396               		.loc 4 91 0
 397 0150 8981      		ldd r24,Y+1
 398 0152 9A81      		ldd r25,Y+2
 399 0154 9093 0000 		sts stdio_base+1,r25
 400 0158 8093 0000 		sts stdio_base,r24
  92:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	ptr_put = (int (*)(void volatile*,char))&usart_serial_putchar;
 401               		.loc 4 92 0
 402 015c 80E0      		ldi r24,lo8(gs(usart_serial_putchar))
 403 015e 90E0      		ldi r25,hi8(gs(usart_serial_putchar))
 404 0160 9093 0000 		sts ptr_put+1,r25
 405 0164 8093 0000 		sts ptr_put,r24
  93:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	ptr_get = (void (*)(void volatile*,char*))&usart_serial_getchar;
 406               		.loc 4 93 0
 407 0168 80E0      		ldi r24,lo8(gs(usart_serial_getchar))
 408 016a 90E0      		ldi r25,hi8(gs(usart_serial_getchar))
 409 016c 9093 0000 		sts ptr_get+1,r25
 410 0170 8093 0000 		sts ptr_get,r24
  94:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** # if (XMEGA || MEGA_RF)
  95:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	usart_serial_init((USART_t *)usart,opt);
 411               		.loc 4 95 0
 412 0174 2B81      		ldd r18,Y+3
 413 0176 3C81      		ldd r19,Y+4
 414 0178 8981      		ldd r24,Y+1
 415 017a 9A81      		ldd r25,Y+2
 416 017c B901      		movw r22,r18
 417 017e 0E94 0000 		call usart_serial_init
  96:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** # elif UC3
  97:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	usart_serial_init(usart,(usart_serial_options_t *)opt);
  98:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** # elif SAM
  99:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	usart_serial_init((Usart *)usart,(usart_serial_options_t *)opt);
 100:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** # else
 101:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** #  error Unsupported chip type
 102:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** # endif
 103:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 
 104:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** # if defined(__GNUC__)
 105:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** #  if (XMEGA || MEGA_RF)
 106:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	// For AVR GCC libc print redirection uses fdevopen.
 107:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	fdevopen((int (*)(char, FILE*))(_write),(int (*)(FILE*))(_read));
 418               		.loc 4 107 0
 419 0182 60E0      		ldi r22,lo8(gs(_read))
 420 0184 70E0      		ldi r23,hi8(gs(_read))
 421 0186 80E0      		ldi r24,lo8(gs(_write))
 422 0188 90E0      		ldi r25,hi8(gs(_write))
 423 018a 0E94 0000 		call fdevopen
 108:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** #  endif
 109:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** #  if UC3 || SAM
 110:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	// For AVR32 and SAM GCC
 111:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	// Specify that stdout and stdin should not be buffered.
 112:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	setbuf(stdout, NULL);
 113:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	setbuf(stdin, NULL);
 114:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	// Note: Already the case in IAR's Normal DLIB default configuration
 115:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	// and AVR GCC library:
 116:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	// - printf() emits one character at a time.
 117:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	// - getchar() requests only 1 byte to exit.
 118:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** #  endif
 119:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** # endif
 120:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** }
 424               		.loc 4 120 0
 425 018e 0000      		nop
 426               	/* epilogue start */
 427 0190 0F90      		pop __tmp_reg__
 428 0192 0F90      		pop __tmp_reg__
 429 0194 0F90      		pop __tmp_reg__
 430 0196 0F90      		pop __tmp_reg__
 431 0198 DF91      		pop r29
 432 019a CF91      		pop r28
 433 019c 0895      		ret
 434               		.cfi_endproc
 435               	.LFE107:
 438               	macsc_enable_manual_bts:
 439               	.LFB121:
 440               		.file 5 "../../../platform/mega_rf/drivers/macsc/macsc_megarf.h"
   1:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
   2:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \file
   3:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
   4:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief AVR MEGARF MAC Symbol Counter Driver Definitions
   5:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
   6:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * Copyright (c) 2013 Atmel Corporation. All rights reserved.
   7:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
   8:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \asf_license_start
   9:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  10:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \page License
  11:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  12:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * Redistribution and use in source and binary forms, with or without
  13:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * modification, are permitted provided that the following conditions are met:
  14:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  15:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * 1. Redistributions of source code must retain the above copyright notice,
  16:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *    this list of conditions and the following disclaimer.
  17:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  18:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * 2. Redistributions in binary form must reproduce the above copyright notice,
  19:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *    this list of conditions and the following disclaimer in the documentation
  20:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *    and/or other materials provided with the distribution.
  21:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  22:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * 3. The name of Atmel may not be used to endorse or promote products derived
  23:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *    from this software without specific prior written permission.
  24:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  25:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * 4. This software may only be redistributed and used in connection with an
  26:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *    Atmel microcontroller product.
  27:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  28:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR IMPLIED
  29:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
  30:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
  31:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR
  32:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  33:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
  34:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  35:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
  36:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  37:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  38:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * POSSIBILITY OF SUCH DAMAGE.
  39:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  40:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \asf_license_stop
  41:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  42:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
  43:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** #ifndef MACSC_MEGARF_H
  44:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** #define MACSC_MEGARF_H
  45:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
  46:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** #include <compiler.h>
  47:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** #include <parts.h>
  48:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** #include "status_codes.h"
  49:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
  50:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** #ifdef __cplusplus
  51:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** extern "C" {
  52:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** #endif
  53:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
  54:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
  55:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \defgroup macsc_group MAC Symbol Counter Driver(MACSC)
  56:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  57:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * See \ref megarf_macsc_quickstart
  58:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  59:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * This is a driver for the AVR MEGARF MAC Symbol Counter Driver(MACSC).
  60:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * It provides functions for enabling, disabling and configuring the module.
  61:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  62:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \section dependencies Dependencies
  63:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * This driver depends on the following modules:
  64:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * - \ref interrupt_group for ISR definition and disabling interrupts during
  65:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * critical code sections.
  66:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * @{
  67:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
  68:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
  69:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
  70:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Interrupt event callback function type
  71:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  72:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * The interrupt handler can be configured to do a function callback,
  73:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * the callback function must match the macsc_callback_t type.
  74:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  75:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
  76:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** typedef void (*macsc_callback_t)(void);
  77:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
  78:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /* ! MAC symbol counter compare Channel index */
  79:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** enum macsc_cc_channel {
  80:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	/* ! Channel 1 */
  81:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	MACSC_CC1 = 1,
  82:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	/* ! Channel 2 */
  83:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	MACSC_CC2 = 2,
  84:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	/* ! Channel 3 */
  85:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	MACSC_CC3 = 3,
  86:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** };
  87:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
  88:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief MAC SC clock source select
  89:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  90:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * uses the SCCKSEL bit in SSCR register to select macsc clk src
  91:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  92:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * If the bit is one,the RTC clock from TOSC1 is selected, otherwise the symbol
  93:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * counter operates with the clock from XTAL1.
  94:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * During transceiver sleep modes the clock falls back to the RTC clock source,
  95:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * regardless of the selected clock. After wakeup, it switches back to the
  96:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * previosly
  97:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * selected clock source.
  98:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
  99:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 100:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** enum macsc_xtal {
 101:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	/* ! 16MHz as macsc clock */
 102:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	MACSC_16MHz = 0,
 103:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	MACSC_32KHz = 1,
 104:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** };
 105:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 106:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 107:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * @brief Reads the 32-bit timer register in the required order of bytes
 108:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 109:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * @param hh hh octet of 32-bit register
 110:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * @param hl hl octet of 32-bit register
 111:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * @param lh lh octet of 32-bit register
 112:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * @param ll ll octet of 32-bit register
 113:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 114:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * @returns uint32_t Value of timer register
 115:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 116:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** static inline uint32_t macsc_read32(volatile uint8_t *hh,
 117:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		volatile uint8_t *hl,
 118:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		volatile uint8_t *lh,
 119:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		volatile uint8_t *ll)
 120:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** {
 121:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	union {
 122:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		uint8_t a[4];
 123:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		uint32_t rv;
 124:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	}
 125:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	x;
 126:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 127:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	x.a[0] = *ll;
 128:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	x.a[1] = *lh;
 129:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	x.a[2] = *hl;
 130:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	x.a[3] = *hh;
 131:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 132:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	return x.rv;
 133:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** }
 134:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 135:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /* ! compare modes */
 136:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** #define MACSC_ABSOLUTE_CMP 0
 137:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** #define MACSC_RELATIVE_CMP 1
 138:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 139:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /** String concatenation by preprocessor used to create proper register names.
 140:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  **/
 141:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** #define CONCAT(a, b) a ## b
 142:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 143:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /** Creates proper subregister names and reads the corresponding values. */
 144:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** #define MACSC_READ32(reg)                  macsc_read32(&CONCAT(reg, HH), \
 145:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		&CONCAT(reg, HL), \
 146:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		&CONCAT(reg, LH), \
 147:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		&CONCAT(reg, LL))
 148:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 149:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** #define MACSC_WRITE32(reg, val)	\
 150:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	do { \
 151:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		union { uint8_t a[4]; uint32_t v; } \
 152:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		x; \
 153:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		x.v = val; \
 154:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		CONCAT(reg, HH) = x.a[3]; \
 155:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		CONCAT(reg, HL) = x.a[2]; \
 156:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		CONCAT(reg, LH) = x.a[1]; \
 157:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		CONCAT(reg, LL) = x.a[0]; \
 158:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	} \
 159:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	while (0)
 160:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 161:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 162:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Enable MAC SC
 163:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 164:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * Enables the SC
 165:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 166:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param clk_src selection of clk source,avalable options in macsc_xtal,fixed
 167:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *  prescalar
 168:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param sleep_enable enable RTC as clock source during sleep
 169:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param auto_ts enable automatic timestamping
 170:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 171:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 172:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** void macsc_enable(void);
 173:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 174:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 175:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Check if MACSC is enabled
 176:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 177:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * check if the MACSC is enabled.
 178:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 179:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param none
 180:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 181:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 182:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** bool is_macsc_enable(void);
 183:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 184:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 185:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Disable MAC SC
 186:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 187:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * Disables the MAC SC
 188:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 189:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param none
 190:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 191:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 192:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** void macsc_disable(void);
 193:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 194:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 195:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Check if back-off slot counter is enabled
 196:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 197:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * check if the back-off slot counter is enabled.
 198:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 199:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param none
 200:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 201:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 202:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** bool is_macsc_backoff_enable(void);
 203:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 204:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 205:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Enables compare interrupts of the MACSC
 206:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 207:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param channel Compare channel
 208:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 209:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** void macsc_enable_cmp_int(enum macsc_cc_channel channel);
 210:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 211:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 212:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Disables compare interrupts of the MACSC
 213:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 214:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param channel Compare channel
 215:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */void macsc_disable_cmp_int(enum macsc_cc_channel channel);
 216:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 217:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 218:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Usage of Absolute compare mode of the MACSC
 219:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 220:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param abs_rel  0 for absoulte cmp;1 for relative cmp
 221:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param cmp compare value for SCOCRx register
 222:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param channel Compare channel
 223:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 224:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** void macsc_use_cmp(bool abs_rel, uint32_t cmp,enum macsc_cc_channel channel);
 225:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 226:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 227:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \ingroup macsc_group
 228:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \defgroup macsc_interrupt_group MAC Symbol Counter (MACSC) interrupt
 229:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * management
 230:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * This group provides functions to configure MACSC module interrupts
 231:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 232:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * @{
 233:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 234:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 235:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 236:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Set MACSC overflow interrupt callback function
 237:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 238:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * This function allows the caller to set and change the interrupt callback
 239:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * function. Without setting a callback function the interrupt handler in the
 240:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * driver will only clear the interrupt flags.
 241:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 242:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param callback Reference to a callback function
 243:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 244:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** void macsc_set_ovf_int_cb(macsc_callback_t callback);
 245:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 246:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 247:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Set MACSC Compare Channel 1 interrupt callback function
 248:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 249:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * This function allows the caller to set and change the interrupt callback
 250:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * function. Without setting a callback function the interrupt handler in the
 251:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * driver will only clear the interrupt flags.
 252:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 253:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param callback Reference to a callback function
 254:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 255:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** void macsc_set_cmp1_int_cb(macsc_callback_t callback);
 256:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 257:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 258:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Set MACSC Compare Channel 2 interrupt callback function
 259:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 260:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * This function allows the caller to set and change the interrupt callback
 261:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * function. Without setting a callback function the interrupt handler in the
 262:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * driver will only clear the interrupt flags.
 263:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 264:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param callback Reference to a callback function
 265:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 266:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** void macsc_set_cmp2_int_cb(macsc_callback_t callback);
 267:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 268:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 269:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Set MACSC Compare Channel 3 interrupt callback function
 270:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 271:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * This function allows the caller to set and change the interrupt callback
 272:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * function. Without setting a callback function the interrupt handler in the
 273:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * driver will only clear the interrupt flags.
 274:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 275:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param callback Reference to a callback function
 276:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 277:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** void macsc_set_cmp3_int_cb(macsc_callback_t callback);
 278:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 279:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 280:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Set MACSC backoff slot counter interrupt callback function
 281:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 282:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * This function allows the caller to set and change the interrupt callback
 283:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * function. Without setting a callback function the interrupt handler in the
 284:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * driver will only clear the interrupt flags.
 285:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 286:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param callback Reference to a callback function
 287:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 288:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** void macsc_set_backoff_slot_cntr_int_cb(macsc_callback_t callback);
 289:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** //@}
 290:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 291:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 292:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Enable 32.768KHz clk using timer 2 async register
 293:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 294:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param none
 295:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 296:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 297:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** static inline void macsc_sleep_clk_enable(void)
 298:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** {
 299:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	ASSR |= (1 << AS2);
 300:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** }
 301:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 302:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 303:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Disable 32.768KHz clk using timer 2 async register
 304:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 305:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param none
 306:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 307:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** static inline void macsc_sleep_clk_disable(void)
 308:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** {
 309:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	ASSR &= ~(1 << AS2);
 310:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** }
 311:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 312:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /* @} */
 313:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 314:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 315:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Configure MAC Symbol Counter Clock Source
 316:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 317:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param macsc macsc clk src
 318:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 319:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** static inline void macsc_write_clock_source(enum macsc_xtal source)
 320:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** {
 321:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	if (source == MACSC_16MHz) {
 322:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		SCCR0 |= (source << SCCKSEL);
 323:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	} else if (source == MACSC_32KHz) {
 324:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		SCCR0 &= ~(1 << SCCKSEL);
 325:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	}
 326:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** }
 327:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 328:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 329:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Read MAC SC Clock Source
 330:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 331:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param none
 332:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \return macsc_xtal enum Clock source selection
 333:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 334:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** static inline enum macsc_xtal macsc_read_clock_source(void)
 335:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** {
 336:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	return (enum macsc_xtal)(SCCR0 & (1 << SCCKSEL));
 337:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** }
 338:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 339:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 340:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Write the Counter value of the MAC Symbol counter
 341:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 342:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param cnt_value Counter value
 343:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 344:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** static inline void macsc_write_count(uint32_t cnt_value)
 345:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** {
 346:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	MACSC_WRITE32(SCCNT, cnt_value);
 347:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** }
 348:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 349:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 350:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Reads the Counter value of the MAC Symbol counter
 351:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 352:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \note Output the Counter value
 353:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 354:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** static inline uint32_t macsc_read_count(void)
 355:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** {
 356:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	return (MACSC_READ32(SCCNT));
 357:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** }
 358:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 359:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 360:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief enable back-off slot counter
 361:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 362:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param none
 363:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \note  Enables interrupt as well	.
 364:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \note This counter works only if transceiver clock is running.So check Trx
 365:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * state in app before using this function in IEEE802.15.4 applications.
 366:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 367:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** static inline bool macsc_backoff_slot_cnt_enable(void)
 368:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** {
 369:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	if (!(PRR1 & (1 << PRTRX24))) {
 370:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		SCCR1 = (1 << SCENBO);
 371:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		SCIRQS |= (1 << IRQSBO);
 372:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		SCIRQM |= (1 << IRQMBO);
 373:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		return true;
 374:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	}
 375:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	else return false;
 376:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** }
 377:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 378:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 379:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Disable back-off slot counter
 380:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 381:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param none
 382:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \note    Disables interrupt as well	.
 383:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \note This counter works only if transceiver clock is running.So check Trx
 384:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * state in app before using this function in IEEE802.15.4 applications.
 385:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 386:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** static inline void macsc_backoff_slot_cnt_disable(void)
 387:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** {
 388:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	SCCR1 &= ~(1 << SCENBO);
 389:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	SCIRQM &= ~(1 << IRQMBO);
 390:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** }
 391:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 392:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 393:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Tests if the Backoff slot cntr interrupt flag is set
 394:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 395:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \return  backoff slot cntr interrupt has occurred or not : IRQSBO
 396:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 397:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** static inline bool macsc_is_slot_cntr_interrupt_flag_set(void)
 398:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** {
 399:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	return (SCIRQS & (1 << IRQSBO));
 400:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** }
 401:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 402:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 403:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Clears the Backoff Slot cntr interrupt flag
 404:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 405:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \note  IRQSBO is cleared
 406:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 407:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** static inline void macsc_clear_slot_cntr_interrupt_flag(void)
 408:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** {
 409:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	SCIRQS |= (1 << IRQSBO);
 410:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** }
 411:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 412:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 413:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Reads the SFD Timestamp register
 414:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 415:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \return Timestamp of last received frame :SCTSR(read-only register)
 416:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 417:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** static inline uint32_t macsc_read_ts(void)
 418:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** {
 419:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	return (MACSC_READ32(SCTSR));
 420:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** }
 421:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 422:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 423:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Reads the Beacon Timestamp register
 424:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 425:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \return Timestamp of last received beacon frame :SCBTSR
 426:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 427:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** static inline uint32_t macsc_read_bts(void)
 428:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** {
 429:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	return (MACSC_READ32(SCBTSR));
 430:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** }
 431:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 432:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 433:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Write the Beacon Timestamp register of the MAC Symbol counter
 434:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * The manual beacon timestamping can be used in conjunction with the
 435:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * relative compare mode of the three compare units to generate compare match
 436:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * interrupts without having a beacon frame received
 437:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 438:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * If set to 1, the current symbol counter value is stored into the beacon
 439:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * timestamp register.
 440:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * The bit is cleared afterwards.
 441:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 442:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 443:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** static inline void macsc_enable_manual_bts(void)
 444:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** {
 441               		.loc 5 444 0
 442               		.cfi_startproc
 443 019e CF93      		push r28
 444               	.LCFI26:
 445               		.cfi_def_cfa_offset 3
 446               		.cfi_offset 28, -2
 447 01a0 DF93      		push r29
 448               	.LCFI27:
 449               		.cfi_def_cfa_offset 4
 450               		.cfi_offset 29, -3
 451 01a2 CDB7      		in r28,__SP_L__
 452 01a4 DEB7      		in r29,__SP_H__
 453               	.LCFI28:
 454               		.cfi_def_cfa_register 28
 455               	/* prologue: function */
 456               	/* frame size = 0 */
 457               	/* stack size = 2 */
 458               	.L__stack_usage = 2
 445:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	SCCR0 |= (1 << SCMBTS);
 459               		.loc 5 445 0
 460 01a6 8CED      		ldi r24,lo8(-36)
 461 01a8 90E0      		ldi r25,0
 462 01aa 2CED      		ldi r18,lo8(-36)
 463 01ac 30E0      		ldi r19,0
 464 01ae F901      		movw r30,r18
 465 01b0 2081      		ld r18,Z
 466 01b2 2064      		ori r18,lo8(64)
 467 01b4 FC01      		movw r30,r24
 468 01b6 2083      		st Z,r18
 446:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	SCCR0 &= ~(1 << SCTSE);
 469               		.loc 5 446 0
 470 01b8 8CED      		ldi r24,lo8(-36)
 471 01ba 90E0      		ldi r25,0
 472 01bc 2CED      		ldi r18,lo8(-36)
 473 01be 30E0      		ldi r19,0
 474 01c0 F901      		movw r30,r18
 475 01c2 2081      		ld r18,Z
 476 01c4 277F      		andi r18,lo8(-9)
 477 01c6 FC01      		movw r30,r24
 478 01c8 2083      		st Z,r18
 447:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** }
 479               		.loc 5 447 0
 480 01ca 0000      		nop
 481               	/* epilogue start */
 482 01cc DF91      		pop r29
 483 01ce CF91      		pop r28
 484 01d0 0895      		ret
 485               		.cfi_endproc
 486               	.LFE121:
 488               	.global	appState
 489               		.section	.bss.appState,"aw",@nobits
 492               	appState:
 493 0000 00        		.zero	1
 494               		.section	.bss.msgReq,"aw",@nobits
 497               	msgReq:
 498 0000 0000 0000 		.zero	20
 498      0000 0000 
 498      0000 0000 
 498      0000 0000 
 498      0000 0000 
 499               		.section	.bss.PanId,"aw",@nobits
 502               	PanId:
 503 0000 00        		.zero	1
 504               		.section	.rodata
 505               	.LC1:
 506 0000 0A4D 5347 		.string	"\nMSG REQ SENT %d"
 506      2052 4551 
 506      2053 454E 
 506      5420 2564 
 506      00
 507               		.text
 508               	.global	appSendData
 510               	appSendData:
 511               	.LFB130:
 512               		.file 6 "ServerLLDN.c"
   1:ServerLLDN.c  **** /*
   2:ServerLLDN.c  **** 	* ServerLLDN.c
   3:ServerLLDN.c  **** 	*
   4:ServerLLDN.c  **** 	* Created: 10/18/2019 5:15:37 PM
   5:ServerLLDN.c  **** 	*  Author: guilherme
   6:ServerLLDN.c  **** 	*/ 
   7:ServerLLDN.c  **** 
   8:ServerLLDN.c  **** #include <stdlib.h>
   9:ServerLLDN.c  **** #include <stdio.h>
  10:ServerLLDN.c  **** #include <string.h>
  11:ServerLLDN.c  **** #include <inttypes.h>
  12:ServerLLDN.c  **** #include "config.h"
  13:ServerLLDN.c  **** #include "sys.h"
  14:ServerLLDN.c  **** #include "phy.h"
  15:ServerLLDN.c  **** #include "sys.h"
  16:ServerLLDN.c  **** #include "nwk.h"
  17:ServerLLDN.c  **** #include "sysclk.h"
  18:ServerLLDN.c  **** #include "sysTimer.h"
  19:ServerLLDN.c  **** #include "sleep_mgr.h"
  20:ServerLLDN.c  **** #include "sleepmgr.h"
  21:ServerLLDN.c  **** #include "led.h"
  22:ServerLLDN.c  **** #include "ioport.h"
  23:ServerLLDN.c  **** #include "conf_sleepmgr.h"
  24:ServerLLDN.c  **** #include "board.h"
  25:ServerLLDN.c  **** #include "platform.h"
  26:ServerLLDN.c  **** 
  27:ServerLLDN.c  **** #include "lldn.h"
  28:ServerLLDN.c  **** 
  29:ServerLLDN.c  **** #if 1
  30:ServerLLDN.c  **** #if (SIO2HOST_CHANNEL == SIO_USB)
  31:ServerLLDN.c  **** /* Only ARM */
  32:ServerLLDN.c  **** #include "hw_timer_lldn.h"
  33:ServerLLDN.c  **** #include "stdio_usb.h"
  34:ServerLLDN.c  **** #define MASTER_MACSC	0
  35:ServerLLDN.c  **** #else
  36:ServerLLDN.c  **** /* Only megarf series */
  37:ServerLLDN.c  **** #include "conf_sio2host.h"
  38:ServerLLDN.c  **** #define MASTER_MACSC	1
  39:ServerLLDN.c  **** #endif
  40:ServerLLDN.c  **** #else
  41:ServerLLDN.c  **** /* Only megarf series */
  42:ServerLLDN.c  **** #define MASTER_MACSC		1
  43:ServerLLDN.c  **** #endif
  44:ServerLLDN.c  **** 
  45:ServerLLDN.c  **** #define HUMAM_READABLE			1
  46:ServerLLDN.c  **** 
  47:ServerLLDN.c  **** #if (MASTER_MACSC == 1)
  48:ServerLLDN.c  **** #include "macsc_megarf.h"
  49:ServerLLDN.c  **** #else
  50:ServerLLDN.c  **** static SYS_Timer_t				tmrBeaconInterval;			// Beacon
  51:ServerLLDN.c  **** static SYS_Timer_t				tmrComputeData;				// Compute data
  52:ServerLLDN.c  **** #endif
  53:ServerLLDN.c  **** 
  54:ServerLLDN.c  **** #define PRINT 1
  55:ServerLLDN.c  **** 
  56:ServerLLDN.c  **** 	
  57:ServerLLDN.c  **** // equation for tTS gives time in seconds, the division by SYMBOL_TIME changes to symbols for count
  58:ServerLLDN.c  **** AppState_t	appState = APP_STATE_INITIAL;
  59:ServerLLDN.c  **** static NWK_DataReq_t msgReq;
  60:ServerLLDN.c  **** static uint8_t PanId;
  61:ServerLLDN.c  **** 
  62:ServerLLDN.c  ****  void appSendData(void)
  63:ServerLLDN.c  **** {
 513               		.loc 6 63 0
 514               		.cfi_startproc
 515 01d2 CF93      		push r28
 516               	.LCFI29:
 517               		.cfi_def_cfa_offset 3
 518               		.cfi_offset 28, -2
 519 01d4 DF93      		push r29
 520               	.LCFI30:
 521               		.cfi_def_cfa_offset 4
 522               		.cfi_offset 29, -3
 523 01d6 CDB7      		in r28,__SP_L__
 524 01d8 DEB7      		in r29,__SP_H__
 525               	.LCFI31:
 526               		.cfi_def_cfa_register 28
 527               	/* prologue: function */
 528               	/* frame size = 0 */
 529               	/* stack size = 2 */
 530               	.L__stack_usage = 2
  64:ServerLLDN.c  **** 	if(msgReq.options != 0)
 531               		.loc 6 64 0
 532 01da 8091 0000 		lds r24,msgReq+9
 533 01de 9091 0000 		lds r25,msgReq+9+1
 534 01e2 892B      		or r24,r25
 535 01e4 01F0      		breq .L17
  65:ServerLLDN.c  **** 	{
  66:ServerLLDN.c  **** 		printf("\nMSG REQ SENT %d",msgReq.options);
 536               		.loc 6 66 0
 537 01e6 8091 0000 		lds r24,msgReq+9
 538 01ea 9091 0000 		lds r25,msgReq+9+1
 539 01ee 292F      		mov r18,r25
 540 01f0 2F93      		push r18
 541 01f2 8F93      		push r24
 542 01f4 80E0      		ldi r24,lo8(.LC1)
 543 01f6 90E0      		ldi r25,hi8(.LC1)
 544 01f8 892F      		mov r24,r25
 545 01fa 8F93      		push r24
 546 01fc 80E0      		ldi r24,lo8(.LC1)
 547 01fe 90E0      		ldi r25,hi8(.LC1)
 548 0200 8F93      		push r24
 549 0202 0E94 0000 		call printf
 550 0206 0F90      		pop __tmp_reg__
 551 0208 0F90      		pop __tmp_reg__
 552 020a 0F90      		pop __tmp_reg__
 553 020c 0F90      		pop __tmp_reg__
  67:ServerLLDN.c  **** 		NWK_DataReq(&msgReq);
 554               		.loc 6 67 0
 555 020e 80E0      		ldi r24,lo8(msgReq)
 556 0210 90E0      		ldi r25,hi8(msgReq)
 557 0212 0E94 0000 		call NWK_DataReq
 558               	.L17:
  68:ServerLLDN.c  **** 	#if !APP_COORDINATOR
  69:ServerLLDN.c  **** 	#endif
  70:ServerLLDN.c  **** 	}
  71:ServerLLDN.c  **** }
 559               		.loc 6 71 0
 560 0216 0000      		nop
 561               	/* epilogue start */
 562 0218 DF91      		pop r29
 563 021a CF91      		pop r28
 564 021c 0895      		ret
 565               		.cfi_endproc
 566               	.LFE130:
 568               	.global	appPanState
 569               		.section	.data.appPanState,"aw",@progbits
 572               	appPanState:
 573 0000 01        		.byte	1
 574               		.comm	nodes_info_arr,1270,1
 575               	.global	config_request_frame
 576               		.section	.data.config_request_frame,"aw",@progbits
 579               	config_request_frame:
 580 0000 0F        		.byte	15
 581 0001 00        		.byte	0
 582 0002 0F        		.byte	15
 583 0003 0000 00   		.zero	3
 584 0006 80        		.byte	128
 585               	.global	conf_req_list
 586               		.section	.bss.conf_req_list,"aw",@nobits
 589               	conf_req_list:
 590 0000 0000      		.zero	2
 591               	.global	index_nodes_array
 592               		.section	.bss.index_nodes_array,"aw",@nobits
 595               	index_nodes_array:
 596 0000 0000      		.zero	2
 597               		.comm	ACKFrame,33,1
 598               	.global	ACKFrame_size
 599               		.section	.bss.ACKFrame_size,"aw",@nobits
 602               	ACKFrame_size:
 603 0000 0000      		.zero	2
 604               	.global	beaconInterval
 605               		.section	.bss.beaconInterval,"aw",@nobits
 608               	beaconInterval:
 609 0000 0000 0000 		.zero	4
 610               	.global	macLLDNnumUplinkTS
 611               		.section	.bss.macLLDNnumUplinkTS,"aw",@nobits
 614               	macLLDNnumUplinkTS:
 615 0000 0000      		.zero	2
 616               		.section	.bss.tmrDelay,"aw",@nobits
 619               	tmrDelay:
 620 0000 0000 0000 		.zero	13
 620      0000 0000 
 620      0000 0000 
 620      00
 621               	.global	counter_associados
 622               		.section	.bss.counter_associados,"aw",@nobits
 625               	counter_associados:
 626 0000 0000      		.zero	2
 627               	.global	cycles_counter
 628               		.section	.data.cycles_counter,"aw",@progbits
 631               	cycles_counter:
 632 0000 01        		.byte	1
 633               		.text
 635               	tmrDelayHandler:
 636               	.LFB131:
  72:ServerLLDN.c  **** 
  73:ServerLLDN.c  **** #if APP_COORDINATOR
  74:ServerLLDN.c  **** 
  75:ServerLLDN.c  **** 	#define NODOS_ASSOCIADOS_ESPERADOS 12
  76:ServerLLDN.c  **** 	
  77:ServerLLDN.c  **** 	AppPanState_t appPanState = APP_PAN_STATE_RESET; // Initial state of PAN node
  78:ServerLLDN.c  **** 	
  79:ServerLLDN.c  **** 	/* Configuration Request Frames */
  80:ServerLLDN.c  **** 	/* Da pra mudar o envio do confrequest pra ja usar essa array com as informas dos nodos */	
  81:ServerLLDN.c  **** 	nodes_info_t nodes_info_arr[254]; // Array for Configure Request messages, one position per node, 
  82:ServerLLDN.c  **** 	NWK_ConfigRequest_t config_request_frame = { .id = LL_CONFIGURATION_REQUEST,
  83:ServerLLDN.c  **** 												 .s_macAddr = APP_ADDR,
  84:ServerLLDN.c  **** 												 .tx_channel = APP_CHANNEL,
  85:ServerLLDN.c  **** 												 .conf.macLLDNmgmtTS = MacLLDNMgmtTS };
  86:ServerLLDN.c  **** 	nodes_info_list_t *conf_req_list = 0;
  87:ServerLLDN.c  **** 	
  88:ServerLLDN.c  **** 	int index_nodes_array = 0;
  89:ServerLLDN.c  **** 	/* Acknowledge Frame and Array */
  90:ServerLLDN.c  **** 	NWK_ACKFormat_t ACKFrame;	// ACK Frame Payload used in Discovery State
  91:ServerLLDN.c  **** 	int ACKFrame_size = 0;
  92:ServerLLDN.c  **** 
  93:ServerLLDN.c  **** 	float beaconInterval = 0; // no precisa ser global
  94:ServerLLDN.c  **** 	
  95:ServerLLDN.c  **** 	int macLLDNnumUplinkTS = 0;		// Number of uplink timeslots, is also the control of associated node
  96:ServerLLDN.c  **** 	
  97:ServerLLDN.c  **** 	/* This timer implements a delay between messages, 
  98:ServerLLDN.c  **** 	 * if not used the nodes are not able to receive the message
  99:ServerLLDN.c  **** 	 */
 100:ServerLLDN.c  **** 	static SYS_Timer_t tmrDelay;	
 101:ServerLLDN.c  **** 	
 102:ServerLLDN.c  **** 	/*  Control variables for testing */	
 103:ServerLLDN.c  **** 	int counter_associados = 0;		// Associated nodes counter
 104:ServerLLDN.c  **** 	uint8_t cycles_counter = macLLDNdiscoveryModeTimeout;
 105:ServerLLDN.c  **** 
 106:ServerLLDN.c  **** 	
 107:ServerLLDN.c  **** 	static void tmrDelayHandler(SYS_Timer_t *timer)
 108:ServerLLDN.c  **** 	{
 637               		.loc 6 108 0
 638               		.cfi_startproc
 639 021e CF93      		push r28
 640               	.LCFI32:
 641               		.cfi_def_cfa_offset 3
 642               		.cfi_offset 28, -2
 643 0220 DF93      		push r29
 644               	.LCFI33:
 645               		.cfi_def_cfa_offset 4
 646               		.cfi_offset 29, -3
 647 0222 00D0      		rcall .
 648               	.LCFI34:
 649               		.cfi_def_cfa_offset 6
 650 0224 CDB7      		in r28,__SP_L__
 651 0226 DEB7      		in r29,__SP_H__
 652               	.LCFI35:
 653               		.cfi_def_cfa_register 28
 654               	/* prologue: function */
 655               	/* frame size = 2 */
 656               	/* stack size = 4 */
 657               	.L__stack_usage = 4
 658 0228 9A83      		std Y+2,r25
 659 022a 8983      		std Y+1,r24
 109:ServerLLDN.c  **** 		appState = APP_STATE_SEND;
 660               		.loc 6 109 0
 661 022c 82E0      		ldi r24,lo8(2)
 662 022e 8093 0000 		sts appState,r24
 110:ServerLLDN.c  **** 	}
 663               		.loc 6 110 0
 664 0232 0000      		nop
 665               	/* epilogue start */
 666 0234 0F90      		pop __tmp_reg__
 667 0236 0F90      		pop __tmp_reg__
 668 0238 DF91      		pop r29
 669 023a CF91      		pop r28
 670 023c 0895      		ret
 671               		.cfi_endproc
 672               	.LFE131:
 675               	lldn_server_beacon:
 676               	.LFB132:
 111:ServerLLDN.c  **** 	
 112:ServerLLDN.c  **** 	static void lldn_server_beacon(void)
 113:ServerLLDN.c  **** 	{
 677               		.loc 6 113 0
 678               		.cfi_startproc
 679 023e CF93      		push r28
 680               	.LCFI36:
 681               		.cfi_def_cfa_offset 3
 682               		.cfi_offset 28, -2
 683 0240 DF93      		push r29
 684               	.LCFI37:
 685               		.cfi_def_cfa_offset 4
 686               		.cfi_offset 29, -3
 687 0242 CDB7      		in r28,__SP_L__
 688 0244 DEB7      		in r29,__SP_H__
 689               	.LCFI38:
 690               		.cfi_def_cfa_register 28
 691               	/* prologue: function */
 692               	/* frame size = 0 */
 693               	/* stack size = 2 */
 694               	.L__stack_usage = 2
 114:ServerLLDN.c  **** 		macsc_enable_manual_bts();
 695               		.loc 6 114 0
 696 0246 0E94 0000 		call macsc_enable_manual_bts
 115:ServerLLDN.c  **** 		appState = APP_STATE_SEND;
 697               		.loc 6 115 0
 698 024a 82E0      		ldi r24,lo8(2)
 699 024c 8093 0000 		sts appState,r24
 116:ServerLLDN.c  **** 	}
 700               		.loc 6 116 0
 701 0250 0000      		nop
 702               	/* epilogue start */
 703 0252 DF91      		pop r29
 704 0254 CF91      		pop r28
 705 0256 0895      		ret
 706               		.cfi_endproc
 707               	.LFE132:
 710               	downlink_delay_handler:
 711               	.LFB133:
 117:ServerLLDN.c  **** 	
 118:ServerLLDN.c  **** 	static void downlink_delay_handler(void)
 119:ServerLLDN.c  **** 	{
 712               		.loc 6 119 0
 713               		.cfi_startproc
 714 0258 CF93      		push r28
 715               	.LCFI39:
 716               		.cfi_def_cfa_offset 3
 717               		.cfi_offset 28, -2
 718 025a DF93      		push r29
 719               	.LCFI40:
 720               		.cfi_def_cfa_offset 4
 721               		.cfi_offset 29, -3
 722 025c CDB7      		in r28,__SP_L__
 723 025e DEB7      		in r29,__SP_H__
 724               	.LCFI41:
 725               		.cfi_def_cfa_register 28
 726               	/* prologue: function */
 727               	/* frame size = 0 */
 728               	/* stack size = 2 */
 729               	.L__stack_usage = 2
 120:ServerLLDN.c  **** 		if(msgReq.options == NWK_OPT_LLDN_ACK)
 730               		.loc 6 120 0
 731 0260 8091 0000 		lds r24,msgReq+9
 732 0264 9091 0000 		lds r25,msgReq+9+1
 733 0268 8115      		cp r24,__zero_reg__
 734 026a 9044      		sbci r25,64
 735 026c 01F4      		brne .L22
 121:ServerLLDN.c  **** 		{
 122:ServerLLDN.c  **** 		appState = APP_STATE_SEND;
 736               		.loc 6 122 0
 737 026e 82E0      		ldi r24,lo8(2)
 738 0270 8093 0000 		sts appState,r24
 739               	.L22:
 123:ServerLLDN.c  **** 		}
 124:ServerLLDN.c  **** 	}
 740               		.loc 6 124 0
 741 0274 0000      		nop
 742               	/* epilogue start */
 743 0276 DF91      		pop r29
 744 0278 CF91      		pop r28
 745 027a 0895      		ret
 746               		.cfi_endproc
 747               	.LFE133:
 750               	end_of_online_handler:
 751               	.LFB134:
 125:ServerLLDN.c  **** 
 126:ServerLLDN.c  **** 	static void end_of_online_handler(void)
 127:ServerLLDN.c  **** 	{
 752               		.loc 6 127 0
 753               		.cfi_startproc
 754 027c CF93      		push r28
 755               	.LCFI42:
 756               		.cfi_def_cfa_offset 3
 757               		.cfi_offset 28, -2
 758 027e DF93      		push r29
 759               	.LCFI43:
 760               		.cfi_def_cfa_offset 4
 761               		.cfi_offset 29, -3
 762 0280 CDB7      		in r28,__SP_L__
 763 0282 DEB7      		in r29,__SP_H__
 764               	.LCFI44:
 765               		.cfi_def_cfa_register 28
 766               	/* prologue: function */
 767               	/* frame size = 0 */
 768               	/* stack size = 2 */
 769               	.L__stack_usage = 2
 128:ServerLLDN.c  **** 		appState = APP_STATE_ATT_PAN_STATE;
 770               		.loc 6 128 0
 771 0284 83E0      		ldi r24,lo8(3)
 772 0286 8093 0000 		sts appState,r24
 129:ServerLLDN.c  **** 		appPanState = APP_PAN_STATE_ONLINE_END_BE;
 773               		.loc 6 129 0
 774 028a 8AE0      		ldi r24,lo8(10)
 775 028c 8093 0000 		sts appPanState,r24
 130:ServerLLDN.c  **** 	}
 776               		.loc 6 130 0
 777 0290 0000      		nop
 778               	/* epilogue start */
 779 0292 DF91      		pop r29
 780 0294 CF91      		pop r28
 781 0296 0895      		ret
 782               		.cfi_endproc
 783               	.LFE134:
 785               		.section	.rodata
 786               	.LC2:
 787 0011 0A41 6464 		.string	"\nAddres %d is already on ACK Array"
 787      7265 7320 
 787      2564 2069 
 787      7320 616C 
 787      7265 6164 
 788               		.text
 790               	addToAckArray:
 791               	.LFB135:
 131:ServerLLDN.c  **** 	
 132:ServerLLDN.c  **** 	#if TIMESLOT_TIMER
 133:ServerLLDN.c  **** 	static void teste_handler(void)
 134:ServerLLDN.c  **** 	{
 135:ServerLLDN.c  **** 		if(msgReq.options)
 136:ServerLLDN.c  **** 			printf("\n***TIMESLOT****");
 137:ServerLLDN.c  **** 		macsc_disable_cmp_int(MACSC_CC3);
 138:ServerLLDN.c  **** 	}
 139:ServerLLDN.c  **** 	#endif
 140:ServerLLDN.c  **** 	
 141:ServerLLDN.c  **** 	static bool addToAckArray(uint16_t addres)
 142:ServerLLDN.c  **** 	{	
 792               		.loc 6 142 0
 793               		.cfi_startproc
 794 0298 CF93      		push r28
 795               	.LCFI45:
 796               		.cfi_def_cfa_offset 3
 797               		.cfi_offset 28, -2
 798 029a DF93      		push r29
 799               	.LCFI46:
 800               		.cfi_def_cfa_offset 4
 801               		.cfi_offset 29, -3
 802 029c 00D0      		rcall .
 803 029e 00D0      		rcall .
 804 02a0 00D0      		rcall .
 805               	.LCFI47:
 806               		.cfi_def_cfa_offset 10
 807 02a2 CDB7      		in r28,__SP_L__
 808 02a4 DEB7      		in r29,__SP_H__
 809               	.LCFI48:
 810               		.cfi_def_cfa_register 28
 811               	/* prologue: function */
 812               	/* frame size = 6 */
 813               	/* stack size = 8 */
 814               	.L__stack_usage = 8
 815 02a6 9E83      		std Y+6,r25
 816 02a8 8D83      		std Y+5,r24
 143:ServerLLDN.c  **** 		int pos =(int) addres / 8;
 817               		.loc 6 143 0
 818 02aa 8D81      		ldd r24,Y+5
 819 02ac 9E81      		ldd r25,Y+6
 820 02ae 9923      		tst r25
 821 02b0 04F4      		brge .L25
 822 02b2 0796      		adiw r24,7
 823               	.L25:
 824 02b4 9595      		asr r25
 825 02b6 8795      		ror r24
 826 02b8 9595      		asr r25
 827 02ba 8795      		ror r24
 828 02bc 9595      		asr r25
 829 02be 8795      		ror r24
 830 02c0 9A83      		std Y+2,r25
 831 02c2 8983      		std Y+1,r24
 144:ServerLLDN.c  **** 		int bit_shift = 8 - (addres % 8);
 832               		.loc 6 144 0
 833 02c4 8D81      		ldd r24,Y+5
 834 02c6 9E81      		ldd r25,Y+6
 835 02c8 8770      		andi r24,7
 836 02ca 9927      		clr r25
 837 02cc 28E0      		ldi r18,lo8(8)
 838 02ce 30E0      		ldi r19,0
 839 02d0 A901      		movw r20,r18
 840 02d2 481B      		sub r20,r24
 841 02d4 590B      		sbc r21,r25
 842 02d6 CA01      		movw r24,r20
 843 02d8 9C83      		std Y+4,r25
 844 02da 8B83      		std Y+3,r24
 145:ServerLLDN.c  **** 		
 146:ServerLLDN.c  **** 		if(ACKFrame.ackFlags[pos] & 1 << bit_shift)
 845               		.loc 6 146 0
 846 02dc 8981      		ldd r24,Y+1
 847 02de 9A81      		ldd r25,Y+2
 848 02e0 8050      		subi r24,lo8(-(ACKFrame+1))
 849 02e2 9040      		sbci r25,hi8(-(ACKFrame+1))
 850 02e4 FC01      		movw r30,r24
 851 02e6 8081      		ld r24,Z
 852 02e8 882F      		mov r24,r24
 853 02ea 90E0      		ldi r25,0
 854 02ec 0B80      		ldd r0,Y+3
 855 02ee 00C0      		rjmp 2f
 856               		1:
 857 02f0 9595      		asr r25
 858 02f2 8795      		ror r24
 859               		2:
 860 02f4 0A94      		dec r0
 861 02f6 02F4      		brpl 1b
 862 02f8 8170      		andi r24,1
 863 02fa 9927      		clr r25
 864 02fc 892B      		or r24,r25
 865 02fe 01F0      		breq .L26
 147:ServerLLDN.c  **** 		{
 148:ServerLLDN.c  **** 			printf("\nAddres %d is already on ACK Array", addres);
 866               		.loc 6 148 0
 867 0300 8E81      		ldd r24,Y+6
 868 0302 8F93      		push r24
 869 0304 8D81      		ldd r24,Y+5
 870 0306 8F93      		push r24
 871 0308 80E0      		ldi r24,lo8(.LC2)
 872 030a 90E0      		ldi r25,hi8(.LC2)
 873 030c 892F      		mov r24,r25
 874 030e 8F93      		push r24
 875 0310 80E0      		ldi r24,lo8(.LC2)
 876 0312 90E0      		ldi r25,hi8(.LC2)
 877 0314 8F93      		push r24
 878 0316 0E94 0000 		call printf
 879 031a 0F90      		pop __tmp_reg__
 880 031c 0F90      		pop __tmp_reg__
 881 031e 0F90      		pop __tmp_reg__
 882 0320 0F90      		pop __tmp_reg__
 149:ServerLLDN.c  **** 			return false;
 883               		.loc 6 149 0
 884 0322 80E0      		ldi r24,0
 885 0324 00C0      		rjmp .L27
 886               	.L26:
 150:ServerLLDN.c  **** 		}
 151:ServerLLDN.c  **** 		
 152:ServerLLDN.c  **** 		if (pos + 1 > ACKFrame_size)
 887               		.loc 6 152 0
 888 0326 8981      		ldd r24,Y+1
 889 0328 9A81      		ldd r25,Y+2
 890 032a 9C01      		movw r18,r24
 891 032c 2F5F      		subi r18,-1
 892 032e 3F4F      		sbci r19,-1
 893 0330 8091 0000 		lds r24,ACKFrame_size
 894 0334 9091 0000 		lds r25,ACKFrame_size+1
 895 0338 8217      		cp r24,r18
 896 033a 9307      		cpc r25,r19
 897 033c 04F4      		brge .L28
 153:ServerLLDN.c  **** 		ACKFrame_size = pos + 1;
 898               		.loc 6 153 0
 899 033e 8981      		ldd r24,Y+1
 900 0340 9A81      		ldd r25,Y+2
 901 0342 0196      		adiw r24,1
 902 0344 9093 0000 		sts ACKFrame_size+1,r25
 903 0348 8093 0000 		sts ACKFrame_size,r24
 904               	.L28:
 154:ServerLLDN.c  **** 		return true;
 905               		.loc 6 154 0
 906 034c 81E0      		ldi r24,lo8(1)
 907               	.L27:
 908               	/* epilogue start */
 155:ServerLLDN.c  **** 	}
 909               		.loc 6 155 0
 910 034e 2696      		adiw r28,6
 911 0350 0FB6      		in __tmp_reg__,__SREG__
 912 0352 F894      		cli
 913 0354 DEBF      		out __SP_H__,r29
 914 0356 0FBE      		out __SREG__,__tmp_reg__
 915 0358 CDBF      		out __SP_L__,r28
 916 035a DF91      		pop r29
 917 035c CF91      		pop r28
 918 035e 0895      		ret
 919               		.cfi_endproc
 920               	.LFE135:
 923               	get_next_confreq:
 924               	.LFB136:
 156:ServerLLDN.c  **** 
 157:ServerLLDN.c  **** 	static void get_next_confreq(NWK_ConfigRequest_t *msg)
 158:ServerLLDN.c  **** 	{
 925               		.loc 6 158 0
 926               		.cfi_startproc
 927 0360 CF93      		push r28
 928               	.LCFI49:
 929               		.cfi_def_cfa_offset 3
 930               		.cfi_offset 28, -2
 931 0362 DF93      		push r29
 932               	.LCFI50:
 933               		.cfi_def_cfa_offset 4
 934               		.cfi_offset 29, -3
 935 0364 00D0      		rcall .
 936 0366 00D0      		rcall .
 937               	.LCFI51:
 938               		.cfi_def_cfa_offset 8
 939 0368 CDB7      		in r28,__SP_L__
 940 036a DEB7      		in r29,__SP_H__
 941               	.LCFI52:
 942               		.cfi_def_cfa_register 28
 943               	/* prologue: function */
 944               	/* frame size = 4 */
 945               	/* stack size = 6 */
 946               	.L__stack_usage = 6
 947 036c 9C83      		std Y+4,r25
 948 036e 8B83      		std Y+3,r24
 159:ServerLLDN.c  **** 		msg->assTimeSlot = conf_req_list->pos;
 949               		.loc 6 159 0
 950 0370 8091 0000 		lds r24,conf_req_list
 951 0374 9091 0000 		lds r25,conf_req_list+1
 952 0378 FC01      		movw r30,r24
 953 037a 8281      		ldd r24,Z+2
 954 037c 9381      		ldd r25,Z+3
 955 037e 282F      		mov r18,r24
 956 0380 8B81      		ldd r24,Y+3
 957 0382 9C81      		ldd r25,Y+4
 958 0384 FC01      		movw r30,r24
 959 0386 2383      		std Z+3,r18
 160:ServerLLDN.c  **** 		msg->macAddr = (uint8_t)conf_req_list->node->mac_addr;
 960               		.loc 6 160 0
 961 0388 8091 0000 		lds r24,conf_req_list
 962 038c 9091 0000 		lds r25,conf_req_list+1
 963 0390 FC01      		movw r30,r24
 964 0392 8081      		ld r24,Z
 965 0394 9181      		ldd r25,Z+1
 966 0396 FC01      		movw r30,r24
 967 0398 8281      		ldd r24,Z+2
 968 039a 9381      		ldd r25,Z+3
 969 039c 9C01      		movw r18,r24
 970 039e 3327      		clr r19
 971 03a0 8B81      		ldd r24,Y+3
 972 03a2 9C81      		ldd r25,Y+4
 973 03a4 FC01      		movw r30,r24
 974 03a6 3583      		std Z+5,r19
 975 03a8 2483      		std Z+4,r18
 161:ServerLLDN.c  **** 		
 162:ServerLLDN.c  **** 		nodes_info_list_t* tmp = conf_req_list;
 976               		.loc 6 162 0
 977 03aa 8091 0000 		lds r24,conf_req_list
 978 03ae 9091 0000 		lds r25,conf_req_list+1
 979 03b2 9A83      		std Y+2,r25
 980 03b4 8983      		std Y+1,r24
 163:ServerLLDN.c  **** 		
 164:ServerLLDN.c  **** 		conf_req_list = conf_req_list->next;
 981               		.loc 6 164 0
 982 03b6 8091 0000 		lds r24,conf_req_list
 983 03ba 9091 0000 		lds r25,conf_req_list+1
 984 03be FC01      		movw r30,r24
 985 03c0 8481      		ldd r24,Z+4
 986 03c2 9581      		ldd r25,Z+5
 987 03c4 9093 0000 		sts conf_req_list+1,r25
 988 03c8 8093 0000 		sts conf_req_list,r24
 165:ServerLLDN.c  **** 		
 166:ServerLLDN.c  **** 		tmp->node = 0;
 989               		.loc 6 166 0
 990 03cc 8981      		ldd r24,Y+1
 991 03ce 9A81      		ldd r25,Y+2
 992 03d0 FC01      		movw r30,r24
 993 03d2 1182      		std Z+1,__zero_reg__
 994 03d4 1082      		st Z,__zero_reg__
 167:ServerLLDN.c  **** 		tmp->next = 0;
 995               		.loc 6 167 0
 996 03d6 8981      		ldd r24,Y+1
 997 03d8 9A81      		ldd r25,Y+2
 998 03da FC01      		movw r30,r24
 999 03dc 1582      		std Z+5,__zero_reg__
 1000 03de 1482      		std Z+4,__zero_reg__
 168:ServerLLDN.c  **** 		free(tmp);
 1001               		.loc 6 168 0
 1002 03e0 8981      		ldd r24,Y+1
 1003 03e2 9A81      		ldd r25,Y+2
 1004 03e4 0E94 0000 		call free
 169:ServerLLDN.c  **** 	}
 1005               		.loc 6 169 0
 1006 03e8 0000      		nop
 1007               	/* epilogue start */
 1008 03ea 0F90      		pop __tmp_reg__
 1009 03ec 0F90      		pop __tmp_reg__
 1010 03ee 0F90      		pop __tmp_reg__
 1011 03f0 0F90      		pop __tmp_reg__
 1012 03f2 DF91      		pop r29
 1013 03f4 CF91      		pop r28
 1014 03f6 0895      		ret
 1015               		.cfi_endproc
 1016               	.LFE136:
 1019               	addConfRequestArray:
 1020               	.LFB137:
 170:ServerLLDN.c  **** 
 171:ServerLLDN.c  **** 	static void addConfRequestArray(NWK_ConfigStatus_t *node)
 172:ServerLLDN.c  **** 	{
 1021               		.loc 6 172 0
 1022               		.cfi_startproc
 1023 03f8 CF93      		push r28
 1024               	.LCFI53:
 1025               		.cfi_def_cfa_offset 3
 1026               		.cfi_offset 28, -2
 1027 03fa DF93      		push r29
 1028               	.LCFI54:
 1029               		.cfi_def_cfa_offset 4
 1030               		.cfi_offset 29, -3
 1031 03fc 00D0      		rcall .
 1032 03fe 00D0      		rcall .
 1033               	.LCFI55:
 1034               		.cfi_def_cfa_offset 8
 1035 0400 CDB7      		in r28,__SP_L__
 1036 0402 DEB7      		in r29,__SP_H__
 1037               	.LCFI56:
 1038               		.cfi_def_cfa_register 28
 1039               	/* prologue: function */
 1040               	/* frame size = 4 */
 1041               	/* stack size = 6 */
 1042               	.L__stack_usage = 6
 1043 0404 9C83      		std Y+4,r25
 1044 0406 8B83      		std Y+3,r24
 173:ServerLLDN.c  **** 		index_nodes_array++;
 1045               		.loc 6 173 0
 1046 0408 8091 0000 		lds r24,index_nodes_array
 1047 040c 9091 0000 		lds r25,index_nodes_array+1
 1048 0410 0196      		adiw r24,1
 1049 0412 9093 0000 		sts index_nodes_array+1,r25
 1050 0416 8093 0000 		sts index_nodes_array,r24
 174:ServerLLDN.c  **** 		int i;
 175:ServerLLDN.c  **** 		for (i = 0; nodes_info_arr[i].mac_addr != 0 && i < 255; i++);
 1051               		.loc 6 175 0
 1052 041a 1A82      		std Y+2,__zero_reg__
 1053 041c 1982      		std Y+1,__zero_reg__
 1054 041e 00C0      		rjmp .L31
 1055               	.L33:
 1056               		.loc 6 175 0 is_stmt 0 discriminator 4
 1057 0420 8981      		ldd r24,Y+1
 1058 0422 9A81      		ldd r25,Y+2
 1059 0424 0196      		adiw r24,1
 1060 0426 9A83      		std Y+2,r25
 1061 0428 8983      		std Y+1,r24
 1062               	.L31:
 1063               		.loc 6 175 0 discriminator 1
 1064 042a 2981      		ldd r18,Y+1
 1065 042c 3A81      		ldd r19,Y+2
 1066 042e C901      		movw r24,r18
 1067 0430 880F      		lsl r24
 1068 0432 991F      		rol r25
 1069 0434 880F      		lsl r24
 1070 0436 991F      		rol r25
 1071 0438 820F      		add r24,r18
 1072 043a 931F      		adc r25,r19
 1073 043c 8050      		subi r24,lo8(-(nodes_info_arr+2))
 1074 043e 9040      		sbci r25,hi8(-(nodes_info_arr+2))
 1075 0440 FC01      		movw r30,r24
 1076 0442 8081      		ld r24,Z
 1077 0444 9181      		ldd r25,Z+1
 1078 0446 892B      		or r24,r25
 1079 0448 01F0      		breq .L32
 1080               		.loc 6 175 0 discriminator 3
 1081 044a 8981      		ldd r24,Y+1
 1082 044c 9A81      		ldd r25,Y+2
 1083 044e 8F3F      		cpi r24,-1
 1084 0450 9105      		cpc r25,__zero_reg__
 1085 0452 04F0      		brlt .L33
 1086               	.L32:
 176:ServerLLDN.c  **** 		
 177:ServerLLDN.c  **** 		if(config_request_frame.conf.tsDuration < node->ts_dir.tsDuration)
 1087               		.loc 6 177 0 is_stmt 1
 1088 0454 8091 0000 		lds r24,config_request_frame+6
 1089 0458 8F77      		andi r24,lo8(127)
 1090 045a 282F      		mov r18,r24
 1091 045c 30E0      		ldi r19,0
 1092 045e 8B81      		ldd r24,Y+3
 1093 0460 9C81      		ldd r25,Y+4
 1094 0462 FC01      		movw r30,r24
 1095 0464 8581      		ldd r24,Z+5
 1096 0466 8F77      		andi r24,lo8(127)
 1097 0468 882F      		mov r24,r24
 1098 046a 90E0      		ldi r25,0
 1099 046c 2817      		cp r18,r24
 1100 046e 3907      		cpc r19,r25
 1101 0470 04F4      		brge .L34
 178:ServerLLDN.c  **** 			config_request_frame.conf.tsDuration = node->ts_dir.tsDuration;
 1102               		.loc 6 178 0
 1103 0472 8B81      		ldd r24,Y+3
 1104 0474 9C81      		ldd r25,Y+4
 1105 0476 FC01      		movw r30,r24
 1106 0478 8581      		ldd r24,Z+5
 1107 047a 8F77      		andi r24,lo8(127)
 1108 047c 8F77      		andi r24,lo8(127)
 1109 047e 9091 0000 		lds r25,config_request_frame+6
 1110 0482 9078      		andi r25,lo8(-128)
 1111 0484 892B      		or r24,r25
 1112 0486 8093 0000 		sts config_request_frame+6,r24
 1113               	.L34:
 179:ServerLLDN.c  **** 		
 180:ServerLLDN.c  **** 		nodes_info_arr[i].mac_addr = node->macAddr;
 1114               		.loc 6 180 0
 1115 048a 8B81      		ldd r24,Y+3
 1116 048c 9C81      		ldd r25,Y+4
 1117 048e FC01      		movw r30,r24
 1118 0490 4381      		ldd r20,Z+3
 1119 0492 5481      		ldd r21,Z+4
 1120 0494 2981      		ldd r18,Y+1
 1121 0496 3A81      		ldd r19,Y+2
 1122 0498 C901      		movw r24,r18
 1123 049a 880F      		lsl r24
 1124 049c 991F      		rol r25
 1125 049e 880F      		lsl r24
 1126 04a0 991F      		rol r25
 1127 04a2 820F      		add r24,r18
 1128 04a4 931F      		adc r25,r19
 1129 04a6 8050      		subi r24,lo8(-(nodes_info_arr+2))
 1130 04a8 9040      		sbci r25,hi8(-(nodes_info_arr+2))
 1131 04aa FC01      		movw r30,r24
 1132 04ac 5183      		std Z+1,r21
 1133 04ae 4083      		st Z,r20
 181:ServerLLDN.c  **** 		nodes_info_arr[i].req_timeslot_duration = node->ts_dir.tsDuration;
 1134               		.loc 6 181 0
 1135 04b0 8B81      		ldd r24,Y+3
 1136 04b2 9C81      		ldd r25,Y+4
 1137 04b4 FC01      		movw r30,r24
 1138 04b6 8581      		ldd r24,Z+5
 1139 04b8 8F77      		andi r24,lo8(127)
 1140 04ba 482F      		mov r20,r24
 1141 04bc 2981      		ldd r18,Y+1
 1142 04be 3A81      		ldd r19,Y+2
 1143 04c0 C901      		movw r24,r18
 1144 04c2 880F      		lsl r24
 1145 04c4 991F      		rol r25
 1146 04c6 880F      		lsl r24
 1147 04c8 991F      		rol r25
 1148 04ca 820F      		add r24,r18
 1149 04cc 931F      		adc r25,r19
 1150 04ce 8050      		subi r24,lo8(-(nodes_info_arr+4))
 1151 04d0 9040      		sbci r25,hi8(-(nodes_info_arr+4))
 1152 04d2 FC01      		movw r30,r24
 1153 04d4 4083      		st Z,r20
 182:ServerLLDN.c  **** 		/*
 183:ServerLLDN.c  **** 		nodes_info_list_t* tmp = (nodes_info_list_t*)malloc( sizeof(nodes_info_list_t) );
 184:ServerLLDN.c  **** 		tmp->node = &nodes_info_arr[i];
 185:ServerLLDN.c  **** 		tmp->pos = i;
 186:ServerLLDN.c  **** 		tmp->next = conf_req_list;
 187:ServerLLDN.c  **** 		conf_req_list = tmp; */
 188:ServerLLDN.c  **** 	}
 1154               		.loc 6 188 0
 1155 04d6 0000      		nop
 1156               	/* epilogue start */
 1157 04d8 0F90      		pop __tmp_reg__
 1158 04da 0F90      		pop __tmp_reg__
 1159 04dc 0F90      		pop __tmp_reg__
 1160 04de 0F90      		pop __tmp_reg__
 1161 04e0 DF91      		pop r29
 1162 04e2 CF91      		pop r28
 1163 04e4 0895      		ret
 1164               		.cfi_endproc
 1165               	.LFE137:
 1167               		.section	.rodata
 1168               	.LC3:
 1169 0034 0A44 4953 		.string	"\nDISC %hhx"
 1169      4320 2568 
 1169      6878 00
 1170               	.LC4:
 1171 003f 0A43 4F4E 		.string	"\nCONF %d"
 1171      4620 2564 
 1171      00
 1172               		.text
 1174               	appCommandInd:
 1175               	.LFB138:
 189:ServerLLDN.c  **** 
 190:ServerLLDN.c  **** 	static bool appCommandInd(NWK_DataInd_t *ind)
 191:ServerLLDN.c  **** 	{
 1176               		.loc 6 191 0
 1177               		.cfi_startproc
 1178 04e6 CF93      		push r28
 1179               	.LCFI57:
 1180               		.cfi_def_cfa_offset 3
 1181               		.cfi_offset 28, -2
 1182 04e8 DF93      		push r29
 1183               	.LCFI58:
 1184               		.cfi_def_cfa_offset 4
 1185               		.cfi_offset 29, -3
 1186 04ea 00D0      		rcall .
 1187 04ec 00D0      		rcall .
 1188 04ee 00D0      		rcall .
 1189               	.LCFI59:
 1190               		.cfi_def_cfa_offset 10
 1191 04f0 CDB7      		in r28,__SP_L__
 1192 04f2 DEB7      		in r29,__SP_H__
 1193               	.LCFI60:
 1194               		.cfi_def_cfa_register 28
 1195               	/* prologue: function */
 1196               	/* frame size = 6 */
 1197               	/* stack size = 8 */
 1198               	.L__stack_usage = 8
 1199 04f4 9E83      		std Y+6,r25
 1200 04f6 8D83      		std Y+5,r24
 192:ServerLLDN.c  **** 		if(ind->data[0] == LL_DISCOVER_RESPONSE)
 1201               		.loc 6 192 0
 1202 04f8 8D81      		ldd r24,Y+5
 1203 04fa 9E81      		ldd r25,Y+6
 1204 04fc FC01      		movw r30,r24
 1205 04fe 8085      		ldd r24,Z+8
 1206 0500 9185      		ldd r25,Z+9
 1207 0502 FC01      		movw r30,r24
 1208 0504 8081      		ld r24,Z
 1209 0506 8D30      		cpi r24,lo8(13)
 1210 0508 01F4      		brne .L36
 1211               	.LBB2:
 193:ServerLLDN.c  **** 		{
 194:ServerLLDN.c  **** 			NWK_DiscoverResponse_t *msg = (NWK_DiscoverResponse_t*)ind->data;
 1212               		.loc 6 194 0
 1213 050a 8D81      		ldd r24,Y+5
 1214 050c 9E81      		ldd r25,Y+6
 1215 050e FC01      		movw r30,r24
 1216 0510 8085      		ldd r24,Z+8
 1217 0512 9185      		ldd r25,Z+9
 1218 0514 9C83      		std Y+4,r25
 1219 0516 8B83      		std Y+3,r24
 195:ServerLLDN.c  **** 			msg->macAddr = ind->data[2];
 1220               		.loc 6 195 0
 1221 0518 8D81      		ldd r24,Y+5
 1222 051a 9E81      		ldd r25,Y+6
 1223 051c FC01      		movw r30,r24
 1224 051e 8085      		ldd r24,Z+8
 1225 0520 9185      		ldd r25,Z+9
 1226 0522 0296      		adiw r24,2
 1227 0524 FC01      		movw r30,r24
 1228 0526 8081      		ld r24,Z
 1229 0528 282F      		mov r18,r24
 1230 052a 30E0      		ldi r19,0
 1231 052c 8B81      		ldd r24,Y+3
 1232 052e 9C81      		ldd r25,Y+4
 1233 0530 FC01      		movw r30,r24
 1234 0532 3283      		std Z+2,r19
 1235 0534 2183      		std Z+1,r18
 196:ServerLLDN.c  **** 			addToAckArray(msg->macAddr);	
 1236               		.loc 6 196 0
 1237 0536 8B81      		ldd r24,Y+3
 1238 0538 9C81      		ldd r25,Y+4
 1239 053a FC01      		movw r30,r24
 1240 053c 8181      		ldd r24,Z+1
 1241 053e 9281      		ldd r25,Z+2
 1242 0540 0E94 0000 		call addToAckArray
 197:ServerLLDN.c  **** 					
 198:ServerLLDN.c  **** 			#if PRINT
 199:ServerLLDN.c  **** 			printf("\nDISC %hhx", msg->ts_dir);	
 1243               		.loc 6 199 0
 1244 0544 8B81      		ldd r24,Y+3
 1245 0546 9C81      		ldd r25,Y+4
 1246 0548 FC01      		movw r30,r24
 1247 054a 8381      		ldd r24,Z+3
 1248 054c 8F93      		push r24
 1249 054e 80E0      		ldi r24,lo8(.LC3)
 1250 0550 90E0      		ldi r25,hi8(.LC3)
 1251 0552 892F      		mov r24,r25
 1252 0554 8F93      		push r24
 1253 0556 80E0      		ldi r24,lo8(.LC3)
 1254 0558 90E0      		ldi r25,hi8(.LC3)
 1255 055a 8F93      		push r24
 1256 055c 0E94 0000 		call printf
 1257 0560 0F90      		pop __tmp_reg__
 1258 0562 0F90      		pop __tmp_reg__
 1259 0564 0F90      		pop __tmp_reg__
 1260               	.LBE2:
 1261 0566 00C0      		rjmp .L37
 1262               	.L36:
 200:ServerLLDN.c  **** 			#endif
 201:ServerLLDN.c  **** 		}
 202:ServerLLDN.c  **** 		else if(ind->data[0] == LL_CONFIGURATION_STATUS)
 1263               		.loc 6 202 0
 1264 0568 8D81      		ldd r24,Y+5
 1265 056a 9E81      		ldd r25,Y+6
 1266 056c FC01      		movw r30,r24
 1267 056e 8085      		ldd r24,Z+8
 1268 0570 9185      		ldd r25,Z+9
 1269 0572 FC01      		movw r30,r24
 1270 0574 8081      		ld r24,Z
 1271 0576 8E30      		cpi r24,lo8(14)
 1272 0578 01F4      		brne .L38
 1273               	.LBB3:
 203:ServerLLDN.c  **** 		{
 204:ServerLLDN.c  **** 			NWK_ConfigStatus_t *msg = (NWK_ConfigStatus_t*)ind->data;
 1274               		.loc 6 204 0
 1275 057a 8D81      		ldd r24,Y+5
 1276 057c 9E81      		ldd r25,Y+6
 1277 057e FC01      		movw r30,r24
 1278 0580 8085      		ldd r24,Z+8
 1279 0582 9185      		ldd r25,Z+9
 1280 0584 9A83      		std Y+2,r25
 1281 0586 8983      		std Y+1,r24
 205:ServerLLDN.c  **** 			addConfRequestArray(msg);
 1282               		.loc 6 205 0
 1283 0588 8981      		ldd r24,Y+1
 1284 058a 9A81      		ldd r25,Y+2
 1285 058c 0E94 0000 		call addConfRequestArray
 206:ServerLLDN.c  **** 			#if PRINT
 207:ServerLLDN.c  **** 			printf("\nCONF %d", msg->macAddr);	
 1286               		.loc 6 207 0
 1287 0590 8981      		ldd r24,Y+1
 1288 0592 9A81      		ldd r25,Y+2
 1289 0594 FC01      		movw r30,r24
 1290 0596 8381      		ldd r24,Z+3
 1291 0598 9481      		ldd r25,Z+4
 1292 059a 292F      		mov r18,r25
 1293 059c 2F93      		push r18
 1294 059e 8F93      		push r24
 1295 05a0 80E0      		ldi r24,lo8(.LC4)
 1296 05a2 90E0      		ldi r25,hi8(.LC4)
 1297 05a4 892F      		mov r24,r25
 1298 05a6 8F93      		push r24
 1299 05a8 80E0      		ldi r24,lo8(.LC4)
 1300 05aa 90E0      		ldi r25,hi8(.LC4)
 1301 05ac 8F93      		push r24
 1302 05ae 0E94 0000 		call printf
 1303 05b2 0F90      		pop __tmp_reg__
 1304 05b4 0F90      		pop __tmp_reg__
 1305 05b6 0F90      		pop __tmp_reg__
 1306 05b8 0F90      		pop __tmp_reg__
 1307               	.LBE3:
 1308 05ba 00C0      		rjmp .L37
 1309               	.L38:
 208:ServerLLDN.c  **** 			#endif
 209:ServerLLDN.c  **** 		}
 210:ServerLLDN.c  **** 		else return false;			
 1310               		.loc 6 210 0
 1311 05bc 80E0      		ldi r24,0
 1312 05be 00C0      		rjmp .L39
 1313               	.L37:
 211:ServerLLDN.c  **** 		return true;
 1314               		.loc 6 211 0
 1315 05c0 81E0      		ldi r24,lo8(1)
 1316               	.L39:
 1317               	/* epilogue start */
 212:ServerLLDN.c  **** 	}
 1318               		.loc 6 212 0
 1319 05c2 2696      		adiw r28,6
 1320 05c4 0FB6      		in __tmp_reg__,__SREG__
 1321 05c6 F894      		cli
 1322 05c8 DEBF      		out __SP_H__,r29
 1323 05ca 0FBE      		out __SREG__,__tmp_reg__
 1324 05cc CDBF      		out __SP_L__,r28
 1325 05ce DF91      		pop r29
 1326 05d0 CF91      		pop r28
 1327 05d2 0895      		ret
 1328               		.cfi_endproc
 1329               	.LFE138:
 1332               	appPanPrepareACK:
 1333               	.LFB139:
 213:ServerLLDN.c  **** 	
 214:ServerLLDN.c  **** 	static void appPanPrepareACK(void)
 215:ServerLLDN.c  **** 	{
 1334               		.loc 6 215 0
 1335               		.cfi_startproc
 1336 05d4 CF93      		push r28
 1337               	.LCFI61:
 1338               		.cfi_def_cfa_offset 3
 1339               		.cfi_offset 28, -2
 1340 05d6 DF93      		push r29
 1341               	.LCFI62:
 1342               		.cfi_def_cfa_offset 4
 1343               		.cfi_offset 29, -3
 1344 05d8 CDB7      		in r28,__SP_L__
 1345 05da DEB7      		in r29,__SP_H__
 1346               	.LCFI63:
 1347               		.cfi_def_cfa_register 28
 1348               	/* prologue: function */
 1349               	/* frame size = 0 */
 1350               	/* stack size = 2 */
 1351               	.L__stack_usage = 2
 216:ServerLLDN.c  **** 		msgReq.dstAddr		= 0;
 1352               		.loc 6 216 0
 1353 05dc 1092 0000 		sts msgReq+5+1,__zero_reg__
 1354 05e0 1092 0000 		sts msgReq+5,__zero_reg__
 217:ServerLLDN.c  **** 		msgReq.dstEndpoint	= APP_BEACON_ENDPOINT;
 1355               		.loc 6 217 0
 1356 05e4 1092 0000 		sts msgReq+7,__zero_reg__
 218:ServerLLDN.c  **** 		msgReq.srcEndpoint	= APP_BEACON_ENDPOINT;
 1357               		.loc 6 218 0
 1358 05e8 1092 0000 		sts msgReq+8,__zero_reg__
 219:ServerLLDN.c  **** 		msgReq.options		= NWK_OPT_LLDN_ACK;
 1359               		.loc 6 219 0
 1360 05ec 80E0      		ldi r24,0
 1361 05ee 90E4      		ldi r25,lo8(64)
 1362 05f0 9093 0000 		sts msgReq+9+1,r25
 1363 05f4 8093 0000 		sts msgReq+9,r24
 220:ServerLLDN.c  **** 		if(ACKFrame_size != 0)
 1364               		.loc 6 220 0
 1365 05f8 8091 0000 		lds r24,ACKFrame_size
 1366 05fc 9091 0000 		lds r25,ACKFrame_size+1
 1367 0600 892B      		or r24,r25
 1368 0602 01F0      		breq .L41
 221:ServerLLDN.c  **** 		{
 222:ServerLLDN.c  **** 			msgReq.data	= (uint8_t *)&ACKFrame;
 1369               		.loc 6 222 0
 1370 0604 80E0      		ldi r24,lo8(ACKFrame)
 1371 0606 90E0      		ldi r25,hi8(ACKFrame)
 1372 0608 9093 0000 		sts msgReq+13+1,r25
 1373 060c 8093 0000 		sts msgReq+13,r24
 223:ServerLLDN.c  **** 			msgReq.size	= sizeof(uint8_t)*(ACKFrame_size + 1);
 1374               		.loc 6 223 0
 1375 0610 8091 0000 		lds r24,ACKFrame_size
 1376 0614 9091 0000 		lds r25,ACKFrame_size+1
 1377 0618 8F5F      		subi r24,lo8(-(1))
 1378 061a 8093 0000 		sts msgReq+15,r24
 224:ServerLLDN.c  **** 		}
 225:ServerLLDN.c  **** 		else
 226:ServerLLDN.c  **** 		{
 227:ServerLLDN.c  **** 			msgReq.data	= 0;
 228:ServerLLDN.c  **** 			msgReq.size	= 0;
 229:ServerLLDN.c  **** 		}
 230:ServerLLDN.c  **** 	}
 1379               		.loc 6 230 0
 1380 061e 00C0      		rjmp .L43
 1381               	.L41:
 227:ServerLLDN.c  **** 			msgReq.size	= 0;
 1382               		.loc 6 227 0
 1383 0620 1092 0000 		sts msgReq+13+1,__zero_reg__
 1384 0624 1092 0000 		sts msgReq+13,__zero_reg__
 228:ServerLLDN.c  **** 		}
 1385               		.loc 6 228 0
 1386 0628 1092 0000 		sts msgReq+15,__zero_reg__
 1387               	.L43:
 1388               		.loc 6 230 0
 1389 062c 0000      		nop
 1390               	/* epilogue start */
 1391 062e DF91      		pop r29
 1392 0630 CF91      		pop r28
 1393 0632 0895      		ret
 1394               		.cfi_endproc
 1395               	.LFE139:
 1398               	appPanReset:
 1399               	.LFB140:
 231:ServerLLDN.c  **** 
 232:ServerLLDN.c  **** 	static void appPanReset(void)
 233:ServerLLDN.c  **** 	{
 1400               		.loc 6 233 0
 1401               		.cfi_startproc
 1402 0634 CF93      		push r28
 1403               	.LCFI64:
 1404               		.cfi_def_cfa_offset 3
 1405               		.cfi_offset 28, -2
 1406 0636 DF93      		push r29
 1407               	.LCFI65:
 1408               		.cfi_def_cfa_offset 4
 1409               		.cfi_offset 29, -3
 1410 0638 00D0      		rcall .
 1411 063a 00D0      		rcall .
 1412               	.LCFI66:
 1413               		.cfi_def_cfa_offset 8
 1414 063c CDB7      		in r28,__SP_L__
 1415 063e DEB7      		in r29,__SP_H__
 1416               	.LCFI67:
 1417               		.cfi_def_cfa_register 28
 1418               	/* prologue: function */
 1419               	/* frame size = 4 */
 1420               	/* stack size = 6 */
 1421               	.L__stack_usage = 6
 234:ServerLLDN.c  **** 		// prepare beacon reset message
 235:ServerLLDN.c  **** 		msgReq.dstAddr		= 0;
 1422               		.loc 6 235 0
 1423 0640 1092 0000 		sts msgReq+5+1,__zero_reg__
 1424 0644 1092 0000 		sts msgReq+5,__zero_reg__
 236:ServerLLDN.c  **** 		msgReq.dstEndpoint	= APP_BEACON_ENDPOINT;
 1425               		.loc 6 236 0
 1426 0648 1092 0000 		sts msgReq+7,__zero_reg__
 237:ServerLLDN.c  **** 		msgReq.srcEndpoint	= APP_BEACON_ENDPOINT;
 1427               		.loc 6 237 0
 1428 064c 1092 0000 		sts msgReq+8,__zero_reg__
 238:ServerLLDN.c  **** 		msgReq.options		= NWK_OPT_LLDN_BEACON | NWK_OPT_RESET_STATE;
 1429               		.loc 6 238 0
 1430 0650 80E4      		ldi r24,lo8(64)
 1431 0652 94E0      		ldi r25,lo8(4)
 1432 0654 9093 0000 		sts msgReq+9+1,r25
 1433 0658 8093 0000 		sts msgReq+9,r24
 239:ServerLLDN.c  **** 		msgReq.data			= NULL;
 1434               		.loc 6 239 0
 1435 065c 1092 0000 		sts msgReq+13+1,__zero_reg__
 1436 0660 1092 0000 		sts msgReq+13,__zero_reg__
 240:ServerLLDN.c  **** 		msgReq.size			= 0;
 1437               		.loc 6 240 0
 1438 0664 1092 0000 		sts msgReq+15,__zero_reg__
 1439               	.LBB4:
 241:ServerLLDN.c  **** 
 242:ServerLLDN.c  **** 		for(int i = 0; i < 32; i++)
 1440               		.loc 6 242 0
 1441 0668 1A82      		std Y+2,__zero_reg__
 1442 066a 1982      		std Y+1,__zero_reg__
 1443 066c 00C0      		rjmp .L45
 1444               	.L46:
 243:ServerLLDN.c  **** 			ACKFrame.ackFlags[i] = 0;
 1445               		.loc 6 243 0 discriminator 3
 1446 066e 8981      		ldd r24,Y+1
 1447 0670 9A81      		ldd r25,Y+2
 1448 0672 8050      		subi r24,lo8(-(ACKFrame+1))
 1449 0674 9040      		sbci r25,hi8(-(ACKFrame+1))
 1450 0676 FC01      		movw r30,r24
 1451 0678 1082      		st Z,__zero_reg__
 242:ServerLLDN.c  **** 			ACKFrame.ackFlags[i] = 0;
 1452               		.loc 6 242 0 discriminator 3
 1453 067a 8981      		ldd r24,Y+1
 1454 067c 9A81      		ldd r25,Y+2
 1455 067e 0196      		adiw r24,1
 1456 0680 9A83      		std Y+2,r25
 1457 0682 8983      		std Y+1,r24
 1458               	.L45:
 242:ServerLLDN.c  **** 			ACKFrame.ackFlags[i] = 0;
 1459               		.loc 6 242 0 is_stmt 0 discriminator 1
 1460 0684 8981      		ldd r24,Y+1
 1461 0686 9A81      		ldd r25,Y+2
 1462 0688 8097      		sbiw r24,32
 1463 068a 04F0      		brlt .L46
 1464               	.LBE4:
 1465               	.LBB5:
 244:ServerLLDN.c  **** 		for (int i = 0; i < 255; i++)
 1466               		.loc 6 244 0 is_stmt 1
 1467 068c 1C82      		std Y+4,__zero_reg__
 1468 068e 1B82      		std Y+3,__zero_reg__
 1469 0690 00C0      		rjmp .L47
 1470               	.L48:
 245:ServerLLDN.c  **** 			nodes_info_arr[i].mac_addr = 0;
 1471               		.loc 6 245 0 discriminator 3
 1472 0692 2B81      		ldd r18,Y+3
 1473 0694 3C81      		ldd r19,Y+4
 1474 0696 C901      		movw r24,r18
 1475 0698 880F      		lsl r24
 1476 069a 991F      		rol r25
 1477 069c 880F      		lsl r24
 1478 069e 991F      		rol r25
 1479 06a0 820F      		add r24,r18
 1480 06a2 931F      		adc r25,r19
 1481 06a4 8050      		subi r24,lo8(-(nodes_info_arr+2))
 1482 06a6 9040      		sbci r25,hi8(-(nodes_info_arr+2))
 1483 06a8 FC01      		movw r30,r24
 1484 06aa 1182      		std Z+1,__zero_reg__
 1485 06ac 1082      		st Z,__zero_reg__
 244:ServerLLDN.c  **** 		for (int i = 0; i < 255; i++)
 1486               		.loc 6 244 0 discriminator 3
 1487 06ae 8B81      		ldd r24,Y+3
 1488 06b0 9C81      		ldd r25,Y+4
 1489 06b2 0196      		adiw r24,1
 1490 06b4 9C83      		std Y+4,r25
 1491 06b6 8B83      		std Y+3,r24
 1492               	.L47:
 244:ServerLLDN.c  **** 		for (int i = 0; i < 255; i++)
 1493               		.loc 6 244 0 is_stmt 0 discriminator 1
 1494 06b8 8B81      		ldd r24,Y+3
 1495 06ba 9C81      		ldd r25,Y+4
 1496 06bc 8F3F      		cpi r24,-1
 1497 06be 9105      		cpc r25,__zero_reg__
 1498 06c0 04F0      		brlt .L48
 1499               	.LBE5:
 246:ServerLLDN.c  **** 		
 247:ServerLLDN.c  **** 		ACKFrame_size = 0;
 1500               		.loc 6 247 0 is_stmt 1
 1501 06c2 1092 0000 		sts ACKFrame_size+1,__zero_reg__
 1502 06c6 1092 0000 		sts ACKFrame_size,__zero_reg__
 248:ServerLLDN.c  **** 		index_nodes_array = 0;
 1503               		.loc 6 248 0
 1504 06ca 1092 0000 		sts index_nodes_array+1,__zero_reg__
 1505 06ce 1092 0000 		sts index_nodes_array,__zero_reg__
 249:ServerLLDN.c  **** 		counter_associados = 0;
 1506               		.loc 6 249 0
 1507 06d2 1092 0000 		sts counter_associados+1,__zero_reg__
 1508 06d6 1092 0000 		sts counter_associados,__zero_reg__
 250:ServerLLDN.c  **** 		n = 0;
 1509               		.loc 6 250 0
 1510 06da 1092 0000 		sts n,__zero_reg__
 251:ServerLLDN.c  **** 	}
 1511               		.loc 6 251 0
 1512 06de 0000      		nop
 1513               	/* epilogue start */
 1514 06e0 0F90      		pop __tmp_reg__
 1515 06e2 0F90      		pop __tmp_reg__
 1516 06e4 0F90      		pop __tmp_reg__
 1517 06e6 0F90      		pop __tmp_reg__
 1518 06e8 DF91      		pop r29
 1519 06ea CF91      		pop r28
 1520 06ec 0895      		ret
 1521               		.cfi_endproc
 1522               	.LFE140:
 1524               	.global	__floatsisf
 1525               	.global	__addsf3
 1526               	.global	__divsf3
 1527               	.global	__mulsf3
 1528               	.global	__fixunssfsi
 1530               	appPanDiscInit:
 1531               	.LFB141:
 252:ServerLLDN.c  **** 
 253:ServerLLDN.c  **** 	static void appPanDiscInit(void)
 254:ServerLLDN.c  **** 	{	
 1532               		.loc 6 254 0
 1533               		.cfi_startproc
 1534 06ee CF93      		push r28
 1535               	.LCFI68:
 1536               		.cfi_def_cfa_offset 3
 1537               		.cfi_offset 28, -2
 1538 06f0 DF93      		push r29
 1539               	.LCFI69:
 1540               		.cfi_def_cfa_offset 4
 1541               		.cfi_offset 29, -3
 1542 06f2 00D0      		rcall .
 1543               	.LCFI70:
 1544               		.cfi_def_cfa_offset 6
 1545 06f4 CDB7      		in r28,__SP_L__
 1546 06f6 DEB7      		in r29,__SP_H__
 1547               	.LCFI71:
 1548               		.cfi_def_cfa_register 28
 1549               	/* prologue: function */
 1550               	/* frame size = 2 */
 1551               	/* stack size = 4 */
 1552               	.L__stack_usage = 4
 1553               	.LBB6:
 255:ServerLLDN.c  **** 		/* clear Ack array of previous discovery state */
 256:ServerLLDN.c  **** 		for(int i = 0; i < 32; i++)
 1554               		.loc 6 256 0
 1555 06f8 1A82      		std Y+2,__zero_reg__
 1556 06fa 1982      		std Y+1,__zero_reg__
 1557 06fc 00C0      		rjmp .L50
 1558               	.L51:
 257:ServerLLDN.c  **** 			ACKFrame.ackFlags[i] = 0;
 1559               		.loc 6 257 0 discriminator 3
 1560 06fe 8981      		ldd r24,Y+1
 1561 0700 9A81      		ldd r25,Y+2
 1562 0702 8050      		subi r24,lo8(-(ACKFrame+1))
 1563 0704 9040      		sbci r25,hi8(-(ACKFrame+1))
 1564 0706 FC01      		movw r30,r24
 1565 0708 1082      		st Z,__zero_reg__
 256:ServerLLDN.c  **** 			ACKFrame.ackFlags[i] = 0;
 1566               		.loc 6 256 0 discriminator 3
 1567 070a 8981      		ldd r24,Y+1
 1568 070c 9A81      		ldd r25,Y+2
 1569 070e 0196      		adiw r24,1
 1570 0710 9A83      		std Y+2,r25
 1571 0712 8983      		std Y+1,r24
 1572               	.L50:
 256:ServerLLDN.c  **** 			ACKFrame.ackFlags[i] = 0;
 1573               		.loc 6 256 0 is_stmt 0 discriminator 1
 1574 0714 8981      		ldd r24,Y+1
 1575 0716 9A81      		ldd r25,Y+2
 1576 0718 8097      		sbiw r24,32
 1577 071a 04F0      		brlt .L51
 1578               	.LBE6:
 258:ServerLLDN.c  **** 		ACKFrame_size = 0;
 1579               		.loc 6 258 0 is_stmt 1
 1580 071c 1092 0000 		sts ACKFrame_size+1,__zero_reg__
 1581 0720 1092 0000 		sts ACKFrame_size,__zero_reg__
 259:ServerLLDN.c  **** 		/* Prepare Beacon Message as first beacon in discovery state */		
 260:ServerLLDN.c  **** 		msgReq.dstAddr				= 0;
 1582               		.loc 6 260 0
 1583 0724 1092 0000 		sts msgReq+5+1,__zero_reg__
 1584 0728 1092 0000 		sts msgReq+5,__zero_reg__
 261:ServerLLDN.c  **** 		msgReq.dstEndpoint			= APP_BEACON_ENDPOINT;
 1585               		.loc 6 261 0
 1586 072c 1092 0000 		sts msgReq+7,__zero_reg__
 262:ServerLLDN.c  **** 		msgReq.srcEndpoint			= APP_BEACON_ENDPOINT;
 1587               		.loc 6 262 0
 1588 0730 1092 0000 		sts msgReq+8,__zero_reg__
 263:ServerLLDN.c  **** 		msgReq.options				= NWK_OPT_LLDN_BEACON | NWK_OPT_DISCOVERY_STATE;
 1589               		.loc 6 263 0
 1590 0734 80E4      		ldi r24,lo8(64)
 1591 0736 91E0      		ldi r25,lo8(1)
 1592 0738 9093 0000 		sts msgReq+9+1,r25
 1593 073c 8093 0000 		sts msgReq+9,r24
 264:ServerLLDN.c  **** 		msgReq.data					= NULL;
 1594               		.loc 6 264 0
 1595 0740 1092 0000 		sts msgReq+13+1,__zero_reg__
 1596 0744 1092 0000 		sts msgReq+13,__zero_reg__
 265:ServerLLDN.c  **** 		msgReq.size					= 0;
 1597               		.loc 6 265 0
 1598 0748 1092 0000 		sts msgReq+15,__zero_reg__
 266:ServerLLDN.c  **** 		
 267:ServerLLDN.c  **** 		
 268:ServerLLDN.c  **** 		/* Only start timers if it is the first association process */
 269:ServerLLDN.c  **** 		if(cycles_counter == 0) 
 1599               		.loc 6 269 0
 1600 074c 8091 0000 		lds r24,cycles_counter
 1601 0750 8823      		tst r24
 1602 0752 01F0      		breq .+2
 1603 0754 00C0      		rjmp .L53
 270:ServerLLDN.c  **** 		{
 271:ServerLLDN.c  **** 			
 272:ServerLLDN.c  **** 		/* Calculates Beacon Intervals according to 802.15.4e - 2012 p. 70 */
 273:ServerLLDN.c  **** 		n = 127; 
 1604               		.loc 6 273 0
 1605 0756 8FE7      		ldi r24,lo8(127)
 1606 0758 8093 0000 		sts n,r24
 274:ServerLLDN.c  **** 		tTS =  ((p_var*sp + (m+n)*sm + macMinLIFSPeriod)/v_var);
 1607               		.loc 6 274 0
 1608 075c 8091 0000 		lds r24,n
 1609 0760 882F      		mov r24,r24
 1610 0762 90E0      		ldi r25,0
 1611 0764 0396      		adiw r24,3
 1612 0766 880F      		lsl r24
 1613 0768 991F      		rol r25
 1614 076a 092E      		mov __tmp_reg__,r25
 1615 076c 000C      		lsl r0
 1616 076e AA0B      		sbc r26,r26
 1617 0770 BB0B      		sbc r27,r27
 1618 0772 BC01      		movw r22,r24
 1619 0774 CD01      		movw r24,r26
 1620 0776 0E94 0000 		call __floatsisf
 1621 077a DC01      		movw r26,r24
 1622 077c CB01      		movw r24,r22
 1623 077e 20E0      		ldi r18,0
 1624 0780 30E0      		ldi r19,0
 1625 0782 40E4      		ldi r20,lo8(64)
 1626 0784 51E4      		ldi r21,lo8(65)
 1627 0786 BC01      		movw r22,r24
 1628 0788 CD01      		movw r24,r26
 1629 078a 0E94 0000 		call __addsf3
 1630 078e DC01      		movw r26,r24
 1631 0790 CB01      		movw r24,r22
 1632 0792 20E0      		ldi r18,0
 1633 0794 30E0      		ldi r19,0
 1634 0796 40E2      		ldi r20,lo8(32)
 1635 0798 52E4      		ldi r21,lo8(66)
 1636 079a BC01      		movw r22,r24
 1637 079c CD01      		movw r24,r26
 1638 079e 0E94 0000 		call __addsf3
 1639 07a2 DC01      		movw r26,r24
 1640 07a4 CB01      		movw r24,r22
 1641 07a6 20E0      		ldi r18,0
 1642 07a8 34E2      		ldi r19,lo8(36)
 1643 07aa 44E7      		ldi r20,lo8(116)
 1644 07ac 57E4      		ldi r21,lo8(71)
 1645 07ae BC01      		movw r22,r24
 1646 07b0 CD01      		movw r24,r26
 1647 07b2 0E94 0000 		call __divsf3
 1648 07b6 DC01      		movw r26,r24
 1649 07b8 CB01      		movw r24,r22
 1650 07ba 8093 0000 		sts tTS,r24
 1651 07be 9093 0000 		sts tTS+1,r25
 1652 07c2 A093 0000 		sts tTS+2,r26
 1653 07c6 B093 0000 		sts tTS+3,r27
 275:ServerLLDN.c  **** 		#if (MASTER_MACSC == 1)
 276:ServerLLDN.c  **** 		
 277:ServerLLDN.c  **** 			beaconInterval = 2 * numBaseTimeSlotperMgmt * (tTS) / (SYMBOL_TIME);
 1654               		.loc 6 277 0
 1655 07ca 8091 0000 		lds r24,tTS
 1656 07ce 9091 0000 		lds r25,tTS+1
 1657 07d2 A091 0000 		lds r26,tTS+2
 1658 07d6 B091 0000 		lds r27,tTS+3
 1659 07da 20E0      		ldi r18,0
 1660 07dc 30E0      		ldi r19,0
 1661 07de 40E8      		ldi r20,lo8(-128)
 1662 07e0 50E4      		ldi r21,lo8(64)
 1663 07e2 BC01      		movw r22,r24
 1664 07e4 CD01      		movw r24,r26
 1665 07e6 0E94 0000 		call __mulsf3
 1666 07ea DC01      		movw r26,r24
 1667 07ec CB01      		movw r24,r22
 1668 07ee 2DEB      		ldi r18,lo8(-67)
 1669 07f0 37E3      		ldi r19,lo8(55)
 1670 07f2 46E8      		ldi r20,lo8(-122)
 1671 07f4 57E3      		ldi r21,lo8(55)
 1672 07f6 BC01      		movw r22,r24
 1673 07f8 CD01      		movw r24,r26
 1674 07fa 0E94 0000 		call __divsf3
 1675 07fe DC01      		movw r26,r24
 1676 0800 CB01      		movw r24,r22
 1677 0802 8093 0000 		sts beaconInterval,r24
 1678 0806 9093 0000 		sts beaconInterval+1,r25
 1679 080a A093 0000 		sts beaconInterval+2,r26
 1680 080e B093 0000 		sts beaconInterval+3,r27
 278:ServerLLDN.c  **** 			/*
 279:ServerLLDN.c  **** 			* Configure interrupts callback functions
 280:ServerLLDN.c  **** 			* overflow interrupt, compare 1,2,3 interrupts
 281:ServerLLDN.c  **** 			*/
 282:ServerLLDN.c  **** 			macsc_set_cmp1_int_cb(lldn_server_beacon);
 1681               		.loc 6 282 0
 1682 0812 80E0      		ldi r24,lo8(gs(lldn_server_beacon))
 1683 0814 90E0      		ldi r25,hi8(gs(lldn_server_beacon))
 1684 0816 0E94 0000 		call macsc_set_cmp1_int_cb
 283:ServerLLDN.c  **** 			/*
 284:ServerLLDN.c  **** 			* Configure MACSC to generate compare interrupts from channels 1,2,3
 285:ServerLLDN.c  **** 			* Set compare mode to absolute, set compare value.
 286:ServerLLDN.c  **** 			*/
 287:ServerLLDN.c  **** 			macsc_enable_manual_bts();
 1685               		.loc 6 287 0
 1686 081a 0E94 0000 		call macsc_enable_manual_bts
 288:ServerLLDN.c  **** 			macsc_enable_cmp_int(MACSC_CC1);
 1687               		.loc 6 288 0
 1688 081e 81E0      		ldi r24,lo8(1)
 1689 0820 0E94 0000 		call macsc_enable_cmp_int
 289:ServerLLDN.c  **** 
 290:ServerLLDN.c  **** 			macsc_use_cmp(MACSC_RELATIVE_CMP, beaconInterval , MACSC_CC1);
 1690               		.loc 6 290 0
 1691 0824 8091 0000 		lds r24,beaconInterval
 1692 0828 9091 0000 		lds r25,beaconInterval+1
 1693 082c A091 0000 		lds r26,beaconInterval+2
 1694 0830 B091 0000 		lds r27,beaconInterval+3
 1695 0834 BC01      		movw r22,r24
 1696 0836 CD01      		movw r24,r26
 1697 0838 0E94 0000 		call __fixunssfsi
 1698 083c DC01      		movw r26,r24
 1699 083e CB01      		movw r24,r22
 1700 0840 21E0      		ldi r18,lo8(1)
 1701 0842 AC01      		movw r20,r24
 1702 0844 BD01      		movw r22,r26
 1703 0846 81E0      		ldi r24,lo8(1)
 1704 0848 0E94 0000 		call macsc_use_cmp
 1705               	.L53:
 291:ServerLLDN.c  **** 			
 292:ServerLLDN.c  **** 			/* Timer used in testing */
 293:ServerLLDN.c  **** 			#if TIMESLOT_TIMER
 294:ServerLLDN.c  **** 			macsc_set_cmp2_int_cb(teste_handler);	
 295:ServerLLDN.c  **** 			macsc_enable_cmp_int(MACSC_CC2);
 296:ServerLLDN.c  **** 			macsc_use_cmp(MACSC_RELATIVE_CMP, beaconInterval / 2, MACSC_CC2);
 297:ServerLLDN.c  **** 			#endif
 298:ServerLLDN.c  **** 			
 299:ServerLLDN.c  **** 		#endif
 300:ServerLLDN.c  **** 		}
 301:ServerLLDN.c  **** 	}
 1706               		.loc 6 301 0
 1707 084c 0000      		nop
 1708               	/* epilogue start */
 1709 084e 0F90      		pop __tmp_reg__
 1710 0850 0F90      		pop __tmp_reg__
 1711 0852 DF91      		pop r29
 1712 0854 CF91      		pop r28
 1713 0856 0895      		ret
 1714               		.cfi_endproc
 1715               	.LFE141:
 1718               	appPanOnlineInit:
 1719               	.LFB142:
 302:ServerLLDN.c  **** 
 303:ServerLLDN.c  **** 	static void appPanOnlineInit()
 304:ServerLLDN.c  **** 	{
 1720               		.loc 6 304 0
 1721               		.cfi_startproc
 1722 0858 CF93      		push r28
 1723               	.LCFI72:
 1724               		.cfi_def_cfa_offset 3
 1725               		.cfi_offset 28, -2
 1726 085a DF93      		push r29
 1727               	.LCFI73:
 1728               		.cfi_def_cfa_offset 4
 1729               		.cfi_offset 29, -3
 1730 085c CDB7      		in r28,__SP_L__
 1731 085e DEB7      		in r29,__SP_H__
 1732               	.LCFI74:
 1733               		.cfi_def_cfa_register 28
 1734               	/* prologue: function */
 1735               	/* frame size = 0 */
 1736               	/* stack size = 2 */
 1737               	.L__stack_usage = 2
 305:ServerLLDN.c  **** 		/*
 306:ServerLLDN.c  **** 		tTS =  ((p_var*sp + (m+n)*sm + macMinLIFSPeriod)/v_var);
 307:ServerLLDN.c  **** 		// beaconInterval = (assTimeSlot + MacLLDNMgmtTS*numBaseTimeSlotperMgmt) * tTS / (SYMBOL_TIME); /
 308:ServerLLDN.c  **** 		// Configure Timers
 309:ServerLLDN.c  **** 		macsc_set_cmp1_int_cb(end_of_online_handler);
 310:ServerLLDN.c  **** 		macsc_enable_manual_bts();
 311:ServerLLDN.c  **** 		macsc_enable_cmp_int(MACSC_CC1);
 312:ServerLLDN.c  **** 		macsc_use_cmp(MACSC_RELATIVE_CMP, beaconInterval, MACSC_CC1);
 313:ServerLLDN.c  **** 		
 314:ServerLLDN.c  **** 		/* prepares online beacon , PRECISA SER REVISADO COM A NORMA, ESTOU EM DVIDA NO TIMESLOTE SIZE, 
 315:ServerLLDN.c  **** 		msgReq.dstAddr				= 0;
 1738               		.loc 6 315 0
 1739 0860 1092 0000 		sts msgReq+5+1,__zero_reg__
 1740 0864 1092 0000 		sts msgReq+5,__zero_reg__
 316:ServerLLDN.c  **** 		msgReq.dstEndpoint			= APP_BEACON_ENDPOINT;
 1741               		.loc 6 316 0
 1742 0868 1092 0000 		sts msgReq+7,__zero_reg__
 317:ServerLLDN.c  **** 		msgReq.srcEndpoint			= APP_BEACON_ENDPOINT;
 1743               		.loc 6 317 0
 1744 086c 1092 0000 		sts msgReq+8,__zero_reg__
 318:ServerLLDN.c  **** 		msgReq.options				= NWK_OPT_LLDN_BEACON | NWK_OPT_ONLINE_STATE;
 1745               		.loc 6 318 0
 1746 0870 80EC      		ldi r24,lo8(-64)
 1747 0872 90E0      		ldi r25,0
 1748 0874 9093 0000 		sts msgReq+9+1,r25
 1749 0878 8093 0000 		sts msgReq+9,r24
 319:ServerLLDN.c  **** 		msgReq.data					= NULL;
 1750               		.loc 6 319 0
 1751 087c 1092 0000 		sts msgReq+13+1,__zero_reg__
 1752 0880 1092 0000 		sts msgReq+13,__zero_reg__
 320:ServerLLDN.c  **** 		msgReq.size					= 0;
 1753               		.loc 6 320 0
 1754 0884 1092 0000 		sts msgReq+15,__zero_reg__
 321:ServerLLDN.c  **** 		
 322:ServerLLDN.c  **** 	}
 1755               		.loc 6 322 0
 1756 0888 0000      		nop
 1757               	/* epilogue start */
 1758 088a DF91      		pop r29
 1759 088c CF91      		pop r28
 1760 088e 0895      		ret
 1761               		.cfi_endproc
 1762               	.LFE142:
 1764               		.section	.rodata
 1765               	.LC5:
 1766 0048 0A20 496E 		.string	"\n Inicio.."
 1766      6963 696F 
 1766      2E2E 00
 1767               		.text
 1769               	appInit:
 1770               	.LFB143:
 323:ServerLLDN.c  **** 
 324:ServerLLDN.c  **** 
 325:ServerLLDN.c  **** #else 
 326:ServerLLDN.c  **** 	uint8_t payloadSize = 0x01;
 327:ServerLLDN.c  **** 	uint8_t assTimeSlot = 0xFF;
 328:ServerLLDN.c  **** 	uint8_t n = 0;
 329:ServerLLDN.c  **** 	
 330:ServerLLDN.c  **** 	static NwkFrameBeaconHeaderLLDN_t *rec_beacon;
 331:ServerLLDN.c  **** 	static NWK_DiscoverResponse_t msgDiscResponse = { .id = LL_DISCOVER_RESPONSE,
 332:ServerLLDN.c  **** 													 .macAddr = APP_ADDR,
 333:ServerLLDN.c  **** 													 .ts_dir.tsDuration = 0x01,
 334:ServerLLDN.c  **** 													 .ts_dir.dirIndicator = 1 };
 335:ServerLLDN.c  **** 	static NWK_ConfigStatus_t msgConfigStatus = { .id = LL_CONFIGURATION_STATUS,
 336:ServerLLDN.c  **** 												 .macAddr = 0x0001,
 337:ServerLLDN.c  **** 												 .s_macAddr = 0x0001,
 338:ServerLLDN.c  **** 												 .ts_dir.dirIndicator = 1,
 339:ServerLLDN.c  **** 												 .assTimeSlot = 0xff };
 340:ServerLLDN.c  **** 	static bool ack_received;
 341:ServerLLDN.c  **** 	bool MacLLDNMgmtTS = 0; 
 342:ServerLLDN.c  **** 	bool associated = 0;
 343:ServerLLDN.c  **** 	
 344:ServerLLDN.c  **** 	static void send_message_timeHandler(void)
 345:ServerLLDN.c  **** 	{
 346:ServerLLDN.c  **** 		appState = APP_STATE_SEND;	
 347:ServerLLDN.c  **** 		#if MASTER_MACSC == 0
 348:ServerLLDN.c  **** 			timer_stop();
 349:ServerLLDN.c  **** 		#endif
 350:ServerLLDN.c  **** 	}
 351:ServerLLDN.c  **** 
 352:ServerLLDN.c  **** 	
 353:ServerLLDN.c  **** 	static bool appBeaconInd(NWK_DataInd_t *ind)
 354:ServerLLDN.c  **** 	{
 355:ServerLLDN.c  **** 		rec_beacon = (NwkFrameBeaconHeaderLLDN_t*)ind->data;
 356:ServerLLDN.c  **** 		//  bom implementar rotinas pra se o nodo estiver associado a um coordeandor e se no estiver
 357:ServerLLDN.c  **** 		PanId = rec_beacon->PanId; // s pode mudar se ele associar
 358:ServerLLDN.c  **** 		
 359:ServerLLDN.c  **** 		if( (rec_beacon->Flags.txState == DISC_MODE && !ack_received) || 
 360:ServerLLDN.c  **** 			(rec_beacon->Flags.txState == CONFIG_MODE && ack_received))
 361:ServerLLDN.c  **** 		{
 362:ServerLLDN.c  **** 			int msg_wait_time = rec_beacon->Flags.numBaseMgmtTimeslots * rec_beacon->TimeSlotSize* 2; // sym
 363:ServerLLDN.c  **** 			#if MASTER_MACSC
 364:ServerLLDN.c  **** 				macsc_enable_manual_bts();
 365:ServerLLDN.c  **** 				macsc_set_cmp1_int_cb(send_message_timeHandler);
 366:ServerLLDN.c  **** 				macsc_enable_cmp_int(MACSC_CC1); 
 367:ServerLLDN.c  **** 				macsc_use_cmp(MACSC_RELATIVE_CMP, msg_wait_time - 250, MACSC_CC1);
 368:ServerLLDN.c  **** 			#else
 369:ServerLLDN.c  **** 				timer_init();
 370:ServerLLDN.c  **** 				timer_delay(msg_wait_time/2 - 100);
 371:ServerLLDN.c  **** 				hw_timer_setup_handler(send_message_timeHandler);
 372:ServerLLDN.c  **** 				timer_start();
 373:ServerLLDN.c  **** 			#endif
 374:ServerLLDN.c  **** 			appState = (rec_beacon->Flags.txState == DISC_MODE) ? APP_STATE_PREP_DISC_REPONSE : APP_STATE_PR
 375:ServerLLDN.c  **** 		}
 376:ServerLLDN.c  **** 		else if (rec_beacon->Flags.txState == RESET_MODE)
 377:ServerLLDN.c  **** 		{
 378:ServerLLDN.c  **** 			ack_received = 0;
 379:ServerLLDN.c  **** 			associated = 0;
 380:ServerLLDN.c  **** 		}
 381:ServerLLDN.c  **** 
 382:ServerLLDN.c  **** 		return true;
 383:ServerLLDN.c  **** 	}
 384:ServerLLDN.c  **** 	
 385:ServerLLDN.c  **** 	static bool appAckInd(NWK_DataInd_t *ind)
 386:ServerLLDN.c  **** 	{
 387:ServerLLDN.c  **** 		NWK_ACKFormat_t *ackframe = (NWK_ACKFormat_t*)ind->data;
 388:ServerLLDN.c  **** 		if(PanId == ackframe->sourceId)
 389:ServerLLDN.c  **** 		{
 390:ServerLLDN.c  **** 			int pos = APP_ADDR / 8;
 391:ServerLLDN.c  **** 			int bit_shift = 8 - APP_ADDR % 8;
 392:ServerLLDN.c  **** 			if( ackframe->ackFlags[pos] & 1 << bit_shift)	
 393:ServerLLDN.c  **** 				{
 394:ServerLLDN.c  **** 				printf("\n ack true");
 395:ServerLLDN.c  **** 				ack_received = true;
 396:ServerLLDN.c  **** 				}
 397:ServerLLDN.c  **** 		}
 398:ServerLLDN.c  **** 		return true;
 399:ServerLLDN.c  **** 	}
 400:ServerLLDN.c  **** 	
 401:ServerLLDN.c  **** 	static bool appCommandInd(NWK_DataInd_t *ind)
 402:ServerLLDN.c  **** 	{
 403:ServerLLDN.c  **** 		if(ind->data[0] == LL_CONFIGURATION_REQUEST)
 404:ServerLLDN.c  **** 		{
 405:ServerLLDN.c  **** 			NWK_ConfigRequest_t *msg = (NWK_ConfigRequest_t*)ind->data;
 406:ServerLLDN.c  **** 			if(msg->macAddr == APP_ADDR)
 407:ServerLLDN.c  **** 			{
 408:ServerLLDN.c  **** 				PHY_SetChannel(msg->tx_channel);
 409:ServerLLDN.c  **** 				NWK_SetPanId(msg->s_macAddr);
 410:ServerLLDN.c  **** 				assTimeSlot = msg->assTimeSlot;
 411:ServerLLDN.c  **** 				n = msg->conf.tsDuration;
 412:ServerLLDN.c  **** 			}
 413:ServerLLDN.c  **** 		}
 414:ServerLLDN.c  **** 		return true;
 415:ServerLLDN.c  **** 	}
 416:ServerLLDN.c  **** 
 417:ServerLLDN.c  **** 	void appPrepareDiscoverResponse()
 418:ServerLLDN.c  **** 	{
 419:ServerLLDN.c  **** 		msgReq.dstAddr				= 0;
 420:ServerLLDN.c  **** 		msgReq.dstEndpoint			= APP_COMMAND_ENDPOINT;
 421:ServerLLDN.c  **** 		msgReq.srcEndpoint			= APP_COMMAND_ENDPOINT;
 422:ServerLLDN.c  **** 		msgReq.options				= NWK_OPT_MAC_COMMAND;
 423:ServerLLDN.c  **** 		msgReq.data					= (uint8_t*)&msgDiscResponse;
 424:ServerLLDN.c  **** 		msgReq.size					= sizeof(msgDiscResponse);
 425:ServerLLDN.c  **** 	}
 426:ServerLLDN.c  **** 	
 427:ServerLLDN.c  **** 	void appPrepareConfigurationStatus()
 428:ServerLLDN.c  **** 	{		
 429:ServerLLDN.c  **** 		msgReq.dstAddr				= 0;
 430:ServerLLDN.c  **** 		msgReq.dstEndpoint			= APP_COMMAND_ENDPOINT;
 431:ServerLLDN.c  **** 		msgReq.srcEndpoint			= APP_COMMAND_ENDPOINT;
 432:ServerLLDN.c  **** 		msgReq.options				= NWK_OPT_MAC_COMMAND;
 433:ServerLLDN.c  **** 		msgReq.data					= (uint8_t*)&msgConfigStatus;
 434:ServerLLDN.c  **** 		msgReq.size					= sizeof(msgConfigStatus);
 435:ServerLLDN.c  **** 	}
 436:ServerLLDN.c  **** 	
 437:ServerLLDN.c  **** #endif // APP_COORDINATOR
 438:ServerLLDN.c  **** 
 439:ServerLLDN.c  **** static void appInit(void)
 440:ServerLLDN.c  **** {
 1771               		.loc 6 440 0
 1772               		.cfi_startproc
 1773 0890 CF93      		push r28
 1774               	.LCFI75:
 1775               		.cfi_def_cfa_offset 3
 1776               		.cfi_offset 28, -2
 1777 0892 DF93      		push r29
 1778               	.LCFI76:
 1779               		.cfi_def_cfa_offset 4
 1780               		.cfi_offset 29, -3
 1781 0894 CDB7      		in r28,__SP_L__
 1782 0896 DEB7      		in r29,__SP_H__
 1783               	.LCFI77:
 1784               		.cfi_def_cfa_register 28
 1785               	/* prologue: function */
 1786               	/* frame size = 0 */
 1787               	/* stack size = 2 */
 1788               	.L__stack_usage = 2
 441:ServerLLDN.c  **** 	NWK_SetAddr(APP_ADDR);
 1789               		.loc 6 441 0
 1790 0898 80E0      		ldi r24,0
 1791 089a 90E0      		ldi r25,0
 1792 089c 0E94 0000 		call NWK_SetAddr
 442:ServerLLDN.c  **** 	PHY_SetChannel(APP_CHANNEL);
 1793               		.loc 6 442 0
 1794 08a0 8FE0      		ldi r24,lo8(15)
 1795 08a2 0E94 0000 		call PHY_SetChannel
 443:ServerLLDN.c  **** 	PHY_SetRxState(true);
 1796               		.loc 6 443 0
 1797 08a6 81E0      		ldi r24,lo8(1)
 1798 08a8 0E94 0000 		call PHY_SetRxState
 444:ServerLLDN.c  **** 		
 445:ServerLLDN.c  **** 	#if APP_COORDINATOR	 
 446:ServerLLDN.c  **** 	printf("\n Inicio.."); 
 1799               		.loc 6 446 0
 1800 08ac 80E0      		ldi r24,lo8(.LC5)
 1801 08ae 90E0      		ldi r25,hi8(.LC5)
 1802 08b0 892F      		mov r24,r25
 1803 08b2 8F93      		push r24
 1804 08b4 80E0      		ldi r24,lo8(.LC5)
 1805 08b6 90E0      		ldi r25,hi8(.LC5)
 1806 08b8 8F93      		push r24
 1807 08ba 0E94 0000 		call printf
 1808 08be 0F90      		pop __tmp_reg__
 1809 08c0 0F90      		pop __tmp_reg__
 447:ServerLLDN.c  **** 	  /* Timer used for delay between messages */
 448:ServerLLDN.c  **** 	  tmrDelay.interval = 2;
 1810               		.loc 6 448 0
 1811 08c2 82E0      		ldi r24,lo8(2)
 1812 08c4 90E0      		ldi r25,0
 1813 08c6 A0E0      		ldi r26,0
 1814 08c8 B0E0      		ldi r27,0
 1815 08ca 8093 0000 		sts tmrDelay+6,r24
 1816 08ce 9093 0000 		sts tmrDelay+6+1,r25
 1817 08d2 A093 0000 		sts tmrDelay+6+2,r26
 1818 08d6 B093 0000 		sts tmrDelay+6+3,r27
 449:ServerLLDN.c  **** 	  tmrDelay.mode = SYS_TIMER_INTERVAL_MODE;
 1819               		.loc 6 449 0
 1820 08da 1092 0000 		sts tmrDelay+10,__zero_reg__
 450:ServerLLDN.c  **** 	  tmrDelay.handler = tmrDelayHandler;
 1821               		.loc 6 450 0
 1822 08de 80E0      		ldi r24,lo8(gs(tmrDelayHandler))
 1823 08e0 90E0      		ldi r25,hi8(gs(tmrDelayHandler))
 1824 08e2 9093 0000 		sts tmrDelay+11+1,r25
 1825 08e6 8093 0000 		sts tmrDelay+11,r24
 451:ServerLLDN.c  **** 	  
 452:ServerLLDN.c  **** 		/* 
 453:ServerLLDN.c  **** 		* Disable CSMA/CA
 454:ServerLLDN.c  **** 		* Disable auto ACK
 455:ServerLLDN.c  **** 		*/
 456:ServerLLDN.c  **** 		NWK_SetPanId(APP_PANID);
 1826               		.loc 6 456 0
 1827 08ea 8EEF      		ldi r24,lo8(-2)
 1828 08ec 9AEC      		ldi r25,lo8(-54)
 1829 08ee 0E94 0000 		call NWK_SetPanId
 457:ServerLLDN.c  **** 		PanId = APP_PANID;
 1830               		.loc 6 457 0
 1831 08f2 8EEF      		ldi r24,lo8(-2)
 1832 08f4 8093 0000 		sts PanId,r24
 458:ServerLLDN.c  **** 		ACKFrame.sourceId = APP_PANID;
 1833               		.loc 6 458 0
 1834 08f8 8EEF      		ldi r24,lo8(-2)
 1835 08fa 8093 0000 		sts ACKFrame,r24
 459:ServerLLDN.c  **** 		PHY_SetTdmaMode(true);
 1836               		.loc 6 459 0
 1837 08fe 81E0      		ldi r24,lo8(1)
 1838 0900 0E94 0000 		call PHY_SetTdmaMode
 460:ServerLLDN.c  **** 		NWK_OpenEndpoint(APP_COMMAND_ENDPOINT, appCommandInd);
 1839               		.loc 6 460 0
 1840 0904 60E0      		ldi r22,lo8(gs(appCommandInd))
 1841 0906 70E0      		ldi r23,hi8(gs(appCommandInd))
 1842 0908 83E0      		ldi r24,lo8(3)
 1843 090a 0E94 0000 		call NWK_OpenEndpoint
 461:ServerLLDN.c  **** 	#else
 462:ServerLLDN.c  **** 		/*
 463:ServerLLDN.c  **** 		 * Enable CSMA/CA
 464:ServerLLDN.c  **** 		 * Enable Random CSMA seed generator
 465:ServerLLDN.c  **** 		 */
 466:ServerLLDN.c  **** 		PHY_SetTdmaMode(false);
 467:ServerLLDN.c  **** 		// PHY_SetOptimizedCSMAValues();
 468:ServerLLDN.c  **** 		
 469:ServerLLDN.c  **** 		payloadSize = 0x01;
 470:ServerLLDN.c  **** 		NWK_OpenEndpoint(APP_BEACON_ENDPOINT, appBeaconInd);
 471:ServerLLDN.c  **** 		NWK_OpenEndpoint(APP_ACK_ENDPOINT, appAckInd);
 472:ServerLLDN.c  **** 		NWK_OpenEndpoint(APP_COMMAND_ENDPOINT, appCommandInd);
 473:ServerLLDN.c  **** 		/*
 474:ServerLLDN.c  **** 		* Configure interrupts callback functions
 475:ServerLLDN.c  **** 		*/
 476:ServerLLDN.c  **** 		
 477:ServerLLDN.c  **** 	#endif // APP_COORDENATOR
 478:ServerLLDN.c  **** 	PHY_SetPromiscuousMode(true);
 1844               		.loc 6 478 0
 1845 090e 81E0      		ldi r24,lo8(1)
 1846 0910 0E94 0000 		call PHY_SetPromiscuousMode
 479:ServerLLDN.c  **** 
 480:ServerLLDN.c  **** }
 1847               		.loc 6 480 0
 1848 0914 0000      		nop
 1849               	/* epilogue start */
 1850 0916 DF91      		pop r29
 1851 0918 CF91      		pop r28
 1852 091a 0895      		ret
 1853               		.cfi_endproc
 1854               	.LFE143:
 1856               		.section	.rodata
 1857               	.LC6:
 1858 0053 0A25 642C 		.string	"\n%d, %d"
 1858      2025 6400 
 1859               		.text
 1861               	APP_TaskHandler:
 1862               	.LFB144:
 481:ServerLLDN.c  **** 
 482:ServerLLDN.c  **** static void APP_TaskHandler(void)
 483:ServerLLDN.c  **** {
 1863               		.loc 6 483 0
 1864               		.cfi_startproc
 1865 091c CF93      		push r28
 1866               	.LCFI78:
 1867               		.cfi_def_cfa_offset 3
 1868               		.cfi_offset 28, -2
 1869 091e DF93      		push r29
 1870               	.LCFI79:
 1871               		.cfi_def_cfa_offset 4
 1872               		.cfi_offset 29, -3
 1873 0920 CDB7      		in r28,__SP_L__
 1874 0922 DEB7      		in r29,__SP_H__
 1875               	.LCFI80:
 1876               		.cfi_def_cfa_register 28
 1877               	/* prologue: function */
 1878               	/* frame size = 0 */
 1879               	/* stack size = 2 */
 1880               	.L__stack_usage = 2
 484:ServerLLDN.c  **** 	switch (appState){
 1881               		.loc 6 484 0
 1882 0924 8091 0000 		lds r24,appState
 1883 0928 882F      		mov r24,r24
 1884 092a 90E0      		ldi r25,0
 1885 092c 8230      		cpi r24,2
 1886 092e 9105      		cpc r25,__zero_reg__
 1887 0930 01F0      		breq .L58
 1888 0932 8330      		cpi r24,3
 1889 0934 9105      		cpc r25,__zero_reg__
 1890 0936 01F0      		breq .L59
 1891 0938 892B      		or r24,r25
 1892 093a 01F0      		breq .L60
 485:ServerLLDN.c  **** 		case APP_STATE_INITIAL:
 486:ServerLLDN.c  **** 		{
 487:ServerLLDN.c  **** 			appInit();
 488:ServerLLDN.c  **** 			#if APP_COORDINATOR
 489:ServerLLDN.c  **** 				appState = APP_STATE_ATT_PAN_STATE;
 490:ServerLLDN.c  **** 			#else
 491:ServerLLDN.c  **** 				appState = APP_STATE_IDLE;
 492:ServerLLDN.c  **** 			#endif
 493:ServerLLDN.c  **** 			break;
 494:ServerLLDN.c  **** 		}
 495:ServerLLDN.c  **** 		case APP_STATE_SEND:
 496:ServerLLDN.c  **** 		{
 497:ServerLLDN.c  **** 			appSendData();
 498:ServerLLDN.c  **** 			#if APP_COORDINATOR
 499:ServerLLDN.c  **** 				/* Every time a message is send updates coordinator to prepare next message */
 500:ServerLLDN.c  **** 				appState = APP_STATE_ATT_PAN_STATE;
 501:ServerLLDN.c  **** 			#else
 502:ServerLLDN.c  **** 				appState = APP_STATE_IDLE;
 503:ServerLLDN.c  **** 			#endif
 504:ServerLLDN.c  **** 			break;
 505:ServerLLDN.c  **** 		}
 506:ServerLLDN.c  **** 		#if APP_COORDINATOR // COORDINATOR SPECIFIC STATE MACHINE
 507:ServerLLDN.c  **** 		case APP_STATE_ATT_PAN_STATE:
 508:ServerLLDN.c  **** 		{
 509:ServerLLDN.c  **** 			switch(appPanState)
 510:ServerLLDN.c  **** 			{
 511:ServerLLDN.c  **** 				/* Prepare beacon to desassociate all nodes */
 512:ServerLLDN.c  **** 				case APP_PAN_STATE_RESET:
 513:ServerLLDN.c  **** 				{
 514:ServerLLDN.c  **** 					appPanReset();
 515:ServerLLDN.c  **** 					appPanState = APP_PAN_STATE_DISC_INITIAL;
 516:ServerLLDN.c  **** 					appState	= APP_STATE_SEND;
 517:ServerLLDN.c  **** 					cycles_counter = 0;
 518:ServerLLDN.c  **** 					break;
 519:ServerLLDN.c  **** 				}
 520:ServerLLDN.c  **** 				/* Prepare first Beacon of Discovery */
 521:ServerLLDN.c  **** 				case APP_PAN_STATE_DISC_INITIAL:
 522:ServerLLDN.c  **** 				{
 523:ServerLLDN.c  **** 					/* if nodes associated is equal to expected number of associated nodes stop association proces
 524:ServerLLDN.c  **** 					 * this implementation was done as is to be used in tests, for real network functionality 
 525:ServerLLDN.c  **** 					 * the number of max association processes must be done through macLLDNdiscoveryModeTimeout
 526:ServerLLDN.c  **** 					 */
 527:ServerLLDN.c  **** 					if(counter_associados == NODOS_ASSOCIADOS_ESPERADOS || cycles_counter >= 1)
 528:ServerLLDN.c  **** 					{	
 529:ServerLLDN.c  **** 						printf("\n%d, %d", cycles_counter, counter_associados);
 530:ServerLLDN.c  **** 						counter_associados = 0;
 531:ServerLLDN.c  **** 						/* if all nodes expected where associated stop beacon generation interruptions */
 532:ServerLLDN.c  **** 						macsc_disable_cmp_int(MACSC_CC1);
 533:ServerLLDN.c  **** 						macsc_disable_cmp_int(MACSC_CC2);
 534:ServerLLDN.c  **** 						msgReq.options = 0;
 535:ServerLLDN.c  **** 						/* set coordinator node to idle further implementation of online state must be done */
 536:ServerLLDN.c  **** 						appState = APP_STATE_IDLE;
 537:ServerLLDN.c  **** 						appPanState = APP_PAN_STATE_IDLE; // APP_PAN_STATE_ONLINE_INIT
 538:ServerLLDN.c  **** 						
 539:ServerLLDN.c  **** 					}
 540:ServerLLDN.c  **** 					/* if not all nodes expected where associated run through association process again */
 541:ServerLLDN.c  **** 					else 
 542:ServerLLDN.c  **** 					{
 543:ServerLLDN.c  **** 						/* prepare beacon message and start timers for beacon */
 544:ServerLLDN.c  **** 						appPanDiscInit();
 545:ServerLLDN.c  **** 						appState	= APP_STATE_IDLE;
 546:ServerLLDN.c  **** 						appPanState = APP_PAN_STATE_DISC_SECOND_BE;
 547:ServerLLDN.c  **** 					}
 548:ServerLLDN.c  **** 					break;
 549:ServerLLDN.c  **** 				}
 550:ServerLLDN.c  **** 				case APP_PAN_STATE_DISC_SECOND_BE:
 551:ServerLLDN.c  **** 				{
 552:ServerLLDN.c  **** 					/* Prepares message as: Discovery Beacon and Second Beacon */
 553:ServerLLDN.c  **** 					msgReq.options = NWK_OPT_LLDN_BEACON | NWK_OPT_DISCOVERY_STATE | NWK_OPT_SECOND_BEACON ;
 554:ServerLLDN.c  **** 					msgReq.data = NULL;
 555:ServerLLDN.c  **** 					msgReq.size = 0;
 556:ServerLLDN.c  **** 					
 557:ServerLLDN.c  **** 					appState	= APP_PAN_STATE_DISC_PREPARE_ACK;
 558:ServerLLDN.c  **** 					appPanState = APP_PAN_STATE_IDLE;
 559:ServerLLDN.c  **** 					break;
 560:ServerLLDN.c  **** 				}
 561:ServerLLDN.c  **** 				case APP_PAN_STATE_DISC_PREPARE_ACK:
 562:ServerLLDN.c  **** 				{
 563:ServerLLDN.c  **** 					/* This timer implements a delay between messages, 
 564:ServerLLDN.c  **** 					 * if not used the nodes are not able to receive the message
 565:ServerLLDN.c  **** 					 */
 566:ServerLLDN.c  **** 					appPanPrepareACK();
 567:ServerLLDN.c  **** 					SYS_TimerStart(&tmrDelay);
 568:ServerLLDN.c  **** 					
 569:ServerLLDN.c  **** 					appPanState = APP_STATE_IDLE; 
 570:ServerLLDN.c  **** 					appState = APP_STATE_IDLE;
 571:ServerLLDN.c  **** 					break;
 572:ServerLLDN.c  **** 				}
 573:ServerLLDN.c  **** 				case APP_PAN_STATE_CONFIG_INITIAL:
 574:ServerLLDN.c  **** 				{
 575:ServerLLDN.c  **** 					/* Prepares the message as: Configuration Beacon and First State Beacon */
 576:ServerLLDN.c  **** 					msgReq.options = NWK_OPT_LLDN_BEACON | NWK_OPT_CONFIG_STATE;
 577:ServerLLDN.c  **** 					msgReq.data = NULL;
 578:ServerLLDN.c  **** 					msgReq.size = 0;
 579:ServerLLDN.c  **** 					
 580:ServerLLDN.c  **** 					appState	= APP_STATE_IDLE;
 581:ServerLLDN.c  **** 					appPanState = APP_PAN_STATE_CONFIG_SECOND_BEACON;
 582:ServerLLDN.c  **** 					break;
 583:ServerLLDN.c  **** 
 584:ServerLLDN.c  **** 				}
 585:ServerLLDN.c  **** 				case APP_PAN_STATE_CONFIG_SECOND_BEACON:
 586:ServerLLDN.c  **** 				{
 587:ServerLLDN.c  **** 					/* Prepares the message as: Configuration Beacon and Second State Beacon */
 588:ServerLLDN.c  **** 					msgReq.options = NWK_OPT_LLDN_BEACON | NWK_OPT_CONFIG_STATE | NWK_OPT_SECOND_BEACON;
 589:ServerLLDN.c  **** 					msgReq.data = NULL;
 590:ServerLLDN.c  **** 					msgReq.size = 0;
 591:ServerLLDN.c  **** 					
 592:ServerLLDN.c  **** 					appState	= APP_STATE_IDLE;
 593:ServerLLDN.c  **** 					appPanState = APP_PAN_STATE_SEND_CONF_REQUEST;
 594:ServerLLDN.c  **** 					break;
 595:ServerLLDN.c  **** 				}
 596:ServerLLDN.c  **** 				case APP_PAN_STATE_SEND_CONF_REQUEST:
 597:ServerLLDN.c  **** 				{
 598:ServerLLDN.c  **** 					/* Send Configuration Requests frames with delay between messages*/
 599:ServerLLDN.c  **** 					if( conf_req_list != 0 )
 600:ServerLLDN.c  **** 					{
 601:ServerLLDN.c  **** 						
 602:ServerLLDN.c  **** 						get_next_confreq(&config_request_frame);
 603:ServerLLDN.c  **** 
 604:ServerLLDN.c  **** 						msgReq.options		= NWK_OPT_MAC_COMMAND;
 605:ServerLLDN.c  **** 						msgReq.data			= (uint8_t*)&config_request_frame;
 606:ServerLLDN.c  **** 						msgReq.size			= sizeof(NWK_ConfigRequest_t);
 607:ServerLLDN.c  **** 						
 608:ServerLLDN.c  **** 						appState	= APP_STATE_IDLE;
 609:ServerLLDN.c  **** 						appPanState = APP_PAN_STATE_SEND_CONF_REQUEST;
 610:ServerLLDN.c  **** 						
 611:ServerLLDN.c  **** 						counter_associados++;												
 612:ServerLLDN.c  **** 						SYS_TimerStart(&tmrDelay);
 613:ServerLLDN.c  **** 					}
 614:ServerLLDN.c  **** 					else
 615:ServerLLDN.c  **** 					{
 616:ServerLLDN.c  **** 						appPanState = APP_PAN_STATE_CONFIG_THIRD_BEACON;
 617:ServerLLDN.c  **** 					}
 618:ServerLLDN.c  **** 					break;
 619:ServerLLDN.c  **** 				}
 620:ServerLLDN.c  **** 				case APP_PAN_STATE_CONFIG_THIRD_BEACON:
 621:ServerLLDN.c  **** 				{
 622:ServerLLDN.c  **** 					msgReq.options = NWK_OPT_LLDN_BEACON | NWK_OPT_CONFIG_STATE | NWK_OPT_THIRD_BEACON;
 623:ServerLLDN.c  **** 					msgReq.data = NULL;
 624:ServerLLDN.c  **** 					msgReq.size = 0;
 625:ServerLLDN.c  **** 					
 626:ServerLLDN.c  **** 					appState	= APP_STATE_IDLE;
 627:ServerLLDN.c  **** 					appPanState = APP_PAN_STATE_DISC_INITIAL;
 628:ServerLLDN.c  **** 					cycles_counter++;	
 629:ServerLLDN.c  **** 					
 630:ServerLLDN.c  **** 					break;
 631:ServerLLDN.c  **** 				}
 632:ServerLLDN.c  **** 				case APP_PAN_STATE_ONLINE_INITIAL:
 633:ServerLLDN.c  **** 				{
 634:ServerLLDN.c  **** 					appPanOnlineInit();
 635:ServerLLDN.c  **** 					break;
 636:ServerLLDN.c  **** 				}
 637:ServerLLDN.c  **** 				case APP_PAN_STATE_ONLINE_END_BE:
 638:ServerLLDN.c  **** 				{
 639:ServerLLDN.c  **** 					if(0)
 640:ServerLLDN.c  **** 					{
 641:ServerLLDN.c  **** 						// implementar as condies para entrar no processo de associao
 642:ServerLLDN.c  **** 					}
 643:ServerLLDN.c  **** 					else
 644:ServerLLDN.c  **** 					{
 645:ServerLLDN.c  **** 						// posso calcular esse valor no onlineinit, o tTS precisa ser recalculado, o seu valor muda n
 646:ServerLLDN.c  **** 						// pode voltar pro state_online_initial porque precisa reconfigurar os timers
 647:ServerLLDN.c  **** 						// precisa revisar o macsc_enable_manual_bts()
 648:ServerLLDN.c  **** 						/*
 649:ServerLLDN.c  **** 						int idle_time =  2 * numBaseTimeSlotperMgmt * (tTS) * 5 / (SYMBOL_TIME); // 5 is the total of
 650:ServerLLDN.c  **** 						macsc_set_cmp1_int_cb(lldn_server_beacon); // esta funo pode s mandar o beacon do online, 
 651:ServerLLDN.c  **** 						macsc_enable_manual_bts();
 652:ServerLLDN.c  **** 						macsc_enable_cmp_int(MACSC_CC1);
 653:ServerLLDN.c  **** 						macsc_use_cmp(MACSC_RELATIVE_CMP, idle_time, MACSC_CC1);
 654:ServerLLDN.c  **** 						*/
 655:ServerLLDN.c  **** 					}
 656:ServerLLDN.c  **** 					break;
 657:ServerLLDN.c  **** 				}
 658:ServerLLDN.c  **** 				case APP_PAN_STATE_IDLE:
 659:ServerLLDN.c  **** 				{
 660:ServerLLDN.c  **** 					msgReq.options = 0;
 661:ServerLLDN.c  **** 					appState = APP_STATE_IDLE;
 662:ServerLLDN.c  **** 					break;
 663:ServerLLDN.c  **** 				}
 664:ServerLLDN.c  **** 			}
 665:ServerLLDN.c  **** 			break;	
 666:ServerLLDN.c  **** 		}
 667:ServerLLDN.c  **** 		#else // NODES SPECIFIC STATE MACHINE
 668:ServerLLDN.c  **** 		case APP_STATE_PREP_DISC_REPONSE:
 669:ServerLLDN.c  **** 		{
 670:ServerLLDN.c  **** 			appPrepareDiscoverResponse();
 671:ServerLLDN.c  **** 			appState = APP_STATE_IDLE;	
 672:ServerLLDN.c  **** 			break;
 673:ServerLLDN.c  **** 		}
 674:ServerLLDN.c  **** 		
 675:ServerLLDN.c  **** 		case APP_STATE_PREP_CONFIG_STATUS:
 676:ServerLLDN.c  **** 		{
 677:ServerLLDN.c  **** 			// se o nodo recebeu ack na fase do discovery prepara a mensagem de configuration status
 678:ServerLLDN.c  **** 			if(ack_received && rec_beacon->confSeqNumber == 0 && associated == 0) {
 679:ServerLLDN.c  **** 				appPrepareConfigurationStatus();
 680:ServerLLDN.c  **** 			}
 681:ServerLLDN.c  **** 			// se o nodo no recebeu desativa o timer e fica em idle
 682:ServerLLDN.c  **** 			else {
 683:ServerLLDN.c  **** 				#if MASTER_MACSC
 684:ServerLLDN.c  **** 				macsc_disable_cmp_int(MACSC_CC1);
 685:ServerLLDN.c  **** 				#else
 686:ServerLLDN.c  **** 				timer_stop();
 687:ServerLLDN.c  **** 				#endif
 688:ServerLLDN.c  **** 			}
 689:ServerLLDN.c  **** 			appState = APP_STATE_IDLE;
 690:ServerLLDN.c  **** 			break;
 691:ServerLLDN.c  **** 		}
 692:ServerLLDN.c  **** 		#endif
 693:ServerLLDN.c  **** 		default:
 694:ServerLLDN.c  **** 		{
 695:ServerLLDN.c  **** 			break;
 1893               		.loc 6 695 0
 1894 093c 00C0      		rjmp .L61
 1895               	.L60:
 487:ServerLLDN.c  **** 			#if APP_COORDINATOR
 1896               		.loc 6 487 0
 1897 093e 0E94 0000 		call appInit
 489:ServerLLDN.c  **** 			#else
 1898               		.loc 6 489 0
 1899 0942 83E0      		ldi r24,lo8(3)
 1900 0944 8093 0000 		sts appState,r24
 493:ServerLLDN.c  **** 		}
 1901               		.loc 6 493 0
 1902 0948 00C0      		rjmp .L61
 1903               	.L58:
 497:ServerLLDN.c  **** 			#if APP_COORDINATOR
 1904               		.loc 6 497 0
 1905 094a 0E94 0000 		call appSendData
 500:ServerLLDN.c  **** 			#else
 1906               		.loc 6 500 0
 1907 094e 83E0      		ldi r24,lo8(3)
 1908 0950 8093 0000 		sts appState,r24
 504:ServerLLDN.c  **** 		}
 1909               		.loc 6 504 0
 1910 0954 00C0      		rjmp .L61
 1911               	.L59:
 509:ServerLLDN.c  **** 			{
 1912               		.loc 6 509 0
 1913 0956 8091 0000 		lds r24,appPanState
 1914 095a 882F      		mov r24,r24
 1915 095c 90E0      		ldi r25,0
 1916 095e 092E      		mov __tmp_reg__,r25
 1917 0960 000C      		lsl r0
 1918 0962 AA0B      		sbc r26,r26
 1919 0964 BB0B      		sbc r27,r27
 1920 0966 40E0      		ldi r20,0
 1921 0968 50E0      		ldi r21,0
 1922 096a 2AE0      		ldi r18,lo8(10)
 1923 096c 30E0      		ldi r19,0
 1924 096e 841B      		sub r24,r20
 1925 0970 950B      		sbc r25,r21
 1926 0972 2817      		cp r18,r24
 1927 0974 3907      		cpc r19,r25
 1928 0976 00F4      		brsh .+2
 1929 0978 00C0      		rjmp .L80
 1930 097a 8050      		subi r24,lo8(-(gs(.L64)))
 1931 097c 9040      		sbci r25,hi8(-(gs(.L64)))
 1932 097e FC01      		movw r30,r24
 1933 0980 0C94 0000 		jmp __tablejump2__
 1934               		.section	.progmem.gcc_sw_table,"a",@progbits
 1935               		.p2align	1
 1936               	.L64:
 1937 0000 0000      		.word gs(.L63)
 1938 0002 0000      		.word gs(.L65)
 1939 0004 0000      		.word gs(.L66)
 1940 0006 0000      		.word gs(.L67)
 1941 0008 0000      		.word gs(.L68)
 1942 000a 0000      		.word gs(.L69)
 1943 000c 0000      		.word gs(.L70)
 1944 000e 0000      		.word gs(.L71)
 1945 0010 0000      		.word gs(.L72)
 1946 0012 0000      		.word gs(.L73)
 1947 0014 0000      		.word gs(.L81)
 1948               		.text
 1949               	.L65:
 514:ServerLLDN.c  **** 					appPanState = APP_PAN_STATE_DISC_INITIAL;
 1950               		.loc 6 514 0
 1951 0984 0E94 0000 		call appPanReset
 515:ServerLLDN.c  **** 					appState	= APP_STATE_SEND;
 1952               		.loc 6 515 0
 1953 0988 82E0      		ldi r24,lo8(2)
 1954 098a 8093 0000 		sts appPanState,r24
 516:ServerLLDN.c  **** 					cycles_counter = 0;
 1955               		.loc 6 516 0
 1956 098e 82E0      		ldi r24,lo8(2)
 1957 0990 8093 0000 		sts appState,r24
 517:ServerLLDN.c  **** 					break;
 1958               		.loc 6 517 0
 1959 0994 1092 0000 		sts cycles_counter,__zero_reg__
 518:ServerLLDN.c  **** 				}
 1960               		.loc 6 518 0
 1961 0998 00C0      		rjmp .L62
 1962               	.L66:
 527:ServerLLDN.c  **** 					{	
 1963               		.loc 6 527 0
 1964 099a 8091 0000 		lds r24,counter_associados
 1965 099e 9091 0000 		lds r25,counter_associados+1
 1966 09a2 0C97      		sbiw r24,12
 1967 09a4 01F0      		breq .L75
 527:ServerLLDN.c  **** 					{	
 1968               		.loc 6 527 0 is_stmt 0 discriminator 1
 1969 09a6 8091 0000 		lds r24,cycles_counter
 1970 09aa 8823      		tst r24
 1971 09ac 01F0      		breq .L76
 1972               	.L75:
 529:ServerLLDN.c  **** 						counter_associados = 0;
 1973               		.loc 6 529 0 is_stmt 1
 1974 09ae 2091 0000 		lds r18,counter_associados
 1975 09b2 3091 0000 		lds r19,counter_associados+1
 1976 09b6 8091 0000 		lds r24,cycles_counter
 1977 09ba 882F      		mov r24,r24
 1978 09bc 90E0      		ldi r25,0
 1979 09be 432F      		mov r20,r19
 1980 09c0 4F93      		push r20
 1981 09c2 2F93      		push r18
 1982 09c4 292F      		mov r18,r25
 1983 09c6 2F93      		push r18
 1984 09c8 8F93      		push r24
 1985 09ca 80E0      		ldi r24,lo8(.LC6)
 1986 09cc 90E0      		ldi r25,hi8(.LC6)
 1987 09ce 892F      		mov r24,r25
 1988 09d0 8F93      		push r24
 1989 09d2 80E0      		ldi r24,lo8(.LC6)
 1990 09d4 90E0      		ldi r25,hi8(.LC6)
 1991 09d6 8F93      		push r24
 1992 09d8 0E94 0000 		call printf
 1993 09dc 0F90      		pop __tmp_reg__
 1994 09de 0F90      		pop __tmp_reg__
 1995 09e0 0F90      		pop __tmp_reg__
 1996 09e2 0F90      		pop __tmp_reg__
 1997 09e4 0F90      		pop __tmp_reg__
 1998 09e6 0F90      		pop __tmp_reg__
 530:ServerLLDN.c  **** 						/* if all nodes expected where associated stop beacon generation interruptions */
 1999               		.loc 6 530 0
 2000 09e8 1092 0000 		sts counter_associados+1,__zero_reg__
 2001 09ec 1092 0000 		sts counter_associados,__zero_reg__
 532:ServerLLDN.c  **** 						macsc_disable_cmp_int(MACSC_CC2);
 2002               		.loc 6 532 0
 2003 09f0 81E0      		ldi r24,lo8(1)
 2004 09f2 0E94 0000 		call macsc_disable_cmp_int
 533:ServerLLDN.c  **** 						msgReq.options = 0;
 2005               		.loc 6 533 0
 2006 09f6 82E0      		ldi r24,lo8(2)
 2007 09f8 0E94 0000 		call macsc_disable_cmp_int
 534:ServerLLDN.c  **** 						/* set coordinator node to idle further implementation of online state must be done */
 2008               		.loc 6 534 0
 2009 09fc 1092 0000 		sts msgReq+9+1,__zero_reg__
 2010 0a00 1092 0000 		sts msgReq+9,__zero_reg__
 536:ServerLLDN.c  **** 						appPanState = APP_PAN_STATE_IDLE; // APP_PAN_STATE_ONLINE_INIT
 2011               		.loc 6 536 0
 2012 0a04 81E0      		ldi r24,lo8(1)
 2013 0a06 8093 0000 		sts appState,r24
 537:ServerLLDN.c  **** 						
 2014               		.loc 6 537 0
 2015 0a0a 1092 0000 		sts appPanState,__zero_reg__
 548:ServerLLDN.c  **** 				}
 2016               		.loc 6 548 0
 2017 0a0e 00C0      		rjmp .L62
 2018               	.L76:
 544:ServerLLDN.c  **** 						appState	= APP_STATE_IDLE;
 2019               		.loc 6 544 0
 2020 0a10 0E94 0000 		call appPanDiscInit
 545:ServerLLDN.c  **** 						appPanState = APP_PAN_STATE_DISC_SECOND_BE;
 2021               		.loc 6 545 0
 2022 0a14 81E0      		ldi r24,lo8(1)
 2023 0a16 8093 0000 		sts appState,r24
 546:ServerLLDN.c  **** 					}
 2024               		.loc 6 546 0
 2025 0a1a 83E0      		ldi r24,lo8(3)
 2026 0a1c 8093 0000 		sts appPanState,r24
 548:ServerLLDN.c  **** 				}
 2027               		.loc 6 548 0
 2028 0a20 00C0      		rjmp .L62
 2029               	.L67:
 553:ServerLLDN.c  **** 					msgReq.data = NULL;
 2030               		.loc 6 553 0
 2031 0a22 80E4      		ldi r24,lo8(64)
 2032 0a24 99E0      		ldi r25,lo8(9)
 2033 0a26 9093 0000 		sts msgReq+9+1,r25
 2034 0a2a 8093 0000 		sts msgReq+9,r24
 554:ServerLLDN.c  **** 					msgReq.size = 0;
 2035               		.loc 6 554 0
 2036 0a2e 1092 0000 		sts msgReq+13+1,__zero_reg__
 2037 0a32 1092 0000 		sts msgReq+13,__zero_reg__
 555:ServerLLDN.c  **** 					
 2038               		.loc 6 555 0
 2039 0a36 1092 0000 		sts msgReq+15,__zero_reg__
 557:ServerLLDN.c  **** 					appPanState = APP_PAN_STATE_IDLE;
 2040               		.loc 6 557 0
 2041 0a3a 84E0      		ldi r24,lo8(4)
 2042 0a3c 8093 0000 		sts appState,r24
 558:ServerLLDN.c  **** 					break;
 2043               		.loc 6 558 0
 2044 0a40 1092 0000 		sts appPanState,__zero_reg__
 559:ServerLLDN.c  **** 				}
 2045               		.loc 6 559 0
 2046 0a44 00C0      		rjmp .L62
 2047               	.L68:
 566:ServerLLDN.c  **** 					SYS_TimerStart(&tmrDelay);
 2048               		.loc 6 566 0
 2049 0a46 0E94 0000 		call appPanPrepareACK
 567:ServerLLDN.c  **** 					
 2050               		.loc 6 567 0
 2051 0a4a 80E0      		ldi r24,lo8(tmrDelay)
 2052 0a4c 90E0      		ldi r25,hi8(tmrDelay)
 2053 0a4e 0E94 0000 		call SYS_TimerStart
 569:ServerLLDN.c  **** 					appState = APP_STATE_IDLE;
 2054               		.loc 6 569 0
 2055 0a52 81E0      		ldi r24,lo8(1)
 2056 0a54 8093 0000 		sts appPanState,r24
 570:ServerLLDN.c  **** 					break;
 2057               		.loc 6 570 0
 2058 0a58 81E0      		ldi r24,lo8(1)
 2059 0a5a 8093 0000 		sts appState,r24
 571:ServerLLDN.c  **** 				}
 2060               		.loc 6 571 0
 2061 0a5e 00C0      		rjmp .L62
 2062               	.L69:
 576:ServerLLDN.c  **** 					msgReq.data = NULL;
 2063               		.loc 6 576 0
 2064 0a60 80E4      		ldi r24,lo8(64)
 2065 0a62 92E0      		ldi r25,lo8(2)
 2066 0a64 9093 0000 		sts msgReq+9+1,r25
 2067 0a68 8093 0000 		sts msgReq+9,r24
 577:ServerLLDN.c  **** 					msgReq.size = 0;
 2068               		.loc 6 577 0
 2069 0a6c 1092 0000 		sts msgReq+13+1,__zero_reg__
 2070 0a70 1092 0000 		sts msgReq+13,__zero_reg__
 578:ServerLLDN.c  **** 					
 2071               		.loc 6 578 0
 2072 0a74 1092 0000 		sts msgReq+15,__zero_reg__
 580:ServerLLDN.c  **** 					appPanState = APP_PAN_STATE_CONFIG_SECOND_BEACON;
 2073               		.loc 6 580 0
 2074 0a78 81E0      		ldi r24,lo8(1)
 2075 0a7a 8093 0000 		sts appState,r24
 581:ServerLLDN.c  **** 					break;
 2076               		.loc 6 581 0
 2077 0a7e 87E0      		ldi r24,lo8(7)
 2078 0a80 8093 0000 		sts appPanState,r24
 582:ServerLLDN.c  **** 
 2079               		.loc 6 582 0
 2080 0a84 00C0      		rjmp .L62
 2081               	.L71:
 588:ServerLLDN.c  **** 					msgReq.data = NULL;
 2082               		.loc 6 588 0
 2083 0a86 80E4      		ldi r24,lo8(64)
 2084 0a88 9AE0      		ldi r25,lo8(10)
 2085 0a8a 9093 0000 		sts msgReq+9+1,r25
 2086 0a8e 8093 0000 		sts msgReq+9,r24
 589:ServerLLDN.c  **** 					msgReq.size = 0;
 2087               		.loc 6 589 0
 2088 0a92 1092 0000 		sts msgReq+13+1,__zero_reg__
 2089 0a96 1092 0000 		sts msgReq+13,__zero_reg__
 590:ServerLLDN.c  **** 					
 2090               		.loc 6 590 0
 2091 0a9a 1092 0000 		sts msgReq+15,__zero_reg__
 592:ServerLLDN.c  **** 					appPanState = APP_PAN_STATE_SEND_CONF_REQUEST;
 2092               		.loc 6 592 0
 2093 0a9e 81E0      		ldi r24,lo8(1)
 2094 0aa0 8093 0000 		sts appState,r24
 593:ServerLLDN.c  **** 					break;
 2095               		.loc 6 593 0
 2096 0aa4 86E0      		ldi r24,lo8(6)
 2097 0aa6 8093 0000 		sts appPanState,r24
 594:ServerLLDN.c  **** 				}
 2098               		.loc 6 594 0
 2099 0aaa 00C0      		rjmp .L62
 2100               	.L70:
 599:ServerLLDN.c  **** 					{
 2101               		.loc 6 599 0
 2102 0aac 8091 0000 		lds r24,conf_req_list
 2103 0ab0 9091 0000 		lds r25,conf_req_list+1
 2104 0ab4 892B      		or r24,r25
 2105 0ab6 01F0      		breq .L78
 602:ServerLLDN.c  **** 
 2106               		.loc 6 602 0
 2107 0ab8 80E0      		ldi r24,lo8(config_request_frame)
 2108 0aba 90E0      		ldi r25,hi8(config_request_frame)
 2109 0abc 0E94 0000 		call get_next_confreq
 604:ServerLLDN.c  **** 						msgReq.data			= (uint8_t*)&config_request_frame;
 2110               		.loc 6 604 0
 2111 0ac0 80E0      		ldi r24,0
 2112 0ac2 90E8      		ldi r25,lo8(-128)
 2113 0ac4 9093 0000 		sts msgReq+9+1,r25
 2114 0ac8 8093 0000 		sts msgReq+9,r24
 605:ServerLLDN.c  **** 						msgReq.size			= sizeof(NWK_ConfigRequest_t);
 2115               		.loc 6 605 0
 2116 0acc 80E0      		ldi r24,lo8(config_request_frame)
 2117 0ace 90E0      		ldi r25,hi8(config_request_frame)
 2118 0ad0 9093 0000 		sts msgReq+13+1,r25
 2119 0ad4 8093 0000 		sts msgReq+13,r24
 606:ServerLLDN.c  **** 						
 2120               		.loc 6 606 0
 2121 0ad8 87E0      		ldi r24,lo8(7)
 2122 0ada 8093 0000 		sts msgReq+15,r24
 608:ServerLLDN.c  **** 						appPanState = APP_PAN_STATE_SEND_CONF_REQUEST;
 2123               		.loc 6 608 0
 2124 0ade 81E0      		ldi r24,lo8(1)
 2125 0ae0 8093 0000 		sts appState,r24
 609:ServerLLDN.c  **** 						
 2126               		.loc 6 609 0
 2127 0ae4 86E0      		ldi r24,lo8(6)
 2128 0ae6 8093 0000 		sts appPanState,r24
 611:ServerLLDN.c  **** 						SYS_TimerStart(&tmrDelay);
 2129               		.loc 6 611 0
 2130 0aea 8091 0000 		lds r24,counter_associados
 2131 0aee 9091 0000 		lds r25,counter_associados+1
 2132 0af2 0196      		adiw r24,1
 2133 0af4 9093 0000 		sts counter_associados+1,r25
 2134 0af8 8093 0000 		sts counter_associados,r24
 612:ServerLLDN.c  **** 					}
 2135               		.loc 6 612 0
 2136 0afc 80E0      		ldi r24,lo8(tmrDelay)
 2137 0afe 90E0      		ldi r25,hi8(tmrDelay)
 2138 0b00 0E94 0000 		call SYS_TimerStart
 618:ServerLLDN.c  **** 				}
 2139               		.loc 6 618 0
 2140 0b04 00C0      		rjmp .L62
 2141               	.L78:
 616:ServerLLDN.c  **** 					}
 2142               		.loc 6 616 0
 2143 0b06 88E0      		ldi r24,lo8(8)
 2144 0b08 8093 0000 		sts appPanState,r24
 618:ServerLLDN.c  **** 				}
 2145               		.loc 6 618 0
 2146 0b0c 00C0      		rjmp .L62
 2147               	.L72:
 622:ServerLLDN.c  **** 					msgReq.data = NULL;
 2148               		.loc 6 622 0
 2149 0b0e 80E4      		ldi r24,lo8(64)
 2150 0b10 92E1      		ldi r25,lo8(18)
 2151 0b12 9093 0000 		sts msgReq+9+1,r25
 2152 0b16 8093 0000 		sts msgReq+9,r24
 623:ServerLLDN.c  **** 					msgReq.size = 0;
 2153               		.loc 6 623 0
 2154 0b1a 1092 0000 		sts msgReq+13+1,__zero_reg__
 2155 0b1e 1092 0000 		sts msgReq+13,__zero_reg__
 624:ServerLLDN.c  **** 					
 2156               		.loc 6 624 0
 2157 0b22 1092 0000 		sts msgReq+15,__zero_reg__
 626:ServerLLDN.c  **** 					appPanState = APP_PAN_STATE_DISC_INITIAL;
 2158               		.loc 6 626 0
 2159 0b26 81E0      		ldi r24,lo8(1)
 2160 0b28 8093 0000 		sts appState,r24
 627:ServerLLDN.c  **** 					cycles_counter++;	
 2161               		.loc 6 627 0
 2162 0b2c 82E0      		ldi r24,lo8(2)
 2163 0b2e 8093 0000 		sts appPanState,r24
 628:ServerLLDN.c  **** 					
 2164               		.loc 6 628 0
 2165 0b32 8091 0000 		lds r24,cycles_counter
 2166 0b36 8F5F      		subi r24,lo8(-(1))
 2167 0b38 8093 0000 		sts cycles_counter,r24
 630:ServerLLDN.c  **** 				}
 2168               		.loc 6 630 0
 2169 0b3c 00C0      		rjmp .L62
 2170               	.L73:
 634:ServerLLDN.c  **** 					break;
 2171               		.loc 6 634 0
 2172 0b3e 0E94 0000 		call appPanOnlineInit
 635:ServerLLDN.c  **** 				}
 2173               		.loc 6 635 0
 2174 0b42 00C0      		rjmp .L62
 2175               	.L63:
 660:ServerLLDN.c  **** 					appState = APP_STATE_IDLE;
 2176               		.loc 6 660 0
 2177 0b44 1092 0000 		sts msgReq+9+1,__zero_reg__
 2178 0b48 1092 0000 		sts msgReq+9,__zero_reg__
 661:ServerLLDN.c  **** 					break;
 2179               		.loc 6 661 0
 2180 0b4c 81E0      		ldi r24,lo8(1)
 2181 0b4e 8093 0000 		sts appState,r24
 662:ServerLLDN.c  **** 				}
 2182               		.loc 6 662 0
 2183 0b52 00C0      		rjmp .L62
 2184               	.L81:
 656:ServerLLDN.c  **** 				}
 2185               		.loc 6 656 0
 2186 0b54 0000      		nop
 2187               	.L62:
 2188               	.L80:
 665:ServerLLDN.c  **** 		}
 2189               		.loc 6 665 0
 2190 0b56 0000      		nop
 2191               	.L61:
 696:ServerLLDN.c  **** 		}
 697:ServerLLDN.c  **** 	}
 698:ServerLLDN.c  **** }
 2192               		.loc 6 698 0
 2193 0b58 0000      		nop
 2194               	/* epilogue start */
 2195 0b5a DF91      		pop r29
 2196 0b5c CF91      		pop r28
 2197 0b5e 0895      		ret
 2198               		.cfi_endproc
 2199               	.LFE144:
 2201               		.section	.rodata
 2202               	.LC0:
 2203 005b 00        		.byte	0
 2204 005c C2        		.byte	-62
 2205 005d 01        		.byte	1
 2206 005e 00        		.byte	0
 2207 005f 03        		.byte	3
 2208 0060 00        		.byte	0
 2209 0061 00        		.byte	0
 2210               		.text
 2211               	.global	main
 2213               	main:
 2214               	.LFB145:
 699:ServerLLDN.c  **** 
 700:ServerLLDN.c  **** 	/*****************************************************************************
 701:ServerLLDN.c  **** 	*****************************************************************************/
 702:ServerLLDN.c  **** 	int main(void)
 703:ServerLLDN.c  **** 	{
 2215               		.loc 6 703 0
 2216               		.cfi_startproc
 2217 0b60 0F93      		push r16
 2218               	.LCFI81:
 2219               		.cfi_def_cfa_offset 3
 2220               		.cfi_offset 16, -2
 2221 0b62 1F93      		push r17
 2222               	.LCFI82:
 2223               		.cfi_def_cfa_offset 4
 2224               		.cfi_offset 17, -3
 2225 0b64 CF93      		push r28
 2226               	.LCFI83:
 2227               		.cfi_def_cfa_offset 5
 2228               		.cfi_offset 28, -4
 2229 0b66 DF93      		push r29
 2230               	.LCFI84:
 2231               		.cfi_def_cfa_offset 6
 2232               		.cfi_offset 29, -5
 2233 0b68 CDB7      		in r28,__SP_L__
 2234 0b6a DEB7      		in r29,__SP_H__
 2235               	.LCFI85:
 2236               		.cfi_def_cfa_register 28
 2237 0b6c 2797      		sbiw r28,7
 2238               	.LCFI86:
 2239               		.cfi_def_cfa_offset 13
 2240 0b6e 0FB6      		in __tmp_reg__,__SREG__
 2241 0b70 F894      		cli
 2242 0b72 DEBF      		out __SP_H__,r29
 2243 0b74 0FBE      		out __SREG__,__tmp_reg__
 2244 0b76 CDBF      		out __SP_L__,r28
 2245               	/* prologue: function */
 2246               	/* frame size = 7 */
 2247               	/* stack size = 11 */
 2248               	.L__stack_usage = 11
 704:ServerLLDN.c  **** 		sysclk_init();
 2249               		.loc 6 704 0
 2250 0b78 0E94 0000 		call sysclk_init
 705:ServerLLDN.c  **** 		board_init();
 2251               		.loc 6 705 0
 2252 0b7c 0E94 0000 		call board_init
 706:ServerLLDN.c  **** 
 707:ServerLLDN.c  **** 		SYS_Init();
 2253               		.loc 6 707 0
 2254 0b80 0E94 0000 		call SYS_Init
 708:ServerLLDN.c  **** 		/* Disable CSMA/CA
 709:ServerLLDN.c  **** 		 * Disable auto ACK
 710:ServerLLDN.c  **** 		 * Enable Rx of LLDN Frame Type as described in 802.15.4e - 2012 
 711:ServerLLDN.c  **** 		 */
 712:ServerLLDN.c  **** 
 713:ServerLLDN.c  **** 		sm_init();
 2255               		.loc 6 713 0
 2256 0b84 0E94 0000 		call sm_init
 714:ServerLLDN.c  **** 
 715:ServerLLDN.c  **** 		// Initialize interrupt vector table support.
 716:ServerLLDN.c  **** 	#if (SIO2HOST_CHANNEL == SIO_USB)
 717:ServerLLDN.c  **** 		irq_initialize_vectors();
 718:ServerLLDN.c  **** 	#endif
 719:ServerLLDN.c  **** 		cpu_irq_enable();
 2257               		.loc 6 719 0
 2258               	/* #APP */
 2259               	 ;  719 "ServerLLDN.c" 1
 2260 0b88 7894      		sei
 2261               	 ;  0 "" 2
 720:ServerLLDN.c  **** 
 721:ServerLLDN.c  **** 	#if 1
 722:ServerLLDN.c  **** 	#if (SIO2HOST_CHANNEL == SIO_USB)
 723:ServerLLDN.c  **** 		stdio_usb_init();
 724:ServerLLDN.c  **** 	#else
 725:ServerLLDN.c  **** 		const usart_serial_options_t usart_serial_options =
 2262               		.loc 6 725 0
 2263               	/* #NOAPP */
 2264 0b8a 27E0      		ldi r18,lo8(7)
 2265 0b8c E0E0      		ldi r30,lo8(.LC0)
 2266 0b8e F0E0      		ldi r31,hi8(.LC0)
 2267 0b90 CE01      		movw r24,r28
 2268 0b92 0196      		adiw r24,1
 2269 0b94 DC01      		movw r26,r24
 2270               		0:
 2271 0b96 0190      		ld r0,Z+
 2272 0b98 0D92      		st X+,r0
 2273 0b9a 2A95      		dec r18
 2274 0b9c 01F4      		brne 0b
 726:ServerLLDN.c  **** 		{
 727:ServerLLDN.c  **** 			.baudrate     = USART_HOST_BAUDRATE,
 728:ServerLLDN.c  **** 			.charlength   = USART_HOST_CHAR_LENGTH,
 729:ServerLLDN.c  **** 			.paritytype   = USART_HOST_PARITY,
 730:ServerLLDN.c  **** 			.stopbits     = USART_HOST_STOP_BITS
 731:ServerLLDN.c  **** 		};
 732:ServerLLDN.c  **** 
 733:ServerLLDN.c  **** 		stdio_serial_init(USART_HOST, &usart_serial_options);
 2275               		.loc 6 733 0
 2276 0b9e CE01      		movw r24,r28
 2277 0ba0 0196      		adiw r24,1
 2278 0ba2 BC01      		movw r22,r24
 2279 0ba4 80EC      		ldi r24,lo8(-64)
 2280 0ba6 90E0      		ldi r25,0
 2281 0ba8 0E94 0000 		call stdio_serial_init
 734:ServerLLDN.c  **** 		usart_double_baud_enable(USART_HOST);
 2282               		.loc 6 734 0
 2283 0bac 80EC      		ldi r24,lo8(-64)
 2284 0bae 90E0      		ldi r25,0
 2285 0bb0 0E94 0000 		call usart_double_baud_enable
 735:ServerLLDN.c  **** 		usart_set_baudrate_precalculated(USART_HOST, USART_HOST_BAUDRATE, sysclk_get_source_clock_hz());
 2286               		.loc 6 735 0
 2287 0bb4 0E94 0000 		call sysclk_get_source_clock_hz
 2288 0bb8 DC01      		movw r26,r24
 2289 0bba CB01      		movw r24,r22
 2290 0bbc 8C01      		movw r16,r24
 2291 0bbe 9D01      		movw r18,r26
 2292 0bc0 40E0      		ldi r20,0
 2293 0bc2 52EC      		ldi r21,lo8(-62)
 2294 0bc4 61E0      		ldi r22,lo8(1)
 2295 0bc6 70E0      		ldi r23,0
 2296 0bc8 80EC      		ldi r24,lo8(-64)
 2297 0bca 90E0      		ldi r25,0
 2298 0bcc 0E94 0000 		call usart_set_baudrate_precalculated
 2299               	.L83:
 736:ServerLLDN.c  **** 
 737:ServerLLDN.c  **** 	#endif
 738:ServerLLDN.c  **** 	#endif
 739:ServerLLDN.c  **** 		for(;;)
 740:ServerLLDN.c  **** 		{
 741:ServerLLDN.c  **** 			SYS_TaskHandler();
 2300               		.loc 6 741 0 discriminator 1
 2301 0bd0 0E94 0000 		call SYS_TaskHandler
 742:ServerLLDN.c  **** 			APP_TaskHandler();
 2302               		.loc 6 742 0 discriminator 1
 2303 0bd4 0E94 0000 		call APP_TaskHandler
 743:ServerLLDN.c  **** 		}
 2304               		.loc 6 743 0 discriminator 1
 2305 0bd8 00C0      		rjmp .L83
 2306               		.cfi_endproc
 2307               	.LFE145:
 2309               	.Letext0:
 2310               		.file 7 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\in
 2311               		.file 8 "../../../stack/LwMesh/TDMA/nwk/inc/nwkRx.h"
 2312               		.file 9 "../../../stack/LwMesh/TDMA/nwk/inc/nwkDataReq.h"
 2313               		.file 10 "../../../stack/LwMesh/TDMA/sys/inc/sysTimer.h"
 2314               		.file 11 "../../../platform/mega_rf/drivers/sleep/sleep.h"
 2315               		.file 12 "lldn.h"
 2316               		.file 13 "../../../platform/mega_rf/utils/status_codes.h"
 2317               		.file 14 "config/config.h"
 2318               		.file 15 "../../../platform/common/services/sleepmgr/mega_rf/sleepmgr.h"
DEFINED SYMBOLS
                            *ABS*:00000000 ServerLLDN.c
C:\Users\GUILHE~1\AppData\Local\Temp\ccipWiYi.s:2      *ABS*:0000003e __SP_H__
C:\Users\GUILHE~1\AppData\Local\Temp\ccipWiYi.s:3      *ABS*:0000003d __SP_L__
C:\Users\GUILHE~1\AppData\Local\Temp\ccipWiYi.s:4      *ABS*:0000003f __SREG__
C:\Users\GUILHE~1\AppData\Local\Temp\ccipWiYi.s:5      *ABS*:0000003b __RAMPZ__
C:\Users\GUILHE~1\AppData\Local\Temp\ccipWiYi.s:6      *ABS*:00000000 __tmp_reg__
C:\Users\GUILHE~1\AppData\Local\Temp\ccipWiYi.s:7      *ABS*:00000001 __zero_reg__
                            *COM*:00000001 n
C:\Users\GUILHE~1\AppData\Local\Temp\ccipWiYi.s:15     .bss.tTS:00000000 tTS
C:\Users\GUILHE~1\AppData\Local\Temp\ccipWiYi.s:19     .text:00000000 sysclk_get_main_hz
C:\Users\GUILHE~1\AppData\Local\Temp\ccipWiYi.s:56     .text:0000001a sysclk_get_source_clock_hz
C:\Users\GUILHE~1\AppData\Local\Temp\ccipWiYi.s:93     .progmem.data.baudctrl_1mhz:00000000 baudctrl_1mhz
C:\Users\GUILHE~1\AppData\Local\Temp\ccipWiYi.s:105    .progmem.data.baudctrl_8mhz:00000000 baudctrl_8mhz
C:\Users\GUILHE~1\AppData\Local\Temp\ccipWiYi.s:117    .progmem.data.baudctrl_16mhz:00000000 baudctrl_16mhz
C:\Users\GUILHE~1\AppData\Local\Temp\ccipWiYi.s:128    .text:00000034 usart_double_baud_enable
C:\Users\GUILHE~1\AppData\Local\Temp\ccipWiYi.s:177    .text:00000062 usart_serial_init
C:\Users\GUILHE~1\AppData\Local\Temp\ccipWiYi.s:272    .text:000000de usart_serial_putchar
C:\Users\GUILHE~1\AppData\Local\Temp\ccipWiYi.s:316    .text:00000106 usart_serial_getchar
C:\Users\GUILHE~1\AppData\Local\Temp\ccipWiYi.s:367    .text:0000013c stdio_serial_init
C:\Users\GUILHE~1\AppData\Local\Temp\ccipWiYi.s:438    .text:0000019e macsc_enable_manual_bts
C:\Users\GUILHE~1\AppData\Local\Temp\ccipWiYi.s:492    .bss.appState:00000000 appState
C:\Users\GUILHE~1\AppData\Local\Temp\ccipWiYi.s:497    .bss.msgReq:00000000 msgReq
C:\Users\GUILHE~1\AppData\Local\Temp\ccipWiYi.s:502    .bss.PanId:00000000 PanId
C:\Users\GUILHE~1\AppData\Local\Temp\ccipWiYi.s:510    .text:000001d2 appSendData
C:\Users\GUILHE~1\AppData\Local\Temp\ccipWiYi.s:572    .data.appPanState:00000000 appPanState
                            *COM*:000004f6 nodes_info_arr
C:\Users\GUILHE~1\AppData\Local\Temp\ccipWiYi.s:579    .data.config_request_frame:00000000 config_request_frame
C:\Users\GUILHE~1\AppData\Local\Temp\ccipWiYi.s:589    .bss.conf_req_list:00000000 conf_req_list
C:\Users\GUILHE~1\AppData\Local\Temp\ccipWiYi.s:595    .bss.index_nodes_array:00000000 index_nodes_array
                            *COM*:00000021 ACKFrame
C:\Users\GUILHE~1\AppData\Local\Temp\ccipWiYi.s:602    .bss.ACKFrame_size:00000000 ACKFrame_size
C:\Users\GUILHE~1\AppData\Local\Temp\ccipWiYi.s:608    .bss.beaconInterval:00000000 beaconInterval
C:\Users\GUILHE~1\AppData\Local\Temp\ccipWiYi.s:614    .bss.macLLDNnumUplinkTS:00000000 macLLDNnumUplinkTS
C:\Users\GUILHE~1\AppData\Local\Temp\ccipWiYi.s:619    .bss.tmrDelay:00000000 tmrDelay
C:\Users\GUILHE~1\AppData\Local\Temp\ccipWiYi.s:625    .bss.counter_associados:00000000 counter_associados
C:\Users\GUILHE~1\AppData\Local\Temp\ccipWiYi.s:631    .data.cycles_counter:00000000 cycles_counter
C:\Users\GUILHE~1\AppData\Local\Temp\ccipWiYi.s:635    .text:0000021e tmrDelayHandler
C:\Users\GUILHE~1\AppData\Local\Temp\ccipWiYi.s:675    .text:0000023e lldn_server_beacon
C:\Users\GUILHE~1\AppData\Local\Temp\ccipWiYi.s:710    .text:00000258 downlink_delay_handler
C:\Users\GUILHE~1\AppData\Local\Temp\ccipWiYi.s:750    .text:0000027c end_of_online_handler
C:\Users\GUILHE~1\AppData\Local\Temp\ccipWiYi.s:790    .text:00000298 addToAckArray
C:\Users\GUILHE~1\AppData\Local\Temp\ccipWiYi.s:923    .text:00000360 get_next_confreq
C:\Users\GUILHE~1\AppData\Local\Temp\ccipWiYi.s:1019   .text:000003f8 addConfRequestArray
C:\Users\GUILHE~1\AppData\Local\Temp\ccipWiYi.s:1174   .text:000004e6 appCommandInd
C:\Users\GUILHE~1\AppData\Local\Temp\ccipWiYi.s:1332   .text:000005d4 appPanPrepareACK
C:\Users\GUILHE~1\AppData\Local\Temp\ccipWiYi.s:1398   .text:00000634 appPanReset
C:\Users\GUILHE~1\AppData\Local\Temp\ccipWiYi.s:1530   .text:000006ee appPanDiscInit
C:\Users\GUILHE~1\AppData\Local\Temp\ccipWiYi.s:1718   .text:00000858 appPanOnlineInit
C:\Users\GUILHE~1\AppData\Local\Temp\ccipWiYi.s:1769   .text:00000890 appInit
C:\Users\GUILHE~1\AppData\Local\Temp\ccipWiYi.s:1861   .text:0000091c APP_TaskHandler
C:\Users\GUILHE~1\AppData\Local\Temp\ccipWiYi.s:2213   .text:00000b60 main

UNDEFINED SYMBOLS
usart_init_rs232
usart_putchar
usart_getchar
stdio_base
ptr_put
ptr_get
_read
_write
fdevopen
printf
NWK_DataReq
free
__floatsisf
__addsf3
__divsf3
__mulsf3
__fixunssfsi
macsc_set_cmp1_int_cb
macsc_enable_cmp_int
macsc_use_cmp
NWK_SetAddr
PHY_SetChannel
PHY_SetRxState
NWK_SetPanId
PHY_SetTdmaMode
NWK_OpenEndpoint
PHY_SetPromiscuousMode
__tablejump2__
macsc_disable_cmp_int
SYS_TimerStart
sysclk_init
board_init
SYS_Init
sm_init
usart_set_baudrate_precalculated
SYS_TaskHandler
__do_copy_data
__do_clear_bss
