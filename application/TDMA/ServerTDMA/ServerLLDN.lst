   1               		.file	"ServerLLDN.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__RAMPZ__ = 0x3b
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.text
   9               	.Ltext0:
  10               		.cfi_sections	.debug_frame
  11               	.global	n
  12               		.section	.bss.n,"aw",@nobits
  15               	n:
  16 0000 00        		.zero	1
  17               		.section	.bss.tTS,"aw",@nobits
  20               	tTS:
  21 0000 0000 0000 		.zero	4
  22               		.text
  24               	sysclk_get_main_hz:
  25               	.LFB67:
  26               		.file 1 "../../../platform/common/services/clock/mega/sysclk.h"
   1:../../../platform/common/services/clock/mega/sysclk.h **** /**
   2:../../../platform/common/services/clock/mega/sysclk.h ****  * \file
   3:../../../platform/common/services/clock/mega/sysclk.h ****  *
   4:../../../platform/common/services/clock/mega/sysclk.h ****  * \brief Chip-specific system clock management functions
   5:../../../platform/common/services/clock/mega/sysclk.h ****  *
   6:../../../platform/common/services/clock/mega/sysclk.h ****  * Copyright (c) 2012 Atmel Corporation. All rights reserved.
   7:../../../platform/common/services/clock/mega/sysclk.h ****  *
   8:../../../platform/common/services/clock/mega/sysclk.h ****  * \asf_license_start
   9:../../../platform/common/services/clock/mega/sysclk.h ****  *
  10:../../../platform/common/services/clock/mega/sysclk.h ****  * \page License
  11:../../../platform/common/services/clock/mega/sysclk.h ****  *
  12:../../../platform/common/services/clock/mega/sysclk.h ****  * Redistribution and use in source and binary forms, with or without
  13:../../../platform/common/services/clock/mega/sysclk.h ****  * modification, are permitted provided that the following conditions are met:
  14:../../../platform/common/services/clock/mega/sysclk.h ****  *
  15:../../../platform/common/services/clock/mega/sysclk.h ****  * 1. Redistributions of source code must retain the above copyright notice,
  16:../../../platform/common/services/clock/mega/sysclk.h ****  *    this list of conditions and the following disclaimer.
  17:../../../platform/common/services/clock/mega/sysclk.h ****  *
  18:../../../platform/common/services/clock/mega/sysclk.h ****  * 2. Redistributions in binary form must reproduce the above copyright notice,
  19:../../../platform/common/services/clock/mega/sysclk.h ****  *    this list of conditions and the following disclaimer in the documentation
  20:../../../platform/common/services/clock/mega/sysclk.h ****  *    and/or other materials provided with the distribution.
  21:../../../platform/common/services/clock/mega/sysclk.h ****  *
  22:../../../platform/common/services/clock/mega/sysclk.h ****  * 3. The name of Atmel may not be used to endorse or promote products derived
  23:../../../platform/common/services/clock/mega/sysclk.h ****  *    from this software without specific prior written permission.
  24:../../../platform/common/services/clock/mega/sysclk.h ****  *
  25:../../../platform/common/services/clock/mega/sysclk.h ****  * 4. This software may only be redistributed and used in connection with an
  26:../../../platform/common/services/clock/mega/sysclk.h ****  *    Atmel microcontroller product.
  27:../../../platform/common/services/clock/mega/sysclk.h ****  *
  28:../../../platform/common/services/clock/mega/sysclk.h ****  * THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR IMPLIED
  29:../../../platform/common/services/clock/mega/sysclk.h ****  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
  30:../../../platform/common/services/clock/mega/sysclk.h ****  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
  31:../../../platform/common/services/clock/mega/sysclk.h ****  * EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR
  32:../../../platform/common/services/clock/mega/sysclk.h ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  33:../../../platform/common/services/clock/mega/sysclk.h ****  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
  34:../../../platform/common/services/clock/mega/sysclk.h ****  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  35:../../../platform/common/services/clock/mega/sysclk.h ****  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
  36:../../../platform/common/services/clock/mega/sysclk.h ****  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  37:../../../platform/common/services/clock/mega/sysclk.h ****  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  38:../../../platform/common/services/clock/mega/sysclk.h ****  * POSSIBILITY OF SUCH DAMAGE.
  39:../../../platform/common/services/clock/mega/sysclk.h ****  *
  40:../../../platform/common/services/clock/mega/sysclk.h ****  * \asf_license_stop
  41:../../../platform/common/services/clock/mega/sysclk.h ****  *
  42:../../../platform/common/services/clock/mega/sysclk.h ****  */
  43:../../../platform/common/services/clock/mega/sysclk.h **** #ifndef MEGA_SYSCLK_H_INCLUDED
  44:../../../platform/common/services/clock/mega/sysclk.h **** #define MEGA_SYSCLK_H_INCLUDED
  45:../../../platform/common/services/clock/mega/sysclk.h **** 
  46:../../../platform/common/services/clock/mega/sysclk.h **** #include <board.h>
  47:../../../platform/common/services/clock/mega/sysclk.h **** #include <compiler.h>
  48:../../../platform/common/services/clock/mega/sysclk.h **** #include <parts.h>
  49:../../../platform/common/services/clock/mega/sysclk.h **** 
  50:../../../platform/common/services/clock/mega/sysclk.h **** /* Include clock configuration for the project. */
  51:../../../platform/common/services/clock/mega/sysclk.h **** #include <conf_clock.h>
  52:../../../platform/common/services/clock/mega/sysclk.h **** 
  53:../../../platform/common/services/clock/mega/sysclk.h **** #ifdef __cplusplus
  54:../../../platform/common/services/clock/mega/sysclk.h **** extern "C" {
  55:../../../platform/common/services/clock/mega/sysclk.h **** #endif
  56:../../../platform/common/services/clock/mega/sysclk.h **** #define ASM __asm__
  57:../../../platform/common/services/clock/mega/sysclk.h **** 
  58:../../../platform/common/services/clock/mega/sysclk.h **** /* CONFIG_SYSCLK_PSDIV  to use default if not defined*/
  59:../../../platform/common/services/clock/mega/sysclk.h **** #ifndef CONFIG_SYSCLK_PSDIV
  60:../../../platform/common/services/clock/mega/sysclk.h **** # define CONFIG_SYSCLK_PSDIV    SYSCLK_PSDIV_8
  61:../../../platform/common/services/clock/mega/sysclk.h **** #endif
  62:../../../platform/common/services/clock/mega/sysclk.h **** 
  63:../../../platform/common/services/clock/mega/sysclk.h **** /* ! \name Prescaler Setting (relative to CLKsys) */
  64:../../../platform/common/services/clock/mega/sysclk.h **** /* @{ */
  65:../../../platform/common/services/clock/mega/sysclk.h **** #define SYSCLK_PSDIV_1      0   /* !< Do not prescale */
  66:../../../platform/common/services/clock/mega/sysclk.h **** #define SYSCLK_PSDIV_2      1   /* !< Prescale CLKper4 by 2 */
  67:../../../platform/common/services/clock/mega/sysclk.h **** #define SYSCLK_PSDIV_4      2   /* !< Prescale CLKper4 by 4 */
  68:../../../platform/common/services/clock/mega/sysclk.h **** #define SYSCLK_PSDIV_8      3   /* !< Prescale CLKper4 by 8 */
  69:../../../platform/common/services/clock/mega/sysclk.h **** #define SYSCLK_PSDIV_16     4   /* !< Prescale CLKper4 by 16 */
  70:../../../platform/common/services/clock/mega/sysclk.h **** #define SYSCLK_PSDIV_32     5   /* !< Prescale CLKper4 by 32 */
  71:../../../platform/common/services/clock/mega/sysclk.h **** #define SYSCLK_PSDIV_64     6   /* !< Prescale CLKper4 by 64 */
  72:../../../platform/common/services/clock/mega/sysclk.h **** #define SYSCLK_PSDIV_128    7   /* !< Prescale CLKper4 by 128 */
  73:../../../platform/common/services/clock/mega/sysclk.h **** #define SYSCLK_PSDIV_256    8   /* !< Prescale CLKper4 by 256 */
  74:../../../platform/common/services/clock/mega/sysclk.h **** 
  75:../../../platform/common/services/clock/mega/sysclk.h **** /* @} */
  76:../../../platform/common/services/clock/mega/sysclk.h **** 
  77:../../../platform/common/services/clock/mega/sysclk.h **** #if MEGA_RF || MEGA_XX0_1 || MEGA_XX4 || MEGA_XX4_A
  78:../../../platform/common/services/clock/mega/sysclk.h **** 
  79:../../../platform/common/services/clock/mega/sysclk.h **** #define NUMBER_OF_POWER_REG       2
  80:../../../platform/common/services/clock/mega/sysclk.h **** /*Starting Address for power reduction*/
  81:../../../platform/common/services/clock/mega/sysclk.h **** #define POWER_REG_ADD             PRR0
  82:../../../platform/common/services/clock/mega/sysclk.h **** 
  83:../../../platform/common/services/clock/mega/sysclk.h **** /* ! \name Power Reduction  Clock Port Numbers */
  84:../../../platform/common/services/clock/mega/sysclk.h **** enum power_red_id {
  85:../../../platform/common/services/clock/mega/sysclk.h **** 	POWER_RED_REG0,     /* !< Devices on PRR0 */
  86:../../../platform/common/services/clock/mega/sysclk.h **** #if !MEGA_XX4 || !MEGA_XX4_A || MEGA_XX0_1
  87:../../../platform/common/services/clock/mega/sysclk.h **** 	POWER_RED_REG1,     /* !< Devices on PRR1 */
  88:../../../platform/common/services/clock/mega/sysclk.h **** #endif
  89:../../../platform/common/services/clock/mega/sysclk.h **** };
  90:../../../platform/common/services/clock/mega/sysclk.h **** #endif
  91:../../../platform/common/services/clock/mega/sysclk.h **** 
  92:../../../platform/common/services/clock/mega/sysclk.h **** /****************************************************
  93:../../../platform/common/services/clock/mega/sysclk.h ****  * Given a dummy type but not used for these groups
  94:../../../platform/common/services/clock/mega/sysclk.h ****  * to support for otherthen megaRF device.
  95:../../../platform/common/services/clock/mega/sysclk.h ****  **************************************************/
  96:../../../platform/common/services/clock/mega/sysclk.h **** #if MEGA_XX8 || MEGA_XX8_A || MEGA_UNSPECIFIED
  97:../../../platform/common/services/clock/mega/sysclk.h **** #define NUMBER_OF_POWER_REG       1
  98:../../../platform/common/services/clock/mega/sysclk.h **** /*Starting Address for power reduction*/
  99:../../../platform/common/services/clock/mega/sysclk.h **** #define POWER_REG_ADD             PRR
 100:../../../platform/common/services/clock/mega/sysclk.h **** 
 101:../../../platform/common/services/clock/mega/sysclk.h **** /* ! \name Power Reduction  Clock Port Numbers */
 102:../../../platform/common/services/clock/mega/sysclk.h **** enum power_red_id {
 103:../../../platform/common/services/clock/mega/sysclk.h **** 	POWER_RED_REG0,     /* !< Devices on PRR */
 104:../../../platform/common/services/clock/mega/sysclk.h **** };
 105:../../../platform/common/services/clock/mega/sysclk.h **** #endif
 106:../../../platform/common/services/clock/mega/sysclk.h **** 
 107:../../../platform/common/services/clock/mega/sysclk.h **** /* Bit mask for the power reduction register based on */
 108:../../../platform/common/services/clock/mega/sysclk.h **** /*   MCU ARCH.                                        */
 109:../../../platform/common/services/clock/mega/sysclk.h **** #if MEGA_RF
 110:../../../platform/common/services/clock/mega/sysclk.h **** /*Bit mask for PRR2 */
 111:../../../platform/common/services/clock/mega/sysclk.h **** 
 112:../../../platform/common/services/clock/mega/sysclk.h **** #define PRRAM0_bm                       1 << PRRAM0
 113:../../../platform/common/services/clock/mega/sysclk.h **** #define PRRAM1_bm                       1 << PRRAM1
 114:../../../platform/common/services/clock/mega/sysclk.h **** #define PRRAM2_bm                       1 << PRRAM2
 115:../../../platform/common/services/clock/mega/sysclk.h **** #define PRRAM3_bm                       1 << PRRAM3
 116:../../../platform/common/services/clock/mega/sysclk.h **** #endif
 117:../../../platform/common/services/clock/mega/sysclk.h **** 
 118:../../../platform/common/services/clock/mega/sysclk.h **** /*Bit mask for the power reduction 0 or PRR*/
 119:../../../platform/common/services/clock/mega/sysclk.h **** #if !MEGA_XX_UN0 && !MEGA_XX_UN0
 120:../../../platform/common/services/clock/mega/sysclk.h **** #define PRADC_bm                        1 << PRADC
 121:../../../platform/common/services/clock/mega/sysclk.h **** #define PRUSART0_bm                     1 << PRUSART0
 122:../../../platform/common/services/clock/mega/sysclk.h **** #define PRSPI_bm                        1 << PRSPI
 123:../../../platform/common/services/clock/mega/sysclk.h **** #define PRTIM1_bm                       1 << PRTIM1
 124:../../../platform/common/services/clock/mega/sysclk.h **** #endif
 125:../../../platform/common/services/clock/mega/sysclk.h **** 
 126:../../../platform/common/services/clock/mega/sysclk.h **** #if MEGA_RF
 127:../../../platform/common/services/clock/mega/sysclk.h **** #define PRPGA_bm                        1 << PRPGA
 128:../../../platform/common/services/clock/mega/sysclk.h **** #endif
 129:../../../platform/common/services/clock/mega/sysclk.h **** 
 130:../../../platform/common/services/clock/mega/sysclk.h **** #if !MEGA_UNSPECIFIED
 131:../../../platform/common/services/clock/mega/sysclk.h **** #define PRTIM0_bm                       1 << PRTIM0
 132:../../../platform/common/services/clock/mega/sysclk.h **** #define PRTIM2_bm                       1 << PRTIM2
 133:../../../platform/common/services/clock/mega/sysclk.h **** #define PRTWI_bm                        1 << PRTWI
 134:../../../platform/common/services/clock/mega/sysclk.h **** #endif
 135:../../../platform/common/services/clock/mega/sysclk.h **** 
 136:../../../platform/common/services/clock/mega/sysclk.h **** #if MEGA_XX_UN2
 137:../../../platform/common/services/clock/mega/sysclk.h **** #define PRLCD_bm                        1 << PRLCD
 138:../../../platform/common/services/clock/mega/sysclk.h **** #endif
 139:../../../platform/common/services/clock/mega/sysclk.h **** 
 140:../../../platform/common/services/clock/mega/sysclk.h **** /*Bit mask for  PRR1  */
 141:../../../platform/common/services/clock/mega/sysclk.h **** #ifdef PRR1
 142:../../../platform/common/services/clock/mega/sysclk.h **** #if (MEGA_XX4 || MEGA_XX4_A)
 143:../../../platform/common/services/clock/mega/sysclk.h **** #define PRTIM3_bm                       1 << PRTIM3
 144:../../../platform/common/services/clock/mega/sysclk.h **** #endif
 145:../../../platform/common/services/clock/mega/sysclk.h **** #endif
 146:../../../platform/common/services/clock/mega/sysclk.h **** 
 147:../../../platform/common/services/clock/mega/sysclk.h **** #if MEGA_RF || MEGA_XX4 || MEGA_XX4_A
 148:../../../platform/common/services/clock/mega/sysclk.h **** #define PRUSART1_bm                     1 << PRUSART1
 149:../../../platform/common/services/clock/mega/sysclk.h **** #define PRUSART2_bm                     1 << PRUSART2
 150:../../../platform/common/services/clock/mega/sysclk.h **** #define PRUSART3_bm                     1 << PRUSART3
 151:../../../platform/common/services/clock/mega/sysclk.h **** #define PRTIM3_bm                       1 << PRTIM3
 152:../../../platform/common/services/clock/mega/sysclk.h **** #define PRTIM4_bm                       1 << PRTIM4
 153:../../../platform/common/services/clock/mega/sysclk.h **** #define PRTIM5_bm                       1 << PRTIM5
 154:../../../platform/common/services/clock/mega/sysclk.h **** #endif
 155:../../../platform/common/services/clock/mega/sysclk.h **** 
 156:../../../platform/common/services/clock/mega/sysclk.h **** #if MEGA_RF
 157:../../../platform/common/services/clock/mega/sysclk.h **** #define PRTRX24_bm                      1 << PRTRX24
 158:../../../platform/common/services/clock/mega/sysclk.h **** #endif
 159:../../../platform/common/services/clock/mega/sysclk.h **** 
 160:../../../platform/common/services/clock/mega/sysclk.h **** /**
 161:../../../platform/common/services/clock/mega/sysclk.h ****  * \name Querying the system clock and its derived clocks
 162:../../../platform/common/services/clock/mega/sysclk.h ****  */
 163:../../../platform/common/services/clock/mega/sysclk.h **** /* @{ */
 164:../../../platform/common/services/clock/mega/sysclk.h **** 
 165:../../../platform/common/services/clock/mega/sysclk.h **** /**
 166:../../../platform/common/services/clock/mega/sysclk.h ****  * \brief Return the current rate in Hz of the main system clock
 167:../../../platform/common/services/clock/mega/sysclk.h ****  * To know the clock value at what frequency the main clock is running
 168:../../../platform/common/services/clock/mega/sysclk.h ****  * \return Frequency of the main system clock, in Hz.
 169:../../../platform/common/services/clock/mega/sysclk.h ****  * \todo : please initialize the SYSCLK_SOURCE in conf_clock.h file for
 170:../../../platform/common/services/clock/mega/sysclk.h ****  * configured source clock using fuses.
 171:../../../platform/common/services/clock/mega/sysclk.h ****  * \eg. #define SYSCLK_SOURCE SYSCLK_SRC_RC16MHZ to use internal RC
 172:../../../platform/common/services/clock/mega/sysclk.h ****  * oscillator for clock source.
 173:../../../platform/common/services/clock/mega/sysclk.h ****  */
 174:../../../platform/common/services/clock/mega/sysclk.h **** static inline uint32_t sysclk_get_main_hz(void)
 175:../../../platform/common/services/clock/mega/sysclk.h **** {
  27               		.loc 1 175 0
  28               		.cfi_startproc
  29 0000 CF93      		push r28
  30               	.LCFI0:
  31               		.cfi_def_cfa_offset 3
  32               		.cfi_offset 28, -2
  33 0002 DF93      		push r29
  34               	.LCFI1:
  35               		.cfi_def_cfa_offset 4
  36               		.cfi_offset 29, -3
  37 0004 CDB7      		in r28,__SP_L__
  38 0006 DEB7      		in r29,__SP_H__
  39               	.LCFI2:
  40               		.cfi_def_cfa_register 28
  41               	/* prologue: function */
  42               	/* frame size = 0 */
  43               	/* stack size = 2 */
  44               	.L__stack_usage = 2
 176:../../../platform/common/services/clock/mega/sysclk.h **** 	switch (SYSCLK_SOURCE) {
 177:../../../platform/common/services/clock/mega/sysclk.h **** 	case SYSCLK_SRC_RC16MHZ:
 178:../../../platform/common/services/clock/mega/sysclk.h **** 		return 16000000UL;
 179:../../../platform/common/services/clock/mega/sysclk.h **** 
 180:../../../platform/common/services/clock/mega/sysclk.h **** 	case SYSCLK_SRC_RC128KHZ:
 181:../../../platform/common/services/clock/mega/sysclk.h **** 		return 128000UL;
 182:../../../platform/common/services/clock/mega/sysclk.h **** 
 183:../../../platform/common/services/clock/mega/sysclk.h **** #if MEGA_RF
 184:../../../platform/common/services/clock/mega/sysclk.h **** 	case SYSCLK_SRC_TRS16MHZ:
 185:../../../platform/common/services/clock/mega/sysclk.h **** 		return 16000000UL;
  45               		.loc 1 185 0
  46 0008 80E0      		ldi r24,0
  47 000a 94E2      		ldi r25,lo8(36)
  48 000c A4EF      		ldi r26,lo8(-12)
  49 000e B0E0      		ldi r27,0
 186:../../../platform/common/services/clock/mega/sysclk.h **** #endif
 187:../../../platform/common/services/clock/mega/sysclk.h **** #ifdef BOARD_EXTERNAL_CLK
 188:../../../platform/common/services/clock/mega/sysclk.h **** 	case SYSCLK_SRC_EXTERNAL:
 189:../../../platform/common/services/clock/mega/sysclk.h **** 		return BOARD_EXTERNAL_CLK;
 190:../../../platform/common/services/clock/mega/sysclk.h **** #endif
 191:../../../platform/common/services/clock/mega/sysclk.h **** 	default:
 192:../../../platform/common/services/clock/mega/sysclk.h **** 
 193:../../../platform/common/services/clock/mega/sysclk.h **** 		return 1000000UL;
 194:../../../platform/common/services/clock/mega/sysclk.h **** 	}
 195:../../../platform/common/services/clock/mega/sysclk.h **** }
  50               		.loc 1 195 0
  51 0010 BC01      		movw r22,r24
  52 0012 CD01      		movw r24,r26
  53               	/* epilogue start */
  54 0014 DF91      		pop r29
  55 0016 CF91      		pop r28
  56 0018 0895      		ret
  57               		.cfi_endproc
  58               	.LFE67:
  61               	sysclk_get_source_clock_hz:
  62               	.LFB68:
 196:../../../platform/common/services/clock/mega/sysclk.h **** 
 197:../../../platform/common/services/clock/mega/sysclk.h **** /**
 198:../../../platform/common/services/clock/mega/sysclk.h ****  * \brief Return the current rate in Hz of source clock in Hz.
 199:../../../platform/common/services/clock/mega/sysclk.h ****  *
 200:../../../platform/common/services/clock/mega/sysclk.h ****  * This clock always runs at the same rate as the CPU clock unless the divider
 201:../../../platform/common/services/clock/mega/sysclk.h ****  * is set.
 202:../../../platform/common/services/clock/mega/sysclk.h ****  *
 203:../../../platform/common/services/clock/mega/sysclk.h ****  * \return Frequency of the system clock, in Hz.
 204:../../../platform/common/services/clock/mega/sysclk.h ****  */
 205:../../../platform/common/services/clock/mega/sysclk.h **** static inline uint32_t sysclk_get_source_clock_hz(void)
 206:../../../platform/common/services/clock/mega/sysclk.h **** {
  63               		.loc 1 206 0
  64               		.cfi_startproc
  65 001a CF93      		push r28
  66               	.LCFI3:
  67               		.cfi_def_cfa_offset 3
  68               		.cfi_offset 28, -2
  69 001c DF93      		push r29
  70               	.LCFI4:
  71               		.cfi_def_cfa_offset 4
  72               		.cfi_offset 29, -3
  73 001e CDB7      		in r28,__SP_L__
  74 0020 DEB7      		in r29,__SP_H__
  75               	.LCFI5:
  76               		.cfi_def_cfa_register 28
  77               	/* prologue: function */
  78               	/* frame size = 0 */
  79               	/* stack size = 2 */
  80               	.L__stack_usage = 2
 207:../../../platform/common/services/clock/mega/sysclk.h **** 	switch (CONFIG_SYSCLK_PSDIV) {
 208:../../../platform/common/services/clock/mega/sysclk.h **** 	case SYSCLK_PSDIV_1: /* Fall through */
 209:../../../platform/common/services/clock/mega/sysclk.h **** 		if (SYSCLK_SOURCE == SYSCLK_SRC_RC16MHZ ||
 210:../../../platform/common/services/clock/mega/sysclk.h **** 				SYSCLK_SOURCE == SYSCLK_SRC_RC128KHZ) {
 211:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 2;
 212:../../../platform/common/services/clock/mega/sysclk.h **** 		} else {
 213:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz();
  81               		.loc 1 213 0
  82 0022 0E94 0000 		call sysclk_get_main_hz
  83 0026 DC01      		movw r26,r24
  84 0028 CB01      		movw r24,r22
 214:../../../platform/common/services/clock/mega/sysclk.h **** 		}
 215:../../../platform/common/services/clock/mega/sysclk.h **** 
 216:../../../platform/common/services/clock/mega/sysclk.h **** 	case SYSCLK_PSDIV_2:
 217:../../../platform/common/services/clock/mega/sysclk.h **** 		if (SYSCLK_SOURCE == SYSCLK_SRC_RC16MHZ ||
 218:../../../platform/common/services/clock/mega/sysclk.h **** 				SYSCLK_SOURCE == SYSCLK_SRC_RC128KHZ) {
 219:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 4;
 220:../../../platform/common/services/clock/mega/sysclk.h **** 		} else {
 221:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 2;
 222:../../../platform/common/services/clock/mega/sysclk.h **** 		}
 223:../../../platform/common/services/clock/mega/sysclk.h **** 
 224:../../../platform/common/services/clock/mega/sysclk.h **** 	case SYSCLK_PSDIV_4:
 225:../../../platform/common/services/clock/mega/sysclk.h **** 		if (SYSCLK_SOURCE == SYSCLK_SRC_RC16MHZ ||
 226:../../../platform/common/services/clock/mega/sysclk.h **** 				SYSCLK_SOURCE == SYSCLK_SRC_RC128KHZ) {
 227:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 8;
 228:../../../platform/common/services/clock/mega/sysclk.h **** 		} else {
 229:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 4;
 230:../../../platform/common/services/clock/mega/sysclk.h **** 		}
 231:../../../platform/common/services/clock/mega/sysclk.h **** 
 232:../../../platform/common/services/clock/mega/sysclk.h **** 	case SYSCLK_PSDIV_8:
 233:../../../platform/common/services/clock/mega/sysclk.h **** 		if (SYSCLK_SOURCE == SYSCLK_SRC_RC16MHZ ||
 234:../../../platform/common/services/clock/mega/sysclk.h **** 				SYSCLK_SOURCE == SYSCLK_SRC_RC128KHZ) {
 235:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 16;
 236:../../../platform/common/services/clock/mega/sysclk.h **** 		} else {
 237:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 8;
 238:../../../platform/common/services/clock/mega/sysclk.h **** 		}
 239:../../../platform/common/services/clock/mega/sysclk.h **** 
 240:../../../platform/common/services/clock/mega/sysclk.h **** 	case SYSCLK_PSDIV_16:
 241:../../../platform/common/services/clock/mega/sysclk.h **** 		if (SYSCLK_SOURCE == SYSCLK_SRC_RC16MHZ ||
 242:../../../platform/common/services/clock/mega/sysclk.h **** 				SYSCLK_SOURCE == SYSCLK_SRC_RC128KHZ) {
 243:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 32;
 244:../../../platform/common/services/clock/mega/sysclk.h **** 		} else {
 245:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 16;
 246:../../../platform/common/services/clock/mega/sysclk.h **** 		}
 247:../../../platform/common/services/clock/mega/sysclk.h **** 
 248:../../../platform/common/services/clock/mega/sysclk.h **** 	case SYSCLK_PSDIV_32:
 249:../../../platform/common/services/clock/mega/sysclk.h **** 		if (SYSCLK_SOURCE == SYSCLK_SRC_RC16MHZ ||
 250:../../../platform/common/services/clock/mega/sysclk.h **** 				SYSCLK_SOURCE == SYSCLK_SRC_RC128KHZ) {
 251:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 64;
 252:../../../platform/common/services/clock/mega/sysclk.h **** 		} else {
 253:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 32;
 254:../../../platform/common/services/clock/mega/sysclk.h **** 		}
 255:../../../platform/common/services/clock/mega/sysclk.h **** 
 256:../../../platform/common/services/clock/mega/sysclk.h **** 	case SYSCLK_PSDIV_64:
 257:../../../platform/common/services/clock/mega/sysclk.h **** 		if (SYSCLK_SOURCE == SYSCLK_SRC_RC16MHZ ||
 258:../../../platform/common/services/clock/mega/sysclk.h **** 				SYSCLK_SOURCE == SYSCLK_SRC_RC128KHZ) {
 259:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 128;
 260:../../../platform/common/services/clock/mega/sysclk.h **** 		} else {
 261:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 64;
 262:../../../platform/common/services/clock/mega/sysclk.h **** 		}
 263:../../../platform/common/services/clock/mega/sysclk.h **** 
 264:../../../platform/common/services/clock/mega/sysclk.h **** 	case SYSCLK_PSDIV_128:
 265:../../../platform/common/services/clock/mega/sysclk.h **** 		if (SYSCLK_SOURCE == SYSCLK_SRC_RC16MHZ ||
 266:../../../platform/common/services/clock/mega/sysclk.h **** 				SYSCLK_SOURCE == SYSCLK_SRC_RC128KHZ) {
 267:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 256;
 268:../../../platform/common/services/clock/mega/sysclk.h **** 		} else {
 269:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 128;
 270:../../../platform/common/services/clock/mega/sysclk.h **** 		}
 271:../../../platform/common/services/clock/mega/sysclk.h **** 
 272:../../../platform/common/services/clock/mega/sysclk.h **** 	case SYSCLK_PSDIV_256:
 273:../../../platform/common/services/clock/mega/sysclk.h **** 		if (SYSCLK_SOURCE == SYSCLK_SRC_RC16MHZ ||
 274:../../../platform/common/services/clock/mega/sysclk.h **** 				SYSCLK_SOURCE == SYSCLK_SRC_RC128KHZ) {
 275:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 512;
 276:../../../platform/common/services/clock/mega/sysclk.h **** 		} else {
 277:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 256;
 278:../../../platform/common/services/clock/mega/sysclk.h **** 		}
 279:../../../platform/common/services/clock/mega/sysclk.h **** 
 280:../../../platform/common/services/clock/mega/sysclk.h **** 	default:
 281:../../../platform/common/services/clock/mega/sysclk.h **** 		/*Invalide case*/
 282:../../../platform/common/services/clock/mega/sysclk.h **** 		return 0;
 283:../../../platform/common/services/clock/mega/sysclk.h **** 	}
 284:../../../platform/common/services/clock/mega/sysclk.h **** }
  85               		.loc 1 284 0
  86 002a BC01      		movw r22,r24
  87 002c CD01      		movw r24,r26
  88               	/* epilogue start */
  89 002e DF91      		pop r29
  90 0030 CF91      		pop r28
  91 0032 0895      		ret
  92               		.cfi_endproc
  93               	.LFE68:
  95               		.section	.progmem.data.baudctrl_1mhz,"a",@progbits
  98               	baudctrl_1mhz:
  99 0000 3300      		.word	51
 100 0002 1900      		.word	25
 101 0004 0C00      		.word	12
 102 0006 0600      		.word	6
 103 0008 0300      		.word	3
 104 000a 0200      		.word	2
 105 000c 0100      		.word	1
 106 000e FF00      		.word	255
 107               		.section	.progmem.data.baudctrl_8mhz,"a",@progbits
 110               	baudctrl_8mhz:
 111 0000 A001      		.word	416
 112 0002 CF00      		.word	207
 113 0004 6700      		.word	103
 114 0006 3300      		.word	51
 115 0008 1900      		.word	25
 116 000a 0C00      		.word	12
 117 000c 0700      		.word	7
 118 000e 0800      		.word	8
 119               		.section	.progmem.data.baudctrl_16mhz,"a",@progbits
 122               	baudctrl_16mhz:
 123 0000 4003      		.word	832
 124 0002 A001      		.word	416
 125 0004 CF00      		.word	207
 126 0006 6700      		.word	103
 127 0008 3300      		.word	51
 128 000a 1900      		.word	25
 129 000c 1000      		.word	16
 130 000e 1000      		.word	16
 131               		.text
 133               	usart_double_baud_enable:
 134               	.LFB101:
 135               		.file 2 "../../../platform/mega_rf/drivers/usart/usart_megarf.h"
   1:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
   2:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \file
   3:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
   4:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief USART driver for AVR MEGARF.
   5:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
   6:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * This file contains basic functions for the AVR MEGA USART, with support for
   7:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * all modes, settings and clock speeds.
   8:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
   9:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * Copyright (c) 2013-2015 Atmel Corporation. All rights reserved.
  10:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
  11:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \asf_license_start
  12:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
  13:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \page License
  14:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
  15:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * Redistribution and use in source and binary forms, with or without
  16:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * modification, are permitted provided that the following conditions are met:
  17:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
  18:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * 1. Redistributions of source code must retain the above copyright notice,
  19:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *    this list of conditions and the following disclaimer.
  20:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
  21:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * 2. Redistributions in binary form must reproduce the above copyright notice,
  22:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *    this list of conditions and the following disclaimer in the documentation
  23:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *    and/or other materials provided with the distribution.
  24:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
  25:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * 3. The name of Atmel may not be used to endorse or promote products derived
  26:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *    from this software without specific prior written permission.
  27:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
  28:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * 4. This software may only be redistributed and used in connection with an
  29:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *    Atmel microcontroller product.
  30:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
  31:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR IMPLIED
  32:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
  33:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
  34:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR
  35:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  36:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
  37:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  38:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
  39:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  40:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  41:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * POSSIBILITY OF SUCH DAMAGE.
  42:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
  43:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \asf_license_stop
  44:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
  45:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
  46:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #ifndef _USART_MEGARF_H_
  47:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define _USART_MEGARF_H_
  48:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
  49:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #ifdef __cplusplus
  50:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** extern "C" {
  51:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #endif
  52:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
  53:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #include "compiler.h"
  54:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #include "status_codes.h"
  55:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
  56:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
  57:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \defgroup megarf_usart_group USART module (USART)
  58:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
  59:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * See \ref megarf_usart_quickstart.
  60:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
  61:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * This is a driver for configuring, enabling, disabling and use of the on-chip
  62:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * USART.
  63:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
  64:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \section dependencies Dependencies
  65:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
  66:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * The USART module depends on the following modules:
  67:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *  - \ref sysclk_group for peripheral clock control.
  68:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *  - \ref port_driver_group for peripheral io port control.
  69:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
  70:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * @{
  71:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
  72:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
  73:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* ! Offset in lookup table for baudrate 1200 */
  74:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_BAUD_1200      0x00
  75:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* ! Offset in lookup table for baudrate 2400 */
  76:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_BAUD_2400      0x01
  77:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* ! Offset in lookup table for baudrate 4800 */
  78:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_BAUD_4800      0x02
  79:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* ! Offset in lookup table for baudrate 9600 */
  80:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_BAUD_9600      0x03
  81:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* ! Offset in lookup table for baudrate 19200 */
  82:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_BAUD_19200     0x04
  83:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* ! Offset in lookup table for baudrate 38400 */
  84:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_BAUD_38400     0x05
  85:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* ! Offset in lookup table for baudrate 57600 */
  86:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_BAUD_57600     0x06
  87:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* ! Offset in lookup table for baudrate 115200 */
  88:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_BAUD_115200    0x07
  89:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* ! Baudrate not in lookup table */
  90:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_BAUD_UNDEFINED 0xFF
  91:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
  92:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** typedef volatile uint8_t register8_t;
  93:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** typedef volatile uint16_t register16_t;
  94:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* Universal Synchronous/Asynchronous Receiver/Transmitter */
  95:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** typedef struct USART_struct {
  96:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	register8_t UCSRnA;  /* Control Register A */
  97:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	register8_t UCSRnB;  /* Control Register B */
  98:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	register8_t UCSRnC;  /* Control Register C */
  99:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	register8_t reserved;
 100:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	register16_t UBRR;  /* Baud Rate Register Value */
 101:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	register8_t UDR;  /* I/O Data Register */
 102:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** } USART_t;
 103:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 104:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USARTA0    (*(USART_t *)0xC0)   /* Universal Asynchronous
 105:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	                                 * Receiver-Transmitter A0 */
 106:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USARTA1    (*(USART_t *)0XC8)   /* Universal Asynchronous
 107:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	                                 * Receiver-Transmitter A1 */
 108:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 109:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* USART.UCSRxA  bit masks and bit positions */
 110:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_RXC_bm  0x80 /* RX complete bit mask.*/
 111:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_RXC_bp  7 /* RX complete bit position.*/
 112:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 113:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_TXC_bm  0x40 /* TX complete bit mask.*/
 114:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_TXC_bp  6 /* TX complete bit position.*/
 115:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 116:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_DRE_bm  0x20 /* DATA Register Empty Bit mask.*/
 117:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_DRE_bp  5 /*  DATA Register Empty bit position.*/
 118:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 119:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_FE_bm   0x10 /* Frame Error bit mask.*/
 120:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_FE_bp   4 /*Frame error bit position.*/
 121:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 122:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_DOR_bm  0x08 /* Data Over Run bit mask.*/
 123:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_DOR_bp  3 /* Data Over Run bit position.*/
 124:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 125:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_UPE_bm  0x04 /* Parity error bit mask.*/
 126:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_UPE_bp  2 /* Parity error bit position.*/
 127:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 128:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_U2X_bm  0x02 /* Double TX speed bit mask.*/
 129:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_U2X_bp  1 /* Double TX speed bit position.*/
 130:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 131:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_MPCM_bm  0x01 /* Multi Processor bit mask.*/
 132:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_MPMC_bp  0 /* Multi processor bit position.*/
 133:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 134:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* USART.UCSRxB  bit masks and bit positions */
 135:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_RXCIE_bm  0x80 /* RX complete interrupt Enable bit mask.*/
 136:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_RXCIE_bp  7 /* RX complete interrupt Enable bit position.*/
 137:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 138:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_TXCIE_bm  0x40 /* TX complete interrupt Enable bit mask.*/
 139:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_TXCIE_bp  6 /* TX complete interrupt Enable bit position.*/
 140:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 141:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_DRIE_bm  0x20 /* Data register empty interrupt Enable bit mask.*/
 142:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_DRIE_bp  5 /* Data register empty interrupt Enable bit position.*/
 143:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 144:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_RXEN_bm  0x10  /* Receiver Enable bit mask. */
 145:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_RXEN_bp  4  /* Receiver Enable bit position. */
 146:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 147:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_TXEN_bm  0x08  /* Transmitter Enable bit mask. */
 148:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_TXEN_bp  3  /* Transmitter Enable bit position. */
 149:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 150:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_CHSIZE2_bm  0x04  /* Character Size bit mask. */
 151:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_CHSIZE2_bp  2 /* Character Size bit position. */
 152:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 153:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_RXB8_bm  0x02  /* Transmit bit 8 bit mask. */
 154:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_RXB8_bp  1  /* Transmit bit 8 bit position. */
 155:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 156:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_TXB8_bm  0x01  /* Transmit bit 8 bit mask. */
 157:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_TXB8_bp  0  /* Transmit bit 8 bit position. */
 158:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 159:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* USART.UCSRxC  bit masks and bit positions */
 160:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_UMSEL01_gm  0xC0 /* USART Mode Select 01 grp mask.*/
 161:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_UMSEL01_gp  6 /* USART Mode Select 01 grp position.*/
 162:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 163:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_UMSEL01_bm  0x80 /* USART Mode Select 01 bit mask.*/
 164:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_UMSEL01_bp  7 /* USART Mode Select 01 bit position.*/
 165:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 166:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_UMSEL00_bm  0x40 /* USART Mode Select 00 bit mask.*/
 167:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_UMSEL00_bp  6 /* USART Mode Select 00 bit position.*/
 168:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 169:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_PMODE_gm  0x30 /* USART Parity Mode Select grp mask.*/
 170:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_PMODE_gp  4 /* USART Parity Mode Select grp position.*/
 171:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 172:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_PMODE01_bm  0x20 /* USART Parity Mode Select 01 bit mask.*/
 173:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_PMODE01_bp  5 /* USART Parity Mode Select 01 bit position.*/
 174:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 175:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_PMODE00_bm  0x10 /* USART Parity Mode Select 00 bit mask.*/
 176:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_PMODE00_bp  4 /* USART Parity Mode Select 00 bit position.*/
 177:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 178:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_STOPB_bm  0x08 /* USART stop bit mask.*/
 179:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_STOPB_bp  3 /* USART stop bit Position.*/
 180:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 181:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_CHSIZE01C_gm  0x06  /* Character Size 10 bit 1 mask. */
 182:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_CHSIZE01C_gp  1 /* Character Size 10 bit position. */
 183:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 184:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_CHSIZE01_bm  0x04  /* Character Size 10 bit 1 mask. */
 185:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_CHSIZE01_bp  2 /* Character Size 10 bit position. */
 186:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 187:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_CHSIZE00_bm  0x02  /* Character Size 00 bit 1 mask. */
 188:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_CHSIZE00_bp  1 /* Character Size bit 00 position. */
 189:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 190:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_UCPOL_bm  0x01  /* Sync mode Pol bit 1 mask. */
 191:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_UCPOL_bp  0 /*Sync mode Pol bit 0 position */
 192:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 193:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_UCPHA_bm 0x02 /* Clock Phase bit mask. */
 194:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_UCPHA_bp 1 /* Clock Phase bit position. */
 195:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 196:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_DORD_bm 0x04 /* Data order bit mask. */
 197:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_DORD_bp 2 /* Data order bit position. */
 198:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 199:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* Character Size */
 200:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** typedef enum USART_CHSIZE_enum {
 201:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	USART_CHSIZE_5BIT_gc = (0x00),  /* Character size: 5 bit */
 202:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	USART_CHSIZE_6BIT_gc = (0x01),  /* Character size: 6 bit */
 203:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	USART_CHSIZE_7BIT_gc = (0x02),  /* Character size: 7 bit */
 204:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	USART_CHSIZE_8BIT_gc = (0x03),  /* Character size: 8 bit */
 205:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	USART_CHSIZE_9BIT_gc = (0x07),  /* Character size: 9 bit */
 206:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** } USART_CHSIZE_t;
 207:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 208:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* Communication Mode */
 209:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** typedef enum USART_CMODE_enum {
 210:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	USART_CMODE_ASYNCHRONOUS_gc = (0x00 << USART_UMSEL01_gp),  /*
 211:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	                                                            *
 212:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	                                                            *
 213:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	                                                            *Asynchronous
 214:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	                                                            * Mode */
 215:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	USART_CMODE_SYNCHRONOUS_gc = (0x01 << USART_UMSEL01_gp),  /* Synchronous
 216:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	                                                           * Mode */
 217:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	USART_CMODE_IRDA_gc = (0x02 << USART_UMSEL01_gp),  /* IrDA Mode */
 218:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	USART_CMODE_MSPI_gc = (0x03 << USART_UMSEL01_gp),  /* Master SPI Mode */
 219:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** } USART_CMODE_t;
 220:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 221:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* Parity Mode */
 222:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** typedef enum USART_PMODE_enum {
 223:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	USART_PMODE_DISABLED_gc = (0x00 << USART_PMODE_gp),  /* No Parity */
 224:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	USART_PMODE_EVEN_gc = (0x02 << USART_PMODE_gp),  /* Even Parity */
 225:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	USART_PMODE_ODD_gc = (0x03 << USART_PMODE_gp),  /* Odd Parity */
 226:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** } USART_PMODE_t;
 227:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 228:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* ! Lookup table containing baudctrl values for CPU frequency 1 Mhz */
 229:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static PROGMEM_DECLARE(uint16_t, baudctrl_1mhz[]) = {
 230:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0033, /* Baud: 1200 */
 231:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0019, /* Baud: 2400 */
 232:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x000C, /* Baud: 4800 */
 233:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0006, /* Baud: 9600 */
 234:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0003, /* Baud: 19200 */
 235:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0002, /* Baud: 38400 */
 236:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0001, /* Baud: 57600 */
 237:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	USART_BAUD_UNDEFINED, /* Baud: 115200 */
 238:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** };
 239:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 240:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* ! Lookup table containing baudctrl values for CPU frequency 8 Mhz */
 241:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static PROGMEM_DECLARE(uint16_t, baudctrl_8mhz[]) = {
 242:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x01A0, /* Baud: 1200 */
 243:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x00CF, /* Baud: 2400 */
 244:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0067, /* Baud: 4800 */
 245:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0033, /* Baud: 9600 */
 246:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0019, /* Baud: 19200 */
 247:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x000C, /* Baud: 38400 */
 248:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0007, /* Baud: 57600 */
 249:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0008, /* Baud: 115200 */
 250:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** };
 251:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 252:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* ! Lookup table containing baudctrl values for CPU frequency 16 Mhz */
 253:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static PROGMEM_DECLARE(uint16_t, baudctrl_16mhz[]) = {
 254:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0340, /* Baud: 1200 */
 255:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x01A0, /* Baud: 2400 */
 256:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x00CF, /* Baud: 4800 */
 257:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0067, /* Baud: 9600 */
 258:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0033, /* Baud: 19200 */
 259:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0019, /* Baud: 38400 */
 260:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0010, /* Baud: 57600 */
 261:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0010, /* Baud: 115200 */
 262:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** };
 263:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 264:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 265:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* ! Input parameters when initializing RS232 and similar modes. */
 266:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** typedef struct usart_rs232_options {
 267:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	/* ! Set baud rate of the USART (unused in slave modes). */
 268:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	uint32_t baudrate;
 269:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 270:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	/* ! Number of bits to transmit as a character (5 to 9). */
 271:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	USART_CHSIZE_t charlength;
 272:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 273:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	/* ! Parity type: USART_PMODE_DISABLED_gc, USART_PMODE_EVEN_gc, */
 274:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	/* ! USART_PMODE_ODD_gc. */
 275:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	USART_PMODE_t paritytype;
 276:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 277:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	/* ! Number of stop bits between two characters: */
 278:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	/* ! true: 2 stop bits */
 279:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	/* ! false: 1 stop bit */
 280:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	bool stopbits;
 281:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** } usart_rs232_options_t;
 282:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 283:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* ! Input parameters when initializing SPI master mode. */
 284:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** typedef struct usart_spi_options {
 285:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	/* ! Set baud rate of the USART in SPI mode. */
 286:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	uint32_t baudrate;
 287:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 288:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	/* ! SPI transmission mode. */
 289:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	uint8_t spimode;
 290:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 291:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	uint8_t data_order;
 292:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** } usart_spi_options_t;
 293:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 294:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 295:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 296:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Enable USART receiver.
 297:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 298:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart Pointer to the USART module
 299:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 300:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline void usart_rx_enable(USART_t *usart)
 301:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 302:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	(usart)->UCSRnB |= USART_RXEN_bm;
 303:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 304:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 305:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 306:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Disable USART receiver.
 307:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 308:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart Pointer to the USART module.
 309:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 310:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline void usart_rx_disable(USART_t *usart)
 311:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 312:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	(usart)->UCSRnB &= ~USART_RXEN_bm;
 313:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 314:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 315:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 316:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief  Configure the USART frame format.
 317:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 318:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *  Sets the frame format, Frame Size, parity mode and number of stop bits.
 319:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 320:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *  \param usart Pointer to the USART module
 321:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *  \param charSize The character size. Use USART_CHSIZE_t type.
 322:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *  \param parityMode The parity Mode. Use USART_PMODE_t type.
 323:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *  \param twoStopBits Enable two stop bit mode. Use bool type.
 324:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 325:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline void usart_format_set(USART_t *usart, USART_CHSIZE_t charSize,
 326:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 		USART_PMODE_t parityMode, bool twoStopBits)
 327:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 328:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	(usart)->UCSRnC
 329:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 		= ((usart)->UCSRnC &
 330:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 			(~USART_CHSIZE01C_gm)) | ((charSize & 0x03)
 331:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 			<< USART_CHSIZE01C_gp);
 332:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	(usart)->UCSRnB
 333:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 		= ((usart)->UCSRnB &
 334:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 			(~USART_CHSIZE2_bm)) | ((charSize & 0x04)
 335:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 			<< USART_CHSIZE2_bp);
 336:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 337:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	(usart)->UCSRnC = ((usart)->UCSRnC & (~USART_PMODE_gm)) | parityMode;
 338:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 339:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	(usart)->UCSRnC = ((usart)->UCSRnC & (~USART_STOPB_bm)) | (twoStopBits
 340:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 			<< USART_STOPB_bp);
 341:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 342:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 343:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 344:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Enable USART transmitter.
 345:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 346:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart Pointer to the USART module.
 347:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 348:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline void usart_tx_enable(USART_t *usart)
 349:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 350:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	(usart)->UCSRnB |= USART_TXEN_bm;
 351:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 352:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 353:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 354:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Disable USART transmitter.
 355:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 356:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart Pointer to the USART module.
 357:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 358:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline void usart_tx_disable(USART_t *usart)
 359:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 360:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	(usart)->UCSRnB &= ~USART_TXEN_bm;
 361:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 362:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 363:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 364:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Enable USART transmit complete interrupt.
 365:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 366:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart Pointer to the USART module.
 367:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 368:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline void usart_tx_complete_interrupt_enable(USART_t *usart)
 369:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 370:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	(usart)->UCSRnB |= USART_TXC_bm;
 371:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 372:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 373:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 374:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Enable USART receive complete interrupt.
 375:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 376:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart Pointer to the USART module.
 377:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 378:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline void usart_rx_complete_interrupt_enable(USART_t *usart)
 379:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 380:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	(usart)->UCSRnB |= USART_RXC_bm;
 381:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 382:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 383:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 384:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Enable USART data register empty interrupt.
 385:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 386:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart Pointer to the USART module.
 387:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 388:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline void usart_data_empty_interrupt_enable(USART_t *usart)
 389:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 390:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	(usart)->UCSRnB |= USART_DRIE_bm;
 391:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 392:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 393:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 394:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Disable USART transmit complete interrupt.
 395:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 396:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart Pointer to the USART module.
 397:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 398:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline void usart_tx_complete_interrupt_disable(USART_t *usart)
 399:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 400:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	(usart)->UCSRnB &= ~USART_TXC_bm;
 401:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 402:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 403:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 404:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Disable USART receive complete interrupt.
 405:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 406:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart Pointer to the USART module.
 407:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 408:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline void usart_rx_complete_interrupt_disable(USART_t *usart)
 409:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 410:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	(usart)->UCSRnB &= ~USART_RXC_bm;
 411:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 412:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 413:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 414:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Disable USART data register empty interrupt.
 415:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 416:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart Pointer to the USART module.
 417:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 418:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline void usart_data_empty_interrupt_disable(USART_t *usart)
 419:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 420:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	(usart)->UCSRnB &= ~USART_DRIE_bm;
 421:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 422:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 423:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 424:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Set the mode the USART run in.
 425:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 426:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * Set the mode the USART run in. The default mode is asynchronous mode.
 427:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 428:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart Pointer to the USART module register section.
 429:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usartmode Selects the USART mode. Use USART_CMODE_t type.
 430:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 431:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * USART modes:
 432:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * - 0x0        : Asynchronous mode.
 433:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * - 0x1        : Synchronous mode.
 434:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * - 0x2        : IrDA mode.
 435:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * - 0x3        : Master SPI mode.
 436:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 437:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline void usart_set_mode(USART_t *usart, USART_CMODE_t usartmode)
 438:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 439:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	(usart)->UCSRnC = ((usart)->UCSRnC & (~USART_UMSEL01_gm)) | usartmode;
 440:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 441:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 442:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 443:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Check if data register empty flag is set.
 444:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 445:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart The USART module.
 446:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 447:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline bool usart_data_register_is_empty(USART_t *usart)
 448:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 449:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	return (usart)->UCSRnA & USART_DRE_bm;
 450:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 451:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 452:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 453:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Checks if the RX complete interrupt flag is set.
 454:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 455:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * Checks if the RX complete interrupt flag is set.
 456:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 457:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart The USART module.
 458:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 459:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline bool usart_rx_is_complete(USART_t *usart)
 460:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 461:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	return (usart)->UCSRnA & USART_RXC_bm;
 462:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 463:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 464:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 465:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Checks if the TX complete interrupt flag is set.
 466:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 467:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * Checks if the TX complete interrupt flag is set.
 468:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 469:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart The USART module.
 470:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 471:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline bool usart_tx_is_complete(USART_t *usart)
 472:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 473:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	return (usart)->UCSRnA & USART_TXC_bm;
 474:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 475:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 476:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 477:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Clear TX complete interrupt flag.
 478:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * TX flag is clear after complete transmission, automatically.
 479:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart The USART module.
 480:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 481:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline void usart_clear_tx_complete(USART_t *usart)
 482:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 483:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****          usart->UCSRnA |=  USART_TXC_bm;
 484:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 485:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 486:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 487:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Write a data to the USART data register.
 488:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 489:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart The USART module.
 490:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param txdata The data to be transmitted.
 491:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 492:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline void usart_put(USART_t *usart, uint8_t txdata)
 493:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 494:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	(usart)->UDR = txdata;
 495:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 496:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 497:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 498:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief  Read a data to the USART data register.
 499:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 500:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart The USART module.
 501:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 502:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \return The received data
 503:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 504:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline uint8_t usart_get(USART_t *usart)
 505:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 506:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	return (usart)->UDR;
 507:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 508:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 509:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 510:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Double the USART transmission speed.
 511:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 512:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart The USART module.
 513:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 514:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline void usart_double_baud_enable(USART_t *usart)
 515:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 136               		.loc 2 515 0
 137               		.cfi_startproc
 138 0034 CF93      		push r28
 139               	.LCFI6:
 140               		.cfi_def_cfa_offset 3
 141               		.cfi_offset 28, -2
 142 0036 DF93      		push r29
 143               	.LCFI7:
 144               		.cfi_def_cfa_offset 4
 145               		.cfi_offset 29, -3
 146 0038 00D0      		rcall .
 147               	.LCFI8:
 148               		.cfi_def_cfa_offset 6
 149 003a CDB7      		in r28,__SP_L__
 150 003c DEB7      		in r29,__SP_H__
 151               	.LCFI9:
 152               		.cfi_def_cfa_register 28
 153               	/* prologue: function */
 154               	/* frame size = 2 */
 155               	/* stack size = 4 */
 156               	.L__stack_usage = 4
 157 003e 9A83      		std Y+2,r25
 158 0040 8983      		std Y+1,r24
 516:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	usart->UCSRnA |=  USART_U2X_bm;
 159               		.loc 2 516 0
 160 0042 8981      		ldd r24,Y+1
 161 0044 9A81      		ldd r25,Y+2
 162 0046 FC01      		movw r30,r24
 163 0048 8081      		ld r24,Z
 164 004a 282F      		mov r18,r24
 165 004c 2260      		ori r18,lo8(2)
 166 004e 8981      		ldd r24,Y+1
 167 0050 9A81      		ldd r25,Y+2
 168 0052 FC01      		movw r30,r24
 169 0054 2083      		st Z,r18
 517:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 170               		.loc 2 517 0
 171 0056 0000      		nop
 172               	/* epilogue start */
 173 0058 0F90      		pop __tmp_reg__
 174 005a 0F90      		pop __tmp_reg__
 175 005c DF91      		pop r29
 176 005e CF91      		pop r28
 177 0060 0895      		ret
 178               		.cfi_endproc
 179               	.LFE101:
 182               	usart_serial_init:
 183               	.LFB104:
 184               		.file 3 "../../../platform/common/services/serial/megarf_usart/usart_serial.h"
   1:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** /**
   2:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * \file
   3:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
   4:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * \brief This file defines a useful set of functions for the Serial interface on 
   5:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * AVR MEGARF devices.
   6:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
   7:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * Copyright (c) 2013 Atmel Corporation. All rights reserved.
   8:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
   9:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * \asf_license_start
  10:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
  11:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * \page License
  12:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
  13:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * Redistribution and use in source and binary forms, with or without
  14:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * modification, are permitted provided that the following conditions are met:
  15:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
  16:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * 1. Redistributions of source code must retain the above copyright notice,
  17:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *    this list of conditions and the following disclaimer.
  18:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
  19:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * 2. Redistributions in binary form must reproduce the above copyright notice,
  20:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *    this list of conditions and the following disclaimer in the documentation
  21:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *    and/or other materials provided with the distribution.
  22:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
  23:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * 3. The name of Atmel may not be used to endorse or promote products derived
  24:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *    from this software without specific prior written permission.
  25:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
  26:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * 4. This software may only be redistributed and used in connection with an
  27:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *    Atmel microcontroller product.
  28:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
  29:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR IMPLIED
  30:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
  31:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
  32:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR
  33:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  34:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
  35:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  36:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
  37:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  38:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  39:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * POSSIBILITY OF SUCH DAMAGE.
  40:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
  41:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * \asf_license_stop
  42:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
  43:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  */
  44:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** #ifndef _USART_SERIAL_H_
  45:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** #define _USART_SERIAL_H_
  46:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 
  47:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** #ifdef __cplusplus
  48:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** extern "C" {
  49:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** #endif
  50:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 
  51:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** #include "compiler.h"
  52:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** #include "sysclk.h"
  53:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** #include "status_codes.h"
  54:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** #include "usart_megarf.h"
  55:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 
  56:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** /*! \name Serial Management Configuration
  57:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  */
  58:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** /* ! @{ */
  59:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** #include "conf_usart_serial.h"
  60:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** /* ! @} */
  61:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 
  62:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** typedef usart_rs232_options_t usart_serial_options_t;
  63:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 
  64:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** typedef USART_t *usart_if;
  65:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 
  66:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** /*! \brief Initializes the Usart in master mode.
  67:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
  68:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * \param usart       Base address of the USART instance.
  69:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * \param options     Options needed to set up RS232 communication (see \ref
  70:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * usart_serial_options_t).
  71:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
  72:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * \retval true if the initialization was successful
  73:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * \retval false if initialization failed (error in baud rate calculation)
  74:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  */
  75:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** static inline bool usart_serial_init(usart_if usart, const
  76:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 		usart_serial_options_t *options)
  77:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** {
 185               		.loc 3 77 0
 186               		.cfi_startproc
 187 0062 CF93      		push r28
 188               	.LCFI10:
 189               		.cfi_def_cfa_offset 3
 190               		.cfi_offset 28, -2
 191 0064 DF93      		push r29
 192               	.LCFI11:
 193               		.cfi_def_cfa_offset 4
 194               		.cfi_offset 29, -3
 195 0066 CDB7      		in r28,__SP_L__
 196 0068 DEB7      		in r29,__SP_H__
 197               	.LCFI12:
 198               		.cfi_def_cfa_register 28
 199 006a 2B97      		sbiw r28,11
 200               	.LCFI13:
 201               		.cfi_def_cfa_offset 15
 202 006c 0FB6      		in __tmp_reg__,__SREG__
 203 006e F894      		cli
 204 0070 DEBF      		out __SP_H__,r29
 205 0072 0FBE      		out __SREG__,__tmp_reg__
 206 0074 CDBF      		out __SP_L__,r28
 207               	/* prologue: function */
 208               	/* frame size = 11 */
 209               	/* stack size = 13 */
 210               	.L__stack_usage = 13
 211 0076 9987      		std Y+9,r25
 212 0078 8887      		std Y+8,r24
 213 007a 7B87      		std Y+11,r23
 214 007c 6A87      		std Y+10,r22
  78:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 	/* USART options. */
  79:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 	usart_rs232_options_t usart_rs232_options;
  80:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 	usart_rs232_options.charlength   = options->charlength;
 215               		.loc 3 80 0
 216 007e 8A85      		ldd r24,Y+10
 217 0080 9B85      		ldd r25,Y+11
 218 0082 FC01      		movw r30,r24
 219 0084 8481      		ldd r24,Z+4
 220 0086 8D83      		std Y+5,r24
  81:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 	usart_rs232_options.paritytype   = options->paritytype;
 221               		.loc 3 81 0
 222 0088 8A85      		ldd r24,Y+10
 223 008a 9B85      		ldd r25,Y+11
 224 008c FC01      		movw r30,r24
 225 008e 8581      		ldd r24,Z+5
 226 0090 8E83      		std Y+6,r24
  82:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 	usart_rs232_options.stopbits     = options->stopbits;
 227               		.loc 3 82 0
 228 0092 8A85      		ldd r24,Y+10
 229 0094 9B85      		ldd r25,Y+11
 230 0096 FC01      		movw r30,r24
 231 0098 8681      		ldd r24,Z+6
 232 009a 8F83      		std Y+7,r24
  83:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 	usart_rs232_options.baudrate     = options->baudrate;
 233               		.loc 3 83 0
 234 009c 8A85      		ldd r24,Y+10
 235 009e 9B85      		ldd r25,Y+11
 236 00a0 FC01      		movw r30,r24
 237 00a2 8081      		ld r24,Z
 238 00a4 9181      		ldd r25,Z+1
 239 00a6 A281      		ldd r26,Z+2
 240 00a8 B381      		ldd r27,Z+3
 241 00aa 8983      		std Y+1,r24
 242 00ac 9A83      		std Y+2,r25
 243 00ae AB83      		std Y+3,r26
 244 00b0 BC83      		std Y+4,r27
  84:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 
  85:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 	if (usart_init_rs232(usart, &usart_rs232_options)) {
 245               		.loc 3 85 0
 246 00b2 8885      		ldd r24,Y+8
 247 00b4 9985      		ldd r25,Y+9
 248 00b6 9E01      		movw r18,r28
 249 00b8 2F5F      		subi r18,-1
 250 00ba 3F4F      		sbci r19,-1
 251 00bc B901      		movw r22,r18
 252 00be 0E94 0000 		call usart_init_rs232
 253 00c2 8823      		tst r24
 254 00c4 01F0      		breq .L7
  86:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 		return true;
 255               		.loc 3 86 0
 256 00c6 81E0      		ldi r24,lo8(1)
 257 00c8 00C0      		rjmp .L9
 258               	.L7:
  87:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 	} else {
  88:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 		return false;
 259               		.loc 3 88 0
 260 00ca 80E0      		ldi r24,0
 261               	.L9:
 262               	/* epilogue start */
  89:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 	}
  90:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** }
 263               		.loc 3 90 0 discriminator 1
 264 00cc 2B96      		adiw r28,11
 265 00ce 0FB6      		in __tmp_reg__,__SREG__
 266 00d0 F894      		cli
 267 00d2 DEBF      		out __SP_H__,r29
 268 00d4 0FBE      		out __SREG__,__tmp_reg__
 269 00d6 CDBF      		out __SP_L__,r28
 270 00d8 DF91      		pop r29
 271 00da CF91      		pop r28
 272 00dc 0895      		ret
 273               		.cfi_endproc
 274               	.LFE104:
 277               	usart_serial_putchar:
 278               	.LFB105:
  91:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 
  92:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** /*! \brief Sends a character with the USART.
  93:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
  94:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * \param usart   Base address of the USART instance.
  95:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * \param c       Character to write.
  96:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
  97:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * \return Status code
  98:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  */
  99:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** static inline status_code_t usart_serial_putchar(usart_if usart, uint8_t c)
 100:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** {
 279               		.loc 3 100 0
 280               		.cfi_startproc
 281 00de CF93      		push r28
 282               	.LCFI14:
 283               		.cfi_def_cfa_offset 3
 284               		.cfi_offset 28, -2
 285 00e0 DF93      		push r29
 286               	.LCFI15:
 287               		.cfi_def_cfa_offset 4
 288               		.cfi_offset 29, -3
 289 00e2 00D0      		rcall .
 290 00e4 1F92      		push __zero_reg__
 291               	.LCFI16:
 292               		.cfi_def_cfa_offset 7
 293 00e6 CDB7      		in r28,__SP_L__
 294 00e8 DEB7      		in r29,__SP_H__
 295               	.LCFI17:
 296               		.cfi_def_cfa_register 28
 297               	/* prologue: function */
 298               	/* frame size = 3 */
 299               	/* stack size = 5 */
 300               	.L__stack_usage = 5
 301 00ea 9A83      		std Y+2,r25
 302 00ec 8983      		std Y+1,r24
 303 00ee 6B83      		std Y+3,r22
 101:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 	return usart_putchar(usart, c);
 304               		.loc 3 101 0
 305 00f0 8981      		ldd r24,Y+1
 306 00f2 9A81      		ldd r25,Y+2
 307 00f4 6B81      		ldd r22,Y+3
 308 00f6 0E94 0000 		call usart_putchar
 309               	/* epilogue start */
 102:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** }
 310               		.loc 3 102 0
 311 00fa 0F90      		pop __tmp_reg__
 312 00fc 0F90      		pop __tmp_reg__
 313 00fe 0F90      		pop __tmp_reg__
 314 0100 DF91      		pop r29
 315 0102 CF91      		pop r28
 316 0104 0895      		ret
 317               		.cfi_endproc
 318               	.LFE105:
 321               	usart_serial_getchar:
 322               	.LFB106:
 103:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 
 104:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** /*! \brief Waits until a character is received, and returns it.
 105:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
 106:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * \param usart   Base address of the USART instance.
 107:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * \param data   Data to read
 108:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
 109:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  */
 110:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** static inline void usart_serial_getchar(usart_if usart, uint8_t *data)
 111:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** {
 323               		.loc 3 111 0
 324               		.cfi_startproc
 325 0106 CF93      		push r28
 326               	.LCFI18:
 327               		.cfi_def_cfa_offset 3
 328               		.cfi_offset 28, -2
 329 0108 DF93      		push r29
 330               	.LCFI19:
 331               		.cfi_def_cfa_offset 4
 332               		.cfi_offset 29, -3
 333 010a 00D0      		rcall .
 334 010c 00D0      		rcall .
 335               	.LCFI20:
 336               		.cfi_def_cfa_offset 8
 337 010e CDB7      		in r28,__SP_L__
 338 0110 DEB7      		in r29,__SP_H__
 339               	.LCFI21:
 340               		.cfi_def_cfa_register 28
 341               	/* prologue: function */
 342               	/* frame size = 4 */
 343               	/* stack size = 6 */
 344               	.L__stack_usage = 6
 345 0112 9A83      		std Y+2,r25
 346 0114 8983      		std Y+1,r24
 347 0116 7C83      		std Y+4,r23
 348 0118 6B83      		std Y+3,r22
 112:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 	*data = usart_getchar(usart);
 349               		.loc 3 112 0
 350 011a 8981      		ldd r24,Y+1
 351 011c 9A81      		ldd r25,Y+2
 352 011e 0E94 0000 		call usart_getchar
 353 0122 282F      		mov r18,r24
 354 0124 8B81      		ldd r24,Y+3
 355 0126 9C81      		ldd r25,Y+4
 356 0128 FC01      		movw r30,r24
 357 012a 2083      		st Z,r18
 113:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** }
 358               		.loc 3 113 0
 359 012c 0000      		nop
 360               	/* epilogue start */
 361 012e 0F90      		pop __tmp_reg__
 362 0130 0F90      		pop __tmp_reg__
 363 0132 0F90      		pop __tmp_reg__
 364 0134 0F90      		pop __tmp_reg__
 365 0136 DF91      		pop r29
 366 0138 CF91      		pop r28
 367 013a 0895      		ret
 368               		.cfi_endproc
 369               	.LFE106:
 372               	stdio_serial_init:
 373               	.LFB107:
 374               		.file 4 "../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h"
   1:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** /**
   2:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
   3:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * \file
   4:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
   5:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * \brief Common Standard I/O Serial Management.
   6:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
   7:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * This file defines a useful set of functions for the Stdio Serial interface on AVR
   8:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * and SAM devices.
   9:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
  10:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * Copyright (c) 2009-2013 Atmel Corporation. All rights reserved.
  11:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
  12:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * \asf_license_start
  13:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
  14:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * \page License
  15:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
  16:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * Redistribution and use in source and binary forms, with or without
  17:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * modification, are permitted provided that the following conditions are met:
  18:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
  19:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * 1. Redistributions of source code must retain the above copyright notice,
  20:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *    this list of conditions and the following disclaimer.
  21:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
  22:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * 2. Redistributions in binary form must reproduce the above copyright notice,
  23:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *    this list of conditions and the following disclaimer in the documentation
  24:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *    and/or other materials provided with the distribution.
  25:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
  26:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * 3. The name of Atmel may not be used to endorse or promote products derived
  27:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *    from this software without specific prior written permission.
  28:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
  29:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * 4. This software may only be redistributed and used in connection with an
  30:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *    Atmel microcontroller product.
  31:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
  32:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR IMPLIED
  33:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
  34:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
  35:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR
  36:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  37:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
  38:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  39:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
  40:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  41:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  42:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * POSSIBILITY OF SUCH DAMAGE.
  43:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
  44:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * \asf_license_stop
  45:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
  46:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  ******************************************************************************/
  47:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 
  48:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 
  49:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** #ifndef _STDIO_SERIAL_H_
  50:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** #define _STDIO_SERIAL_H_
  51:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 
  52:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** /**
  53:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * \defgroup group_common_utils_stdio_stdio_serial Standard serial I/O (stdio)
  54:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * \ingroup group_common_utils_stdio
  55:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
  56:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * Common standard serial I/O management driver that
  57:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * implements a stdio serial interface on AVR and SAM devices.
  58:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
  59:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * \{
  60:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  */
  61:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 
  62:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** #include <stdio.h>
  63:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** #include "compiler.h"
  64:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** #ifndef SAMD20
  65:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** # include "sysclk.h"
  66:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** #endif
  67:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** #include "serial.h"
  68:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 
  69:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** #if (XMEGA || MEGA_RF) && defined(__GNUC__)
  70:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	extern int _write (char c, int *f);
  71:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	extern int _read (int *f);
  72:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** #endif
  73:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 
  74:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 
  75:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** //! Pointer to the base of the USART module instance to use for stdio.
  76:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** extern volatile void *volatile stdio_base;
  77:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** //! Pointer to the external low level write function.
  78:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** extern int (*ptr_put)(void volatile*, char);
  79:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 
  80:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** //! Pointer to the external low level read function.
  81:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** extern void (*ptr_get)(void volatile*, char*);
  82:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 
  83:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** /*! \brief Initializes the stdio in Serial Mode.
  84:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
  85:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * \param usart       Base address of the USART instance.
  86:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * \param opt         Options needed to set up RS232 communication (see \ref usart_options_t).
  87:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
  88:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  */
  89:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** static inline void stdio_serial_init(volatile void *usart, const usart_serial_options_t *opt)
  90:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** {
 375               		.loc 4 90 0
 376               		.cfi_startproc
 377 013c CF93      		push r28
 378               	.LCFI22:
 379               		.cfi_def_cfa_offset 3
 380               		.cfi_offset 28, -2
 381 013e DF93      		push r29
 382               	.LCFI23:
 383               		.cfi_def_cfa_offset 4
 384               		.cfi_offset 29, -3
 385 0140 00D0      		rcall .
 386 0142 00D0      		rcall .
 387               	.LCFI24:
 388               		.cfi_def_cfa_offset 8
 389 0144 CDB7      		in r28,__SP_L__
 390 0146 DEB7      		in r29,__SP_H__
 391               	.LCFI25:
 392               		.cfi_def_cfa_register 28
 393               	/* prologue: function */
 394               	/* frame size = 4 */
 395               	/* stack size = 6 */
 396               	.L__stack_usage = 6
 397 0148 9A83      		std Y+2,r25
 398 014a 8983      		std Y+1,r24
 399 014c 7C83      		std Y+4,r23
 400 014e 6B83      		std Y+3,r22
  91:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	stdio_base = (void *)usart;
 401               		.loc 4 91 0
 402 0150 8981      		ldd r24,Y+1
 403 0152 9A81      		ldd r25,Y+2
 404 0154 9093 0000 		sts stdio_base+1,r25
 405 0158 8093 0000 		sts stdio_base,r24
  92:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	ptr_put = (int (*)(void volatile*,char))&usart_serial_putchar;
 406               		.loc 4 92 0
 407 015c 80E0      		ldi r24,lo8(gs(usart_serial_putchar))
 408 015e 90E0      		ldi r25,hi8(gs(usart_serial_putchar))
 409 0160 9093 0000 		sts ptr_put+1,r25
 410 0164 8093 0000 		sts ptr_put,r24
  93:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	ptr_get = (void (*)(void volatile*,char*))&usart_serial_getchar;
 411               		.loc 4 93 0
 412 0168 80E0      		ldi r24,lo8(gs(usart_serial_getchar))
 413 016a 90E0      		ldi r25,hi8(gs(usart_serial_getchar))
 414 016c 9093 0000 		sts ptr_get+1,r25
 415 0170 8093 0000 		sts ptr_get,r24
  94:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** # if (XMEGA || MEGA_RF)
  95:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	usart_serial_init((USART_t *)usart,opt);
 416               		.loc 4 95 0
 417 0174 2B81      		ldd r18,Y+3
 418 0176 3C81      		ldd r19,Y+4
 419 0178 8981      		ldd r24,Y+1
 420 017a 9A81      		ldd r25,Y+2
 421 017c B901      		movw r22,r18
 422 017e 0E94 0000 		call usart_serial_init
  96:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** # elif UC3
  97:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	usart_serial_init(usart,(usart_serial_options_t *)opt);
  98:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** # elif SAM
  99:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	usart_serial_init((Usart *)usart,(usart_serial_options_t *)opt);
 100:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** # else
 101:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** #  error Unsupported chip type
 102:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** # endif
 103:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 
 104:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** # if defined(__GNUC__)
 105:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** #  if (XMEGA || MEGA_RF)
 106:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	// For AVR GCC libc print redirection uses fdevopen.
 107:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	fdevopen((int (*)(char, FILE*))(_write),(int (*)(FILE*))(_read));
 423               		.loc 4 107 0
 424 0182 60E0      		ldi r22,lo8(gs(_read))
 425 0184 70E0      		ldi r23,hi8(gs(_read))
 426 0186 80E0      		ldi r24,lo8(gs(_write))
 427 0188 90E0      		ldi r25,hi8(gs(_write))
 428 018a 0E94 0000 		call fdevopen
 108:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** #  endif
 109:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** #  if UC3 || SAM
 110:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	// For AVR32 and SAM GCC
 111:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	// Specify that stdout and stdin should not be buffered.
 112:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	setbuf(stdout, NULL);
 113:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	setbuf(stdin, NULL);
 114:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	// Note: Already the case in IAR's Normal DLIB default configuration
 115:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	// and AVR GCC library:
 116:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	// - printf() emits one character at a time.
 117:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	// - getchar() requests only 1 byte to exit.
 118:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** #  endif
 119:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** # endif
 120:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** }
 429               		.loc 4 120 0
 430 018e 0000      		nop
 431               	/* epilogue start */
 432 0190 0F90      		pop __tmp_reg__
 433 0192 0F90      		pop __tmp_reg__
 434 0194 0F90      		pop __tmp_reg__
 435 0196 0F90      		pop __tmp_reg__
 436 0198 DF91      		pop r29
 437 019a CF91      		pop r28
 438 019c 0895      		ret
 439               		.cfi_endproc
 440               	.LFE107:
 443               	macsc_enable_manual_bts:
 444               	.LFB121:
 445               		.file 5 "../../../platform/mega_rf/drivers/macsc/macsc_megarf.h"
   1:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
   2:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \file
   3:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
   4:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief AVR MEGARF MAC Symbol Counter Driver Definitions
   5:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
   6:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * Copyright (c) 2013 Atmel Corporation. All rights reserved.
   7:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
   8:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \asf_license_start
   9:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  10:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \page License
  11:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  12:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * Redistribution and use in source and binary forms, with or without
  13:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * modification, are permitted provided that the following conditions are met:
  14:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  15:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * 1. Redistributions of source code must retain the above copyright notice,
  16:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *    this list of conditions and the following disclaimer.
  17:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  18:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * 2. Redistributions in binary form must reproduce the above copyright notice,
  19:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *    this list of conditions and the following disclaimer in the documentation
  20:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *    and/or other materials provided with the distribution.
  21:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  22:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * 3. The name of Atmel may not be used to endorse or promote products derived
  23:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *    from this software without specific prior written permission.
  24:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  25:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * 4. This software may only be redistributed and used in connection with an
  26:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *    Atmel microcontroller product.
  27:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  28:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR IMPLIED
  29:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
  30:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
  31:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR
  32:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  33:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
  34:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  35:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
  36:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  37:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  38:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * POSSIBILITY OF SUCH DAMAGE.
  39:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  40:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \asf_license_stop
  41:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  42:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
  43:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** #ifndef MACSC_MEGARF_H
  44:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** #define MACSC_MEGARF_H
  45:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
  46:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** #include <compiler.h>
  47:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** #include <parts.h>
  48:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** #include "status_codes.h"
  49:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
  50:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** #ifdef __cplusplus
  51:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** extern "C" {
  52:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** #endif
  53:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
  54:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
  55:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \defgroup macsc_group MAC Symbol Counter Driver(MACSC)
  56:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  57:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * See \ref megarf_macsc_quickstart
  58:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  59:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * This is a driver for the AVR MEGARF MAC Symbol Counter Driver(MACSC).
  60:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * It provides functions for enabling, disabling and configuring the module.
  61:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  62:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \section dependencies Dependencies
  63:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * This driver depends on the following modules:
  64:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * - \ref interrupt_group for ISR definition and disabling interrupts during
  65:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * critical code sections.
  66:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * @{
  67:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
  68:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
  69:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
  70:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Interrupt event callback function type
  71:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  72:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * The interrupt handler can be configured to do a function callback,
  73:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * the callback function must match the macsc_callback_t type.
  74:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  75:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
  76:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** typedef void (*macsc_callback_t)(void);
  77:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
  78:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /* ! MAC symbol counter compare Channel index */
  79:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** enum macsc_cc_channel {
  80:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	/* ! Channel 1 */
  81:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	MACSC_CC1 = 1,
  82:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	/* ! Channel 2 */
  83:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	MACSC_CC2 = 2,
  84:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	/* ! Channel 3 */
  85:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	MACSC_CC3 = 3,
  86:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** };
  87:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
  88:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief MAC SC clock source select
  89:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  90:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * uses the SCCKSEL bit in SSCR register to select macsc clk src
  91:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  92:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * If the bit is one,the RTC clock from TOSC1 is selected, otherwise the symbol
  93:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * counter operates with the clock from XTAL1.
  94:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * During transceiver sleep modes the clock falls back to the RTC clock source,
  95:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * regardless of the selected clock. After wakeup, it switches back to the
  96:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * previosly
  97:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * selected clock source.
  98:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
  99:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 100:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** enum macsc_xtal {
 101:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	/* ! 16MHz as macsc clock */
 102:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	MACSC_16MHz = 0,
 103:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	MACSC_32KHz = 1,
 104:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** };
 105:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 106:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 107:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * @brief Reads the 32-bit timer register in the required order of bytes
 108:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 109:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * @param hh hh octet of 32-bit register
 110:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * @param hl hl octet of 32-bit register
 111:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * @param lh lh octet of 32-bit register
 112:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * @param ll ll octet of 32-bit register
 113:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 114:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * @returns uint32_t Value of timer register
 115:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 116:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** static inline uint32_t macsc_read32(volatile uint8_t *hh,
 117:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		volatile uint8_t *hl,
 118:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		volatile uint8_t *lh,
 119:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		volatile uint8_t *ll)
 120:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** {
 121:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	union {
 122:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		uint8_t a[4];
 123:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		uint32_t rv;
 124:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	}
 125:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	x;
 126:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 127:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	x.a[0] = *ll;
 128:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	x.a[1] = *lh;
 129:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	x.a[2] = *hl;
 130:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	x.a[3] = *hh;
 131:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 132:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	return x.rv;
 133:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** }
 134:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 135:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /* ! compare modes */
 136:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** #define MACSC_ABSOLUTE_CMP 0
 137:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** #define MACSC_RELATIVE_CMP 1
 138:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 139:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /** String concatenation by preprocessor used to create proper register names.
 140:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  **/
 141:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** #define CONCAT(a, b) a ## b
 142:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 143:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /** Creates proper subregister names and reads the corresponding values. */
 144:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** #define MACSC_READ32(reg)                  macsc_read32(&CONCAT(reg, HH), \
 145:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		&CONCAT(reg, HL), \
 146:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		&CONCAT(reg, LH), \
 147:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		&CONCAT(reg, LL))
 148:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 149:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** #define MACSC_WRITE32(reg, val)	\
 150:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	do { \
 151:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		union { uint8_t a[4]; uint32_t v; } \
 152:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		x; \
 153:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		x.v = val; \
 154:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		CONCAT(reg, HH) = x.a[3]; \
 155:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		CONCAT(reg, HL) = x.a[2]; \
 156:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		CONCAT(reg, LH) = x.a[1]; \
 157:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		CONCAT(reg, LL) = x.a[0]; \
 158:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	} \
 159:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	while (0)
 160:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 161:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 162:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Enable MAC SC
 163:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 164:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * Enables the SC
 165:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 166:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param clk_src selection of clk source,avalable options in macsc_xtal,fixed
 167:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *  prescalar
 168:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param sleep_enable enable RTC as clock source during sleep
 169:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param auto_ts enable automatic timestamping
 170:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 171:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 172:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** void macsc_enable(void);
 173:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 174:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 175:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Check if MACSC is enabled
 176:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 177:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * check if the MACSC is enabled.
 178:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 179:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param none
 180:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 181:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 182:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** bool is_macsc_enable(void);
 183:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 184:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 185:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Disable MAC SC
 186:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 187:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * Disables the MAC SC
 188:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 189:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param none
 190:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 191:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 192:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** void macsc_disable(void);
 193:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 194:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 195:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Check if back-off slot counter is enabled
 196:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 197:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * check if the back-off slot counter is enabled.
 198:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 199:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param none
 200:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 201:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 202:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** bool is_macsc_backoff_enable(void);
 203:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 204:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 205:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Enables compare interrupts of the MACSC
 206:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 207:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param channel Compare channel
 208:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 209:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** void macsc_enable_cmp_int(enum macsc_cc_channel channel);
 210:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 211:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 212:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Disables compare interrupts of the MACSC
 213:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 214:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param channel Compare channel
 215:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */void macsc_disable_cmp_int(enum macsc_cc_channel channel);
 216:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 217:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 218:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Usage of Absolute compare mode of the MACSC
 219:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 220:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param abs_rel  0 for absoulte cmp;1 for relative cmp
 221:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param cmp compare value for SCOCRx register
 222:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param channel Compare channel
 223:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 224:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** void macsc_use_cmp(bool abs_rel, uint32_t cmp,enum macsc_cc_channel channel);
 225:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 226:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 227:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \ingroup macsc_group
 228:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \defgroup macsc_interrupt_group MAC Symbol Counter (MACSC) interrupt
 229:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * management
 230:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * This group provides functions to configure MACSC module interrupts
 231:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 232:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * @{
 233:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 234:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 235:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 236:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Set MACSC overflow interrupt callback function
 237:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 238:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * This function allows the caller to set and change the interrupt callback
 239:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * function. Without setting a callback function the interrupt handler in the
 240:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * driver will only clear the interrupt flags.
 241:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 242:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param callback Reference to a callback function
 243:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 244:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** void macsc_set_ovf_int_cb(macsc_callback_t callback);
 245:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 246:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 247:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Set MACSC Compare Channel 1 interrupt callback function
 248:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 249:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * This function allows the caller to set and change the interrupt callback
 250:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * function. Without setting a callback function the interrupt handler in the
 251:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * driver will only clear the interrupt flags.
 252:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 253:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param callback Reference to a callback function
 254:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 255:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** void macsc_set_cmp1_int_cb(macsc_callback_t callback);
 256:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 257:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 258:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Set MACSC Compare Channel 2 interrupt callback function
 259:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 260:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * This function allows the caller to set and change the interrupt callback
 261:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * function. Without setting a callback function the interrupt handler in the
 262:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * driver will only clear the interrupt flags.
 263:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 264:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param callback Reference to a callback function
 265:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 266:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** void macsc_set_cmp2_int_cb(macsc_callback_t callback);
 267:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 268:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 269:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Set MACSC Compare Channel 3 interrupt callback function
 270:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 271:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * This function allows the caller to set and change the interrupt callback
 272:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * function. Without setting a callback function the interrupt handler in the
 273:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * driver will only clear the interrupt flags.
 274:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 275:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param callback Reference to a callback function
 276:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 277:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** void macsc_set_cmp3_int_cb(macsc_callback_t callback);
 278:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 279:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 280:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Set MACSC backoff slot counter interrupt callback function
 281:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 282:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * This function allows the caller to set and change the interrupt callback
 283:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * function. Without setting a callback function the interrupt handler in the
 284:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * driver will only clear the interrupt flags.
 285:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 286:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param callback Reference to a callback function
 287:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 288:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** void macsc_set_backoff_slot_cntr_int_cb(macsc_callback_t callback);
 289:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** //@}
 290:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 291:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 292:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Enable 32.768KHz clk using timer 2 async register
 293:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 294:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param none
 295:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 296:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 297:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** static inline void macsc_sleep_clk_enable(void)
 298:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** {
 299:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	ASSR |= (1 << AS2);
 300:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** }
 301:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 302:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 303:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Disable 32.768KHz clk using timer 2 async register
 304:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 305:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param none
 306:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 307:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** static inline void macsc_sleep_clk_disable(void)
 308:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** {
 309:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	ASSR &= ~(1 << AS2);
 310:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** }
 311:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 312:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /* @} */
 313:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 314:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 315:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Configure MAC Symbol Counter Clock Source
 316:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 317:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param macsc macsc clk src
 318:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 319:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** static inline void macsc_write_clock_source(enum macsc_xtal source)
 320:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** {
 321:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	if (source == MACSC_16MHz) {
 322:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		SCCR0 |= (source << SCCKSEL);
 323:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	} else if (source == MACSC_32KHz) {
 324:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		SCCR0 &= ~(1 << SCCKSEL);
 325:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	}
 326:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** }
 327:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 328:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 329:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Read MAC SC Clock Source
 330:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 331:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param none
 332:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \return macsc_xtal enum Clock source selection
 333:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 334:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** static inline enum macsc_xtal macsc_read_clock_source(void)
 335:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** {
 336:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	return (enum macsc_xtal)(SCCR0 & (1 << SCCKSEL));
 337:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** }
 338:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 339:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 340:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Write the Counter value of the MAC Symbol counter
 341:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 342:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param cnt_value Counter value
 343:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 344:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** static inline void macsc_write_count(uint32_t cnt_value)
 345:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** {
 346:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	MACSC_WRITE32(SCCNT, cnt_value);
 347:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** }
 348:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 349:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 350:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Reads the Counter value of the MAC Symbol counter
 351:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 352:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \note Output the Counter value
 353:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 354:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** static inline uint32_t macsc_read_count(void)
 355:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** {
 356:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	return (MACSC_READ32(SCCNT));
 357:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** }
 358:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 359:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 360:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief enable back-off slot counter
 361:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 362:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param none
 363:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \note  Enables interrupt as well	.
 364:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \note This counter works only if transceiver clock is running.So check Trx
 365:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * state in app before using this function in IEEE802.15.4 applications.
 366:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 367:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** static inline bool macsc_backoff_slot_cnt_enable(void)
 368:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** {
 369:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	if (!(PRR1 & (1 << PRTRX24))) {
 370:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		SCCR1 = (1 << SCENBO);
 371:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		SCIRQS |= (1 << IRQSBO);
 372:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		SCIRQM |= (1 << IRQMBO);
 373:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		return true;
 374:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	}
 375:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	else return false;
 376:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** }
 377:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 378:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 379:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Disable back-off slot counter
 380:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 381:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param none
 382:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \note    Disables interrupt as well	.
 383:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \note This counter works only if transceiver clock is running.So check Trx
 384:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * state in app before using this function in IEEE802.15.4 applications.
 385:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 386:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** static inline void macsc_backoff_slot_cnt_disable(void)
 387:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** {
 388:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	SCCR1 &= ~(1 << SCENBO);
 389:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	SCIRQM &= ~(1 << IRQMBO);
 390:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** }
 391:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 392:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 393:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Tests if the Backoff slot cntr interrupt flag is set
 394:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 395:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \return  backoff slot cntr interrupt has occurred or not : IRQSBO
 396:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 397:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** static inline bool macsc_is_slot_cntr_interrupt_flag_set(void)
 398:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** {
 399:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	return (SCIRQS & (1 << IRQSBO));
 400:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** }
 401:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 402:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 403:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Clears the Backoff Slot cntr interrupt flag
 404:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 405:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \note  IRQSBO is cleared
 406:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 407:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** static inline void macsc_clear_slot_cntr_interrupt_flag(void)
 408:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** {
 409:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	SCIRQS |= (1 << IRQSBO);
 410:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** }
 411:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 412:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 413:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Reads the SFD Timestamp register
 414:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 415:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \return Timestamp of last received frame :SCTSR(read-only register)
 416:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 417:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** static inline uint32_t macsc_read_ts(void)
 418:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** {
 419:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	return (MACSC_READ32(SCTSR));
 420:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** }
 421:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 422:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 423:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Reads the Beacon Timestamp register
 424:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 425:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \return Timestamp of last received beacon frame :SCBTSR
 426:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 427:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** static inline uint32_t macsc_read_bts(void)
 428:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** {
 429:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	return (MACSC_READ32(SCBTSR));
 430:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** }
 431:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 432:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 433:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Write the Beacon Timestamp register of the MAC Symbol counter
 434:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * The manual beacon timestamping can be used in conjunction with the
 435:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * relative compare mode of the three compare units to generate compare match
 436:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * interrupts without having a beacon frame received
 437:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 438:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * If set to 1, the current symbol counter value is stored into the beacon
 439:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * timestamp register.
 440:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * The bit is cleared afterwards.
 441:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 442:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 443:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** static inline void macsc_enable_manual_bts(void)
 444:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** {
 446               		.loc 5 444 0
 447               		.cfi_startproc
 448 019e CF93      		push r28
 449               	.LCFI26:
 450               		.cfi_def_cfa_offset 3
 451               		.cfi_offset 28, -2
 452 01a0 DF93      		push r29
 453               	.LCFI27:
 454               		.cfi_def_cfa_offset 4
 455               		.cfi_offset 29, -3
 456 01a2 CDB7      		in r28,__SP_L__
 457 01a4 DEB7      		in r29,__SP_H__
 458               	.LCFI28:
 459               		.cfi_def_cfa_register 28
 460               	/* prologue: function */
 461               	/* frame size = 0 */
 462               	/* stack size = 2 */
 463               	.L__stack_usage = 2
 445:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	SCCR0 |= (1 << SCMBTS);
 464               		.loc 5 445 0
 465 01a6 8CED      		ldi r24,lo8(-36)
 466 01a8 90E0      		ldi r25,0
 467 01aa 2CED      		ldi r18,lo8(-36)
 468 01ac 30E0      		ldi r19,0
 469 01ae F901      		movw r30,r18
 470 01b0 2081      		ld r18,Z
 471 01b2 2064      		ori r18,lo8(64)
 472 01b4 FC01      		movw r30,r24
 473 01b6 2083      		st Z,r18
 446:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	SCCR0 &= ~(1 << SCTSE);
 474               		.loc 5 446 0
 475 01b8 8CED      		ldi r24,lo8(-36)
 476 01ba 90E0      		ldi r25,0
 477 01bc 2CED      		ldi r18,lo8(-36)
 478 01be 30E0      		ldi r19,0
 479 01c0 F901      		movw r30,r18
 480 01c2 2081      		ld r18,Z
 481 01c4 277F      		andi r18,lo8(-9)
 482 01c6 FC01      		movw r30,r24
 483 01c8 2083      		st Z,r18
 447:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** }
 484               		.loc 5 447 0
 485 01ca 0000      		nop
 486               	/* epilogue start */
 487 01cc DF91      		pop r29
 488 01ce CF91      		pop r28
 489 01d0 0895      		ret
 490               		.cfi_endproc
 491               	.LFE121:
 493               	.global	appState
 494               		.section	.bss.appState,"aw",@nobits
 497               	appState:
 498 0000 00        		.zero	1
 499               		.section	.bss.msgReq,"aw",@nobits
 502               	msgReq:
 503 0000 0000 0000 		.zero	20
 503      0000 0000 
 503      0000 0000 
 503      0000 0000 
 503      0000 0000 
 504               		.section	.bss.PanId,"aw",@nobits
 507               	PanId:
 508 0000 00        		.zero	1
 509               		.text
 511               	appSendData:
 512               	.LFB130:
 513               		.file 6 "ServerLLDN.c"
   1:ServerLLDN.c  **** /*
   2:ServerLLDN.c  **** 	* ServerLLDN.c
   3:ServerLLDN.c  **** 	*
   4:ServerLLDN.c  **** 	* Created: 10/18/2019 5:15:37 PM
   5:ServerLLDN.c  **** 	*  Author: guilherme
   6:ServerLLDN.c  **** 	*/ 
   7:ServerLLDN.c  **** 
   8:ServerLLDN.c  **** #include <stdlib.h>
   9:ServerLLDN.c  **** #include <stdio.h>
  10:ServerLLDN.c  **** #include <string.h>
  11:ServerLLDN.c  **** #include <inttypes.h>
  12:ServerLLDN.c  **** #include "config.h"
  13:ServerLLDN.c  **** #include "sys.h"
  14:ServerLLDN.c  **** #include "phy.h"
  15:ServerLLDN.c  **** #include "sys.h"
  16:ServerLLDN.c  **** #include "nwk.h"
  17:ServerLLDN.c  **** #include "sysclk.h"
  18:ServerLLDN.c  **** #include "sysTimer.h"
  19:ServerLLDN.c  **** #include "sleep_mgr.h"
  20:ServerLLDN.c  **** #include "sleepmgr.h"
  21:ServerLLDN.c  **** #include "led.h"
  22:ServerLLDN.c  **** #include "ioport.h"
  23:ServerLLDN.c  **** #include "conf_sleepmgr.h"
  24:ServerLLDN.c  **** #include "board.h"
  25:ServerLLDN.c  **** #include "platform.h"
  26:ServerLLDN.c  **** #include "lldn.h"
  27:ServerLLDN.c  **** 
  28:ServerLLDN.c  **** #if APP_COORDINATOR
  29:ServerLLDN.c  **** 	#if (SIO2HOST_CHANNEL == SIO_USB)
  30:ServerLLDN.c  **** 		/* Only ARM */
  31:ServerLLDN.c  **** 		#include "stdio_usb.h"
  32:ServerLLDN.c  **** 		#define MASTER_MACSC	0
  33:ServerLLDN.c  **** 		#define TIMESLOT_TIMER	0
  34:ServerLLDN.c  **** 	#else
  35:ServerLLDN.c  **** 		/* Only megarf series */
  36:ServerLLDN.c  **** 		#include "conf_sio2host.h" // necessary for prints
  37:ServerLLDN.c  **** 		#define MASTER_MACSC	1
  38:ServerLLDN.c  **** 		#define TIMESLOT_TIMER	0
  39:ServerLLDN.c  **** 	#endif
  40:ServerLLDN.c  **** #else
  41:ServerLLDN.c  **** 	/* Only megarf series */
  42:ServerLLDN.c  **** 	#include "conf_sio2host.h" // necessary for prints
  43:ServerLLDN.c  **** 	#define MASTER_MACSC		1
  44:ServerLLDN.c  **** #endif
  45:ServerLLDN.c  **** 
  46:ServerLLDN.c  **** #define PRINT 0
  47:ServerLLDN.c  **** 
  48:ServerLLDN.c  **** #if (MASTER_MACSC == 1)
  49:ServerLLDN.c  **** 	#include "macsc_megarf.h"
  50:ServerLLDN.c  **** #else
  51:ServerLLDN.c  **** 	// static SYS_Timer_t				tmrBeaconInterval;			// Beacon
  52:ServerLLDN.c  **** 	// static SYS_Timer_t				tmrComputeData;				// Compute data
  53:ServerLLDN.c  **** #endif
  54:ServerLLDN.c  **** 	
  55:ServerLLDN.c  **** // equation for tTS gives time in seconds, the division by SYMBOL_TIME changes to symbols for count
  56:ServerLLDN.c  **** AppState_t	appState = APP_STATE_INITIAL;
  57:ServerLLDN.c  **** static NWK_DataReq_t msgReq;
  58:ServerLLDN.c  **** static uint8_t PanId;
  59:ServerLLDN.c  **** 
  60:ServerLLDN.c  **** static void appSendData(void)
  61:ServerLLDN.c  **** {
 514               		.loc 6 61 0
 515               		.cfi_startproc
 516 01d2 CF93      		push r28
 517               	.LCFI29:
 518               		.cfi_def_cfa_offset 3
 519               		.cfi_offset 28, -2
 520 01d4 DF93      		push r29
 521               	.LCFI30:
 522               		.cfi_def_cfa_offset 4
 523               		.cfi_offset 29, -3
 524 01d6 CDB7      		in r28,__SP_L__
 525 01d8 DEB7      		in r29,__SP_H__
 526               	.LCFI31:
 527               		.cfi_def_cfa_register 28
 528               	/* prologue: function */
 529               	/* frame size = 0 */
 530               	/* stack size = 2 */
 531               	.L__stack_usage = 2
  62:ServerLLDN.c  **** 	if(msgReq.options != 0)
 532               		.loc 6 62 0
 533 01da 8091 0000 		lds r24,msgReq+9
 534 01de 9091 0000 		lds r25,msgReq+9+1
 535 01e2 892B      		or r24,r25
 536 01e4 01F0      		breq .L17
  63:ServerLLDN.c  **** 	{
  64:ServerLLDN.c  **** 		// printf("\nMSG REQ SENT %d",msgReq.options);
  65:ServerLLDN.c  **** 		NWK_DataReq(&msgReq);
 537               		.loc 6 65 0
 538 01e6 80E0      		ldi r24,lo8(msgReq)
 539 01e8 90E0      		ldi r25,hi8(msgReq)
 540 01ea 0E94 0000 		call NWK_DataReq
 541               	.L17:
  66:ServerLLDN.c  **** 	#if !APP_COORDINATOR
  67:ServerLLDN.c  **** 	#endif
  68:ServerLLDN.c  **** 	}
  69:ServerLLDN.c  **** }
 542               		.loc 6 69 0
 543 01ee 0000      		nop
 544               	/* epilogue start */
 545 01f0 DF91      		pop r29
 546 01f2 CF91      		pop r28
 547 01f4 0895      		ret
 548               		.cfi_endproc
 549               	.LFE130:
 551               		.section	.bss.rec_beacon,"aw",@nobits
 554               	rec_beacon:
 555 0000 0000      		.zero	2
 556               		.section	.bss.msgConfigStatus,"aw",@nobits
 559               	msgConfigStatus:
 560 0000 0000 0000 		.zero	6
 560      0000 
 561               		.section	.bss.msgDiscResponse,"aw",@nobits
 564               	msgDiscResponse:
 565 0000 0000 0000 		.zero	4
 566               		.section	.data.payloadSize,"aw",@progbits
 569               	payloadSize:
 570 0000 01        		.byte	1
 571               	.global	assTimeSlot
 572               		.section	.data.assTimeSlot,"aw",@progbits
 575               	assTimeSlot:
 576 0000 FF        		.byte	-1
 577               		.section	.bss.ack_received,"aw",@nobits
 580               	ack_received:
 581 0000 00        		.zero	1
 582               	.global	MacLLDNMgmtTS
 583               		.section	.bss.MacLLDNMgmtTS,"aw",@nobits
 586               	MacLLDNMgmtTS:
 587 0000 00        		.zero	1
 588               	.global	associated
 589               		.section	.bss.associated,"aw",@nobits
 592               	associated:
 593 0000 00        		.zero	1
 594               		.text
 596               	send_message_timeHandler:
 597               	.LFB131:
  70:ServerLLDN.c  **** 
  71:ServerLLDN.c  **** #if APP_COORDINATOR
  72:ServerLLDN.c  **** 
  73:ServerLLDN.c  **** 	#define NODOS_ASSOCIADOS_ESPERADOS 12
  74:ServerLLDN.c  **** 
  75:ServerLLDN.c  **** 	float beaconInterval = 0;
  76:ServerLLDN.c  **** 	AppPanState_t appPanState = APP_PAN_STATE_RESET;		// Initial state of PAN node
  77:ServerLLDN.c  **** 	NWK_ACKFormat_t ACKFrame;								// ACK Frame Payload used in Discovery State
  78:ServerLLDN.c  **** 	int ACKFrame_size = 0;									// Bitmap size 
  79:ServerLLDN.c  **** 	uint8_t cycles_counter = macLLDNdiscoveryModeTimeout;
  80:ServerLLDN.c  **** 	int counter_associados = 0;								// Associated nodes counter
  81:ServerLLDN.c  **** 	NWK_ConfigRequest_t msgsConfRequest[254];				// Array for Configure Request messages, one position
  82:ServerLLDN.c  **** 	NWK_ConfigRequest_t ConfigRequest;
  83:ServerLLDN.c  **** 	int macLLDNnumUplinkTS = 0;								// Number of uplink timeslots, is also the control of associate
  84:ServerLLDN.c  **** 	int index_ConfRequest = 0;
  85:ServerLLDN.c  **** 	int index_TimeSlot = 0;
  86:ServerLLDN.c  **** 	static SYS_Timer_t tmrDelay_Discovery;							// Timer for delay between messages
  87:ServerLLDN.c  **** 	static SYS_Timer_t tmrDelay_Configuration;						// Timer for delay between messages
  88:ServerLLDN.c  **** 	
  89:ServerLLDN.c  **** 	
  90:ServerLLDN.c  **** 	int count_discovery = 0;
  91:ServerLLDN.c  **** 	int count_configuration = 0;
  92:ServerLLDN.c  **** 
  93:ServerLLDN.c  **** 	
  94:ServerLLDN.c  **** 	static void tmrDelayHandler(SYS_Timer_t *timer)
  95:ServerLLDN.c  **** 	{
  96:ServerLLDN.c  **** 		// printf("\nTimer_Software");
  97:ServerLLDN.c  **** 		appState = APP_STATE_SEND;
  98:ServerLLDN.c  **** 	}
  99:ServerLLDN.c  **** 	
 100:ServerLLDN.c  **** 	
 101:ServerLLDN.c  **** 	static void tmrResetHandler(SYS_Timer_t *timer)
 102:ServerLLDN.c  **** 	{
 103:ServerLLDN.c  **** 		// printf("\nTimer_Software");
 104:ServerLLDN.c  **** 		appState = APP_STATE_INITIAL;
 105:ServerLLDN.c  **** 		appPanState = APP_PAN_STATE_RESET;
 106:ServerLLDN.c  **** 	}
 107:ServerLLDN.c  **** 	
 108:ServerLLDN.c  **** 	
 109:ServerLLDN.c  **** 	static void lldn_server_beacon(void)
 110:ServerLLDN.c  **** 	{
 111:ServerLLDN.c  **** 		// printf("\nBeacon Timer");
 112:ServerLLDN.c  **** 		macsc_enable_manual_bts();
 113:ServerLLDN.c  **** 		appState = APP_STATE_SEND;
 114:ServerLLDN.c  **** 	}
 115:ServerLLDN.c  **** 	
 116:ServerLLDN.c  **** 	static void downlink_delay_handler(void)
 117:ServerLLDN.c  **** 	{
 118:ServerLLDN.c  **** 		if(msgReq.options == NWK_OPT_LLDN_ACK)
 119:ServerLLDN.c  **** 		{
 120:ServerLLDN.c  **** 			//printf("\ndelay timer");
 121:ServerLLDN.c  **** 		appState = APP_STATE_SEND;
 122:ServerLLDN.c  **** 		}
 123:ServerLLDN.c  **** 	}
 124:ServerLLDN.c  **** 	
 125:ServerLLDN.c  **** 	/*
 126:ServerLLDN.c  **** 	static void start_online_handler(void)
 127:ServerLLDN.c  **** 	{
 128:ServerLLDN.c  **** 		appPanState = APP_PAN_STATE_ONLINE_INITIAL
 129:ServerLLDN.c  **** 	}
 130:ServerLLDN.c  **** 	*/
 131:ServerLLDN.c  **** 	static void end_online_handler(void)
 132:ServerLLDN.c  **** 	{
 133:ServerLLDN.c  **** 		appState = APP_STATE_ATT_PAN_STATE;
 134:ServerLLDN.c  **** 		appPanState = APP_PAN_STATE_ONLINE_END_BE;
 135:ServerLLDN.c  **** 	}
 136:ServerLLDN.c  **** 	
 137:ServerLLDN.c  **** 	#if TIMESLOT_TIMER
 138:ServerLLDN.c  **** 	static void teste_handler(void)
 139:ServerLLDN.c  **** 	{
 140:ServerLLDN.c  **** 		if(msgReq.options)
 141:ServerLLDN.c  **** 		printf("\n***TIMESLOT****");
 142:ServerLLDN.c  **** 		macsc_disable_cmp_int(MACSC_CC3);
 143:ServerLLDN.c  **** 	}
 144:ServerLLDN.c  **** 	#endif
 145:ServerLLDN.c  **** 	
 146:ServerLLDN.c  **** 	static void addToAckArray(uint16_t addres)
 147:ServerLLDN.c  **** 	{	
 148:ServerLLDN.c  **** 		count_discovery++;
 149:ServerLLDN.c  **** 		int pos =(int) addres / 8;
 150:ServerLLDN.c  **** 		int bit_shift = 8 - (addres % 8);
 151:ServerLLDN.c  **** 		
 152:ServerLLDN.c  **** 		if(ACKFrame.ackFlags[pos] & 1 << bit_shift)
 153:ServerLLDN.c  **** 			printf("\n Addres colision");
 154:ServerLLDN.c  **** 		else
 155:ServerLLDN.c  **** 		{
 156:ServerLLDN.c  **** 			ACKFrame.ackFlags[pos] |= 1 << bit_shift;
 157:ServerLLDN.c  **** 			count_discovery++;
 158:ServerLLDN.c  **** 		}
 159:ServerLLDN.c  **** 		if (pos + 1 > ACKFrame_size)
 160:ServerLLDN.c  **** 		ACKFrame_size = pos + 1;
 161:ServerLLDN.c  **** 	}
 162:ServerLLDN.c  **** 	
 163:ServerLLDN.c  **** 	static void addConfRequestArray(NWK_ConfigStatus_t *node)
 164:ServerLLDN.c  **** 	{
 165:ServerLLDN.c  **** 		count_configuration++;
 166:ServerLLDN.c  **** 		index_ConfRequest++;
 167:ServerLLDN.c  **** 		
 168:ServerLLDN.c  **** 		if(node->ts_dir.tsDuration > n)
 169:ServerLLDN.c  **** 			n = node->ts_dir.tsDuration;
 170:ServerLLDN.c  **** 
 171:ServerLLDN.c  **** 		msgsConfRequest[index_ConfRequest].id = LL_CONFIGURATION_REQUEST;
 172:ServerLLDN.c  ****  		msgsConfRequest[index_ConfRequest].macAddr = node->macAddr;
 173:ServerLLDN.c  ****  		msgsConfRequest[index_ConfRequest].s_macAddr = APP_ADDR;
 174:ServerLLDN.c  ****  		msgsConfRequest[index_ConfRequest].tx_channel = APP_CHANNEL;
 175:ServerLLDN.c  ****  		msgsConfRequest[index_ConfRequest].assTimeSlot = (uint8_t)index_ConfRequest + (uint8_t)index_Tim
 176:ServerLLDN.c  ****  		msgsConfRequest[index_ConfRequest].conf.macLLDNmgmtTS = MacLLDNMgmtTS;
 177:ServerLLDN.c  **** 	}
 178:ServerLLDN.c  **** 		
 179:ServerLLDN.c  **** 	static void CopyToConfigRequest(int i)
 180:ServerLLDN.c  **** 	{
 181:ServerLLDN.c  **** 		ConfigRequest.id = msgsConfRequest[i].id;
 182:ServerLLDN.c  **** 		ConfigRequest.s_macAddr = msgsConfRequest[i].s_macAddr;
 183:ServerLLDN.c  **** 		ConfigRequest.tx_channel = msgsConfRequest[i].tx_channel;
 184:ServerLLDN.c  **** 		ConfigRequest.assTimeSlot = msgsConfRequest[i].assTimeSlot;
 185:ServerLLDN.c  **** 		ConfigRequest.macAddr = msgsConfRequest[i].macAddr;
 186:ServerLLDN.c  **** 		ConfigRequest.conf.tsDuration = n;
 187:ServerLLDN.c  **** 		ConfigRequest.conf.macLLDNmgmtTS = msgsConfRequest[i].conf.macLLDNmgmtTS;
 188:ServerLLDN.c  **** 	}
 189:ServerLLDN.c  **** 	
 190:ServerLLDN.c  **** 	static bool appCommandInd(NWK_DataInd_t *ind)
 191:ServerLLDN.c  **** 	{
 192:ServerLLDN.c  **** 		if(ind->data[0] == LL_DISCOVER_RESPONSE)
 193:ServerLLDN.c  **** 		{
 194:ServerLLDN.c  **** 			NWK_DiscoverResponse_t *msg = (NWK_DiscoverResponse_t*)ind->data;
 195:ServerLLDN.c  **** 			addToAckArray(msg->macAddr);
 196:ServerLLDN.c  **** 			#if PRINT
 197:ServerLLDN.c  **** 			printf("\nDISC %d", msg->macAddr);	
 198:ServerLLDN.c  **** 			#endif
 199:ServerLLDN.c  **** 		}
 200:ServerLLDN.c  **** 		else if(ind->data[0] == LL_CONFIGURATION_STATUS)
 201:ServerLLDN.c  **** 		{
 202:ServerLLDN.c  **** 			NWK_ConfigStatus_t *msg = (NWK_ConfigStatus_t*)ind->data;
 203:ServerLLDN.c  **** 			addConfRequestArray(msg);
 204:ServerLLDN.c  **** 			#if PRINT
 205:ServerLLDN.c  **** 			printf("\nCONF %d", msg->macAddr);	
 206:ServerLLDN.c  **** 			#endif
 207:ServerLLDN.c  **** 		}
 208:ServerLLDN.c  **** 		else return false;			
 209:ServerLLDN.c  **** 		return true;
 210:ServerLLDN.c  **** 	}
 211:ServerLLDN.c  **** 	
 212:ServerLLDN.c  **** 	static void appPanPrepareACK(void)
 213:ServerLLDN.c  **** 	{
 214:ServerLLDN.c  **** 		msgReq.dstAddr				= 0;
 215:ServerLLDN.c  **** 		msgReq.dstEndpoint			= APP_BEACON_ENDPOINT;
 216:ServerLLDN.c  **** 		msgReq.srcEndpoint			= APP_BEACON_ENDPOINT;
 217:ServerLLDN.c  **** 		msgReq.options				= NWK_OPT_LLDN_ACK;
 218:ServerLLDN.c  **** 		msgReq.data					= (uint8_t *)&ACKFrame;
 219:ServerLLDN.c  **** 		msgReq.size					= sizeof(uint8_t)*(ACKFrame_size + 1);
 220:ServerLLDN.c  **** 		
 221:ServerLLDN.c  **** 	}
 222:ServerLLDN.c  **** 
 223:ServerLLDN.c  **** 	static void appPanReset(void)
 224:ServerLLDN.c  **** 	{
 225:ServerLLDN.c  **** 		// prepare beacon reset message
 226:ServerLLDN.c  **** 		msgReq.dstAddr		= 0;
 227:ServerLLDN.c  **** 		msgReq.dstEndpoint	= APP_BEACON_ENDPOINT;
 228:ServerLLDN.c  **** 		msgReq.srcEndpoint	= APP_BEACON_ENDPOINT;
 229:ServerLLDN.c  **** 		msgReq.options		= NWK_OPT_LLDN_BEACON | NWK_OPT_RESET_STATE;
 230:ServerLLDN.c  **** 		msgReq.data			= NULL;
 231:ServerLLDN.c  **** 		msgReq.size			= 0;
 232:ServerLLDN.c  **** 
 233:ServerLLDN.c  **** 		for(int i = 0; i < 32; i++)
 234:ServerLLDN.c  **** 			ACKFrame.ackFlags[i] = 0;
 235:ServerLLDN.c  **** 		ACKFrame_size = 0;
 236:ServerLLDN.c  **** 		index_TimeSlot = 0;
 237:ServerLLDN.c  **** 		index_ConfRequest = 0;
 238:ServerLLDN.c  **** 		counter_associados = 0;
 239:ServerLLDN.c  **** 		n = 0;
 240:ServerLLDN.c  **** 	}
 241:ServerLLDN.c  **** 
 242:ServerLLDN.c  **** 	static void appPanDiscInit(void)
 243:ServerLLDN.c  **** 	{	
 244:ServerLLDN.c  **** 		/* clear Ack array of previous discovery state */
 245:ServerLLDN.c  **** 		for(int i = 0; i < 32; i++)
 246:ServerLLDN.c  **** 			ACKFrame.ackFlags[i] = 0;
 247:ServerLLDN.c  **** 		ACKFrame_size = 0;
 248:ServerLLDN.c  **** 		/* Prepare Beacon Message as first beacon in discovery state */		
 249:ServerLLDN.c  **** 		msgReq.dstAddr				= 0;
 250:ServerLLDN.c  **** 		msgReq.dstEndpoint			= APP_BEACON_ENDPOINT;
 251:ServerLLDN.c  **** 		msgReq.srcEndpoint			= APP_BEACON_ENDPOINT;
 252:ServerLLDN.c  **** 		msgReq.options				= NWK_OPT_LLDN_BEACON | NWK_OPT_DISCOVERY_STATE;
 253:ServerLLDN.c  **** 		msgReq.data					= NULL;
 254:ServerLLDN.c  **** 		msgReq.size					= 0;
 255:ServerLLDN.c  **** 		
 256:ServerLLDN.c  **** 		
 257:ServerLLDN.c  **** 		/* Only start timers if it is the first association process */
 258:ServerLLDN.c  **** 		if(cycles_counter == 0) 
 259:ServerLLDN.c  **** 		{
 260:ServerLLDN.c  **** 			
 261:ServerLLDN.c  **** 		/* Calculates Beacon Intervals according to 802.15.4e - 2012 p. 70 */
 262:ServerLLDN.c  **** 		n = 127; 
 263:ServerLLDN.c  **** 		tTS =  ((p_var*sp + (m+n)*sm + macMinLIFSPeriod)/v_var);
 264:ServerLLDN.c  **** 		#if (MASTER_MACSC == 1)
 265:ServerLLDN.c  **** 		
 266:ServerLLDN.c  **** 			beaconInterval = 2 * numBaseTimeSlotperMgmt * (tTS) / (SYMBOL_TIME);
 267:ServerLLDN.c  **** 			/*
 268:ServerLLDN.c  **** 			* Configure interrupts callback functions
 269:ServerLLDN.c  **** 			* overflow interrupt, compare 1,2,3 interrupts
 270:ServerLLDN.c  **** 			*/
 271:ServerLLDN.c  **** 			macsc_set_cmp1_int_cb(lldn_server_beacon);
 272:ServerLLDN.c  **** 			macsc_set_cmp3_int_cb(downlink_delay_handler);
 273:ServerLLDN.c  **** 			/*
 274:ServerLLDN.c  **** 			* Configure MACSC to generate compare interrupts from channels 1,2,3
 275:ServerLLDN.c  **** 			* Set compare mode to absolute, set compare value.
 276:ServerLLDN.c  **** 			*/
 277:ServerLLDN.c  **** 			macsc_enable_manual_bts();
 278:ServerLLDN.c  **** 			macsc_enable_cmp_int(MACSC_CC1);
 279:ServerLLDN.c  **** 			macsc_enable_cmp_int(MACSC_CC3);
 280:ServerLLDN.c  **** 
 281:ServerLLDN.c  **** 			
 282:ServerLLDN.c  **** 			macsc_use_cmp(MACSC_RELATIVE_CMP, beaconInterval , MACSC_CC1);
 283:ServerLLDN.c  **** 			macsc_use_cmp(MACSC_RELATIVE_CMP, 3 * beaconInterval / 8 , MACSC_CC3);
 284:ServerLLDN.c  **** 			
 285:ServerLLDN.c  **** 			/* Timer used in testing */
 286:ServerLLDN.c  **** 			#if TIMESLOT_TIMER
 287:ServerLLDN.c  **** 			macsc_set_cmp2_int_cb(teste_handler);	
 288:ServerLLDN.c  **** 			macsc_enable_cmp_int(MACSC_CC2);
 289:ServerLLDN.c  **** 			macsc_use_cmp(MACSC_RELATIVE_CMP, beaconInterval / 2, MACSC_CC2);
 290:ServerLLDN.c  **** 			#endif
 291:ServerLLDN.c  **** 			
 292:ServerLLDN.c  **** 		#endif
 293:ServerLLDN.c  **** 		}
 294:ServerLLDN.c  **** 	}
 295:ServerLLDN.c  **** 
 296:ServerLLDN.c  **** 	static void appPanOnlineInit()
 297:ServerLLDN.c  **** 	{
 298:ServerLLDN.c  **** 		tTS =  ((p_var*sp + (m+n)*sm + macMinLIFSPeriod)/v_var);
 299:ServerLLDN.c  **** 		beaconInterval = (assTimeSlot + MacLLDNMgmtTS*numBaseTimeSlotperMgmt) * tTS / (SYMBOL_TIME); // (
 300:ServerLLDN.c  **** 		// Configure Timers
 301:ServerLLDN.c  **** 		macsc_set_cmp1_int_cb(end_online_handler);
 302:ServerLLDN.c  **** 		macsc_enable_manual_bts();
 303:ServerLLDN.c  **** 		macsc_enable_cmp_int(MACSC_CC1);
 304:ServerLLDN.c  **** 		macsc_use_cmp(MACSC_RELATIVE_CMP, beaconInterval, MACSC_CC1);
 305:ServerLLDN.c  **** 		
 306:ServerLLDN.c  **** 		/* prepares online beacon , PRECISA SER REVISADO COM A NORMA, ESTOU EM DVIDA NO TIMESLOTE SIZE, 
 307:ServerLLDN.c  **** 		msgReq.dstAddr				= 0;
 308:ServerLLDN.c  **** 		msgReq.dstEndpoint			= APP_BEACON_ENDPOINT;
 309:ServerLLDN.c  **** 		msgReq.srcEndpoint			= APP_BEACON_ENDPOINT;
 310:ServerLLDN.c  **** 		msgReq.options				= NWK_OPT_LLDN_BEACON | NWK_OPT_ONLINE_STATE;
 311:ServerLLDN.c  **** 		msgReq.data					= NULL;
 312:ServerLLDN.c  **** 		msgReq.size					= 0;
 313:ServerLLDN.c  **** 	}
 314:ServerLLDN.c  **** 
 315:ServerLLDN.c  **** 
 316:ServerLLDN.c  **** #else 
 317:ServerLLDN.c  **** 	static NwkFrameBeaconHeaderLLDN_t *rec_beacon;
 318:ServerLLDN.c  **** 	static NWK_ConfigStatus_t msgConfigStatus;
 319:ServerLLDN.c  **** 	static NWK_DiscoverResponse_t msgDiscResponse;
 320:ServerLLDN.c  **** 
 321:ServerLLDN.c  **** 	static uint8_t payloadSize = 0x01;
 322:ServerLLDN.c  **** 	uint8_t assTimeSlot = 0xFF;
 323:ServerLLDN.c  **** 	uint8_t n = 0;
 324:ServerLLDN.c  **** 	
 325:ServerLLDN.c  **** 	static bool ack_received;
 326:ServerLLDN.c  **** 	bool MacLLDNMgmtTS = 0; 
 327:ServerLLDN.c  **** 	bool associated = 0;
 328:ServerLLDN.c  **** 	
 329:ServerLLDN.c  **** 	static void send_message_timeHandler(void)
 330:ServerLLDN.c  **** 	{
 598               		.loc 6 330 0
 599               		.cfi_startproc
 600 01f6 CF93      		push r28
 601               	.LCFI32:
 602               		.cfi_def_cfa_offset 3
 603               		.cfi_offset 28, -2
 604 01f8 DF93      		push r29
 605               	.LCFI33:
 606               		.cfi_def_cfa_offset 4
 607               		.cfi_offset 29, -3
 608 01fa CDB7      		in r28,__SP_L__
 609 01fc DEB7      		in r29,__SP_H__
 610               	.LCFI34:
 611               		.cfi_def_cfa_register 28
 612               	/* prologue: function */
 613               	/* frame size = 0 */
 614               	/* stack size = 2 */
 615               	.L__stack_usage = 2
 331:ServerLLDN.c  **** 		appState = APP_STATE_SEND;	
 616               		.loc 6 331 0
 617 01fe 82E0      		ldi r24,lo8(2)
 618 0200 8093 0000 		sts appState,r24
 332:ServerLLDN.c  **** 	}
 619               		.loc 6 332 0
 620 0204 0000      		nop
 621               	/* epilogue start */
 622 0206 DF91      		pop r29
 623 0208 CF91      		pop r28
 624 020a 0895      		ret
 625               		.cfi_endproc
 626               	.LFE131:
 628               		.section	.rodata
 629               	.LC1:
 630 0000 6163 6B20 		.string	"ack = %d"
 630      3D20 2564 
 630      00
 631               		.text
 633               	appBeaconInd:
 634               	.LFB132:
 333:ServerLLDN.c  **** 
 334:ServerLLDN.c  **** 	
 335:ServerLLDN.c  **** 	static bool appBeaconInd(NWK_DataInd_t *ind)
 336:ServerLLDN.c  **** 	{
 635               		.loc 6 336 0
 636               		.cfi_startproc
 637 020c CF93      		push r28
 638               	.LCFI35:
 639               		.cfi_def_cfa_offset 3
 640               		.cfi_offset 28, -2
 641 020e DF93      		push r29
 642               	.LCFI36:
 643               		.cfi_def_cfa_offset 4
 644               		.cfi_offset 29, -3
 645 0210 00D0      		rcall .
 646 0212 00D0      		rcall .
 647               	.LCFI37:
 648               		.cfi_def_cfa_offset 8
 649 0214 CDB7      		in r28,__SP_L__
 650 0216 DEB7      		in r29,__SP_H__
 651               	.LCFI38:
 652               		.cfi_def_cfa_register 28
 653               	/* prologue: function */
 654               	/* frame size = 4 */
 655               	/* stack size = 6 */
 656               	.L__stack_usage = 6
 657 0218 9C83      		std Y+4,r25
 658 021a 8B83      		std Y+3,r24
 337:ServerLLDN.c  **** 		macsc_enable_manual_bts();	
 659               		.loc 6 337 0
 660 021c 0E94 0000 		call macsc_enable_manual_bts
 338:ServerLLDN.c  **** 		rec_beacon = (NwkFrameBeaconHeaderLLDN_t*)ind->data;
 661               		.loc 6 338 0
 662 0220 8B81      		ldd r24,Y+3
 663 0222 9C81      		ldd r25,Y+4
 664 0224 FC01      		movw r30,r24
 665 0226 8085      		ldd r24,Z+8
 666 0228 9185      		ldd r25,Z+9
 667 022a 9093 0000 		sts rec_beacon+1,r25
 668 022e 8093 0000 		sts rec_beacon,r24
 339:ServerLLDN.c  **** 		//  bom implementar rotinas pra se o nodo estiver associado a um coordeandor e se no estiver
 340:ServerLLDN.c  **** 		PanId = rec_beacon->PanId; // s pode mudar se ele associar
 669               		.loc 6 340 0
 670 0232 8091 0000 		lds r24,rec_beacon
 671 0236 9091 0000 		lds r25,rec_beacon+1
 672 023a FC01      		movw r30,r24
 673 023c 8481      		ldd r24,Z+4
 674 023e 8093 0000 		sts PanId,r24
 341:ServerLLDN.c  **** 		
 342:ServerLLDN.c  **** 		if( (rec_beacon->Flags.txState == DISC_MODE && !ack_received) || 
 675               		.loc 6 342 0
 676 0242 8091 0000 		lds r24,rec_beacon
 677 0246 9091 0000 		lds r25,rec_beacon+1
 678 024a FC01      		movw r30,r24
 679 024c 8381      		ldd r24,Z+3
 680 024e 8770      		andi r24,lo8(7)
 681 0250 8430      		cpi r24,lo8(4)
 682 0252 01F4      		brne .L20
 683               		.loc 6 342 0 is_stmt 0 discriminator 1
 684 0254 9091 0000 		lds r25,ack_received
 685 0258 81E0      		ldi r24,lo8(1)
 686 025a 8927      		eor r24,r25
 687 025c 8823      		tst r24
 688 025e 01F4      		brne .L21
 689               	.L20:
 343:ServerLLDN.c  **** 			(rec_beacon->Flags.txState == CONFIG_MODE && ack_received))
 690               		.loc 6 343 0 is_stmt 1 discriminator 3
 691 0260 8091 0000 		lds r24,rec_beacon
 692 0264 9091 0000 		lds r25,rec_beacon+1
 693 0268 FC01      		movw r30,r24
 694 026a 8381      		ldd r24,Z+3
 695 026c 8770      		andi r24,lo8(7)
 342:ServerLLDN.c  **** 			(rec_beacon->Flags.txState == CONFIG_MODE && ack_received))
 696               		.loc 6 342 0 discriminator 3
 697 026e 8630      		cpi r24,lo8(6)
 698 0270 01F0      		breq .+2
 699 0272 00C0      		rjmp .L22
 700               		.loc 6 343 0
 701 0274 8091 0000 		lds r24,ack_received
 702 0278 8823      		tst r24
 703 027a 01F4      		brne .+2
 704 027c 00C0      		rjmp .L22
 705               	.L21:
 706               	.LBB2:
 344:ServerLLDN.c  **** 		{
 345:ServerLLDN.c  **** 			int msg_wait_time = rec_beacon->Flags.numBaseMgmtTimeslots * rec_beacon->TimeSlotSize* 2 - 250; 
 707               		.loc 6 345 0
 708 027e 8091 0000 		lds r24,rec_beacon
 709 0282 9091 0000 		lds r25,rec_beacon+1
 710 0286 FC01      		movw r30,r24
 711 0288 8381      		ldd r24,Z+3
 712 028a 8295      		swap r24
 713 028c 8695      		lsr r24
 714 028e 8770      		andi r24,lo8(7)
 715 0290 482F      		mov r20,r24
 716 0292 50E0      		ldi r21,0
 717 0294 8091 0000 		lds r24,rec_beacon
 718 0298 9091 0000 		lds r25,rec_beacon+1
 719 029c FC01      		movw r30,r24
 720 029e 8681      		ldd r24,Z+6
 721 02a0 282F      		mov r18,r24
 722 02a2 30E0      		ldi r19,0
 723 02a4 429F      		mul r20,r18
 724 02a6 C001      		movw r24,r0
 725 02a8 439F      		mul r20,r19
 726 02aa 900D      		add r25,r0
 727 02ac 529F      		mul r21,r18
 728 02ae 900D      		add r25,r0
 729 02b0 1124      		clr r1
 730 02b2 8D57      		subi r24,125
 731 02b4 9109      		sbc r25,__zero_reg__
 732 02b6 880F      		lsl r24
 733 02b8 991F      		rol r25
 734 02ba 9A83      		std Y+2,r25
 735 02bc 8983      		std Y+1,r24
 346:ServerLLDN.c  **** 			macsc_set_cmp1_int_cb(send_message_timeHandler);
 736               		.loc 6 346 0
 737 02be 80E0      		ldi r24,lo8(gs(send_message_timeHandler))
 738 02c0 90E0      		ldi r25,hi8(gs(send_message_timeHandler))
 739 02c2 0E94 0000 		call macsc_set_cmp1_int_cb
 347:ServerLLDN.c  **** 			
 348:ServerLLDN.c  **** 			macsc_enable_cmp_int(MACSC_CC1);
 740               		.loc 6 348 0
 741 02c6 81E0      		ldi r24,lo8(1)
 742 02c8 0E94 0000 		call macsc_enable_cmp_int
 349:ServerLLDN.c  **** 				  
 350:ServerLLDN.c  **** 			macsc_use_cmp(MACSC_RELATIVE_CMP, msg_wait_time , MACSC_CC1);
 743               		.loc 6 350 0
 744 02cc 8981      		ldd r24,Y+1
 745 02ce 9A81      		ldd r25,Y+2
 746 02d0 092E      		mov __tmp_reg__,r25
 747 02d2 000C      		lsl r0
 748 02d4 AA0B      		sbc r26,r26
 749 02d6 BB0B      		sbc r27,r27
 750 02d8 21E0      		ldi r18,lo8(1)
 751 02da AC01      		movw r20,r24
 752 02dc BD01      		movw r22,r26
 753 02de 81E0      		ldi r24,lo8(1)
 754 02e0 0E94 0000 		call macsc_use_cmp
 351:ServerLLDN.c  **** 			appState = (rec_beacon->Flags.txState == DISC_MODE) ? APP_STATE_PREP_DISC_REPONSE : APP_STATE_PR
 755               		.loc 6 351 0
 756 02e4 8091 0000 		lds r24,rec_beacon
 757 02e8 9091 0000 		lds r25,rec_beacon+1
 758 02ec FC01      		movw r30,r24
 759 02ee 8381      		ldd r24,Z+3
 760 02f0 8770      		andi r24,lo8(7)
 761 02f2 8430      		cpi r24,lo8(4)
 762 02f4 01F4      		brne .L23
 763               		.loc 6 351 0 is_stmt 0 discriminator 1
 764 02f6 84E0      		ldi r24,lo8(4)
 765 02f8 00C0      		rjmp .L24
 766               	.L23:
 767               		.loc 6 351 0 discriminator 2
 768 02fa 85E0      		ldi r24,lo8(5)
 769               	.L24:
 770               		.loc 6 351 0 discriminator 4
 771 02fc 8093 0000 		sts appState,r24
 772               	.LBE2:
 344:ServerLLDN.c  **** 			int msg_wait_time = rec_beacon->Flags.numBaseMgmtTimeslots * rec_beacon->TimeSlotSize* 2 - 250; 
 773               		.loc 6 344 0 is_stmt 1 discriminator 4
 774 0300 00C0      		rjmp .L25
 775               	.L22:
 352:ServerLLDN.c  **** 		}
 353:ServerLLDN.c  **** 		else if (rec_beacon->Flags.txState == RESET_MODE)
 776               		.loc 6 353 0
 777 0302 8091 0000 		lds r24,rec_beacon
 778 0306 9091 0000 		lds r25,rec_beacon+1
 779 030a FC01      		movw r30,r24
 780 030c 8381      		ldd r24,Z+3
 781 030e 8770      		andi r24,lo8(7)
 782 0310 8730      		cpi r24,lo8(7)
 783 0312 01F4      		brne .L25
 354:ServerLLDN.c  **** 		{
 355:ServerLLDN.c  **** 			
 356:ServerLLDN.c  **** 			ack_received = 0;
 784               		.loc 6 356 0
 785 0314 1092 0000 		sts ack_received,__zero_reg__
 357:ServerLLDN.c  **** 			associated = 0;
 786               		.loc 6 357 0
 787 0318 1092 0000 		sts associated,__zero_reg__
 358:ServerLLDN.c  **** 			printf("ack = %d" ,ack_received);
 788               		.loc 6 358 0
 789 031c 8091 0000 		lds r24,ack_received
 790 0320 882F      		mov r24,r24
 791 0322 90E0      		ldi r25,0
 792 0324 292F      		mov r18,r25
 793 0326 2F93      		push r18
 794 0328 8F93      		push r24
 795 032a 80E0      		ldi r24,lo8(.LC1)
 796 032c 90E0      		ldi r25,hi8(.LC1)
 797 032e 892F      		mov r24,r25
 798 0330 8F93      		push r24
 799 0332 80E0      		ldi r24,lo8(.LC1)
 800 0334 90E0      		ldi r25,hi8(.LC1)
 801 0336 8F93      		push r24
 802 0338 0E94 0000 		call printf
 803 033c 0F90      		pop __tmp_reg__
 804 033e 0F90      		pop __tmp_reg__
 805 0340 0F90      		pop __tmp_reg__
 806 0342 0F90      		pop __tmp_reg__
 807               	.L25:
 359:ServerLLDN.c  **** 		}
 360:ServerLLDN.c  **** 
 361:ServerLLDN.c  **** 		return true;
 808               		.loc 6 361 0
 809 0344 81E0      		ldi r24,lo8(1)
 810               	/* epilogue start */
 362:ServerLLDN.c  **** 	}
 811               		.loc 6 362 0
 812 0346 0F90      		pop __tmp_reg__
 813 0348 0F90      		pop __tmp_reg__
 814 034a 0F90      		pop __tmp_reg__
 815 034c 0F90      		pop __tmp_reg__
 816 034e DF91      		pop r29
 817 0350 CF91      		pop r28
 818 0352 0895      		ret
 819               		.cfi_endproc
 820               	.LFE132:
 822               		.section	.rodata
 823               	.LC2:
 824 0009 0A20 6163 		.string	"\n ack true"
 824      6B20 7472 
 824      7565 00
 825               		.text
 827               	appAckInd:
 828               	.LFB133:
 363:ServerLLDN.c  **** 	
 364:ServerLLDN.c  **** 	static bool appAckInd(NWK_DataInd_t *ind)
 365:ServerLLDN.c  **** 	{
 829               		.loc 6 365 0
 830               		.cfi_startproc
 831 0354 CF93      		push r28
 832               	.LCFI39:
 833               		.cfi_def_cfa_offset 3
 834               		.cfi_offset 28, -2
 835 0356 DF93      		push r29
 836               	.LCFI40:
 837               		.cfi_def_cfa_offset 4
 838               		.cfi_offset 29, -3
 839 0358 CDB7      		in r28,__SP_L__
 840 035a DEB7      		in r29,__SP_H__
 841               	.LCFI41:
 842               		.cfi_def_cfa_register 28
 843 035c 2897      		sbiw r28,8
 844               	.LCFI42:
 845               		.cfi_def_cfa_offset 12
 846 035e 0FB6      		in __tmp_reg__,__SREG__
 847 0360 F894      		cli
 848 0362 DEBF      		out __SP_H__,r29
 849 0364 0FBE      		out __SREG__,__tmp_reg__
 850 0366 CDBF      		out __SP_L__,r28
 851               	/* prologue: function */
 852               	/* frame size = 8 */
 853               	/* stack size = 10 */
 854               	.L__stack_usage = 10
 855 0368 9887      		std Y+8,r25
 856 036a 8F83      		std Y+7,r24
 366:ServerLLDN.c  **** 		NWK_ACKFormat_t *ackframe = (NWK_ACKFormat_t*)ind->data;
 857               		.loc 6 366 0
 858 036c 8F81      		ldd r24,Y+7
 859 036e 9885      		ldd r25,Y+8
 860 0370 FC01      		movw r30,r24
 861 0372 8085      		ldd r24,Z+8
 862 0374 9185      		ldd r25,Z+9
 863 0376 9A83      		std Y+2,r25
 864 0378 8983      		std Y+1,r24
 367:ServerLLDN.c  **** 		if(PanId == ackframe->sourceId)
 865               		.loc 6 367 0
 866 037a 8981      		ldd r24,Y+1
 867 037c 9A81      		ldd r25,Y+2
 868 037e FC01      		movw r30,r24
 869 0380 9081      		ld r25,Z
 870 0382 8091 0000 		lds r24,PanId
 871 0386 9817      		cp r25,r24
 872 0388 01F4      		brne .L28
 873               	.LBB3:
 368:ServerLLDN.c  **** 		{
 369:ServerLLDN.c  **** 			int pos = APP_ADDR / 8;
 874               		.loc 6 369 0
 875 038a 1C82      		std Y+4,__zero_reg__
 876 038c 1B82      		std Y+3,__zero_reg__
 370:ServerLLDN.c  **** 			int bit_shift = 8 - APP_ADDR % 8;
 877               		.loc 6 370 0
 878 038e 87E0      		ldi r24,lo8(7)
 879 0390 90E0      		ldi r25,0
 880 0392 9E83      		std Y+6,r25
 881 0394 8D83      		std Y+5,r24
 371:ServerLLDN.c  **** 			if( ackframe->ackFlags[pos] & 1 << bit_shift)	
 882               		.loc 6 371 0
 883 0396 2981      		ldd r18,Y+1
 884 0398 3A81      		ldd r19,Y+2
 885 039a 8B81      		ldd r24,Y+3
 886 039c 9C81      		ldd r25,Y+4
 887 039e 820F      		add r24,r18
 888 03a0 931F      		adc r25,r19
 889 03a2 0196      		adiw r24,1
 890 03a4 FC01      		movw r30,r24
 891 03a6 8081      		ld r24,Z
 892 03a8 882F      		mov r24,r24
 893 03aa 90E0      		ldi r25,0
 894 03ac 0D80      		ldd r0,Y+5
 895 03ae 00C0      		rjmp 2f
 896               		1:
 897 03b0 9595      		asr r25
 898 03b2 8795      		ror r24
 899               		2:
 900 03b4 0A94      		dec r0
 901 03b6 02F4      		brpl 1b
 902 03b8 8170      		andi r24,1
 903 03ba 9927      		clr r25
 904 03bc 892B      		or r24,r25
 905 03be 01F0      		breq .L28
 372:ServerLLDN.c  **** 				{
 373:ServerLLDN.c  **** 				printf("\n ack true");
 906               		.loc 6 373 0
 907 03c0 80E0      		ldi r24,lo8(.LC2)
 908 03c2 90E0      		ldi r25,hi8(.LC2)
 909 03c4 892F      		mov r24,r25
 910 03c6 8F93      		push r24
 911 03c8 80E0      		ldi r24,lo8(.LC2)
 912 03ca 90E0      		ldi r25,hi8(.LC2)
 913 03cc 8F93      		push r24
 914 03ce 0E94 0000 		call printf
 915 03d2 0F90      		pop __tmp_reg__
 916 03d4 0F90      		pop __tmp_reg__
 374:ServerLLDN.c  **** 				ack_received = true;
 917               		.loc 6 374 0
 918 03d6 81E0      		ldi r24,lo8(1)
 919 03d8 8093 0000 		sts ack_received,r24
 920               	.L28:
 921               	.LBE3:
 375:ServerLLDN.c  **** 				}
 376:ServerLLDN.c  **** 		}
 377:ServerLLDN.c  **** 		return true;
 922               		.loc 6 377 0
 923 03dc 81E0      		ldi r24,lo8(1)
 924               	/* epilogue start */
 378:ServerLLDN.c  **** 	}
 925               		.loc 6 378 0
 926 03de 2896      		adiw r28,8
 927 03e0 0FB6      		in __tmp_reg__,__SREG__
 928 03e2 F894      		cli
 929 03e4 DEBF      		out __SP_H__,r29
 930 03e6 0FBE      		out __SREG__,__tmp_reg__
 931 03e8 CDBF      		out __SP_L__,r28
 932 03ea DF91      		pop r29
 933 03ec CF91      		pop r28
 934 03ee 0895      		ret
 935               		.cfi_endproc
 936               	.LFE133:
 939               	appCommandInd:
 940               	.LFB134:
 379:ServerLLDN.c  **** 	
 380:ServerLLDN.c  **** 	static bool appCommandInd(NWK_DataInd_t *ind)
 381:ServerLLDN.c  **** 	{
 941               		.loc 6 381 0
 942               		.cfi_startproc
 943 03f0 CF93      		push r28
 944               	.LCFI43:
 945               		.cfi_def_cfa_offset 3
 946               		.cfi_offset 28, -2
 947 03f2 DF93      		push r29
 948               	.LCFI44:
 949               		.cfi_def_cfa_offset 4
 950               		.cfi_offset 29, -3
 951 03f4 00D0      		rcall .
 952 03f6 00D0      		rcall .
 953               	.LCFI45:
 954               		.cfi_def_cfa_offset 8
 955 03f8 CDB7      		in r28,__SP_L__
 956 03fa DEB7      		in r29,__SP_H__
 957               	.LCFI46:
 958               		.cfi_def_cfa_register 28
 959               	/* prologue: function */
 960               	/* frame size = 4 */
 961               	/* stack size = 6 */
 962               	.L__stack_usage = 6
 963 03fc 9C83      		std Y+4,r25
 964 03fe 8B83      		std Y+3,r24
 382:ServerLLDN.c  **** 		if(ind->data[0] == LL_CONFIGURATION_REQUEST)
 965               		.loc 6 382 0
 966 0400 8B81      		ldd r24,Y+3
 967 0402 9C81      		ldd r25,Y+4
 968 0404 FC01      		movw r30,r24
 969 0406 8085      		ldd r24,Z+8
 970 0408 9185      		ldd r25,Z+9
 971 040a FC01      		movw r30,r24
 972 040c 8081      		ld r24,Z
 973 040e 8F30      		cpi r24,lo8(15)
 974 0410 01F4      		brne .L31
 975               	.LBB4:
 383:ServerLLDN.c  **** 		{
 384:ServerLLDN.c  **** 			NWK_ConfigRequest_t *msg = (NWK_ConfigRequest_t*)ind->data;
 976               		.loc 6 384 0
 977 0412 8B81      		ldd r24,Y+3
 978 0414 9C81      		ldd r25,Y+4
 979 0416 FC01      		movw r30,r24
 980 0418 8085      		ldd r24,Z+8
 981 041a 9185      		ldd r25,Z+9
 982 041c 9A83      		std Y+2,r25
 983 041e 8983      		std Y+1,r24
 385:ServerLLDN.c  **** 			if(msg->macAddr == APP_ADDR)
 984               		.loc 6 385 0
 985 0420 8981      		ldd r24,Y+1
 986 0422 9A81      		ldd r25,Y+2
 987 0424 FC01      		movw r30,r24
 988 0426 8481      		ldd r24,Z+4
 989 0428 9581      		ldd r25,Z+5
 990 042a 0197      		sbiw r24,1
 991 042c 01F4      		brne .L31
 386:ServerLLDN.c  **** 			{
 387:ServerLLDN.c  **** 				PHY_SetChannel(msg->tx_channel);
 992               		.loc 6 387 0
 993 042e 8981      		ldd r24,Y+1
 994 0430 9A81      		ldd r25,Y+2
 995 0432 FC01      		movw r30,r24
 996 0434 8281      		ldd r24,Z+2
 997 0436 0E94 0000 		call PHY_SetChannel
 388:ServerLLDN.c  **** 				NWK_SetPanId(msg->s_macAddr);
 998               		.loc 6 388 0
 999 043a 8981      		ldd r24,Y+1
 1000 043c 9A81      		ldd r25,Y+2
 1001 043e FC01      		movw r30,r24
 1002 0440 8181      		ldd r24,Z+1
 1003 0442 882F      		mov r24,r24
 1004 0444 90E0      		ldi r25,0
 1005 0446 0E94 0000 		call NWK_SetPanId
 389:ServerLLDN.c  **** 				assTimeSlot = msg->assTimeSlot;
 1006               		.loc 6 389 0
 1007 044a 8981      		ldd r24,Y+1
 1008 044c 9A81      		ldd r25,Y+2
 1009 044e FC01      		movw r30,r24
 1010 0450 8381      		ldd r24,Z+3
 1011 0452 8093 0000 		sts assTimeSlot,r24
 390:ServerLLDN.c  **** 				n = msg->conf.tsDuration;
 1012               		.loc 6 390 0
 1013 0456 8981      		ldd r24,Y+1
 1014 0458 9A81      		ldd r25,Y+2
 1015 045a FC01      		movw r30,r24
 1016 045c 8681      		ldd r24,Z+6
 1017 045e 8F77      		andi r24,lo8(127)
 1018 0460 8093 0000 		sts n,r24
 1019               	.L31:
 1020               	.LBE4:
 391:ServerLLDN.c  **** 			}
 392:ServerLLDN.c  **** 		}
 393:ServerLLDN.c  **** 		return true;
 1021               		.loc 6 393 0
 1022 0464 81E0      		ldi r24,lo8(1)
 1023               	/* epilogue start */
 394:ServerLLDN.c  **** 	}
 1024               		.loc 6 394 0
 1025 0466 0F90      		pop __tmp_reg__
 1026 0468 0F90      		pop __tmp_reg__
 1027 046a 0F90      		pop __tmp_reg__
 1028 046c 0F90      		pop __tmp_reg__
 1029 046e DF91      		pop r29
 1030 0470 CF91      		pop r28
 1031 0472 0895      		ret
 1032               		.cfi_endproc
 1033               	.LFE134:
 1035               	.global	appPrepareDiscoverResponse
 1037               	appPrepareDiscoverResponse:
 1038               	.LFB135:
 395:ServerLLDN.c  **** 
 396:ServerLLDN.c  **** 	void appPrepareDiscoverResponse()
 397:ServerLLDN.c  **** 	{
 1039               		.loc 6 397 0
 1040               		.cfi_startproc
 1041 0474 CF93      		push r28
 1042               	.LCFI47:
 1043               		.cfi_def_cfa_offset 3
 1044               		.cfi_offset 28, -2
 1045 0476 DF93      		push r29
 1046               	.LCFI48:
 1047               		.cfi_def_cfa_offset 4
 1048               		.cfi_offset 29, -3
 1049 0478 CDB7      		in r28,__SP_L__
 1050 047a DEB7      		in r29,__SP_H__
 1051               	.LCFI49:
 1052               		.cfi_def_cfa_register 28
 1053               	/* prologue: function */
 1054               	/* frame size = 0 */
 1055               	/* stack size = 2 */
 1056               	.L__stack_usage = 2
 398:ServerLLDN.c  **** 		msgDiscResponse.id					= LL_DISCOVER_RESPONSE;
 1057               		.loc 6 398 0
 1058 047c 8DE0      		ldi r24,lo8(13)
 1059 047e 8093 0000 		sts msgDiscResponse,r24
 399:ServerLLDN.c  **** 		msgDiscResponse.macAddr				= APP_ADDR;
 1060               		.loc 6 399 0
 1061 0482 81E0      		ldi r24,lo8(1)
 1062 0484 90E0      		ldi r25,0
 1063 0486 9093 0000 		sts msgDiscResponse+1+1,r25
 1064 048a 8093 0000 		sts msgDiscResponse+1,r24
 400:ServerLLDN.c  **** 		msgDiscResponse.ts_dir.tsDuration	= payloadSize;
 1065               		.loc 6 400 0
 1066 048e 8091 0000 		lds r24,payloadSize
 1067 0492 8F77      		andi r24,lo8(127)
 1068 0494 8F77      		andi r24,lo8(127)
 1069 0496 9091 0000 		lds r25,msgDiscResponse+3
 1070 049a 9078      		andi r25,lo8(-128)
 1071 049c 892B      		or r24,r25
 1072 049e 8093 0000 		sts msgDiscResponse+3,r24
 401:ServerLLDN.c  **** 		msgDiscResponse.ts_dir.dirIndicator = 1;
 1073               		.loc 6 401 0
 1074 04a2 8091 0000 		lds r24,msgDiscResponse+3
 1075 04a6 8068      		ori r24,lo8(-128)
 1076 04a8 8093 0000 		sts msgDiscResponse+3,r24
 402:ServerLLDN.c  **** 		
 403:ServerLLDN.c  **** 		msgReq.dstAddr				= 0;
 1077               		.loc 6 403 0
 1078 04ac 1092 0000 		sts msgReq+5+1,__zero_reg__
 1079 04b0 1092 0000 		sts msgReq+5,__zero_reg__
 404:ServerLLDN.c  **** 		msgReq.dstEndpoint			= APP_COMMAND_ENDPOINT;
 1080               		.loc 6 404 0
 1081 04b4 83E0      		ldi r24,lo8(3)
 1082 04b6 8093 0000 		sts msgReq+7,r24
 405:ServerLLDN.c  **** 		msgReq.srcEndpoint			= APP_COMMAND_ENDPOINT;
 1083               		.loc 6 405 0
 1084 04ba 83E0      		ldi r24,lo8(3)
 1085 04bc 8093 0000 		sts msgReq+8,r24
 406:ServerLLDN.c  **** 		msgReq.options				= NWK_OPT_MAC_COMMAND;
 1086               		.loc 6 406 0
 1087 04c0 80E0      		ldi r24,0
 1088 04c2 90E8      		ldi r25,lo8(-128)
 1089 04c4 9093 0000 		sts msgReq+9+1,r25
 1090 04c8 8093 0000 		sts msgReq+9,r24
 407:ServerLLDN.c  **** 		msgReq.data					= (uint8_t*)&msgDiscResponse;
 1091               		.loc 6 407 0
 1092 04cc 80E0      		ldi r24,lo8(msgDiscResponse)
 1093 04ce 90E0      		ldi r25,hi8(msgDiscResponse)
 1094 04d0 9093 0000 		sts msgReq+13+1,r25
 1095 04d4 8093 0000 		sts msgReq+13,r24
 408:ServerLLDN.c  **** 		msgReq.size					= sizeof(msgDiscResponse);
 1096               		.loc 6 408 0
 1097 04d8 84E0      		ldi r24,lo8(4)
 1098 04da 8093 0000 		sts msgReq+15,r24
 409:ServerLLDN.c  **** 	}
 1099               		.loc 6 409 0
 1100 04de 0000      		nop
 1101               	/* epilogue start */
 1102 04e0 DF91      		pop r29
 1103 04e2 CF91      		pop r28
 1104 04e4 0895      		ret
 1105               		.cfi_endproc
 1106               	.LFE135:
 1108               	.global	appPrepareConfigurationStatus
 1110               	appPrepareConfigurationStatus:
 1111               	.LFB136:
 410:ServerLLDN.c  **** 	
 411:ServerLLDN.c  **** 	void appPrepareConfigurationStatus()
 412:ServerLLDN.c  **** 	{
 1112               		.loc 6 412 0
 1113               		.cfi_startproc
 1114 04e6 CF93      		push r28
 1115               	.LCFI50:
 1116               		.cfi_def_cfa_offset 3
 1117               		.cfi_offset 28, -2
 1118 04e8 DF93      		push r29
 1119               	.LCFI51:
 1120               		.cfi_def_cfa_offset 4
 1121               		.cfi_offset 29, -3
 1122 04ea CDB7      		in r28,__SP_L__
 1123 04ec DEB7      		in r29,__SP_H__
 1124               	.LCFI52:
 1125               		.cfi_def_cfa_register 28
 1126               	/* prologue: function */
 1127               	/* frame size = 0 */
 1128               	/* stack size = 2 */
 1129               	.L__stack_usage = 2
 413:ServerLLDN.c  **** 		msgConfigStatus.id					  = LL_CONFIGURATION_STATUS;
 1130               		.loc 6 413 0
 1131 04ee 8EE0      		ldi r24,lo8(14)
 1132 04f0 8093 0000 		sts msgConfigStatus,r24
 414:ServerLLDN.c  **** 		msgConfigStatus.macAddr				  = APP_ADDR;
 1133               		.loc 6 414 0
 1134 04f4 81E0      		ldi r24,lo8(1)
 1135 04f6 90E0      		ldi r25,0
 1136 04f8 9093 0000 		sts msgConfigStatus+3+1,r25
 1137 04fc 8093 0000 		sts msgConfigStatus+3,r24
 415:ServerLLDN.c  **** 		msgConfigStatus.s_macAddr			  = APP_ADDR;
 1138               		.loc 6 415 0
 1139 0500 81E0      		ldi r24,lo8(1)
 1140 0502 8093 0000 		sts msgConfigStatus+1,r24
 416:ServerLLDN.c  **** 		msgConfigStatus.ts_dir.tsDuration	  = payloadSize;
 1141               		.loc 6 416 0
 1142 0506 8091 0000 		lds r24,payloadSize
 1143 050a 8F77      		andi r24,lo8(127)
 1144 050c 8F77      		andi r24,lo8(127)
 1145 050e 9091 0000 		lds r25,msgConfigStatus+5
 1146 0512 9078      		andi r25,lo8(-128)
 1147 0514 892B      		or r24,r25
 1148 0516 8093 0000 		sts msgConfigStatus+5,r24
 417:ServerLLDN.c  **** 		msgConfigStatus.ts_dir.dirIndicator   = 1;
 1149               		.loc 6 417 0
 1150 051a 8091 0000 		lds r24,msgConfigStatus+5
 1151 051e 8068      		ori r24,lo8(-128)
 1152 0520 8093 0000 		sts msgConfigStatus+5,r24
 418:ServerLLDN.c  **** 		// assTimeSlot precisa ser variado quando for implementar
 419:ServerLLDN.c  **** 		// no caso inicial a rede no est em andamento ainda portanto faz
 420:ServerLLDN.c  **** 		// sentido nenhum nodo ter timeslot assigned
 421:ServerLLDN.c  **** 		msgConfigStatus.assTimeSlot = assTimeSlot;
 1153               		.loc 6 421 0
 1154 0524 8091 0000 		lds r24,assTimeSlot
 1155 0528 8093 0000 		sts msgConfigStatus+2,r24
 422:ServerLLDN.c  **** 
 423:ServerLLDN.c  **** 		
 424:ServerLLDN.c  **** 		msgReq.dstAddr				= 0;
 1156               		.loc 6 424 0
 1157 052c 1092 0000 		sts msgReq+5+1,__zero_reg__
 1158 0530 1092 0000 		sts msgReq+5,__zero_reg__
 425:ServerLLDN.c  **** 		msgReq.dstEndpoint			= APP_COMMAND_ENDPOINT;
 1159               		.loc 6 425 0
 1160 0534 83E0      		ldi r24,lo8(3)
 1161 0536 8093 0000 		sts msgReq+7,r24
 426:ServerLLDN.c  **** 		msgReq.srcEndpoint			= APP_COMMAND_ENDPOINT;
 1162               		.loc 6 426 0
 1163 053a 83E0      		ldi r24,lo8(3)
 1164 053c 8093 0000 		sts msgReq+8,r24
 427:ServerLLDN.c  **** 		msgReq.options				= NWK_OPT_MAC_COMMAND;
 1165               		.loc 6 427 0
 1166 0540 80E0      		ldi r24,0
 1167 0542 90E8      		ldi r25,lo8(-128)
 1168 0544 9093 0000 		sts msgReq+9+1,r25
 1169 0548 8093 0000 		sts msgReq+9,r24
 428:ServerLLDN.c  **** 		msgReq.data					= (uint8_t*)&msgConfigStatus;
 1170               		.loc 6 428 0
 1171 054c 80E0      		ldi r24,lo8(msgConfigStatus)
 1172 054e 90E0      		ldi r25,hi8(msgConfigStatus)
 1173 0550 9093 0000 		sts msgReq+13+1,r25
 1174 0554 8093 0000 		sts msgReq+13,r24
 429:ServerLLDN.c  **** 		msgReq.size					= sizeof(msgConfigStatus);
 1175               		.loc 6 429 0
 1176 0558 86E0      		ldi r24,lo8(6)
 1177 055a 8093 0000 		sts msgReq+15,r24
 430:ServerLLDN.c  **** 	}
 1178               		.loc 6 430 0
 1179 055e 0000      		nop
 1180               	/* epilogue start */
 1181 0560 DF91      		pop r29
 1182 0562 CF91      		pop r28
 1183 0564 0895      		ret
 1184               		.cfi_endproc
 1185               	.LFE136:
 1188               	appInit:
 1189               	.LFB137:
 431:ServerLLDN.c  **** 	
 432:ServerLLDN.c  **** #endif // APP_COORDINATOR
 433:ServerLLDN.c  **** 
 434:ServerLLDN.c  **** static void appInit(void)
 435:ServerLLDN.c  **** {
 1190               		.loc 6 435 0
 1191               		.cfi_startproc
 1192 0566 CF93      		push r28
 1193               	.LCFI53:
 1194               		.cfi_def_cfa_offset 3
 1195               		.cfi_offset 28, -2
 1196 0568 DF93      		push r29
 1197               	.LCFI54:
 1198               		.cfi_def_cfa_offset 4
 1199               		.cfi_offset 29, -3
 1200 056a CDB7      		in r28,__SP_L__
 1201 056c DEB7      		in r29,__SP_H__
 1202               	.LCFI55:
 1203               		.cfi_def_cfa_register 28
 1204               	/* prologue: function */
 1205               	/* frame size = 0 */
 1206               	/* stack size = 2 */
 1207               	.L__stack_usage = 2
 436:ServerLLDN.c  **** 	NWK_SetAddr(APP_ADDR);
 1208               		.loc 6 436 0
 1209 056e 81E0      		ldi r24,lo8(1)
 1210 0570 90E0      		ldi r25,0
 1211 0572 0E94 0000 		call NWK_SetAddr
 437:ServerLLDN.c  **** 	PHY_SetChannel(APP_CHANNEL);
 1212               		.loc 6 437 0
 1213 0576 8FE0      		ldi r24,lo8(15)
 1214 0578 0E94 0000 		call PHY_SetChannel
 438:ServerLLDN.c  **** 	PHY_SetRxState(true);
 1215               		.loc 6 438 0
 1216 057c 81E0      		ldi r24,lo8(1)
 1217 057e 0E94 0000 		call PHY_SetRxState
 439:ServerLLDN.c  **** 		
 440:ServerLLDN.c  **** 	#if APP_COORDINATOR
 441:ServerLLDN.c  **** 	  /* Timer used for delay between messages */
 442:ServerLLDN.c  **** 	  tmrDelay_Discovery.interval = 2000;
 443:ServerLLDN.c  **** 	  tmrDelay_Discovery.mode = SYS_TIMER_PERIODIC_MODE;
 444:ServerLLDN.c  **** 	  tmrDelay_Discovery.handler = tmrResetHandler;
 445:ServerLLDN.c  **** 	  // SYS_TimerStart(&tmrDelay_Discovery);
 446:ServerLLDN.c  **** 
 447:ServerLLDN.c  **** 	  
 448:ServerLLDN.c  **** 	  /* Timer used for delay between messages */
 449:ServerLLDN.c  **** 	  tmrDelay_Configuration.interval = 2;
 450:ServerLLDN.c  **** 	  tmrDelay_Configuration.mode = SYS_TIMER_INTERVAL_MODE;
 451:ServerLLDN.c  **** 	  tmrDelay_Configuration.handler = tmrDelayHandler;
 452:ServerLLDN.c  **** 	  
 453:ServerLLDN.c  **** 		/* 
 454:ServerLLDN.c  **** 		* Disable CSMA/CA
 455:ServerLLDN.c  **** 		* Disable auto ACK
 456:ServerLLDN.c  **** 		*/
 457:ServerLLDN.c  **** 		NWK_SetPanId(APP_PANID);
 458:ServerLLDN.c  **** 		PanId = APP_PANID;
 459:ServerLLDN.c  **** 		ACKFrame.sourceId = APP_PANID;
 460:ServerLLDN.c  **** 		PHY_SetTdmaMode(true);
 461:ServerLLDN.c  **** 		NWK_OpenEndpoint(APP_COMMAND_ENDPOINT, appCommandInd);
 462:ServerLLDN.c  **** 	#else
 463:ServerLLDN.c  **** 		/*
 464:ServerLLDN.c  **** 		 * Enable CSMA/CA
 465:ServerLLDN.c  **** 		 * Enable Random CSMA seed generator
 466:ServerLLDN.c  **** 		 */
 467:ServerLLDN.c  **** 		PHY_SetTdmaMode(false);
 1218               		.loc 6 467 0
 1219 0582 80E0      		ldi r24,0
 1220 0584 0E94 0000 		call PHY_SetTdmaMode
 468:ServerLLDN.c  **** 		PHY_SetOptimizedCSMAValues();
 1221               		.loc 6 468 0
 1222 0588 0E94 0000 		call PHY_SetOptimizedCSMAValues
 469:ServerLLDN.c  **** 		
 470:ServerLLDN.c  **** 		payloadSize = 0x01;
 1223               		.loc 6 470 0
 1224 058c 81E0      		ldi r24,lo8(1)
 1225 058e 8093 0000 		sts payloadSize,r24
 471:ServerLLDN.c  **** 		NWK_OpenEndpoint(APP_BEACON_ENDPOINT, appBeaconInd);
 1226               		.loc 6 471 0
 1227 0592 60E0      		ldi r22,lo8(gs(appBeaconInd))
 1228 0594 70E0      		ldi r23,hi8(gs(appBeaconInd))
 1229 0596 80E0      		ldi r24,0
 1230 0598 0E94 0000 		call NWK_OpenEndpoint
 472:ServerLLDN.c  **** 		NWK_OpenEndpoint(APP_ACK_ENDPOINT, appAckInd);
 1231               		.loc 6 472 0
 1232 059c 60E0      		ldi r22,lo8(gs(appAckInd))
 1233 059e 70E0      		ldi r23,hi8(gs(appAckInd))
 1234 05a0 84E0      		ldi r24,lo8(4)
 1235 05a2 0E94 0000 		call NWK_OpenEndpoint
 473:ServerLLDN.c  **** 		NWK_OpenEndpoint(APP_COMMAND_ENDPOINT, appCommandInd);
 1236               		.loc 6 473 0
 1237 05a6 60E0      		ldi r22,lo8(gs(appCommandInd))
 1238 05a8 70E0      		ldi r23,hi8(gs(appCommandInd))
 1239 05aa 83E0      		ldi r24,lo8(3)
 1240 05ac 0E94 0000 		call NWK_OpenEndpoint
 474:ServerLLDN.c  **** 		/*
 475:ServerLLDN.c  **** 		* Configure interrupts callback functions
 476:ServerLLDN.c  **** 		*/
 477:ServerLLDN.c  **** 		
 478:ServerLLDN.c  **** 	#endif // APP_COORDENATOR
 479:ServerLLDN.c  **** 	PHY_SetPromiscuousMode(true);
 1241               		.loc 6 479 0
 1242 05b0 81E0      		ldi r24,lo8(1)
 1243 05b2 0E94 0000 		call PHY_SetPromiscuousMode
 480:ServerLLDN.c  **** 
 481:ServerLLDN.c  **** }
 1244               		.loc 6 481 0
 1245 05b6 0000      		nop
 1246               	/* epilogue start */
 1247 05b8 DF91      		pop r29
 1248 05ba CF91      		pop r28
 1249 05bc 0895      		ret
 1250               		.cfi_endproc
 1251               	.LFE137:
 1254               	APP_TaskHandler:
 1255               	.LFB138:
 482:ServerLLDN.c  **** 
 483:ServerLLDN.c  **** static void APP_TaskHandler(void)
 484:ServerLLDN.c  **** {
 1256               		.loc 6 484 0
 1257               		.cfi_startproc
 1258 05be CF93      		push r28
 1259               	.LCFI56:
 1260               		.cfi_def_cfa_offset 3
 1261               		.cfi_offset 28, -2
 1262 05c0 DF93      		push r29
 1263               	.LCFI57:
 1264               		.cfi_def_cfa_offset 4
 1265               		.cfi_offset 29, -3
 1266 05c2 CDB7      		in r28,__SP_L__
 1267 05c4 DEB7      		in r29,__SP_H__
 1268               	.LCFI58:
 1269               		.cfi_def_cfa_register 28
 1270               	/* prologue: function */
 1271               	/* frame size = 0 */
 1272               	/* stack size = 2 */
 1273               	.L__stack_usage = 2
 485:ServerLLDN.c  **** 	switch (appState){
 1274               		.loc 6 485 0
 1275 05c6 8091 0000 		lds r24,appState
 1276 05ca 882F      		mov r24,r24
 1277 05cc 90E0      		ldi r25,0
 1278 05ce 8230      		cpi r24,2
 1279 05d0 9105      		cpc r25,__zero_reg__
 1280 05d2 01F0      		breq .L38
 1281 05d4 8330      		cpi r24,3
 1282 05d6 9105      		cpc r25,__zero_reg__
 1283 05d8 04F4      		brge .L39
 1284 05da 892B      		or r24,r25
 1285 05dc 01F0      		breq .L40
 486:ServerLLDN.c  **** 		case APP_STATE_INITIAL:
 487:ServerLLDN.c  **** 		{
 488:ServerLLDN.c  **** 			appInit();
 489:ServerLLDN.c  **** 			#if APP_COORDINATOR
 490:ServerLLDN.c  **** 				appState = APP_STATE_ATT_PAN_STATE;
 491:ServerLLDN.c  **** 			#else
 492:ServerLLDN.c  **** 				appState = APP_STATE_IDLE;
 493:ServerLLDN.c  **** 			#endif
 494:ServerLLDN.c  **** 			break;
 495:ServerLLDN.c  **** 		}
 496:ServerLLDN.c  **** 		case APP_STATE_SEND:
 497:ServerLLDN.c  **** 		{
 498:ServerLLDN.c  **** 			appSendData();
 499:ServerLLDN.c  **** 			#if APP_COORDINATOR
 500:ServerLLDN.c  **** 				/* Every time a message is send updates coordinator to prepare next message */
 501:ServerLLDN.c  **** 				appState = APP_STATE_ATT_PAN_STATE;
 502:ServerLLDN.c  **** 			#else
 503:ServerLLDN.c  **** 				appState = APP_STATE_IDLE;
 504:ServerLLDN.c  **** 			#endif
 505:ServerLLDN.c  **** 			break;
 506:ServerLLDN.c  **** 		}
 507:ServerLLDN.c  **** 		#if APP_COORDINATOR // COORDINATOR SPECIFIC STATE MACHINE
 508:ServerLLDN.c  **** 		case APP_STATE_ATT_PAN_STATE:
 509:ServerLLDN.c  **** 		{
 510:ServerLLDN.c  **** 			switch(appPanState)
 511:ServerLLDN.c  **** 			{
 512:ServerLLDN.c  **** 				/* Prepare beacon to desassociate all nodes */
 513:ServerLLDN.c  **** 				case APP_PAN_STATE_RESET:
 514:ServerLLDN.c  **** 				{
 515:ServerLLDN.c  **** 					appPanReset();
 516:ServerLLDN.c  **** 					appPanState = APP_PAN_STATE_DISC_INITIAL;
 517:ServerLLDN.c  **** 					appState	= APP_STATE_SEND;
 518:ServerLLDN.c  **** 					cycles_counter = 0;
 519:ServerLLDN.c  **** 					break;
 520:ServerLLDN.c  **** 				}
 521:ServerLLDN.c  **** 				/* Prepare first Beacon of Discovery */
 522:ServerLLDN.c  **** 				case APP_PAN_STATE_DISC_INITIAL:
 523:ServerLLDN.c  **** 				{
 524:ServerLLDN.c  **** 					index_ConfRequest = 0;
 525:ServerLLDN.c  **** 					count_discovery = 0;
 526:ServerLLDN.c  **** 					count_configuration = 0; 
 527:ServerLLDN.c  **** 					/* if nodes associated is equal to expected number of associated nodes stop association proces
 528:ServerLLDN.c  **** 					 * this implementation was done as is to be used in tests, for real network functionality 
 529:ServerLLDN.c  **** 					 * the number of max association processes must be done through macLLDNdiscoveryModeTimeout
 530:ServerLLDN.c  **** 					 */
 531:ServerLLDN.c  **** 					if(counter_associados == NODOS_ASSOCIADOS_ESPERADOS || cycles_counter >= 12)
 532:ServerLLDN.c  **** 					{	
 533:ServerLLDN.c  **** 						printf("\n%d, %d", cycles_counter, counter_associados);
 534:ServerLLDN.c  **** 						counter_associados = 0;
 535:ServerLLDN.c  **** 						/* if all nodes expected where associated stop beacon generation interruptions */
 536:ServerLLDN.c  **** 						macsc_disable_cmp_int(MACSC_CC1);
 537:ServerLLDN.c  **** 						macsc_disable_cmp_int(MACSC_CC2);
 538:ServerLLDN.c  **** 						macsc_disable_cmp_int(MACSC_CC3);
 539:ServerLLDN.c  **** 						msgReq.options = 0;
 540:ServerLLDN.c  **** 						/* set coordinator node to idle further implementation of online state must be done */
 541:ServerLLDN.c  **** 						appState = APP_STATE_IDLE;
 542:ServerLLDN.c  **** 						appPanState = APP_PAN_STATE_IDLE; // APP_PAN_STATE_ONLINE_INIT
 543:ServerLLDN.c  **** 						
 544:ServerLLDN.c  **** 					}
 545:ServerLLDN.c  **** 					/* if not all nodes expected where associated run through association process again */
 546:ServerLLDN.c  **** 					else 
 547:ServerLLDN.c  **** 					{
 548:ServerLLDN.c  **** 						/* prepare beacon message and start timers for beacon */
 549:ServerLLDN.c  **** 						appPanDiscInit();
 550:ServerLLDN.c  **** 						appState	= APP_STATE_IDLE;
 551:ServerLLDN.c  **** 						appPanState = APP_PAN_STATE_DISC_SECOND_BE;
 552:ServerLLDN.c  **** 					}
 553:ServerLLDN.c  **** 					break;
 554:ServerLLDN.c  **** 				}
 555:ServerLLDN.c  **** 				case APP_PAN_STATE_DISC_SECOND_BE:
 556:ServerLLDN.c  **** 				{
 557:ServerLLDN.c  **** 					/* Prepares message as: Discovery Beacon and Second Beacon */
 558:ServerLLDN.c  **** 					msgReq.options = NWK_OPT_LLDN_BEACON | NWK_OPT_DISCOVERY_STATE | NWK_OPT_SECOND_BEACON ;
 559:ServerLLDN.c  **** 					msgReq.data = NULL;
 560:ServerLLDN.c  **** 					msgReq.size = 0;
 561:ServerLLDN.c  **** 					appState	= APP_STATE_IDLE;
 562:ServerLLDN.c  **** 					appPanState = APP_PAN_STATE_DISC_PREPARE_ACK;
 563:ServerLLDN.c  **** 					break;
 564:ServerLLDN.c  **** 				}
 565:ServerLLDN.c  **** 				case APP_PAN_STATE_DISC_PREPARE_ACK:
 566:ServerLLDN.c  **** 				{
 567:ServerLLDN.c  **** 					/* This timer implements a delay between messages, 
 568:ServerLLDN.c  **** 					 * if not used the nodes are not able to receive the message
 569:ServerLLDN.c  **** 					 */
 570:ServerLLDN.c  **** 					appPanPrepareACK();
 571:ServerLLDN.c  **** 					//SYS_TimerStart(&tmrDelay_Discovery);
 572:ServerLLDN.c  **** 					
 573:ServerLLDN.c  **** 					appPanState = APP_PAN_STATE_CONFIG_INITIAL; 
 574:ServerLLDN.c  **** 					appState = APP_STATE_IDLE;
 575:ServerLLDN.c  **** 					break;
 576:ServerLLDN.c  **** 				}
 577:ServerLLDN.c  **** 				case APP_PAN_STATE_CONFIG_INITIAL:
 578:ServerLLDN.c  **** 				{
 579:ServerLLDN.c  **** 					/* Prepares the message as: Configuration Beacon and First State Beacon */
 580:ServerLLDN.c  **** 					msgReq.options = NWK_OPT_LLDN_BEACON | NWK_OPT_CONFIG_STATE;
 581:ServerLLDN.c  **** 					msgReq.data = NULL;
 582:ServerLLDN.c  **** 					msgReq.size = 0;
 583:ServerLLDN.c  **** 					appState	= APP_STATE_IDLE;
 584:ServerLLDN.c  **** 					appPanState = APP_PAN_STATE_CONFIG_SECOND_BEACON;
 585:ServerLLDN.c  **** 					break;
 586:ServerLLDN.c  **** 
 587:ServerLLDN.c  **** 				}
 588:ServerLLDN.c  **** 				case APP_PAN_STATE_CONFIG_SECOND_BEACON:
 589:ServerLLDN.c  **** 				{
 590:ServerLLDN.c  **** 					/* Prepares the message as: Configuration Beacon and Second State Beacon */
 591:ServerLLDN.c  **** 					msgReq.options = NWK_OPT_LLDN_BEACON | NWK_OPT_CONFIG_STATE | NWK_OPT_SECOND_BEACON;
 592:ServerLLDN.c  **** 					msgReq.data = NULL;
 593:ServerLLDN.c  **** 					msgReq.size = 0;
 594:ServerLLDN.c  **** 					appState	= APP_STATE_IDLE;
 595:ServerLLDN.c  **** 					appPanState = APP_PAN_STATE_SEND_CONF_REQUEST;
 596:ServerLLDN.c  **** 					break;
 597:ServerLLDN.c  **** 				}
 598:ServerLLDN.c  **** 				case APP_PAN_STATE_SEND_CONF_REQUEST:
 599:ServerLLDN.c  **** 				{
 600:ServerLLDN.c  **** 					index_TimeSlot = index_ConfRequest;
 601:ServerLLDN.c  **** 					/* Send Configuration Requests frames 
 602:ServerLLDN.c  **** 					 * PRECISA SER MUDADO, NA IMPLEMENTAO ATUAL A LOCAO DE SLOTS NO EST CORRETA
 603:ServerLLDN.c  **** 					 */
 604:ServerLLDN.c  **** 					if(index_ConfRequest > 0)
 605:ServerLLDN.c  **** 					{
 606:ServerLLDN.c  **** 						CopyToConfigRequest(index_ConfRequest);
 607:ServerLLDN.c  **** 						msgReq.options		= NWK_OPT_MAC_COMMAND;
 608:ServerLLDN.c  **** 						msgReq.data			= (uint8_t*)&ConfigRequest;
 609:ServerLLDN.c  **** 						msgReq.size			= sizeof(NWK_ConfigRequest_t);
 610:ServerLLDN.c  **** 						appState	= APP_STATE_IDLE;
 611:ServerLLDN.c  **** 						appPanState = APP_PAN_STATE_SEND_CONF_REQUEST;
 612:ServerLLDN.c  **** 						index_ConfRequest--;
 613:ServerLLDN.c  **** 						counter_associados++;
 614:ServerLLDN.c  **** 						SYS_TimerStart(&tmrDelay_Configuration);
 615:ServerLLDN.c  **** 					}
 616:ServerLLDN.c  **** 					else
 617:ServerLLDN.c  **** 					{
 618:ServerLLDN.c  **** 						appPanState = APP_PAN_STATE_CONFIG_THIRD_BEACON;
 619:ServerLLDN.c  **** 					}
 620:ServerLLDN.c  **** 					break;
 621:ServerLLDN.c  **** 				}
 622:ServerLLDN.c  **** 				case APP_PAN_STATE_CONFIG_THIRD_BEACON:
 623:ServerLLDN.c  **** 				{
 624:ServerLLDN.c  **** 					msgReq.options = NWK_OPT_LLDN_BEACON | NWK_OPT_CONFIG_STATE | NWK_OPT_THIRD_BEACON;
 625:ServerLLDN.c  **** 					msgReq.data = NULL;
 626:ServerLLDN.c  **** 					msgReq.size = 0;
 627:ServerLLDN.c  **** 					appState	= APP_STATE_IDLE;
 628:ServerLLDN.c  **** 					appPanState = APP_PAN_STATE_DISC_INITIAL;
 629:ServerLLDN.c  **** 					cycles_counter++;	
 630:ServerLLDN.c  **** 					
 631:ServerLLDN.c  **** 					break;
 632:ServerLLDN.c  **** 				}
 633:ServerLLDN.c  **** 				case APP_PAN_STATE_ONLINE_INITIAL:
 634:ServerLLDN.c  **** 				{
 635:ServerLLDN.c  **** 					appPanOnlineInit();
 636:ServerLLDN.c  **** 					break;
 637:ServerLLDN.c  **** 				}
 638:ServerLLDN.c  **** 				case APP_PAN_STATE_ONLINE_END_BE:
 639:ServerLLDN.c  **** 				{
 640:ServerLLDN.c  **** 					if(0)
 641:ServerLLDN.c  **** 					{
 642:ServerLLDN.c  **** 						// implementar as condies para entrar no processo de associao
 643:ServerLLDN.c  **** 					}
 644:ServerLLDN.c  **** 					else
 645:ServerLLDN.c  **** 					{
 646:ServerLLDN.c  **** 						// posso calcular esse valor no onlineinit, o tTS precisa ser recalculado, o seu valor muda n
 647:ServerLLDN.c  **** 						// pode voltar pro state_online_initial porque precisa reconfigurar os timers
 648:ServerLLDN.c  **** 						// precisa revisar o macsc_enable_manual_bts()
 649:ServerLLDN.c  **** 						int idle_time =  2 * numBaseTimeSlotperMgmt * (tTS) * 5 / (SYMBOL_TIME); // 5 is the total of
 650:ServerLLDN.c  **** 						macsc_set_cmp1_int_cb(lldn_server_beacon); // esta funo pode s mandar o beacon do online, 
 651:ServerLLDN.c  **** 						macsc_enable_manual_bts();
 652:ServerLLDN.c  **** 						macsc_enable_cmp_int(MACSC_CC1);
 653:ServerLLDN.c  **** 						macsc_use_cmp(MACSC_RELATIVE_CMP, idle_time, MACSC_CC1);
 654:ServerLLDN.c  **** 					}
 655:ServerLLDN.c  **** 					break;
 656:ServerLLDN.c  **** 				}
 657:ServerLLDN.c  **** 				case APP_PAN_STATE_IDLE:
 658:ServerLLDN.c  **** 				{
 659:ServerLLDN.c  **** 					msgReq.options = 0;
 660:ServerLLDN.c  **** 					appState = APP_STATE_IDLE;
 661:ServerLLDN.c  **** 					break;
 662:ServerLLDN.c  **** 				}
 663:ServerLLDN.c  **** 			}
 664:ServerLLDN.c  **** 			break;	
 665:ServerLLDN.c  **** 		}
 666:ServerLLDN.c  **** 		#else // NODES SPECIFIC STATE MACHINE
 667:ServerLLDN.c  **** 		case APP_STATE_PREP_DISC_REPONSE:
 668:ServerLLDN.c  **** 		{
 669:ServerLLDN.c  **** 			// desativar timer espera timeslot
 670:ServerLLDN.c  **** 			if(rec_beacon->confSeqNumber == 0)
 671:ServerLLDN.c  **** 			{
 672:ServerLLDN.c  **** 				appPrepareDiscoverResponse();
 673:ServerLLDN.c  **** 			}
 674:ServerLLDN.c  **** 			else msgReq.options = 0;
 675:ServerLLDN.c  **** 			appState = APP_STATE_IDLE;	
 676:ServerLLDN.c  **** 			break;
 677:ServerLLDN.c  **** 		}
 678:ServerLLDN.c  **** 		
 679:ServerLLDN.c  **** 		case APP_STATE_PREP_CONFIG_STATUS:
 680:ServerLLDN.c  **** 		{
 681:ServerLLDN.c  **** 			// se o nodo recebeu ack na fase do discovery prepara a mensagem de configuration status
 682:ServerLLDN.c  **** 			if(ack_received && rec_beacon->confSeqNumber == 0 && associated == 0) {
 683:ServerLLDN.c  **** 				appPrepareConfigurationStatus();
 684:ServerLLDN.c  **** 			}
 685:ServerLLDN.c  **** 			// se o nodo no recebeu desativa o timer e fica em idle
 686:ServerLLDN.c  **** 			else {
 687:ServerLLDN.c  **** 				macsc_disable_cmp_int(MACSC_CC1);
 688:ServerLLDN.c  **** 			}
 689:ServerLLDN.c  **** 			appState = APP_STATE_IDLE;
 690:ServerLLDN.c  **** 			break;
 691:ServerLLDN.c  **** 		}
 692:ServerLLDN.c  **** 		#endif
 693:ServerLLDN.c  **** 		default:
 694:ServerLLDN.c  **** 		{
 695:ServerLLDN.c  **** 			break;
 1286               		.loc 6 695 0
 1287 05de 00C0      		rjmp .L43
 1288               	.L39:
 485:ServerLLDN.c  **** 	switch (appState){
 1289               		.loc 6 485 0
 1290 05e0 8430      		cpi r24,4
 1291 05e2 9105      		cpc r25,__zero_reg__
 1292 05e4 01F0      		breq .L41
 1293 05e6 0597      		sbiw r24,5
 1294 05e8 01F0      		breq .L42
 1295               		.loc 6 695 0
 1296 05ea 00C0      		rjmp .L43
 1297               	.L40:
 488:ServerLLDN.c  **** 			#if APP_COORDINATOR
 1298               		.loc 6 488 0
 1299 05ec 0E94 0000 		call appInit
 492:ServerLLDN.c  **** 			#endif
 1300               		.loc 6 492 0
 1301 05f0 81E0      		ldi r24,lo8(1)
 1302 05f2 8093 0000 		sts appState,r24
 494:ServerLLDN.c  **** 		}
 1303               		.loc 6 494 0
 1304 05f6 00C0      		rjmp .L43
 1305               	.L38:
 498:ServerLLDN.c  **** 			#if APP_COORDINATOR
 1306               		.loc 6 498 0
 1307 05f8 0E94 0000 		call appSendData
 503:ServerLLDN.c  **** 			#endif
 1308               		.loc 6 503 0
 1309 05fc 81E0      		ldi r24,lo8(1)
 1310 05fe 8093 0000 		sts appState,r24
 505:ServerLLDN.c  **** 		}
 1311               		.loc 6 505 0
 1312 0602 00C0      		rjmp .L43
 1313               	.L41:
 670:ServerLLDN.c  **** 			{
 1314               		.loc 6 670 0
 1315 0604 8091 0000 		lds r24,rec_beacon
 1316 0608 9091 0000 		lds r25,rec_beacon+1
 1317 060c FC01      		movw r30,r24
 1318 060e 8581      		ldd r24,Z+5
 1319 0610 8823      		tst r24
 1320 0612 01F4      		brne .L44
 672:ServerLLDN.c  **** 			}
 1321               		.loc 6 672 0
 1322 0614 0E94 0000 		call appPrepareDiscoverResponse
 1323 0618 00C0      		rjmp .L45
 1324               	.L44:
 674:ServerLLDN.c  **** 			appState = APP_STATE_IDLE;	
 1325               		.loc 6 674 0
 1326 061a 1092 0000 		sts msgReq+9+1,__zero_reg__
 1327 061e 1092 0000 		sts msgReq+9,__zero_reg__
 1328               	.L45:
 675:ServerLLDN.c  **** 			break;
 1329               		.loc 6 675 0
 1330 0622 81E0      		ldi r24,lo8(1)
 1331 0624 8093 0000 		sts appState,r24
 676:ServerLLDN.c  **** 		}
 1332               		.loc 6 676 0
 1333 0628 00C0      		rjmp .L43
 1334               	.L42:
 682:ServerLLDN.c  **** 				appPrepareConfigurationStatus();
 1335               		.loc 6 682 0
 1336 062a 8091 0000 		lds r24,ack_received
 1337 062e 8823      		tst r24
 1338 0630 01F0      		breq .L46
 682:ServerLLDN.c  **** 				appPrepareConfigurationStatus();
 1339               		.loc 6 682 0 is_stmt 0 discriminator 1
 1340 0632 8091 0000 		lds r24,rec_beacon
 1341 0636 9091 0000 		lds r25,rec_beacon+1
 1342 063a FC01      		movw r30,r24
 1343 063c 8581      		ldd r24,Z+5
 1344 063e 8823      		tst r24
 1345 0640 01F4      		brne .L46
 682:ServerLLDN.c  **** 				appPrepareConfigurationStatus();
 1346               		.loc 6 682 0 discriminator 2
 1347 0642 9091 0000 		lds r25,associated
 1348 0646 81E0      		ldi r24,lo8(1)
 1349 0648 8927      		eor r24,r25
 1350 064a 8823      		tst r24
 1351 064c 01F0      		breq .L46
 683:ServerLLDN.c  **** 			}
 1352               		.loc 6 683 0 is_stmt 1
 1353 064e 0E94 0000 		call appPrepareConfigurationStatus
 1354 0652 00C0      		rjmp .L47
 1355               	.L46:
 687:ServerLLDN.c  **** 			}
 1356               		.loc 6 687 0
 1357 0654 81E0      		ldi r24,lo8(1)
 1358 0656 0E94 0000 		call macsc_disable_cmp_int
 1359               	.L47:
 689:ServerLLDN.c  **** 			break;
 1360               		.loc 6 689 0
 1361 065a 81E0      		ldi r24,lo8(1)
 1362 065c 8093 0000 		sts appState,r24
 690:ServerLLDN.c  **** 		}
 1363               		.loc 6 690 0
 1364 0660 0000      		nop
 1365               	.L43:
 696:ServerLLDN.c  **** 		}
 697:ServerLLDN.c  **** 	}
 698:ServerLLDN.c  **** }
 1366               		.loc 6 698 0
 1367 0662 0000      		nop
 1368               	/* epilogue start */
 1369 0664 DF91      		pop r29
 1370 0666 CF91      		pop r28
 1371 0668 0895      		ret
 1372               		.cfi_endproc
 1373               	.LFE138:
 1375               		.section	.rodata
 1376               	.LC0:
 1377 0014 00        		.byte	0
 1378 0015 C2        		.byte	-62
 1379 0016 01        		.byte	1
 1380 0017 00        		.byte	0
 1381 0018 03        		.byte	3
 1382 0019 00        		.byte	0
 1383 001a 00        		.byte	0
 1384               		.text
 1385               	.global	main
 1387               	main:
 1388               	.LFB139:
 699:ServerLLDN.c  **** 
 700:ServerLLDN.c  **** 	/*****************************************************************************
 701:ServerLLDN.c  **** 	*****************************************************************************/
 702:ServerLLDN.c  **** 	int main(void)
 703:ServerLLDN.c  **** 	{
 1389               		.loc 6 703 0
 1390               		.cfi_startproc
 1391 066a 0F93      		push r16
 1392               	.LCFI59:
 1393               		.cfi_def_cfa_offset 3
 1394               		.cfi_offset 16, -2
 1395 066c 1F93      		push r17
 1396               	.LCFI60:
 1397               		.cfi_def_cfa_offset 4
 1398               		.cfi_offset 17, -3
 1399 066e CF93      		push r28
 1400               	.LCFI61:
 1401               		.cfi_def_cfa_offset 5
 1402               		.cfi_offset 28, -4
 1403 0670 DF93      		push r29
 1404               	.LCFI62:
 1405               		.cfi_def_cfa_offset 6
 1406               		.cfi_offset 29, -5
 1407 0672 CDB7      		in r28,__SP_L__
 1408 0674 DEB7      		in r29,__SP_H__
 1409               	.LCFI63:
 1410               		.cfi_def_cfa_register 28
 1411 0676 2797      		sbiw r28,7
 1412               	.LCFI64:
 1413               		.cfi_def_cfa_offset 13
 1414 0678 0FB6      		in __tmp_reg__,__SREG__
 1415 067a F894      		cli
 1416 067c DEBF      		out __SP_H__,r29
 1417 067e 0FBE      		out __SREG__,__tmp_reg__
 1418 0680 CDBF      		out __SP_L__,r28
 1419               	/* prologue: function */
 1420               	/* frame size = 7 */
 1421               	/* stack size = 11 */
 1422               	.L__stack_usage = 11
 704:ServerLLDN.c  **** 		sysclk_init();
 1423               		.loc 6 704 0
 1424 0682 0E94 0000 		call sysclk_init
 705:ServerLLDN.c  **** 		board_init();
 1425               		.loc 6 705 0
 1426 0686 0E94 0000 		call board_init
 706:ServerLLDN.c  **** 
 707:ServerLLDN.c  **** 		SYS_Init();
 1427               		.loc 6 707 0
 1428 068a 0E94 0000 		call SYS_Init
 708:ServerLLDN.c  **** 		/* Disable CSMA/CA
 709:ServerLLDN.c  **** 		 * Disable auto ACK
 710:ServerLLDN.c  **** 		 * Enable Rx of LLDN Frame Type as described in 802.15.4e - 2012 
 711:ServerLLDN.c  **** 		 */
 712:ServerLLDN.c  **** 
 713:ServerLLDN.c  **** 		sm_init();
 1429               		.loc 6 713 0
 1430 068e 0E94 0000 		call sm_init
 714:ServerLLDN.c  **** 
 715:ServerLLDN.c  **** 		// Initialize interrupt vector table support.
 716:ServerLLDN.c  **** 	#if (SIO2HOST_CHANNEL == SIO_USB)
 717:ServerLLDN.c  **** 		irq_initialize_vectors();
 718:ServerLLDN.c  **** 	#endif
 719:ServerLLDN.c  **** 		cpu_irq_enable();
 1431               		.loc 6 719 0
 1432               	/* #APP */
 1433               	 ;  719 "ServerLLDN.c" 1
 1434 0692 7894      		sei
 1435               	 ;  0 "" 2
 720:ServerLLDN.c  **** 
 721:ServerLLDN.c  **** 	#if 1
 722:ServerLLDN.c  **** 	#if (SIO2HOST_CHANNEL == SIO_USB)
 723:ServerLLDN.c  **** 		stdio_usb_init();
 724:ServerLLDN.c  **** 	#else
 725:ServerLLDN.c  **** 		const usart_serial_options_t usart_serial_options =
 1436               		.loc 6 725 0
 1437               	/* #NOAPP */
 1438 0694 27E0      		ldi r18,lo8(7)
 1439 0696 E0E0      		ldi r30,lo8(.LC0)
 1440 0698 F0E0      		ldi r31,hi8(.LC0)
 1441 069a CE01      		movw r24,r28
 1442 069c 0196      		adiw r24,1
 1443 069e DC01      		movw r26,r24
 1444               		0:
 1445 06a0 0190      		ld r0,Z+
 1446 06a2 0D92      		st X+,r0
 1447 06a4 2A95      		dec r18
 1448 06a6 01F4      		brne 0b
 726:ServerLLDN.c  **** 		{
 727:ServerLLDN.c  **** 			.baudrate     = USART_HOST_BAUDRATE,
 728:ServerLLDN.c  **** 			.charlength   = USART_HOST_CHAR_LENGTH,
 729:ServerLLDN.c  **** 			.paritytype   = USART_HOST_PARITY,
 730:ServerLLDN.c  **** 			.stopbits     = USART_HOST_STOP_BITS
 731:ServerLLDN.c  **** 		};
 732:ServerLLDN.c  **** 
 733:ServerLLDN.c  **** 		stdio_serial_init(USART_HOST, &usart_serial_options);
 1449               		.loc 6 733 0
 1450 06a8 CE01      		movw r24,r28
 1451 06aa 0196      		adiw r24,1
 1452 06ac BC01      		movw r22,r24
 1453 06ae 80EC      		ldi r24,lo8(-64)
 1454 06b0 90E0      		ldi r25,0
 1455 06b2 0E94 0000 		call stdio_serial_init
 734:ServerLLDN.c  **** 		usart_double_baud_enable(USART_HOST);
 1456               		.loc 6 734 0
 1457 06b6 80EC      		ldi r24,lo8(-64)
 1458 06b8 90E0      		ldi r25,0
 1459 06ba 0E94 0000 		call usart_double_baud_enable
 735:ServerLLDN.c  **** 		usart_set_baudrate_precalculated(USART_HOST, USART_HOST_BAUDRATE, sysclk_get_source_clock_hz());
 1460               		.loc 6 735 0
 1461 06be 0E94 0000 		call sysclk_get_source_clock_hz
 1462 06c2 DC01      		movw r26,r24
 1463 06c4 CB01      		movw r24,r22
 1464 06c6 8C01      		movw r16,r24
 1465 06c8 9D01      		movw r18,r26
 1466 06ca 40E0      		ldi r20,0
 1467 06cc 52EC      		ldi r21,lo8(-62)
 1468 06ce 61E0      		ldi r22,lo8(1)
 1469 06d0 70E0      		ldi r23,0
 1470 06d2 80EC      		ldi r24,lo8(-64)
 1471 06d4 90E0      		ldi r25,0
 1472 06d6 0E94 0000 		call usart_set_baudrate_precalculated
 1473               	.L49:
 736:ServerLLDN.c  **** 
 737:ServerLLDN.c  **** 	#endif
 738:ServerLLDN.c  **** 	#endif
 739:ServerLLDN.c  **** 		for(;;)
 740:ServerLLDN.c  **** 		{
 741:ServerLLDN.c  **** 			SYS_TaskHandler();
 1474               		.loc 6 741 0 discriminator 1
 1475 06da 0E94 0000 		call SYS_TaskHandler
 742:ServerLLDN.c  **** 			APP_TaskHandler();
 1476               		.loc 6 742 0 discriminator 1
 1477 06de 0E94 0000 		call APP_TaskHandler
 743:ServerLLDN.c  **** 		}
 1478               		.loc 6 743 0 discriminator 1
 1479 06e2 00C0      		rjmp .L49
 1480               		.cfi_endproc
 1481               	.LFE139:
 1483               	.Letext0:
 1484               		.file 7 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\in
 1485               		.file 8 "../../../stack/LwMesh/TDMA/nwk/inc/nwkFrame.h"
 1486               		.file 9 "../../../stack/LwMesh/TDMA/nwk/inc/nwkRx.h"
 1487               		.file 10 "../../../stack/LwMesh/TDMA/nwk/inc/nwkDataReq.h"
 1488               		.file 11 "../../../platform/mega_rf/drivers/sleep/sleep.h"
 1489               		.file 12 "lldn.h"
 1490               		.file 13 "../../../platform/mega_rf/utils/status_codes.h"
 1491               		.file 14 "config/config.h"
 1492               		.file 15 "../../../platform/common/services/sleepmgr/mega_rf/sleepmgr.h"
DEFINED SYMBOLS
                            *ABS*:00000000 ServerLLDN.c
C:\Users\GUILHE~1\AppData\Local\Temp\ccKDSeWN.s:2      *ABS*:0000003e __SP_H__
C:\Users\GUILHE~1\AppData\Local\Temp\ccKDSeWN.s:3      *ABS*:0000003d __SP_L__
C:\Users\GUILHE~1\AppData\Local\Temp\ccKDSeWN.s:4      *ABS*:0000003f __SREG__
C:\Users\GUILHE~1\AppData\Local\Temp\ccKDSeWN.s:5      *ABS*:0000003b __RAMPZ__
C:\Users\GUILHE~1\AppData\Local\Temp\ccKDSeWN.s:6      *ABS*:00000000 __tmp_reg__
C:\Users\GUILHE~1\AppData\Local\Temp\ccKDSeWN.s:7      *ABS*:00000001 __zero_reg__
C:\Users\GUILHE~1\AppData\Local\Temp\ccKDSeWN.s:15     .bss.n:00000000 n
C:\Users\GUILHE~1\AppData\Local\Temp\ccKDSeWN.s:20     .bss.tTS:00000000 tTS
C:\Users\GUILHE~1\AppData\Local\Temp\ccKDSeWN.s:24     .text:00000000 sysclk_get_main_hz
C:\Users\GUILHE~1\AppData\Local\Temp\ccKDSeWN.s:61     .text:0000001a sysclk_get_source_clock_hz
C:\Users\GUILHE~1\AppData\Local\Temp\ccKDSeWN.s:98     .progmem.data.baudctrl_1mhz:00000000 baudctrl_1mhz
C:\Users\GUILHE~1\AppData\Local\Temp\ccKDSeWN.s:110    .progmem.data.baudctrl_8mhz:00000000 baudctrl_8mhz
C:\Users\GUILHE~1\AppData\Local\Temp\ccKDSeWN.s:122    .progmem.data.baudctrl_16mhz:00000000 baudctrl_16mhz
C:\Users\GUILHE~1\AppData\Local\Temp\ccKDSeWN.s:133    .text:00000034 usart_double_baud_enable
C:\Users\GUILHE~1\AppData\Local\Temp\ccKDSeWN.s:182    .text:00000062 usart_serial_init
C:\Users\GUILHE~1\AppData\Local\Temp\ccKDSeWN.s:277    .text:000000de usart_serial_putchar
C:\Users\GUILHE~1\AppData\Local\Temp\ccKDSeWN.s:321    .text:00000106 usart_serial_getchar
C:\Users\GUILHE~1\AppData\Local\Temp\ccKDSeWN.s:372    .text:0000013c stdio_serial_init
C:\Users\GUILHE~1\AppData\Local\Temp\ccKDSeWN.s:443    .text:0000019e macsc_enable_manual_bts
C:\Users\GUILHE~1\AppData\Local\Temp\ccKDSeWN.s:497    .bss.appState:00000000 appState
C:\Users\GUILHE~1\AppData\Local\Temp\ccKDSeWN.s:502    .bss.msgReq:00000000 msgReq
C:\Users\GUILHE~1\AppData\Local\Temp\ccKDSeWN.s:507    .bss.PanId:00000000 PanId
C:\Users\GUILHE~1\AppData\Local\Temp\ccKDSeWN.s:511    .text:000001d2 appSendData
C:\Users\GUILHE~1\AppData\Local\Temp\ccKDSeWN.s:554    .bss.rec_beacon:00000000 rec_beacon
C:\Users\GUILHE~1\AppData\Local\Temp\ccKDSeWN.s:559    .bss.msgConfigStatus:00000000 msgConfigStatus
C:\Users\GUILHE~1\AppData\Local\Temp\ccKDSeWN.s:564    .bss.msgDiscResponse:00000000 msgDiscResponse
C:\Users\GUILHE~1\AppData\Local\Temp\ccKDSeWN.s:569    .data.payloadSize:00000000 payloadSize
C:\Users\GUILHE~1\AppData\Local\Temp\ccKDSeWN.s:575    .data.assTimeSlot:00000000 assTimeSlot
C:\Users\GUILHE~1\AppData\Local\Temp\ccKDSeWN.s:580    .bss.ack_received:00000000 ack_received
C:\Users\GUILHE~1\AppData\Local\Temp\ccKDSeWN.s:586    .bss.MacLLDNMgmtTS:00000000 MacLLDNMgmtTS
C:\Users\GUILHE~1\AppData\Local\Temp\ccKDSeWN.s:592    .bss.associated:00000000 associated
C:\Users\GUILHE~1\AppData\Local\Temp\ccKDSeWN.s:596    .text:000001f6 send_message_timeHandler
C:\Users\GUILHE~1\AppData\Local\Temp\ccKDSeWN.s:633    .text:0000020c appBeaconInd
C:\Users\GUILHE~1\AppData\Local\Temp\ccKDSeWN.s:827    .text:00000354 appAckInd
C:\Users\GUILHE~1\AppData\Local\Temp\ccKDSeWN.s:939    .text:000003f0 appCommandInd
C:\Users\GUILHE~1\AppData\Local\Temp\ccKDSeWN.s:1037   .text:00000474 appPrepareDiscoverResponse
C:\Users\GUILHE~1\AppData\Local\Temp\ccKDSeWN.s:1110   .text:000004e6 appPrepareConfigurationStatus
C:\Users\GUILHE~1\AppData\Local\Temp\ccKDSeWN.s:1188   .text:00000566 appInit
C:\Users\GUILHE~1\AppData\Local\Temp\ccKDSeWN.s:1254   .text:000005be APP_TaskHandler
C:\Users\GUILHE~1\AppData\Local\Temp\ccKDSeWN.s:1387   .text:0000066a main

UNDEFINED SYMBOLS
usart_init_rs232
usart_putchar
usart_getchar
stdio_base
ptr_put
ptr_get
_read
_write
fdevopen
NWK_DataReq
macsc_set_cmp1_int_cb
macsc_enable_cmp_int
macsc_use_cmp
printf
PHY_SetChannel
NWK_SetPanId
NWK_SetAddr
PHY_SetRxState
PHY_SetTdmaMode
PHY_SetOptimizedCSMAValues
NWK_OpenEndpoint
PHY_SetPromiscuousMode
macsc_disable_cmp_int
sysclk_init
board_init
SYS_Init
sm_init
usart_set_baudrate_precalculated
SYS_TaskHandler
__do_copy_data
__do_clear_bss
