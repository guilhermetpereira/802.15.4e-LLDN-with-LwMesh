   1               		.file	"ServerLLDN.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__RAMPZ__ = 0x3b
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.text
   9               	.Ltext0:
  10               		.cfi_sections	.debug_frame
  11               	.global	n
  12               		.section	.bss.n,"aw",@nobits
  15               	n:
  16 0000 00        		.zero	1
  17               		.comm	tTS,4,1
  18               		.comm	macLLDNnumTimeSlots,2,1
  19               		.comm	macLLDNnumUplinkTS,2,1
  20               		.comm	macLLDNRetransmitTS,2,1
  21               		.text
  23               	sysclk_get_main_hz:
  24               	.LFB67:
  25               		.file 1 "../../../platform/common/services/clock/mega/sysclk.h"
   1:../../../platform/common/services/clock/mega/sysclk.h **** /**
   2:../../../platform/common/services/clock/mega/sysclk.h ****  * \file
   3:../../../platform/common/services/clock/mega/sysclk.h ****  *
   4:../../../platform/common/services/clock/mega/sysclk.h ****  * \brief Chip-specific system clock management functions
   5:../../../platform/common/services/clock/mega/sysclk.h ****  *
   6:../../../platform/common/services/clock/mega/sysclk.h ****  * Copyright (c) 2012 Atmel Corporation. All rights reserved.
   7:../../../platform/common/services/clock/mega/sysclk.h ****  *
   8:../../../platform/common/services/clock/mega/sysclk.h ****  * \asf_license_start
   9:../../../platform/common/services/clock/mega/sysclk.h ****  *
  10:../../../platform/common/services/clock/mega/sysclk.h ****  * \page License
  11:../../../platform/common/services/clock/mega/sysclk.h ****  *
  12:../../../platform/common/services/clock/mega/sysclk.h ****  * Redistribution and use in source and binary forms, with or without
  13:../../../platform/common/services/clock/mega/sysclk.h ****  * modification, are permitted provided that the following conditions are met:
  14:../../../platform/common/services/clock/mega/sysclk.h ****  *
  15:../../../platform/common/services/clock/mega/sysclk.h ****  * 1. Redistributions of source code must retain the above copyright notice,
  16:../../../platform/common/services/clock/mega/sysclk.h ****  *    this list of conditions and the following disclaimer.
  17:../../../platform/common/services/clock/mega/sysclk.h ****  *
  18:../../../platform/common/services/clock/mega/sysclk.h ****  * 2. Redistributions in binary form must reproduce the above copyright notice,
  19:../../../platform/common/services/clock/mega/sysclk.h ****  *    this list of conditions and the following disclaimer in the documentation
  20:../../../platform/common/services/clock/mega/sysclk.h ****  *    and/or other materials provided with the distribution.
  21:../../../platform/common/services/clock/mega/sysclk.h ****  *
  22:../../../platform/common/services/clock/mega/sysclk.h ****  * 3. The name of Atmel may not be used to endorse or promote products derived
  23:../../../platform/common/services/clock/mega/sysclk.h ****  *    from this software without specific prior written permission.
  24:../../../platform/common/services/clock/mega/sysclk.h ****  *
  25:../../../platform/common/services/clock/mega/sysclk.h ****  * 4. This software may only be redistributed and used in connection with an
  26:../../../platform/common/services/clock/mega/sysclk.h ****  *    Atmel microcontroller product.
  27:../../../platform/common/services/clock/mega/sysclk.h ****  *
  28:../../../platform/common/services/clock/mega/sysclk.h ****  * THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR IMPLIED
  29:../../../platform/common/services/clock/mega/sysclk.h ****  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
  30:../../../platform/common/services/clock/mega/sysclk.h ****  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
  31:../../../platform/common/services/clock/mega/sysclk.h ****  * EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR
  32:../../../platform/common/services/clock/mega/sysclk.h ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  33:../../../platform/common/services/clock/mega/sysclk.h ****  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
  34:../../../platform/common/services/clock/mega/sysclk.h ****  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  35:../../../platform/common/services/clock/mega/sysclk.h ****  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
  36:../../../platform/common/services/clock/mega/sysclk.h ****  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  37:../../../platform/common/services/clock/mega/sysclk.h ****  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  38:../../../platform/common/services/clock/mega/sysclk.h ****  * POSSIBILITY OF SUCH DAMAGE.
  39:../../../platform/common/services/clock/mega/sysclk.h ****  *
  40:../../../platform/common/services/clock/mega/sysclk.h ****  * \asf_license_stop
  41:../../../platform/common/services/clock/mega/sysclk.h ****  *
  42:../../../platform/common/services/clock/mega/sysclk.h ****  */
  43:../../../platform/common/services/clock/mega/sysclk.h **** #ifndef MEGA_SYSCLK_H_INCLUDED
  44:../../../platform/common/services/clock/mega/sysclk.h **** #define MEGA_SYSCLK_H_INCLUDED
  45:../../../platform/common/services/clock/mega/sysclk.h **** 
  46:../../../platform/common/services/clock/mega/sysclk.h **** #include <board.h>
  47:../../../platform/common/services/clock/mega/sysclk.h **** #include <compiler.h>
  48:../../../platform/common/services/clock/mega/sysclk.h **** #include <parts.h>
  49:../../../platform/common/services/clock/mega/sysclk.h **** 
  50:../../../platform/common/services/clock/mega/sysclk.h **** /* Include clock configuration for the project. */
  51:../../../platform/common/services/clock/mega/sysclk.h **** #include <conf_clock.h>
  52:../../../platform/common/services/clock/mega/sysclk.h **** 
  53:../../../platform/common/services/clock/mega/sysclk.h **** #ifdef __cplusplus
  54:../../../platform/common/services/clock/mega/sysclk.h **** extern "C" {
  55:../../../platform/common/services/clock/mega/sysclk.h **** #endif
  56:../../../platform/common/services/clock/mega/sysclk.h **** #define ASM __asm__
  57:../../../platform/common/services/clock/mega/sysclk.h **** 
  58:../../../platform/common/services/clock/mega/sysclk.h **** /* CONFIG_SYSCLK_PSDIV  to use default if not defined*/
  59:../../../platform/common/services/clock/mega/sysclk.h **** #ifndef CONFIG_SYSCLK_PSDIV
  60:../../../platform/common/services/clock/mega/sysclk.h **** # define CONFIG_SYSCLK_PSDIV    SYSCLK_PSDIV_8
  61:../../../platform/common/services/clock/mega/sysclk.h **** #endif
  62:../../../platform/common/services/clock/mega/sysclk.h **** 
  63:../../../platform/common/services/clock/mega/sysclk.h **** /* ! \name Prescaler Setting (relative to CLKsys) */
  64:../../../platform/common/services/clock/mega/sysclk.h **** /* @{ */
  65:../../../platform/common/services/clock/mega/sysclk.h **** #define SYSCLK_PSDIV_1      0   /* !< Do not prescale */
  66:../../../platform/common/services/clock/mega/sysclk.h **** #define SYSCLK_PSDIV_2      1   /* !< Prescale CLKper4 by 2 */
  67:../../../platform/common/services/clock/mega/sysclk.h **** #define SYSCLK_PSDIV_4      2   /* !< Prescale CLKper4 by 4 */
  68:../../../platform/common/services/clock/mega/sysclk.h **** #define SYSCLK_PSDIV_8      3   /* !< Prescale CLKper4 by 8 */
  69:../../../platform/common/services/clock/mega/sysclk.h **** #define SYSCLK_PSDIV_16     4   /* !< Prescale CLKper4 by 16 */
  70:../../../platform/common/services/clock/mega/sysclk.h **** #define SYSCLK_PSDIV_32     5   /* !< Prescale CLKper4 by 32 */
  71:../../../platform/common/services/clock/mega/sysclk.h **** #define SYSCLK_PSDIV_64     6   /* !< Prescale CLKper4 by 64 */
  72:../../../platform/common/services/clock/mega/sysclk.h **** #define SYSCLK_PSDIV_128    7   /* !< Prescale CLKper4 by 128 */
  73:../../../platform/common/services/clock/mega/sysclk.h **** #define SYSCLK_PSDIV_256    8   /* !< Prescale CLKper4 by 256 */
  74:../../../platform/common/services/clock/mega/sysclk.h **** 
  75:../../../platform/common/services/clock/mega/sysclk.h **** /* @} */
  76:../../../platform/common/services/clock/mega/sysclk.h **** 
  77:../../../platform/common/services/clock/mega/sysclk.h **** #if MEGA_RF || MEGA_XX0_1 || MEGA_XX4 || MEGA_XX4_A
  78:../../../platform/common/services/clock/mega/sysclk.h **** 
  79:../../../platform/common/services/clock/mega/sysclk.h **** #define NUMBER_OF_POWER_REG       2
  80:../../../platform/common/services/clock/mega/sysclk.h **** /*Starting Address for power reduction*/
  81:../../../platform/common/services/clock/mega/sysclk.h **** #define POWER_REG_ADD             PRR0
  82:../../../platform/common/services/clock/mega/sysclk.h **** 
  83:../../../platform/common/services/clock/mega/sysclk.h **** /* ! \name Power Reduction  Clock Port Numbers */
  84:../../../platform/common/services/clock/mega/sysclk.h **** enum power_red_id {
  85:../../../platform/common/services/clock/mega/sysclk.h **** 	POWER_RED_REG0,     /* !< Devices on PRR0 */
  86:../../../platform/common/services/clock/mega/sysclk.h **** #if !MEGA_XX4 || !MEGA_XX4_A || MEGA_XX0_1
  87:../../../platform/common/services/clock/mega/sysclk.h **** 	POWER_RED_REG1,     /* !< Devices on PRR1 */
  88:../../../platform/common/services/clock/mega/sysclk.h **** #endif
  89:../../../platform/common/services/clock/mega/sysclk.h **** };
  90:../../../platform/common/services/clock/mega/sysclk.h **** #endif
  91:../../../platform/common/services/clock/mega/sysclk.h **** 
  92:../../../platform/common/services/clock/mega/sysclk.h **** /****************************************************
  93:../../../platform/common/services/clock/mega/sysclk.h ****  * Given a dummy type but not used for these groups
  94:../../../platform/common/services/clock/mega/sysclk.h ****  * to support for otherthen megaRF device.
  95:../../../platform/common/services/clock/mega/sysclk.h ****  **************************************************/
  96:../../../platform/common/services/clock/mega/sysclk.h **** #if MEGA_XX8 || MEGA_XX8_A || MEGA_UNSPECIFIED
  97:../../../platform/common/services/clock/mega/sysclk.h **** #define NUMBER_OF_POWER_REG       1
  98:../../../platform/common/services/clock/mega/sysclk.h **** /*Starting Address for power reduction*/
  99:../../../platform/common/services/clock/mega/sysclk.h **** #define POWER_REG_ADD             PRR
 100:../../../platform/common/services/clock/mega/sysclk.h **** 
 101:../../../platform/common/services/clock/mega/sysclk.h **** /* ! \name Power Reduction  Clock Port Numbers */
 102:../../../platform/common/services/clock/mega/sysclk.h **** enum power_red_id {
 103:../../../platform/common/services/clock/mega/sysclk.h **** 	POWER_RED_REG0,     /* !< Devices on PRR */
 104:../../../platform/common/services/clock/mega/sysclk.h **** };
 105:../../../platform/common/services/clock/mega/sysclk.h **** #endif
 106:../../../platform/common/services/clock/mega/sysclk.h **** 
 107:../../../platform/common/services/clock/mega/sysclk.h **** /* Bit mask for the power reduction register based on */
 108:../../../platform/common/services/clock/mega/sysclk.h **** /*   MCU ARCH.                                        */
 109:../../../platform/common/services/clock/mega/sysclk.h **** #if MEGA_RF
 110:../../../platform/common/services/clock/mega/sysclk.h **** /*Bit mask for PRR2 */
 111:../../../platform/common/services/clock/mega/sysclk.h **** 
 112:../../../platform/common/services/clock/mega/sysclk.h **** #define PRRAM0_bm                       1 << PRRAM0
 113:../../../platform/common/services/clock/mega/sysclk.h **** #define PRRAM1_bm                       1 << PRRAM1
 114:../../../platform/common/services/clock/mega/sysclk.h **** #define PRRAM2_bm                       1 << PRRAM2
 115:../../../platform/common/services/clock/mega/sysclk.h **** #define PRRAM3_bm                       1 << PRRAM3
 116:../../../platform/common/services/clock/mega/sysclk.h **** #endif
 117:../../../platform/common/services/clock/mega/sysclk.h **** 
 118:../../../platform/common/services/clock/mega/sysclk.h **** /*Bit mask for the power reduction 0 or PRR*/
 119:../../../platform/common/services/clock/mega/sysclk.h **** #if !MEGA_XX_UN0 && !MEGA_XX_UN0
 120:../../../platform/common/services/clock/mega/sysclk.h **** #define PRADC_bm                        1 << PRADC
 121:../../../platform/common/services/clock/mega/sysclk.h **** #define PRUSART0_bm                     1 << PRUSART0
 122:../../../platform/common/services/clock/mega/sysclk.h **** #define PRSPI_bm                        1 << PRSPI
 123:../../../platform/common/services/clock/mega/sysclk.h **** #define PRTIM1_bm                       1 << PRTIM1
 124:../../../platform/common/services/clock/mega/sysclk.h **** #endif
 125:../../../platform/common/services/clock/mega/sysclk.h **** 
 126:../../../platform/common/services/clock/mega/sysclk.h **** #if MEGA_RF
 127:../../../platform/common/services/clock/mega/sysclk.h **** #define PRPGA_bm                        1 << PRPGA
 128:../../../platform/common/services/clock/mega/sysclk.h **** #endif
 129:../../../platform/common/services/clock/mega/sysclk.h **** 
 130:../../../platform/common/services/clock/mega/sysclk.h **** #if !MEGA_UNSPECIFIED
 131:../../../platform/common/services/clock/mega/sysclk.h **** #define PRTIM0_bm                       1 << PRTIM0
 132:../../../platform/common/services/clock/mega/sysclk.h **** #define PRTIM2_bm                       1 << PRTIM2
 133:../../../platform/common/services/clock/mega/sysclk.h **** #define PRTWI_bm                        1 << PRTWI
 134:../../../platform/common/services/clock/mega/sysclk.h **** #endif
 135:../../../platform/common/services/clock/mega/sysclk.h **** 
 136:../../../platform/common/services/clock/mega/sysclk.h **** #if MEGA_XX_UN2
 137:../../../platform/common/services/clock/mega/sysclk.h **** #define PRLCD_bm                        1 << PRLCD
 138:../../../platform/common/services/clock/mega/sysclk.h **** #endif
 139:../../../platform/common/services/clock/mega/sysclk.h **** 
 140:../../../platform/common/services/clock/mega/sysclk.h **** /*Bit mask for  PRR1  */
 141:../../../platform/common/services/clock/mega/sysclk.h **** #ifdef PRR1
 142:../../../platform/common/services/clock/mega/sysclk.h **** #if (MEGA_XX4 || MEGA_XX4_A)
 143:../../../platform/common/services/clock/mega/sysclk.h **** #define PRTIM3_bm                       1 << PRTIM3
 144:../../../platform/common/services/clock/mega/sysclk.h **** #endif
 145:../../../platform/common/services/clock/mega/sysclk.h **** #endif
 146:../../../platform/common/services/clock/mega/sysclk.h **** 
 147:../../../platform/common/services/clock/mega/sysclk.h **** #if MEGA_RF || MEGA_XX4 || MEGA_XX4_A
 148:../../../platform/common/services/clock/mega/sysclk.h **** #define PRUSART1_bm                     1 << PRUSART1
 149:../../../platform/common/services/clock/mega/sysclk.h **** #define PRUSART2_bm                     1 << PRUSART2
 150:../../../platform/common/services/clock/mega/sysclk.h **** #define PRUSART3_bm                     1 << PRUSART3
 151:../../../platform/common/services/clock/mega/sysclk.h **** #define PRTIM3_bm                       1 << PRTIM3
 152:../../../platform/common/services/clock/mega/sysclk.h **** #define PRTIM4_bm                       1 << PRTIM4
 153:../../../platform/common/services/clock/mega/sysclk.h **** #define PRTIM5_bm                       1 << PRTIM5
 154:../../../platform/common/services/clock/mega/sysclk.h **** #endif
 155:../../../platform/common/services/clock/mega/sysclk.h **** 
 156:../../../platform/common/services/clock/mega/sysclk.h **** #if MEGA_RF
 157:../../../platform/common/services/clock/mega/sysclk.h **** #define PRTRX24_bm                      1 << PRTRX24
 158:../../../platform/common/services/clock/mega/sysclk.h **** #endif
 159:../../../platform/common/services/clock/mega/sysclk.h **** 
 160:../../../platform/common/services/clock/mega/sysclk.h **** /**
 161:../../../platform/common/services/clock/mega/sysclk.h ****  * \name Querying the system clock and its derived clocks
 162:../../../platform/common/services/clock/mega/sysclk.h ****  */
 163:../../../platform/common/services/clock/mega/sysclk.h **** /* @{ */
 164:../../../platform/common/services/clock/mega/sysclk.h **** 
 165:../../../platform/common/services/clock/mega/sysclk.h **** /**
 166:../../../platform/common/services/clock/mega/sysclk.h ****  * \brief Return the current rate in Hz of the main system clock
 167:../../../platform/common/services/clock/mega/sysclk.h ****  * To know the clock value at what frequency the main clock is running
 168:../../../platform/common/services/clock/mega/sysclk.h ****  * \return Frequency of the main system clock, in Hz.
 169:../../../platform/common/services/clock/mega/sysclk.h ****  * \todo : please initialize the SYSCLK_SOURCE in conf_clock.h file for
 170:../../../platform/common/services/clock/mega/sysclk.h ****  * configured source clock using fuses.
 171:../../../platform/common/services/clock/mega/sysclk.h ****  * \eg. #define SYSCLK_SOURCE SYSCLK_SRC_RC16MHZ to use internal RC
 172:../../../platform/common/services/clock/mega/sysclk.h ****  * oscillator for clock source.
 173:../../../platform/common/services/clock/mega/sysclk.h ****  */
 174:../../../platform/common/services/clock/mega/sysclk.h **** static inline uint32_t sysclk_get_main_hz(void)
 175:../../../platform/common/services/clock/mega/sysclk.h **** {
  26               		.loc 1 175 0
  27               		.cfi_startproc
  28 0000 CF93      		push r28
  29               	.LCFI0:
  30               		.cfi_def_cfa_offset 3
  31               		.cfi_offset 28, -2
  32 0002 DF93      		push r29
  33               	.LCFI1:
  34               		.cfi_def_cfa_offset 4
  35               		.cfi_offset 29, -3
  36 0004 CDB7      		in r28,__SP_L__
  37 0006 DEB7      		in r29,__SP_H__
  38               	.LCFI2:
  39               		.cfi_def_cfa_register 28
  40               	/* prologue: function */
  41               	/* frame size = 0 */
  42               	/* stack size = 2 */
  43               	.L__stack_usage = 2
 176:../../../platform/common/services/clock/mega/sysclk.h **** 	switch (SYSCLK_SOURCE) {
 177:../../../platform/common/services/clock/mega/sysclk.h **** 	case SYSCLK_SRC_RC16MHZ:
 178:../../../platform/common/services/clock/mega/sysclk.h **** 		return 16000000UL;
 179:../../../platform/common/services/clock/mega/sysclk.h **** 
 180:../../../platform/common/services/clock/mega/sysclk.h **** 	case SYSCLK_SRC_RC128KHZ:
 181:../../../platform/common/services/clock/mega/sysclk.h **** 		return 128000UL;
 182:../../../platform/common/services/clock/mega/sysclk.h **** 
 183:../../../platform/common/services/clock/mega/sysclk.h **** #if MEGA_RF
 184:../../../platform/common/services/clock/mega/sysclk.h **** 	case SYSCLK_SRC_TRS16MHZ:
 185:../../../platform/common/services/clock/mega/sysclk.h **** 		return 16000000UL;
  44               		.loc 1 185 0
  45 0008 80E0      		ldi r24,0
  46 000a 94E2      		ldi r25,lo8(36)
  47 000c A4EF      		ldi r26,lo8(-12)
  48 000e B0E0      		ldi r27,0
 186:../../../platform/common/services/clock/mega/sysclk.h **** #endif
 187:../../../platform/common/services/clock/mega/sysclk.h **** #ifdef BOARD_EXTERNAL_CLK
 188:../../../platform/common/services/clock/mega/sysclk.h **** 	case SYSCLK_SRC_EXTERNAL:
 189:../../../platform/common/services/clock/mega/sysclk.h **** 		return BOARD_EXTERNAL_CLK;
 190:../../../platform/common/services/clock/mega/sysclk.h **** #endif
 191:../../../platform/common/services/clock/mega/sysclk.h **** 	default:
 192:../../../platform/common/services/clock/mega/sysclk.h **** 
 193:../../../platform/common/services/clock/mega/sysclk.h **** 		return 1000000UL;
 194:../../../platform/common/services/clock/mega/sysclk.h **** 	}
 195:../../../platform/common/services/clock/mega/sysclk.h **** }
  49               		.loc 1 195 0
  50 0010 BC01      		movw r22,r24
  51 0012 CD01      		movw r24,r26
  52               	/* epilogue start */
  53 0014 DF91      		pop r29
  54 0016 CF91      		pop r28
  55 0018 0895      		ret
  56               		.cfi_endproc
  57               	.LFE67:
  60               	sysclk_get_source_clock_hz:
  61               	.LFB68:
 196:../../../platform/common/services/clock/mega/sysclk.h **** 
 197:../../../platform/common/services/clock/mega/sysclk.h **** /**
 198:../../../platform/common/services/clock/mega/sysclk.h ****  * \brief Return the current rate in Hz of source clock in Hz.
 199:../../../platform/common/services/clock/mega/sysclk.h ****  *
 200:../../../platform/common/services/clock/mega/sysclk.h ****  * This clock always runs at the same rate as the CPU clock unless the divider
 201:../../../platform/common/services/clock/mega/sysclk.h ****  * is set.
 202:../../../platform/common/services/clock/mega/sysclk.h ****  *
 203:../../../platform/common/services/clock/mega/sysclk.h ****  * \return Frequency of the system clock, in Hz.
 204:../../../platform/common/services/clock/mega/sysclk.h ****  */
 205:../../../platform/common/services/clock/mega/sysclk.h **** static inline uint32_t sysclk_get_source_clock_hz(void)
 206:../../../platform/common/services/clock/mega/sysclk.h **** {
  62               		.loc 1 206 0
  63               		.cfi_startproc
  64 001a CF93      		push r28
  65               	.LCFI3:
  66               		.cfi_def_cfa_offset 3
  67               		.cfi_offset 28, -2
  68 001c DF93      		push r29
  69               	.LCFI4:
  70               		.cfi_def_cfa_offset 4
  71               		.cfi_offset 29, -3
  72 001e CDB7      		in r28,__SP_L__
  73 0020 DEB7      		in r29,__SP_H__
  74               	.LCFI5:
  75               		.cfi_def_cfa_register 28
  76               	/* prologue: function */
  77               	/* frame size = 0 */
  78               	/* stack size = 2 */
  79               	.L__stack_usage = 2
 207:../../../platform/common/services/clock/mega/sysclk.h **** 	switch (CONFIG_SYSCLK_PSDIV) {
 208:../../../platform/common/services/clock/mega/sysclk.h **** 	case SYSCLK_PSDIV_1: /* Fall through */
 209:../../../platform/common/services/clock/mega/sysclk.h **** 		if (SYSCLK_SOURCE == SYSCLK_SRC_RC16MHZ ||
 210:../../../platform/common/services/clock/mega/sysclk.h **** 				SYSCLK_SOURCE == SYSCLK_SRC_RC128KHZ) {
 211:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 2;
 212:../../../platform/common/services/clock/mega/sysclk.h **** 		} else {
 213:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz();
  80               		.loc 1 213 0
  81 0022 0E94 0000 		call sysclk_get_main_hz
  82 0026 DC01      		movw r26,r24
  83 0028 CB01      		movw r24,r22
 214:../../../platform/common/services/clock/mega/sysclk.h **** 		}
 215:../../../platform/common/services/clock/mega/sysclk.h **** 
 216:../../../platform/common/services/clock/mega/sysclk.h **** 	case SYSCLK_PSDIV_2:
 217:../../../platform/common/services/clock/mega/sysclk.h **** 		if (SYSCLK_SOURCE == SYSCLK_SRC_RC16MHZ ||
 218:../../../platform/common/services/clock/mega/sysclk.h **** 				SYSCLK_SOURCE == SYSCLK_SRC_RC128KHZ) {
 219:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 4;
 220:../../../platform/common/services/clock/mega/sysclk.h **** 		} else {
 221:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 2;
 222:../../../platform/common/services/clock/mega/sysclk.h **** 		}
 223:../../../platform/common/services/clock/mega/sysclk.h **** 
 224:../../../platform/common/services/clock/mega/sysclk.h **** 	case SYSCLK_PSDIV_4:
 225:../../../platform/common/services/clock/mega/sysclk.h **** 		if (SYSCLK_SOURCE == SYSCLK_SRC_RC16MHZ ||
 226:../../../platform/common/services/clock/mega/sysclk.h **** 				SYSCLK_SOURCE == SYSCLK_SRC_RC128KHZ) {
 227:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 8;
 228:../../../platform/common/services/clock/mega/sysclk.h **** 		} else {
 229:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 4;
 230:../../../platform/common/services/clock/mega/sysclk.h **** 		}
 231:../../../platform/common/services/clock/mega/sysclk.h **** 
 232:../../../platform/common/services/clock/mega/sysclk.h **** 	case SYSCLK_PSDIV_8:
 233:../../../platform/common/services/clock/mega/sysclk.h **** 		if (SYSCLK_SOURCE == SYSCLK_SRC_RC16MHZ ||
 234:../../../platform/common/services/clock/mega/sysclk.h **** 				SYSCLK_SOURCE == SYSCLK_SRC_RC128KHZ) {
 235:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 16;
 236:../../../platform/common/services/clock/mega/sysclk.h **** 		} else {
 237:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 8;
 238:../../../platform/common/services/clock/mega/sysclk.h **** 		}
 239:../../../platform/common/services/clock/mega/sysclk.h **** 
 240:../../../platform/common/services/clock/mega/sysclk.h **** 	case SYSCLK_PSDIV_16:
 241:../../../platform/common/services/clock/mega/sysclk.h **** 		if (SYSCLK_SOURCE == SYSCLK_SRC_RC16MHZ ||
 242:../../../platform/common/services/clock/mega/sysclk.h **** 				SYSCLK_SOURCE == SYSCLK_SRC_RC128KHZ) {
 243:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 32;
 244:../../../platform/common/services/clock/mega/sysclk.h **** 		} else {
 245:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 16;
 246:../../../platform/common/services/clock/mega/sysclk.h **** 		}
 247:../../../platform/common/services/clock/mega/sysclk.h **** 
 248:../../../platform/common/services/clock/mega/sysclk.h **** 	case SYSCLK_PSDIV_32:
 249:../../../platform/common/services/clock/mega/sysclk.h **** 		if (SYSCLK_SOURCE == SYSCLK_SRC_RC16MHZ ||
 250:../../../platform/common/services/clock/mega/sysclk.h **** 				SYSCLK_SOURCE == SYSCLK_SRC_RC128KHZ) {
 251:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 64;
 252:../../../platform/common/services/clock/mega/sysclk.h **** 		} else {
 253:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 32;
 254:../../../platform/common/services/clock/mega/sysclk.h **** 		}
 255:../../../platform/common/services/clock/mega/sysclk.h **** 
 256:../../../platform/common/services/clock/mega/sysclk.h **** 	case SYSCLK_PSDIV_64:
 257:../../../platform/common/services/clock/mega/sysclk.h **** 		if (SYSCLK_SOURCE == SYSCLK_SRC_RC16MHZ ||
 258:../../../platform/common/services/clock/mega/sysclk.h **** 				SYSCLK_SOURCE == SYSCLK_SRC_RC128KHZ) {
 259:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 128;
 260:../../../platform/common/services/clock/mega/sysclk.h **** 		} else {
 261:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 64;
 262:../../../platform/common/services/clock/mega/sysclk.h **** 		}
 263:../../../platform/common/services/clock/mega/sysclk.h **** 
 264:../../../platform/common/services/clock/mega/sysclk.h **** 	case SYSCLK_PSDIV_128:
 265:../../../platform/common/services/clock/mega/sysclk.h **** 		if (SYSCLK_SOURCE == SYSCLK_SRC_RC16MHZ ||
 266:../../../platform/common/services/clock/mega/sysclk.h **** 				SYSCLK_SOURCE == SYSCLK_SRC_RC128KHZ) {
 267:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 256;
 268:../../../platform/common/services/clock/mega/sysclk.h **** 		} else {
 269:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 128;
 270:../../../platform/common/services/clock/mega/sysclk.h **** 		}
 271:../../../platform/common/services/clock/mega/sysclk.h **** 
 272:../../../platform/common/services/clock/mega/sysclk.h **** 	case SYSCLK_PSDIV_256:
 273:../../../platform/common/services/clock/mega/sysclk.h **** 		if (SYSCLK_SOURCE == SYSCLK_SRC_RC16MHZ ||
 274:../../../platform/common/services/clock/mega/sysclk.h **** 				SYSCLK_SOURCE == SYSCLK_SRC_RC128KHZ) {
 275:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 512;
 276:../../../platform/common/services/clock/mega/sysclk.h **** 		} else {
 277:../../../platform/common/services/clock/mega/sysclk.h **** 			return sysclk_get_main_hz() / 256;
 278:../../../platform/common/services/clock/mega/sysclk.h **** 		}
 279:../../../platform/common/services/clock/mega/sysclk.h **** 
 280:../../../platform/common/services/clock/mega/sysclk.h **** 	default:
 281:../../../platform/common/services/clock/mega/sysclk.h **** 		/*Invalide case*/
 282:../../../platform/common/services/clock/mega/sysclk.h **** 		return 0;
 283:../../../platform/common/services/clock/mega/sysclk.h **** 	}
 284:../../../platform/common/services/clock/mega/sysclk.h **** }
  84               		.loc 1 284 0
  85 002a BC01      		movw r22,r24
  86 002c CD01      		movw r24,r26
  87               	/* epilogue start */
  88 002e DF91      		pop r29
  89 0030 CF91      		pop r28
  90 0032 0895      		ret
  91               		.cfi_endproc
  92               	.LFE68:
  94               		.section	.progmem.data.baudctrl_1mhz,"a",@progbits
  97               	baudctrl_1mhz:
  98 0000 3300      		.word	51
  99 0002 1900      		.word	25
 100 0004 0C00      		.word	12
 101 0006 0600      		.word	6
 102 0008 0300      		.word	3
 103 000a 0200      		.word	2
 104 000c 0100      		.word	1
 105 000e FF00      		.word	255
 106               		.section	.progmem.data.baudctrl_8mhz,"a",@progbits
 109               	baudctrl_8mhz:
 110 0000 A001      		.word	416
 111 0002 CF00      		.word	207
 112 0004 6700      		.word	103
 113 0006 3300      		.word	51
 114 0008 1900      		.word	25
 115 000a 0C00      		.word	12
 116 000c 0700      		.word	7
 117 000e 0800      		.word	8
 118               		.section	.progmem.data.baudctrl_16mhz,"a",@progbits
 121               	baudctrl_16mhz:
 122 0000 4003      		.word	832
 123 0002 A001      		.word	416
 124 0004 CF00      		.word	207
 125 0006 6700      		.word	103
 126 0008 3300      		.word	51
 127 000a 1900      		.word	25
 128 000c 1000      		.word	16
 129 000e 1000      		.word	16
 130               		.text
 132               	usart_double_baud_enable:
 133               	.LFB101:
 134               		.file 2 "../../../platform/mega_rf/drivers/usart/usart_megarf.h"
   1:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
   2:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \file
   3:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
   4:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief USART driver for AVR MEGARF.
   5:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
   6:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * This file contains basic functions for the AVR MEGA USART, with support for
   7:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * all modes, settings and clock speeds.
   8:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
   9:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * Copyright (c) 2013-2015 Atmel Corporation. All rights reserved.
  10:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
  11:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \asf_license_start
  12:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
  13:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \page License
  14:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
  15:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * Redistribution and use in source and binary forms, with or without
  16:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * modification, are permitted provided that the following conditions are met:
  17:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
  18:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * 1. Redistributions of source code must retain the above copyright notice,
  19:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *    this list of conditions and the following disclaimer.
  20:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
  21:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * 2. Redistributions in binary form must reproduce the above copyright notice,
  22:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *    this list of conditions and the following disclaimer in the documentation
  23:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *    and/or other materials provided with the distribution.
  24:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
  25:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * 3. The name of Atmel may not be used to endorse or promote products derived
  26:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *    from this software without specific prior written permission.
  27:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
  28:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * 4. This software may only be redistributed and used in connection with an
  29:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *    Atmel microcontroller product.
  30:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
  31:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR IMPLIED
  32:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
  33:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
  34:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR
  35:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  36:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
  37:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  38:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
  39:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  40:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  41:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * POSSIBILITY OF SUCH DAMAGE.
  42:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
  43:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \asf_license_stop
  44:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
  45:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
  46:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #ifndef _USART_MEGARF_H_
  47:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define _USART_MEGARF_H_
  48:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
  49:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #ifdef __cplusplus
  50:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** extern "C" {
  51:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #endif
  52:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
  53:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #include "compiler.h"
  54:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #include "status_codes.h"
  55:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
  56:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
  57:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \defgroup megarf_usart_group USART module (USART)
  58:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
  59:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * See \ref megarf_usart_quickstart.
  60:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
  61:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * This is a driver for configuring, enabling, disabling and use of the on-chip
  62:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * USART.
  63:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
  64:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \section dependencies Dependencies
  65:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
  66:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * The USART module depends on the following modules:
  67:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *  - \ref sysclk_group for peripheral clock control.
  68:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *  - \ref port_driver_group for peripheral io port control.
  69:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
  70:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * @{
  71:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
  72:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
  73:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* ! Offset in lookup table for baudrate 1200 */
  74:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_BAUD_1200      0x00
  75:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* ! Offset in lookup table for baudrate 2400 */
  76:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_BAUD_2400      0x01
  77:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* ! Offset in lookup table for baudrate 4800 */
  78:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_BAUD_4800      0x02
  79:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* ! Offset in lookup table for baudrate 9600 */
  80:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_BAUD_9600      0x03
  81:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* ! Offset in lookup table for baudrate 19200 */
  82:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_BAUD_19200     0x04
  83:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* ! Offset in lookup table for baudrate 38400 */
  84:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_BAUD_38400     0x05
  85:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* ! Offset in lookup table for baudrate 57600 */
  86:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_BAUD_57600     0x06
  87:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* ! Offset in lookup table for baudrate 115200 */
  88:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_BAUD_115200    0x07
  89:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* ! Baudrate not in lookup table */
  90:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_BAUD_UNDEFINED 0xFF
  91:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
  92:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** typedef volatile uint8_t register8_t;
  93:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** typedef volatile uint16_t register16_t;
  94:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* Universal Synchronous/Asynchronous Receiver/Transmitter */
  95:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** typedef struct USART_struct {
  96:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	register8_t UCSRnA;  /* Control Register A */
  97:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	register8_t UCSRnB;  /* Control Register B */
  98:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	register8_t UCSRnC;  /* Control Register C */
  99:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	register8_t reserved;
 100:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	register16_t UBRR;  /* Baud Rate Register Value */
 101:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	register8_t UDR;  /* I/O Data Register */
 102:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** } USART_t;
 103:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 104:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USARTA0    (*(USART_t *)0xC0)   /* Universal Asynchronous
 105:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	                                 * Receiver-Transmitter A0 */
 106:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USARTA1    (*(USART_t *)0XC8)   /* Universal Asynchronous
 107:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	                                 * Receiver-Transmitter A1 */
 108:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 109:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* USART.UCSRxA  bit masks and bit positions */
 110:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_RXC_bm  0x80 /* RX complete bit mask.*/
 111:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_RXC_bp  7 /* RX complete bit position.*/
 112:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 113:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_TXC_bm  0x40 /* TX complete bit mask.*/
 114:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_TXC_bp  6 /* TX complete bit position.*/
 115:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 116:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_DRE_bm  0x20 /* DATA Register Empty Bit mask.*/
 117:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_DRE_bp  5 /*  DATA Register Empty bit position.*/
 118:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 119:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_FE_bm   0x10 /* Frame Error bit mask.*/
 120:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_FE_bp   4 /*Frame error bit position.*/
 121:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 122:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_DOR_bm  0x08 /* Data Over Run bit mask.*/
 123:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_DOR_bp  3 /* Data Over Run bit position.*/
 124:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 125:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_UPE_bm  0x04 /* Parity error bit mask.*/
 126:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_UPE_bp  2 /* Parity error bit position.*/
 127:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 128:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_U2X_bm  0x02 /* Double TX speed bit mask.*/
 129:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_U2X_bp  1 /* Double TX speed bit position.*/
 130:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 131:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_MPCM_bm  0x01 /* Multi Processor bit mask.*/
 132:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_MPMC_bp  0 /* Multi processor bit position.*/
 133:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 134:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* USART.UCSRxB  bit masks and bit positions */
 135:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_RXCIE_bm  0x80 /* RX complete interrupt Enable bit mask.*/
 136:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_RXCIE_bp  7 /* RX complete interrupt Enable bit position.*/
 137:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 138:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_TXCIE_bm  0x40 /* TX complete interrupt Enable bit mask.*/
 139:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_TXCIE_bp  6 /* TX complete interrupt Enable bit position.*/
 140:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 141:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_DRIE_bm  0x20 /* Data register empty interrupt Enable bit mask.*/
 142:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_DRIE_bp  5 /* Data register empty interrupt Enable bit position.*/
 143:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 144:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_RXEN_bm  0x10  /* Receiver Enable bit mask. */
 145:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_RXEN_bp  4  /* Receiver Enable bit position. */
 146:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 147:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_TXEN_bm  0x08  /* Transmitter Enable bit mask. */
 148:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_TXEN_bp  3  /* Transmitter Enable bit position. */
 149:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 150:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_CHSIZE2_bm  0x04  /* Character Size bit mask. */
 151:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_CHSIZE2_bp  2 /* Character Size bit position. */
 152:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 153:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_RXB8_bm  0x02  /* Transmit bit 8 bit mask. */
 154:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_RXB8_bp  1  /* Transmit bit 8 bit position. */
 155:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 156:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_TXB8_bm  0x01  /* Transmit bit 8 bit mask. */
 157:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_TXB8_bp  0  /* Transmit bit 8 bit position. */
 158:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 159:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* USART.UCSRxC  bit masks and bit positions */
 160:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_UMSEL01_gm  0xC0 /* USART Mode Select 01 grp mask.*/
 161:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_UMSEL01_gp  6 /* USART Mode Select 01 grp position.*/
 162:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 163:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_UMSEL01_bm  0x80 /* USART Mode Select 01 bit mask.*/
 164:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_UMSEL01_bp  7 /* USART Mode Select 01 bit position.*/
 165:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 166:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_UMSEL00_bm  0x40 /* USART Mode Select 00 bit mask.*/
 167:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_UMSEL00_bp  6 /* USART Mode Select 00 bit position.*/
 168:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 169:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_PMODE_gm  0x30 /* USART Parity Mode Select grp mask.*/
 170:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_PMODE_gp  4 /* USART Parity Mode Select grp position.*/
 171:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 172:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_PMODE01_bm  0x20 /* USART Parity Mode Select 01 bit mask.*/
 173:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_PMODE01_bp  5 /* USART Parity Mode Select 01 bit position.*/
 174:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 175:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_PMODE00_bm  0x10 /* USART Parity Mode Select 00 bit mask.*/
 176:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_PMODE00_bp  4 /* USART Parity Mode Select 00 bit position.*/
 177:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 178:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_STOPB_bm  0x08 /* USART stop bit mask.*/
 179:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_STOPB_bp  3 /* USART stop bit Position.*/
 180:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 181:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_CHSIZE01C_gm  0x06  /* Character Size 10 bit 1 mask. */
 182:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_CHSIZE01C_gp  1 /* Character Size 10 bit position. */
 183:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 184:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_CHSIZE01_bm  0x04  /* Character Size 10 bit 1 mask. */
 185:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_CHSIZE01_bp  2 /* Character Size 10 bit position. */
 186:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 187:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_CHSIZE00_bm  0x02  /* Character Size 00 bit 1 mask. */
 188:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_CHSIZE00_bp  1 /* Character Size bit 00 position. */
 189:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 190:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_UCPOL_bm  0x01  /* Sync mode Pol bit 1 mask. */
 191:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_UCPOL_bp  0 /*Sync mode Pol bit 0 position */
 192:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 193:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_UCPHA_bm 0x02 /* Clock Phase bit mask. */
 194:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_UCPHA_bp 1 /* Clock Phase bit position. */
 195:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 196:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_DORD_bm 0x04 /* Data order bit mask. */
 197:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** #define USART_DORD_bp 2 /* Data order bit position. */
 198:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 199:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* Character Size */
 200:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** typedef enum USART_CHSIZE_enum {
 201:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	USART_CHSIZE_5BIT_gc = (0x00),  /* Character size: 5 bit */
 202:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	USART_CHSIZE_6BIT_gc = (0x01),  /* Character size: 6 bit */
 203:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	USART_CHSIZE_7BIT_gc = (0x02),  /* Character size: 7 bit */
 204:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	USART_CHSIZE_8BIT_gc = (0x03),  /* Character size: 8 bit */
 205:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	USART_CHSIZE_9BIT_gc = (0x07),  /* Character size: 9 bit */
 206:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** } USART_CHSIZE_t;
 207:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 208:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* Communication Mode */
 209:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** typedef enum USART_CMODE_enum {
 210:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	USART_CMODE_ASYNCHRONOUS_gc = (0x00 << USART_UMSEL01_gp),  /*
 211:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	                                                            *
 212:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	                                                            *
 213:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	                                                            *Asynchronous
 214:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	                                                            * Mode */
 215:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	USART_CMODE_SYNCHRONOUS_gc = (0x01 << USART_UMSEL01_gp),  /* Synchronous
 216:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	                                                           * Mode */
 217:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	USART_CMODE_IRDA_gc = (0x02 << USART_UMSEL01_gp),  /* IrDA Mode */
 218:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	USART_CMODE_MSPI_gc = (0x03 << USART_UMSEL01_gp),  /* Master SPI Mode */
 219:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** } USART_CMODE_t;
 220:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 221:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* Parity Mode */
 222:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** typedef enum USART_PMODE_enum {
 223:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	USART_PMODE_DISABLED_gc = (0x00 << USART_PMODE_gp),  /* No Parity */
 224:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	USART_PMODE_EVEN_gc = (0x02 << USART_PMODE_gp),  /* Even Parity */
 225:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	USART_PMODE_ODD_gc = (0x03 << USART_PMODE_gp),  /* Odd Parity */
 226:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** } USART_PMODE_t;
 227:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 228:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* ! Lookup table containing baudctrl values for CPU frequency 1 Mhz */
 229:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static PROGMEM_DECLARE(uint16_t, baudctrl_1mhz[]) = {
 230:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0033, /* Baud: 1200 */
 231:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0019, /* Baud: 2400 */
 232:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x000C, /* Baud: 4800 */
 233:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0006, /* Baud: 9600 */
 234:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0003, /* Baud: 19200 */
 235:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0002, /* Baud: 38400 */
 236:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0001, /* Baud: 57600 */
 237:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	USART_BAUD_UNDEFINED, /* Baud: 115200 */
 238:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** };
 239:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 240:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* ! Lookup table containing baudctrl values for CPU frequency 8 Mhz */
 241:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static PROGMEM_DECLARE(uint16_t, baudctrl_8mhz[]) = {
 242:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x01A0, /* Baud: 1200 */
 243:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x00CF, /* Baud: 2400 */
 244:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0067, /* Baud: 4800 */
 245:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0033, /* Baud: 9600 */
 246:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0019, /* Baud: 19200 */
 247:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x000C, /* Baud: 38400 */
 248:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0007, /* Baud: 57600 */
 249:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0008, /* Baud: 115200 */
 250:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** };
 251:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 252:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* ! Lookup table containing baudctrl values for CPU frequency 16 Mhz */
 253:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static PROGMEM_DECLARE(uint16_t, baudctrl_16mhz[]) = {
 254:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0340, /* Baud: 1200 */
 255:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x01A0, /* Baud: 2400 */
 256:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x00CF, /* Baud: 4800 */
 257:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0067, /* Baud: 9600 */
 258:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0033, /* Baud: 19200 */
 259:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0019, /* Baud: 38400 */
 260:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0010, /* Baud: 57600 */
 261:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	0x0010, /* Baud: 115200 */
 262:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** };
 263:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 264:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 265:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* ! Input parameters when initializing RS232 and similar modes. */
 266:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** typedef struct usart_rs232_options {
 267:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	/* ! Set baud rate of the USART (unused in slave modes). */
 268:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	uint32_t baudrate;
 269:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 270:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	/* ! Number of bits to transmit as a character (5 to 9). */
 271:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	USART_CHSIZE_t charlength;
 272:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 273:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	/* ! Parity type: USART_PMODE_DISABLED_gc, USART_PMODE_EVEN_gc, */
 274:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	/* ! USART_PMODE_ODD_gc. */
 275:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	USART_PMODE_t paritytype;
 276:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 277:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	/* ! Number of stop bits between two characters: */
 278:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	/* ! true: 2 stop bits */
 279:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	/* ! false: 1 stop bit */
 280:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	bool stopbits;
 281:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** } usart_rs232_options_t;
 282:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 283:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /* ! Input parameters when initializing SPI master mode. */
 284:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** typedef struct usart_spi_options {
 285:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	/* ! Set baud rate of the USART in SPI mode. */
 286:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	uint32_t baudrate;
 287:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 288:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	/* ! SPI transmission mode. */
 289:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	uint8_t spimode;
 290:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 291:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	uint8_t data_order;
 292:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** } usart_spi_options_t;
 293:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 294:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 295:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 296:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Enable USART receiver.
 297:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 298:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart Pointer to the USART module
 299:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 300:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline void usart_rx_enable(USART_t *usart)
 301:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 302:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	(usart)->UCSRnB |= USART_RXEN_bm;
 303:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 304:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 305:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 306:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Disable USART receiver.
 307:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 308:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart Pointer to the USART module.
 309:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 310:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline void usart_rx_disable(USART_t *usart)
 311:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 312:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	(usart)->UCSRnB &= ~USART_RXEN_bm;
 313:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 314:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 315:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 316:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief  Configure the USART frame format.
 317:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 318:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *  Sets the frame format, Frame Size, parity mode and number of stop bits.
 319:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 320:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *  \param usart Pointer to the USART module
 321:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *  \param charSize The character size. Use USART_CHSIZE_t type.
 322:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *  \param parityMode The parity Mode. Use USART_PMODE_t type.
 323:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *  \param twoStopBits Enable two stop bit mode. Use bool type.
 324:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 325:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline void usart_format_set(USART_t *usart, USART_CHSIZE_t charSize,
 326:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 		USART_PMODE_t parityMode, bool twoStopBits)
 327:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 328:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	(usart)->UCSRnC
 329:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 		= ((usart)->UCSRnC &
 330:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 			(~USART_CHSIZE01C_gm)) | ((charSize & 0x03)
 331:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 			<< USART_CHSIZE01C_gp);
 332:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	(usart)->UCSRnB
 333:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 		= ((usart)->UCSRnB &
 334:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 			(~USART_CHSIZE2_bm)) | ((charSize & 0x04)
 335:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 			<< USART_CHSIZE2_bp);
 336:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 337:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	(usart)->UCSRnC = ((usart)->UCSRnC & (~USART_PMODE_gm)) | parityMode;
 338:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 339:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	(usart)->UCSRnC = ((usart)->UCSRnC & (~USART_STOPB_bm)) | (twoStopBits
 340:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 			<< USART_STOPB_bp);
 341:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 342:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 343:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 344:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Enable USART transmitter.
 345:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 346:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart Pointer to the USART module.
 347:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 348:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline void usart_tx_enable(USART_t *usart)
 349:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 350:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	(usart)->UCSRnB |= USART_TXEN_bm;
 351:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 352:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 353:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 354:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Disable USART transmitter.
 355:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 356:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart Pointer to the USART module.
 357:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 358:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline void usart_tx_disable(USART_t *usart)
 359:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 360:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	(usart)->UCSRnB &= ~USART_TXEN_bm;
 361:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 362:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 363:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 364:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Enable USART transmit complete interrupt.
 365:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 366:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart Pointer to the USART module.
 367:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 368:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline void usart_tx_complete_interrupt_enable(USART_t *usart)
 369:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 370:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	(usart)->UCSRnB |= USART_TXC_bm;
 371:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 372:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 373:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 374:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Enable USART receive complete interrupt.
 375:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 376:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart Pointer to the USART module.
 377:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 378:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline void usart_rx_complete_interrupt_enable(USART_t *usart)
 379:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 380:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	(usart)->UCSRnB |= USART_RXC_bm;
 381:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 382:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 383:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 384:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Enable USART data register empty interrupt.
 385:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 386:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart Pointer to the USART module.
 387:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 388:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline void usart_data_empty_interrupt_enable(USART_t *usart)
 389:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 390:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	(usart)->UCSRnB |= USART_DRIE_bm;
 391:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 392:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 393:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 394:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Disable USART transmit complete interrupt.
 395:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 396:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart Pointer to the USART module.
 397:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 398:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline void usart_tx_complete_interrupt_disable(USART_t *usart)
 399:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 400:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	(usart)->UCSRnB &= ~USART_TXC_bm;
 401:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 402:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 403:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 404:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Disable USART receive complete interrupt.
 405:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 406:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart Pointer to the USART module.
 407:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 408:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline void usart_rx_complete_interrupt_disable(USART_t *usart)
 409:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 410:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	(usart)->UCSRnB &= ~USART_RXC_bm;
 411:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 412:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 413:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 414:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Disable USART data register empty interrupt.
 415:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 416:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart Pointer to the USART module.
 417:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 418:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline void usart_data_empty_interrupt_disable(USART_t *usart)
 419:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 420:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	(usart)->UCSRnB &= ~USART_DRIE_bm;
 421:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 422:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 423:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 424:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Set the mode the USART run in.
 425:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 426:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * Set the mode the USART run in. The default mode is asynchronous mode.
 427:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 428:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart Pointer to the USART module register section.
 429:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usartmode Selects the USART mode. Use USART_CMODE_t type.
 430:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 431:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * USART modes:
 432:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * - 0x0        : Asynchronous mode.
 433:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * - 0x1        : Synchronous mode.
 434:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * - 0x2        : IrDA mode.
 435:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * - 0x3        : Master SPI mode.
 436:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 437:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline void usart_set_mode(USART_t *usart, USART_CMODE_t usartmode)
 438:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 439:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	(usart)->UCSRnC = ((usart)->UCSRnC & (~USART_UMSEL01_gm)) | usartmode;
 440:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 441:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 442:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 443:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Check if data register empty flag is set.
 444:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 445:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart The USART module.
 446:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 447:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline bool usart_data_register_is_empty(USART_t *usart)
 448:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 449:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	return (usart)->UCSRnA & USART_DRE_bm;
 450:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 451:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 452:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 453:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Checks if the RX complete interrupt flag is set.
 454:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 455:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * Checks if the RX complete interrupt flag is set.
 456:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 457:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart The USART module.
 458:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 459:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline bool usart_rx_is_complete(USART_t *usart)
 460:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 461:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	return (usart)->UCSRnA & USART_RXC_bm;
 462:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 463:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 464:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 465:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Checks if the TX complete interrupt flag is set.
 466:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 467:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * Checks if the TX complete interrupt flag is set.
 468:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 469:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart The USART module.
 470:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 471:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline bool usart_tx_is_complete(USART_t *usart)
 472:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 473:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	return (usart)->UCSRnA & USART_TXC_bm;
 474:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 475:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 476:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 477:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Clear TX complete interrupt flag.
 478:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * TX flag is clear after complete transmission, automatically.
 479:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart The USART module.
 480:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 481:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline void usart_clear_tx_complete(USART_t *usart)
 482:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 483:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****          usart->UCSRnA |=  USART_TXC_bm;
 484:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 485:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 486:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 487:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Write a data to the USART data register.
 488:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 489:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart The USART module.
 490:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param txdata The data to be transmitted.
 491:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 492:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline void usart_put(USART_t *usart, uint8_t txdata)
 493:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 494:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	(usart)->UDR = txdata;
 495:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 496:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 497:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 498:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief  Read a data to the USART data register.
 499:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 500:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart The USART module.
 501:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 502:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \return The received data
 503:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 504:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline uint8_t usart_get(USART_t *usart)
 505:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 506:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	return (usart)->UDR;
 507:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 508:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 
 509:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** /**
 510:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \brief Double the USART transmission speed.
 511:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  *
 512:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  * \param usart The USART module.
 513:../../../platform/mega_rf/drivers/usart/usart_megarf.h ****  */
 514:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** static inline void usart_double_baud_enable(USART_t *usart)
 515:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** {
 135               		.loc 2 515 0
 136               		.cfi_startproc
 137 0034 CF93      		push r28
 138               	.LCFI6:
 139               		.cfi_def_cfa_offset 3
 140               		.cfi_offset 28, -2
 141 0036 DF93      		push r29
 142               	.LCFI7:
 143               		.cfi_def_cfa_offset 4
 144               		.cfi_offset 29, -3
 145 0038 00D0      		rcall .
 146               	.LCFI8:
 147               		.cfi_def_cfa_offset 6
 148 003a CDB7      		in r28,__SP_L__
 149 003c DEB7      		in r29,__SP_H__
 150               	.LCFI9:
 151               		.cfi_def_cfa_register 28
 152               	/* prologue: function */
 153               	/* frame size = 2 */
 154               	/* stack size = 4 */
 155               	.L__stack_usage = 4
 156 003e 9A83      		std Y+2,r25
 157 0040 8983      		std Y+1,r24
 516:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** 	usart->UCSRnA |=  USART_U2X_bm;
 158               		.loc 2 516 0
 159 0042 8981      		ldd r24,Y+1
 160 0044 9A81      		ldd r25,Y+2
 161 0046 FC01      		movw r30,r24
 162 0048 8081      		ld r24,Z
 163 004a 282F      		mov r18,r24
 164 004c 2260      		ori r18,lo8(2)
 165 004e 8981      		ldd r24,Y+1
 166 0050 9A81      		ldd r25,Y+2
 167 0052 FC01      		movw r30,r24
 168 0054 2083      		st Z,r18
 517:../../../platform/mega_rf/drivers/usart/usart_megarf.h **** }
 169               		.loc 2 517 0
 170 0056 0000      		nop
 171               	/* epilogue start */
 172 0058 0F90      		pop __tmp_reg__
 173 005a 0F90      		pop __tmp_reg__
 174 005c DF91      		pop r29
 175 005e CF91      		pop r28
 176 0060 0895      		ret
 177               		.cfi_endproc
 178               	.LFE101:
 181               	usart_serial_init:
 182               	.LFB104:
 183               		.file 3 "../../../platform/common/services/serial/megarf_usart/usart_serial.h"
   1:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** /**
   2:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * \file
   3:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
   4:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * \brief This file defines a useful set of functions for the Serial interface on 
   5:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * AVR MEGARF devices.
   6:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
   7:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * Copyright (c) 2013 Atmel Corporation. All rights reserved.
   8:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
   9:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * \asf_license_start
  10:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
  11:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * \page License
  12:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
  13:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * Redistribution and use in source and binary forms, with or without
  14:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * modification, are permitted provided that the following conditions are met:
  15:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
  16:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * 1. Redistributions of source code must retain the above copyright notice,
  17:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *    this list of conditions and the following disclaimer.
  18:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
  19:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * 2. Redistributions in binary form must reproduce the above copyright notice,
  20:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *    this list of conditions and the following disclaimer in the documentation
  21:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *    and/or other materials provided with the distribution.
  22:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
  23:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * 3. The name of Atmel may not be used to endorse or promote products derived
  24:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *    from this software without specific prior written permission.
  25:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
  26:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * 4. This software may only be redistributed and used in connection with an
  27:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *    Atmel microcontroller product.
  28:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
  29:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR IMPLIED
  30:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
  31:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
  32:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR
  33:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  34:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
  35:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  36:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
  37:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  38:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  39:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * POSSIBILITY OF SUCH DAMAGE.
  40:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
  41:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * \asf_license_stop
  42:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
  43:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  */
  44:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** #ifndef _USART_SERIAL_H_
  45:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** #define _USART_SERIAL_H_
  46:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 
  47:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** #ifdef __cplusplus
  48:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** extern "C" {
  49:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** #endif
  50:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 
  51:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** #include "compiler.h"
  52:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** #include "sysclk.h"
  53:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** #include "status_codes.h"
  54:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** #include "usart_megarf.h"
  55:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 
  56:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** /*! \name Serial Management Configuration
  57:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  */
  58:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** /* ! @{ */
  59:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** #include "conf_usart_serial.h"
  60:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** /* ! @} */
  61:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 
  62:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** typedef usart_rs232_options_t usart_serial_options_t;
  63:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 
  64:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** typedef USART_t *usart_if;
  65:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 
  66:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** /*! \brief Initializes the Usart in master mode.
  67:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
  68:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * \param usart       Base address of the USART instance.
  69:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * \param options     Options needed to set up RS232 communication (see \ref
  70:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * usart_serial_options_t).
  71:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
  72:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * \retval true if the initialization was successful
  73:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * \retval false if initialization failed (error in baud rate calculation)
  74:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  */
  75:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** static inline bool usart_serial_init(usart_if usart, const
  76:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 		usart_serial_options_t *options)
  77:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** {
 184               		.loc 3 77 0
 185               		.cfi_startproc
 186 0062 CF93      		push r28
 187               	.LCFI10:
 188               		.cfi_def_cfa_offset 3
 189               		.cfi_offset 28, -2
 190 0064 DF93      		push r29
 191               	.LCFI11:
 192               		.cfi_def_cfa_offset 4
 193               		.cfi_offset 29, -3
 194 0066 CDB7      		in r28,__SP_L__
 195 0068 DEB7      		in r29,__SP_H__
 196               	.LCFI12:
 197               		.cfi_def_cfa_register 28
 198 006a 2B97      		sbiw r28,11
 199               	.LCFI13:
 200               		.cfi_def_cfa_offset 15
 201 006c 0FB6      		in __tmp_reg__,__SREG__
 202 006e F894      		cli
 203 0070 DEBF      		out __SP_H__,r29
 204 0072 0FBE      		out __SREG__,__tmp_reg__
 205 0074 CDBF      		out __SP_L__,r28
 206               	/* prologue: function */
 207               	/* frame size = 11 */
 208               	/* stack size = 13 */
 209               	.L__stack_usage = 13
 210 0076 9987      		std Y+9,r25
 211 0078 8887      		std Y+8,r24
 212 007a 7B87      		std Y+11,r23
 213 007c 6A87      		std Y+10,r22
  78:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 	/* USART options. */
  79:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 	usart_rs232_options_t usart_rs232_options;
  80:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 	usart_rs232_options.charlength   = options->charlength;
 214               		.loc 3 80 0
 215 007e 8A85      		ldd r24,Y+10
 216 0080 9B85      		ldd r25,Y+11
 217 0082 FC01      		movw r30,r24
 218 0084 8481      		ldd r24,Z+4
 219 0086 8D83      		std Y+5,r24
  81:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 	usart_rs232_options.paritytype   = options->paritytype;
 220               		.loc 3 81 0
 221 0088 8A85      		ldd r24,Y+10
 222 008a 9B85      		ldd r25,Y+11
 223 008c FC01      		movw r30,r24
 224 008e 8581      		ldd r24,Z+5
 225 0090 8E83      		std Y+6,r24
  82:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 	usart_rs232_options.stopbits     = options->stopbits;
 226               		.loc 3 82 0
 227 0092 8A85      		ldd r24,Y+10
 228 0094 9B85      		ldd r25,Y+11
 229 0096 FC01      		movw r30,r24
 230 0098 8681      		ldd r24,Z+6
 231 009a 8F83      		std Y+7,r24
  83:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 	usart_rs232_options.baudrate     = options->baudrate;
 232               		.loc 3 83 0
 233 009c 8A85      		ldd r24,Y+10
 234 009e 9B85      		ldd r25,Y+11
 235 00a0 FC01      		movw r30,r24
 236 00a2 8081      		ld r24,Z
 237 00a4 9181      		ldd r25,Z+1
 238 00a6 A281      		ldd r26,Z+2
 239 00a8 B381      		ldd r27,Z+3
 240 00aa 8983      		std Y+1,r24
 241 00ac 9A83      		std Y+2,r25
 242 00ae AB83      		std Y+3,r26
 243 00b0 BC83      		std Y+4,r27
  84:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 
  85:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 	if (usart_init_rs232(usart, &usart_rs232_options)) {
 244               		.loc 3 85 0
 245 00b2 8885      		ldd r24,Y+8
 246 00b4 9985      		ldd r25,Y+9
 247 00b6 9E01      		movw r18,r28
 248 00b8 2F5F      		subi r18,-1
 249 00ba 3F4F      		sbci r19,-1
 250 00bc B901      		movw r22,r18
 251 00be 0E94 0000 		call usart_init_rs232
 252 00c2 8823      		tst r24
 253 00c4 01F0      		breq .L7
  86:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 		return true;
 254               		.loc 3 86 0
 255 00c6 81E0      		ldi r24,lo8(1)
 256 00c8 00C0      		rjmp .L9
 257               	.L7:
  87:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 	} else {
  88:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 		return false;
 258               		.loc 3 88 0
 259 00ca 80E0      		ldi r24,0
 260               	.L9:
 261               	/* epilogue start */
  89:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 	}
  90:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** }
 262               		.loc 3 90 0 discriminator 1
 263 00cc 2B96      		adiw r28,11
 264 00ce 0FB6      		in __tmp_reg__,__SREG__
 265 00d0 F894      		cli
 266 00d2 DEBF      		out __SP_H__,r29
 267 00d4 0FBE      		out __SREG__,__tmp_reg__
 268 00d6 CDBF      		out __SP_L__,r28
 269 00d8 DF91      		pop r29
 270 00da CF91      		pop r28
 271 00dc 0895      		ret
 272               		.cfi_endproc
 273               	.LFE104:
 276               	usart_serial_putchar:
 277               	.LFB105:
  91:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 
  92:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** /*! \brief Sends a character with the USART.
  93:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
  94:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * \param usart   Base address of the USART instance.
  95:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * \param c       Character to write.
  96:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
  97:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * \return Status code
  98:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  */
  99:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** static inline status_code_t usart_serial_putchar(usart_if usart, uint8_t c)
 100:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** {
 278               		.loc 3 100 0
 279               		.cfi_startproc
 280 00de CF93      		push r28
 281               	.LCFI14:
 282               		.cfi_def_cfa_offset 3
 283               		.cfi_offset 28, -2
 284 00e0 DF93      		push r29
 285               	.LCFI15:
 286               		.cfi_def_cfa_offset 4
 287               		.cfi_offset 29, -3
 288 00e2 00D0      		rcall .
 289 00e4 1F92      		push __zero_reg__
 290               	.LCFI16:
 291               		.cfi_def_cfa_offset 7
 292 00e6 CDB7      		in r28,__SP_L__
 293 00e8 DEB7      		in r29,__SP_H__
 294               	.LCFI17:
 295               		.cfi_def_cfa_register 28
 296               	/* prologue: function */
 297               	/* frame size = 3 */
 298               	/* stack size = 5 */
 299               	.L__stack_usage = 5
 300 00ea 9A83      		std Y+2,r25
 301 00ec 8983      		std Y+1,r24
 302 00ee 6B83      		std Y+3,r22
 101:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 	return usart_putchar(usart, c);
 303               		.loc 3 101 0
 304 00f0 8981      		ldd r24,Y+1
 305 00f2 9A81      		ldd r25,Y+2
 306 00f4 6B81      		ldd r22,Y+3
 307 00f6 0E94 0000 		call usart_putchar
 308               	/* epilogue start */
 102:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** }
 309               		.loc 3 102 0
 310 00fa 0F90      		pop __tmp_reg__
 311 00fc 0F90      		pop __tmp_reg__
 312 00fe 0F90      		pop __tmp_reg__
 313 0100 DF91      		pop r29
 314 0102 CF91      		pop r28
 315 0104 0895      		ret
 316               		.cfi_endproc
 317               	.LFE105:
 320               	usart_serial_getchar:
 321               	.LFB106:
 103:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 
 104:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** /*! \brief Waits until a character is received, and returns it.
 105:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
 106:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * \param usart   Base address of the USART instance.
 107:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  * \param data   Data to read
 108:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  *
 109:../../../platform/common/services/serial/megarf_usart/usart_serial.h ****  */
 110:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** static inline void usart_serial_getchar(usart_if usart, uint8_t *data)
 111:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** {
 322               		.loc 3 111 0
 323               		.cfi_startproc
 324 0106 CF93      		push r28
 325               	.LCFI18:
 326               		.cfi_def_cfa_offset 3
 327               		.cfi_offset 28, -2
 328 0108 DF93      		push r29
 329               	.LCFI19:
 330               		.cfi_def_cfa_offset 4
 331               		.cfi_offset 29, -3
 332 010a 00D0      		rcall .
 333 010c 00D0      		rcall .
 334               	.LCFI20:
 335               		.cfi_def_cfa_offset 8
 336 010e CDB7      		in r28,__SP_L__
 337 0110 DEB7      		in r29,__SP_H__
 338               	.LCFI21:
 339               		.cfi_def_cfa_register 28
 340               	/* prologue: function */
 341               	/* frame size = 4 */
 342               	/* stack size = 6 */
 343               	.L__stack_usage = 6
 344 0112 9A83      		std Y+2,r25
 345 0114 8983      		std Y+1,r24
 346 0116 7C83      		std Y+4,r23
 347 0118 6B83      		std Y+3,r22
 112:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** 	*data = usart_getchar(usart);
 348               		.loc 3 112 0
 349 011a 8981      		ldd r24,Y+1
 350 011c 9A81      		ldd r25,Y+2
 351 011e 0E94 0000 		call usart_getchar
 352 0122 282F      		mov r18,r24
 353 0124 8B81      		ldd r24,Y+3
 354 0126 9C81      		ldd r25,Y+4
 355 0128 FC01      		movw r30,r24
 356 012a 2083      		st Z,r18
 113:../../../platform/common/services/serial/megarf_usart/usart_serial.h **** }
 357               		.loc 3 113 0
 358 012c 0000      		nop
 359               	/* epilogue start */
 360 012e 0F90      		pop __tmp_reg__
 361 0130 0F90      		pop __tmp_reg__
 362 0132 0F90      		pop __tmp_reg__
 363 0134 0F90      		pop __tmp_reg__
 364 0136 DF91      		pop r29
 365 0138 CF91      		pop r28
 366 013a 0895      		ret
 367               		.cfi_endproc
 368               	.LFE106:
 371               	stdio_serial_init:
 372               	.LFB107:
 373               		.file 4 "../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h"
   1:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** /**
   2:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
   3:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * \file
   4:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
   5:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * \brief Common Standard I/O Serial Management.
   6:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
   7:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * This file defines a useful set of functions for the Stdio Serial interface on AVR
   8:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * and SAM devices.
   9:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
  10:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * Copyright (c) 2009-2013 Atmel Corporation. All rights reserved.
  11:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
  12:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * \asf_license_start
  13:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
  14:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * \page License
  15:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
  16:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * Redistribution and use in source and binary forms, with or without
  17:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * modification, are permitted provided that the following conditions are met:
  18:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
  19:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * 1. Redistributions of source code must retain the above copyright notice,
  20:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *    this list of conditions and the following disclaimer.
  21:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
  22:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * 2. Redistributions in binary form must reproduce the above copyright notice,
  23:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *    this list of conditions and the following disclaimer in the documentation
  24:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *    and/or other materials provided with the distribution.
  25:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
  26:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * 3. The name of Atmel may not be used to endorse or promote products derived
  27:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *    from this software without specific prior written permission.
  28:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
  29:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * 4. This software may only be redistributed and used in connection with an
  30:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *    Atmel microcontroller product.
  31:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
  32:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR IMPLIED
  33:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
  34:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
  35:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR
  36:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  37:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
  38:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  39:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
  40:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  41:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  42:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * POSSIBILITY OF SUCH DAMAGE.
  43:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
  44:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * \asf_license_stop
  45:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
  46:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  ******************************************************************************/
  47:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 
  48:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 
  49:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** #ifndef _STDIO_SERIAL_H_
  50:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** #define _STDIO_SERIAL_H_
  51:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 
  52:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** /**
  53:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * \defgroup group_common_utils_stdio_stdio_serial Standard serial I/O (stdio)
  54:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * \ingroup group_common_utils_stdio
  55:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
  56:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * Common standard serial I/O management driver that
  57:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * implements a stdio serial interface on AVR and SAM devices.
  58:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
  59:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * \{
  60:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  */
  61:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 
  62:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** #include <stdio.h>
  63:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** #include "compiler.h"
  64:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** #ifndef SAMD20
  65:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** # include "sysclk.h"
  66:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** #endif
  67:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** #include "serial.h"
  68:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 
  69:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** #if (XMEGA || MEGA_RF) && defined(__GNUC__)
  70:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	extern int _write (char c, int *f);
  71:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	extern int _read (int *f);
  72:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** #endif
  73:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 
  74:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 
  75:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** //! Pointer to the base of the USART module instance to use for stdio.
  76:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** extern volatile void *volatile stdio_base;
  77:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** //! Pointer to the external low level write function.
  78:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** extern int (*ptr_put)(void volatile*, char);
  79:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 
  80:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** //! Pointer to the external low level read function.
  81:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** extern void (*ptr_get)(void volatile*, char*);
  82:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 
  83:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** /*! \brief Initializes the stdio in Serial Mode.
  84:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
  85:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * \param usart       Base address of the USART instance.
  86:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  * \param opt         Options needed to set up RS232 communication (see \ref usart_options_t).
  87:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  *
  88:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h ****  */
  89:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** static inline void stdio_serial_init(volatile void *usart, const usart_serial_options_t *opt)
  90:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** {
 374               		.loc 4 90 0
 375               		.cfi_startproc
 376 013c CF93      		push r28
 377               	.LCFI22:
 378               		.cfi_def_cfa_offset 3
 379               		.cfi_offset 28, -2
 380 013e DF93      		push r29
 381               	.LCFI23:
 382               		.cfi_def_cfa_offset 4
 383               		.cfi_offset 29, -3
 384 0140 00D0      		rcall .
 385 0142 00D0      		rcall .
 386               	.LCFI24:
 387               		.cfi_def_cfa_offset 8
 388 0144 CDB7      		in r28,__SP_L__
 389 0146 DEB7      		in r29,__SP_H__
 390               	.LCFI25:
 391               		.cfi_def_cfa_register 28
 392               	/* prologue: function */
 393               	/* frame size = 4 */
 394               	/* stack size = 6 */
 395               	.L__stack_usage = 6
 396 0148 9A83      		std Y+2,r25
 397 014a 8983      		std Y+1,r24
 398 014c 7C83      		std Y+4,r23
 399 014e 6B83      		std Y+3,r22
  91:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	stdio_base = (void *)usart;
 400               		.loc 4 91 0
 401 0150 8981      		ldd r24,Y+1
 402 0152 9A81      		ldd r25,Y+2
 403 0154 9093 0000 		sts stdio_base+1,r25
 404 0158 8093 0000 		sts stdio_base,r24
  92:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	ptr_put = (int (*)(void volatile*,char))&usart_serial_putchar;
 405               		.loc 4 92 0
 406 015c 80E0      		ldi r24,lo8(gs(usart_serial_putchar))
 407 015e 90E0      		ldi r25,hi8(gs(usart_serial_putchar))
 408 0160 9093 0000 		sts ptr_put+1,r25
 409 0164 8093 0000 		sts ptr_put,r24
  93:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	ptr_get = (void (*)(void volatile*,char*))&usart_serial_getchar;
 410               		.loc 4 93 0
 411 0168 80E0      		ldi r24,lo8(gs(usart_serial_getchar))
 412 016a 90E0      		ldi r25,hi8(gs(usart_serial_getchar))
 413 016c 9093 0000 		sts ptr_get+1,r25
 414 0170 8093 0000 		sts ptr_get,r24
  94:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** # if (XMEGA || MEGA_RF)
  95:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	usart_serial_init((USART_t *)usart,opt);
 415               		.loc 4 95 0
 416 0174 2B81      		ldd r18,Y+3
 417 0176 3C81      		ldd r19,Y+4
 418 0178 8981      		ldd r24,Y+1
 419 017a 9A81      		ldd r25,Y+2
 420 017c B901      		movw r22,r18
 421 017e 0E94 0000 		call usart_serial_init
  96:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** # elif UC3
  97:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	usart_serial_init(usart,(usart_serial_options_t *)opt);
  98:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** # elif SAM
  99:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	usart_serial_init((Usart *)usart,(usart_serial_options_t *)opt);
 100:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** # else
 101:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** #  error Unsupported chip type
 102:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** # endif
 103:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 
 104:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** # if defined(__GNUC__)
 105:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** #  if (XMEGA || MEGA_RF)
 106:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	// For AVR GCC libc print redirection uses fdevopen.
 107:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	fdevopen((int (*)(char, FILE*))(_write),(int (*)(FILE*))(_read));
 422               		.loc 4 107 0
 423 0182 60E0      		ldi r22,lo8(gs(_read))
 424 0184 70E0      		ldi r23,hi8(gs(_read))
 425 0186 80E0      		ldi r24,lo8(gs(_write))
 426 0188 90E0      		ldi r25,hi8(gs(_write))
 427 018a 0E94 0000 		call fdevopen
 108:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** #  endif
 109:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** #  if UC3 || SAM
 110:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	// For AVR32 and SAM GCC
 111:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	// Specify that stdout and stdin should not be buffered.
 112:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	setbuf(stdout, NULL);
 113:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	setbuf(stdin, NULL);
 114:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	// Note: Already the case in IAR's Normal DLIB default configuration
 115:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	// and AVR GCC library:
 116:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	// - printf() emits one character at a time.
 117:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** 	// - getchar() requests only 1 byte to exit.
 118:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** #  endif
 119:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** # endif
 120:../../../platform/common/utils/stdio/stdio_serial/stdio_serial.h **** }
 428               		.loc 4 120 0
 429 018e 0000      		nop
 430               	/* epilogue start */
 431 0190 0F90      		pop __tmp_reg__
 432 0192 0F90      		pop __tmp_reg__
 433 0194 0F90      		pop __tmp_reg__
 434 0196 0F90      		pop __tmp_reg__
 435 0198 DF91      		pop r29
 436 019a CF91      		pop r28
 437 019c 0895      		ret
 438               		.cfi_endproc
 439               	.LFE107:
 442               	macsc_enable_manual_bts:
 443               	.LFB121:
 444               		.file 5 "../../../platform/mega_rf/drivers/macsc/macsc_megarf.h"
   1:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
   2:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \file
   3:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
   4:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief AVR MEGARF MAC Symbol Counter Driver Definitions
   5:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
   6:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * Copyright (c) 2013 Atmel Corporation. All rights reserved.
   7:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
   8:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \asf_license_start
   9:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  10:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \page License
  11:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  12:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * Redistribution and use in source and binary forms, with or without
  13:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * modification, are permitted provided that the following conditions are met:
  14:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  15:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * 1. Redistributions of source code must retain the above copyright notice,
  16:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *    this list of conditions and the following disclaimer.
  17:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  18:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * 2. Redistributions in binary form must reproduce the above copyright notice,
  19:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *    this list of conditions and the following disclaimer in the documentation
  20:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *    and/or other materials provided with the distribution.
  21:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  22:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * 3. The name of Atmel may not be used to endorse or promote products derived
  23:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *    from this software without specific prior written permission.
  24:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  25:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * 4. This software may only be redistributed and used in connection with an
  26:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *    Atmel microcontroller product.
  27:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  28:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR IMPLIED
  29:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
  30:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
  31:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR
  32:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  33:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
  34:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  35:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
  36:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  37:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  38:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * POSSIBILITY OF SUCH DAMAGE.
  39:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  40:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \asf_license_stop
  41:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  42:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
  43:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** #ifndef MACSC_MEGARF_H
  44:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** #define MACSC_MEGARF_H
  45:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
  46:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** #include <compiler.h>
  47:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** #include <parts.h>
  48:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** #include "status_codes.h"
  49:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
  50:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** #ifdef __cplusplus
  51:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** extern "C" {
  52:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** #endif
  53:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
  54:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
  55:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \defgroup macsc_group MAC Symbol Counter Driver(MACSC)
  56:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  57:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * See \ref megarf_macsc_quickstart
  58:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  59:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * This is a driver for the AVR MEGARF MAC Symbol Counter Driver(MACSC).
  60:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * It provides functions for enabling, disabling and configuring the module.
  61:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  62:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \section dependencies Dependencies
  63:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * This driver depends on the following modules:
  64:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * - \ref interrupt_group for ISR definition and disabling interrupts during
  65:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * critical code sections.
  66:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * @{
  67:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
  68:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
  69:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
  70:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Interrupt event callback function type
  71:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  72:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * The interrupt handler can be configured to do a function callback,
  73:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * the callback function must match the macsc_callback_t type.
  74:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  75:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
  76:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** typedef void (*macsc_callback_t)(void);
  77:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
  78:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /* ! MAC symbol counter compare Channel index */
  79:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** enum macsc_cc_channel {
  80:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	/* ! Channel 1 */
  81:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	MACSC_CC1 = 1,
  82:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	/* ! Channel 2 */
  83:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	MACSC_CC2 = 2,
  84:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	/* ! Channel 3 */
  85:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	MACSC_CC3 = 3,
  86:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** };
  87:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
  88:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief MAC SC clock source select
  89:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  90:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * uses the SCCKSEL bit in SSCR register to select macsc clk src
  91:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
  92:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * If the bit is one,the RTC clock from TOSC1 is selected, otherwise the symbol
  93:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * counter operates with the clock from XTAL1.
  94:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * During transceiver sleep modes the clock falls back to the RTC clock source,
  95:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * regardless of the selected clock. After wakeup, it switches back to the
  96:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * previosly
  97:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * selected clock source.
  98:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
  99:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 100:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** enum macsc_xtal {
 101:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	/* ! 16MHz as macsc clock */
 102:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	MACSC_16MHz = 0,
 103:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	MACSC_32KHz = 1,
 104:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** };
 105:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 106:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 107:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * @brief Reads the 32-bit timer register in the required order of bytes
 108:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 109:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * @param hh hh octet of 32-bit register
 110:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * @param hl hl octet of 32-bit register
 111:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * @param lh lh octet of 32-bit register
 112:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * @param ll ll octet of 32-bit register
 113:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 114:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * @returns uint32_t Value of timer register
 115:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 116:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** static inline uint32_t macsc_read32(volatile uint8_t *hh,
 117:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		volatile uint8_t *hl,
 118:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		volatile uint8_t *lh,
 119:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		volatile uint8_t *ll)
 120:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** {
 121:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	union {
 122:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		uint8_t a[4];
 123:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		uint32_t rv;
 124:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	}
 125:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	x;
 126:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 127:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	x.a[0] = *ll;
 128:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	x.a[1] = *lh;
 129:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	x.a[2] = *hl;
 130:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	x.a[3] = *hh;
 131:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 132:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	return x.rv;
 133:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** }
 134:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 135:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /* ! compare modes */
 136:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** #define MACSC_ABSOLUTE_CMP 0
 137:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** #define MACSC_RELATIVE_CMP 1
 138:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 139:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /** String concatenation by preprocessor used to create proper register names.
 140:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  **/
 141:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** #define CONCAT(a, b) a ## b
 142:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 143:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /** Creates proper subregister names and reads the corresponding values. */
 144:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** #define MACSC_READ32(reg)                  macsc_read32(&CONCAT(reg, HH), \
 145:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		&CONCAT(reg, HL), \
 146:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		&CONCAT(reg, LH), \
 147:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		&CONCAT(reg, LL))
 148:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 149:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** #define MACSC_WRITE32(reg, val)	\
 150:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	do { \
 151:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		union { uint8_t a[4]; uint32_t v; } \
 152:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		x; \
 153:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		x.v = val; \
 154:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		CONCAT(reg, HH) = x.a[3]; \
 155:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		CONCAT(reg, HL) = x.a[2]; \
 156:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		CONCAT(reg, LH) = x.a[1]; \
 157:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		CONCAT(reg, LL) = x.a[0]; \
 158:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	} \
 159:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	while (0)
 160:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 161:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 162:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Enable MAC SC
 163:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 164:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * Enables the SC
 165:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 166:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param clk_src selection of clk source,avalable options in macsc_xtal,fixed
 167:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *  prescalar
 168:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param sleep_enable enable RTC as clock source during sleep
 169:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param auto_ts enable automatic timestamping
 170:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 171:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 172:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** void macsc_enable(void);
 173:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 174:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 175:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Check if MACSC is enabled
 176:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 177:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * check if the MACSC is enabled.
 178:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 179:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param none
 180:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 181:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 182:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** bool is_macsc_enable(void);
 183:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 184:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 185:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Disable MAC SC
 186:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 187:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * Disables the MAC SC
 188:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 189:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param none
 190:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 191:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 192:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** void macsc_disable(void);
 193:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 194:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 195:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Check if back-off slot counter is enabled
 196:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 197:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * check if the back-off slot counter is enabled.
 198:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 199:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param none
 200:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 201:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 202:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** bool is_macsc_backoff_enable(void);
 203:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 204:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 205:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Enables compare interrupts of the MACSC
 206:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 207:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param channel Compare channel
 208:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 209:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** void macsc_enable_cmp_int(enum macsc_cc_channel channel);
 210:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 211:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 212:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Disables compare interrupts of the MACSC
 213:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 214:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param channel Compare channel
 215:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */void macsc_disable_cmp_int(enum macsc_cc_channel channel);
 216:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 217:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 218:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Usage of Absolute compare mode of the MACSC
 219:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 220:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param abs_rel  0 for absoulte cmp;1 for relative cmp
 221:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param cmp compare value for SCOCRx register
 222:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param channel Compare channel
 223:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 224:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** void macsc_use_cmp(bool abs_rel, uint32_t cmp,enum macsc_cc_channel channel);
 225:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 226:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 227:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \ingroup macsc_group
 228:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \defgroup macsc_interrupt_group MAC Symbol Counter (MACSC) interrupt
 229:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * management
 230:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * This group provides functions to configure MACSC module interrupts
 231:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 232:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * @{
 233:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 234:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 235:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 236:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Set MACSC overflow interrupt callback function
 237:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 238:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * This function allows the caller to set and change the interrupt callback
 239:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * function. Without setting a callback function the interrupt handler in the
 240:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * driver will only clear the interrupt flags.
 241:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 242:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param callback Reference to a callback function
 243:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 244:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** void macsc_set_ovf_int_cb(macsc_callback_t callback);
 245:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 246:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 247:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Set MACSC Compare Channel 1 interrupt callback function
 248:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 249:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * This function allows the caller to set and change the interrupt callback
 250:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * function. Without setting a callback function the interrupt handler in the
 251:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * driver will only clear the interrupt flags.
 252:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 253:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param callback Reference to a callback function
 254:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 255:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** void macsc_set_cmp1_int_cb(macsc_callback_t callback);
 256:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 257:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 258:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Set MACSC Compare Channel 2 interrupt callback function
 259:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 260:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * This function allows the caller to set and change the interrupt callback
 261:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * function. Without setting a callback function the interrupt handler in the
 262:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * driver will only clear the interrupt flags.
 263:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 264:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param callback Reference to a callback function
 265:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 266:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** void macsc_set_cmp2_int_cb(macsc_callback_t callback);
 267:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 268:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 269:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Set MACSC Compare Channel 3 interrupt callback function
 270:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 271:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * This function allows the caller to set and change the interrupt callback
 272:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * function. Without setting a callback function the interrupt handler in the
 273:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * driver will only clear the interrupt flags.
 274:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 275:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param callback Reference to a callback function
 276:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 277:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** void macsc_set_cmp3_int_cb(macsc_callback_t callback);
 278:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 279:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 280:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Set MACSC backoff slot counter interrupt callback function
 281:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 282:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * This function allows the caller to set and change the interrupt callback
 283:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * function. Without setting a callback function the interrupt handler in the
 284:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * driver will only clear the interrupt flags.
 285:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 286:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param callback Reference to a callback function
 287:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 288:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** void macsc_set_backoff_slot_cntr_int_cb(macsc_callback_t callback);
 289:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** //@}
 290:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 291:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 292:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Enable 32.768KHz clk using timer 2 async register
 293:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 294:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param none
 295:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 296:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 297:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** static inline void macsc_sleep_clk_enable(void)
 298:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** {
 299:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	ASSR |= (1 << AS2);
 300:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** }
 301:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 302:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 303:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Disable 32.768KHz clk using timer 2 async register
 304:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 305:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param none
 306:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 307:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** static inline void macsc_sleep_clk_disable(void)
 308:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** {
 309:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	ASSR &= ~(1 << AS2);
 310:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** }
 311:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 312:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /* @} */
 313:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 314:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 315:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Configure MAC Symbol Counter Clock Source
 316:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 317:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param macsc macsc clk src
 318:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 319:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** static inline void macsc_write_clock_source(enum macsc_xtal source)
 320:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** {
 321:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	if (source == MACSC_16MHz) {
 322:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		SCCR0 |= (source << SCCKSEL);
 323:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	} else if (source == MACSC_32KHz) {
 324:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		SCCR0 &= ~(1 << SCCKSEL);
 325:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	}
 326:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** }
 327:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 328:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 329:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Read MAC SC Clock Source
 330:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 331:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param none
 332:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \return macsc_xtal enum Clock source selection
 333:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 334:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** static inline enum macsc_xtal macsc_read_clock_source(void)
 335:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** {
 336:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	return (enum macsc_xtal)(SCCR0 & (1 << SCCKSEL));
 337:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** }
 338:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 339:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 340:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Write the Counter value of the MAC Symbol counter
 341:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 342:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param cnt_value Counter value
 343:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 344:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** static inline void macsc_write_count(uint32_t cnt_value)
 345:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** {
 346:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	MACSC_WRITE32(SCCNT, cnt_value);
 347:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** }
 348:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 349:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 350:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Reads the Counter value of the MAC Symbol counter
 351:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 352:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \note Output the Counter value
 353:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 354:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** static inline uint32_t macsc_read_count(void)
 355:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** {
 356:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	return (MACSC_READ32(SCCNT));
 357:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** }
 358:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 359:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 360:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief enable back-off slot counter
 361:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 362:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param none
 363:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \note  Enables interrupt as well	.
 364:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \note This counter works only if transceiver clock is running.So check Trx
 365:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * state in app before using this function in IEEE802.15.4 applications.
 366:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 367:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** static inline bool macsc_backoff_slot_cnt_enable(void)
 368:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** {
 369:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	if (!(PRR1 & (1 << PRTRX24))) {
 370:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		SCCR1 = (1 << SCENBO);
 371:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		SCIRQS |= (1 << IRQSBO);
 372:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		SCIRQM |= (1 << IRQMBO);
 373:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 		return true;
 374:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	}
 375:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	else return false;
 376:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** }
 377:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 378:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 379:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Disable back-off slot counter
 380:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 381:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \param none
 382:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \note    Disables interrupt as well	.
 383:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \note This counter works only if transceiver clock is running.So check Trx
 384:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * state in app before using this function in IEEE802.15.4 applications.
 385:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 386:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** static inline void macsc_backoff_slot_cnt_disable(void)
 387:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** {
 388:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	SCCR1 &= ~(1 << SCENBO);
 389:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	SCIRQM &= ~(1 << IRQMBO);
 390:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** }
 391:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 392:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 393:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Tests if the Backoff slot cntr interrupt flag is set
 394:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 395:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \return  backoff slot cntr interrupt has occurred or not : IRQSBO
 396:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 397:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** static inline bool macsc_is_slot_cntr_interrupt_flag_set(void)
 398:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** {
 399:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	return (SCIRQS & (1 << IRQSBO));
 400:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** }
 401:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 402:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 403:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Clears the Backoff Slot cntr interrupt flag
 404:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 405:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \note  IRQSBO is cleared
 406:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 407:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** static inline void macsc_clear_slot_cntr_interrupt_flag(void)
 408:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** {
 409:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	SCIRQS |= (1 << IRQSBO);
 410:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** }
 411:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 412:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 413:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Reads the SFD Timestamp register
 414:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 415:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \return Timestamp of last received frame :SCTSR(read-only register)
 416:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 417:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** static inline uint32_t macsc_read_ts(void)
 418:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** {
 419:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	return (MACSC_READ32(SCTSR));
 420:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** }
 421:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 422:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 423:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Reads the Beacon Timestamp register
 424:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 425:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \return Timestamp of last received beacon frame :SCBTSR
 426:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 427:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** static inline uint32_t macsc_read_bts(void)
 428:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** {
 429:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	return (MACSC_READ32(SCBTSR));
 430:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** }
 431:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 
 432:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** /**
 433:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * \brief Write the Beacon Timestamp register of the MAC Symbol counter
 434:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * The manual beacon timestamping can be used in conjunction with the
 435:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * relative compare mode of the three compare units to generate compare match
 436:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * interrupts without having a beacon frame received
 437:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 438:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * If set to 1, the current symbol counter value is stored into the beacon
 439:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * timestamp register.
 440:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  * The bit is cleared afterwards.
 441:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  *
 442:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h ****  */
 443:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** static inline void macsc_enable_manual_bts(void)
 444:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** {
 445               		.loc 5 444 0
 446               		.cfi_startproc
 447 019e CF93      		push r28
 448               	.LCFI26:
 449               		.cfi_def_cfa_offset 3
 450               		.cfi_offset 28, -2
 451 01a0 DF93      		push r29
 452               	.LCFI27:
 453               		.cfi_def_cfa_offset 4
 454               		.cfi_offset 29, -3
 455 01a2 CDB7      		in r28,__SP_L__
 456 01a4 DEB7      		in r29,__SP_H__
 457               	.LCFI28:
 458               		.cfi_def_cfa_register 28
 459               	/* prologue: function */
 460               	/* frame size = 0 */
 461               	/* stack size = 2 */
 462               	.L__stack_usage = 2
 445:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	SCCR0 |= (1 << SCMBTS);
 463               		.loc 5 445 0
 464 01a6 8CED      		ldi r24,lo8(-36)
 465 01a8 90E0      		ldi r25,0
 466 01aa 2CED      		ldi r18,lo8(-36)
 467 01ac 30E0      		ldi r19,0
 468 01ae F901      		movw r30,r18
 469 01b0 2081      		ld r18,Z
 470 01b2 2064      		ori r18,lo8(64)
 471 01b4 FC01      		movw r30,r24
 472 01b6 2083      		st Z,r18
 446:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** 	SCCR0 &= ~(1 << SCTSE);
 473               		.loc 5 446 0
 474 01b8 8CED      		ldi r24,lo8(-36)
 475 01ba 90E0      		ldi r25,0
 476 01bc 2CED      		ldi r18,lo8(-36)
 477 01be 30E0      		ldi r19,0
 478 01c0 F901      		movw r30,r18
 479 01c2 2081      		ld r18,Z
 480 01c4 277F      		andi r18,lo8(-9)
 481 01c6 FC01      		movw r30,r24
 482 01c8 2083      		st Z,r18
 447:../../../platform/mega_rf/drivers/macsc/macsc_megarf.h **** }
 483               		.loc 5 447 0
 484 01ca 0000      		nop
 485               	/* epilogue start */
 486 01cc DF91      		pop r29
 487 01ce CF91      		pop r28
 488 01d0 0895      		ret
 489               		.cfi_endproc
 490               	.LFE121:
 492               	.global	appState
 493               		.section	.bss.appState,"aw",@nobits
 496               	appState:
 497 0000 00        		.zero	1
 498               		.section	.bss.msgReq,"aw",@nobits
 501               	msgReq:
 502 0000 0000 0000 		.zero	20
 502      0000 0000 
 502      0000 0000 
 502      0000 0000 
 502      0000 0000 
 503               		.section	.bss.PanId,"aw",@nobits
 506               	PanId:
 507 0000 00        		.zero	1
 508               		.section	.rodata
 509               	.LC1:
 510 0000 0A4D 5347 		.string	"\nMSG REQ SENT %d"
 510      2052 4551 
 510      2053 454E 
 510      5420 2564 
 510      00
 511               		.text
 512               	.global	appSendData
 514               	appSendData:
 515               	.LFB130:
 516               		.file 6 "ServerLLDN.c"
   1:ServerLLDN.c  **** /*
   2:ServerLLDN.c  **** 	* ServerLLDN.c
   3:ServerLLDN.c  **** 	*
   4:ServerLLDN.c  **** 	* Created: 10/18/2019 5:15:37 PM
   5:ServerLLDN.c  **** 	*  Author: guilherme
   6:ServerLLDN.c  **** 	*/ 
   7:ServerLLDN.c  **** 
   8:ServerLLDN.c  **** #include <stdlib.h>
   9:ServerLLDN.c  **** #include <stdio.h>
  10:ServerLLDN.c  **** #include <string.h>
  11:ServerLLDN.c  **** #include <inttypes.h>
  12:ServerLLDN.c  **** #include "config.h"
  13:ServerLLDN.c  **** #include "sys.h"
  14:ServerLLDN.c  **** #include "phy.h"
  15:ServerLLDN.c  **** #include "sys.h"
  16:ServerLLDN.c  **** #include "nwk.h"
  17:ServerLLDN.c  **** #include "sysclk.h"
  18:ServerLLDN.c  **** #include "sysTimer.h"
  19:ServerLLDN.c  **** #include "sleep_mgr.h"
  20:ServerLLDN.c  **** #include "sleepmgr.h"
  21:ServerLLDN.c  **** #include "led.h"
  22:ServerLLDN.c  **** #include "ioport.h"
  23:ServerLLDN.c  **** #include "conf_sleepmgr.h"
  24:ServerLLDN.c  **** #include "board.h"
  25:ServerLLDN.c  **** #include "platform.h"
  26:ServerLLDN.c  **** 
  27:ServerLLDN.c  **** #include "lldn.h"
  28:ServerLLDN.c  **** 
  29:ServerLLDN.c  **** #if 1
  30:ServerLLDN.c  **** #if (SIO2HOST_CHANNEL == SIO_USB)
  31:ServerLLDN.c  **** /* Only ARM */
  32:ServerLLDN.c  **** #include "hw_timer_lldn.h"
  33:ServerLLDN.c  **** #include "stdio_usb.h"
  34:ServerLLDN.c  **** #define MASTER_MACSC	0
  35:ServerLLDN.c  **** #else
  36:ServerLLDN.c  **** /* Only megarf series */
  37:ServerLLDN.c  **** #include "conf_sio2host.h"
  38:ServerLLDN.c  **** #define MASTER_MACSC	1
  39:ServerLLDN.c  **** #endif
  40:ServerLLDN.c  **** #else
  41:ServerLLDN.c  **** /* Only megarf series */
  42:ServerLLDN.c  **** #define MASTER_MACSC		1
  43:ServerLLDN.c  **** #endif
  44:ServerLLDN.c  **** 
  45:ServerLLDN.c  **** #define HUMAM_READABLE			1
  46:ServerLLDN.c  **** 
  47:ServerLLDN.c  **** #if (MASTER_MACSC == 1)
  48:ServerLLDN.c  **** #include "macsc_megarf.h"
  49:ServerLLDN.c  **** #define TIMESLOT_TIMER 0
  50:ServerLLDN.c  **** #else
  51:ServerLLDN.c  **** static SYS_Timer_t				tmrBeaconInterval;			// Beacon
  52:ServerLLDN.c  **** static SYS_Timer_t				tmrComputeData;				// Compute data
  53:ServerLLDN.c  **** #endif
  54:ServerLLDN.c  **** 
  55:ServerLLDN.c  **** #define PRINT 1
  56:ServerLLDN.c  **** 
  57:ServerLLDN.c  **** 	
  58:ServerLLDN.c  **** // equation for tTS gives time in seconds, the division by SYMBOL_TIME changes to symbols for count
  59:ServerLLDN.c  **** AppState_t	appState = APP_STATE_INITIAL;
  60:ServerLLDN.c  **** static NWK_DataReq_t msgReq;
  61:ServerLLDN.c  **** static uint8_t PanId;
  62:ServerLLDN.c  **** 
  63:ServerLLDN.c  ****  void appSendData(void)
  64:ServerLLDN.c  **** {
 517               		.loc 6 64 0
 518               		.cfi_startproc
 519 01d2 CF93      		push r28
 520               	.LCFI29:
 521               		.cfi_def_cfa_offset 3
 522               		.cfi_offset 28, -2
 523 01d4 DF93      		push r29
 524               	.LCFI30:
 525               		.cfi_def_cfa_offset 4
 526               		.cfi_offset 29, -3
 527 01d6 CDB7      		in r28,__SP_L__
 528 01d8 DEB7      		in r29,__SP_H__
 529               	.LCFI31:
 530               		.cfi_def_cfa_register 28
 531               	/* prologue: function */
 532               	/* frame size = 0 */
 533               	/* stack size = 2 */
 534               	.L__stack_usage = 2
  65:ServerLLDN.c  **** 	if(msgReq.options != 0)
 535               		.loc 6 65 0
 536 01da 8091 0000 		lds r24,msgReq+9
 537 01de 9091 0000 		lds r25,msgReq+9+1
 538 01e2 892B      		or r24,r25
 539 01e4 01F0      		breq .L17
  66:ServerLLDN.c  **** 	{
  67:ServerLLDN.c  **** 		printf("\nMSG REQ SENT %d",msgReq.options);
 540               		.loc 6 67 0
 541 01e6 8091 0000 		lds r24,msgReq+9
 542 01ea 9091 0000 		lds r25,msgReq+9+1
 543 01ee 292F      		mov r18,r25
 544 01f0 2F93      		push r18
 545 01f2 8F93      		push r24
 546 01f4 80E0      		ldi r24,lo8(.LC1)
 547 01f6 90E0      		ldi r25,hi8(.LC1)
 548 01f8 892F      		mov r24,r25
 549 01fa 8F93      		push r24
 550 01fc 80E0      		ldi r24,lo8(.LC1)
 551 01fe 90E0      		ldi r25,hi8(.LC1)
 552 0200 8F93      		push r24
 553 0202 0E94 0000 		call printf
 554 0206 0F90      		pop __tmp_reg__
 555 0208 0F90      		pop __tmp_reg__
 556 020a 0F90      		pop __tmp_reg__
 557 020c 0F90      		pop __tmp_reg__
  68:ServerLLDN.c  **** 		NWK_DataReq(&msgReq);
 558               		.loc 6 68 0
 559 020e 80E0      		ldi r24,lo8(msgReq)
 560 0210 90E0      		ldi r25,hi8(msgReq)
 561 0212 0E94 0000 		call NWK_DataReq
 562               	.L17:
  69:ServerLLDN.c  **** 	#if !APP_COORDINATOR
  70:ServerLLDN.c  **** 	#endif
  71:ServerLLDN.c  **** 	}
  72:ServerLLDN.c  **** }
 563               		.loc 6 72 0
 564 0216 0000      		nop
 565               	/* epilogue start */
 566 0218 DF91      		pop r29
 567 021a CF91      		pop r28
 568 021c 0895      		ret
 569               		.cfi_endproc
 570               	.LFE130:
 572               	.global	payloadSize
 573               		.section	.data.payloadSize,"aw",@progbits
 576               	payloadSize:
 577 0000 16        		.byte	22
 578               	.global	assTimeSlot
 579               		.section	.data.assTimeSlot,"aw",@progbits
 582               	assTimeSlot:
 583 0000 FF        		.byte	-1
 584               		.comm	rec_beacon,2,1
 585               		.comm	ackframe,2,1
 586               		.section	.data.msgDiscResponse,"aw",@progbits
 589               	msgDiscResponse:
 590 0000 0D        		.byte	13
 591 0001 01        		.byte	1
 592 0002 96        		.byte	150
 593               		.section	.data.msgConfigStatus,"aw",@progbits
 596               	msgConfigStatus:
 597 0000 0E        		.byte	14
 598 0001 01        		.byte	1
 599 0002 FF        		.byte	-1
 600 0003 01        		.byte	1
 601 0004 96        		.byte	150
 602               	.global	data_payload
 603               		.section	.data.data_payload,"aw",@progbits
 606               	data_payload:
 607 0000 01        		.byte	1
 608               		.section	.bss.ack_received,"aw",@nobits
 611               	ack_received:
 612 0000 00        		.zero	1
 613               	.global	MacLLDNMgmtTS
 614               		.section	.bss.MacLLDNMgmtTS,"aw",@nobits
 617               	MacLLDNMgmtTS:
 618 0000 00        		.zero	1
 619               	.global	associated
 620               		.section	.bss.associated,"aw",@nobits
 623               	associated:
 624 0000 00        		.zero	1
 625               		.comm	ts_time,2,1
 626               	.global	STATE
 627               		.section	.data.STATE,"aw",@progbits
 630               	STATE:
 631 0000 0A        		.byte	10
 632               		.text
 634               	send_message_timeHandler:
 635               	.LFB131:
  73:ServerLLDN.c  **** 
  74:ServerLLDN.c  **** #if APP_COORDINATOR
  75:ServerLLDN.c  **** 
  76:ServerLLDN.c  **** 	#define NODOS_ASSOCIADOS_ESPERADOS 12
  77:ServerLLDN.c  **** 	
  78:ServerLLDN.c  **** 	AppPanState_t appPanState = APP_PAN_STATE_RESET; // Initial state of PAN node
  79:ServerLLDN.c  **** 	
  80:ServerLLDN.c  **** 	/* Configuration Request Frames */
  81:ServerLLDN.c  **** 	/* Da pra mudar o envio do confrequest pra ja usar essa array com as informas dos nodos */	
  82:ServerLLDN.c  **** 	nodes_info_t nodes_info_arr[50]; // Array for Configure Request messages, one position per node, 2
  83:ServerLLDN.c  **** 	NWK_ConfigRequest_t config_request_frame = { .id = LL_CONFIGURATION_REQUEST,
  84:ServerLLDN.c  **** 												 .s_macAddr = APP_ADDR,
  85:ServerLLDN.c  **** 												 .tx_channel = APP_CHANNEL,
  86:ServerLLDN.c  **** 												 .conf.macLLDNmgmtTS = MacLLDNMgmtTS };
  87:ServerLLDN.c  **** 	nodes_info_list_t *conf_req_list = NULL;
  88:ServerLLDN.c  **** 
  89:ServerLLDN.c  **** 	/* Acknowledge Frame and Array */
  90:ServerLLDN.c  **** 	NWK_ACKFormat_t ACKFrame;	// ACK Frame Payload used in Discovery State
  91:ServerLLDN.c  **** 	int ACKFrame_size = 0;
  92:ServerLLDN.c  **** 
  93:ServerLLDN.c  **** 	float beaconInterval = 0; // no precisa ser global
  94:ServerLLDN.c  **** 	float beaconInterval_association = 0;
  95:ServerLLDN.c  **** 	
  96:ServerLLDN.c  **** 	/* This timer implements a delay between messages, 
  97:ServerLLDN.c  **** 	 * if not used the nodes are not able to receive the message
  98:ServerLLDN.c  **** 	 */
  99:ServerLLDN.c  **** 	static SYS_Timer_t tmrDelay;	
 100:ServerLLDN.c  **** 	
 101:ServerLLDN.c  **** 	/*  Control variables for testing */	
 102:ServerLLDN.c  **** 	int assTimeSlot = 0;
 103:ServerLLDN.c  **** 	uint8_t timeslot_counter = 0;
 104:ServerLLDN.c  **** 
 105:ServerLLDN.c  **** 	int counter_associados = 0;		// Associated nodes counter
 106:ServerLLDN.c  **** 	uint8_t cycles_counter = macLLDNdiscoveryModeTimeout;
 107:ServerLLDN.c  **** 
 108:ServerLLDN.c  **** 	bool association_request = false;
 109:ServerLLDN.c  **** 
 110:ServerLLDN.c  **** 	/* data related variables */
 111:ServerLLDN.c  **** 	msg_info_t msg_info_array[50]; // size of array limited by hardware
 112:ServerLLDN.c  **** 	unsigned int size_msg_info = 0;
 113:ServerLLDN.c  **** 	bool data_received = false;	
 114:ServerLLDN.c  **** 	float succes_rate = 0;
 115:ServerLLDN.c  **** 	
 116:ServerLLDN.c  **** 	int counter_delay_msg = 0;
 117:ServerLLDN.c  **** 	
 118:ServerLLDN.c  **** 	static void tmrDelayHandler(SYS_Timer_t *timer)
 119:ServerLLDN.c  **** 	{
 120:ServerLLDN.c  **** 		printf("\ndelay handler");
 121:ServerLLDN.c  **** 		appState = APP_STATE_SEND;
 122:ServerLLDN.c  **** 	}
 123:ServerLLDN.c  **** 	
 124:ServerLLDN.c  **** 	static void lldn_server_beacon(void)
 125:ServerLLDN.c  **** 	{
 126:ServerLLDN.c  **** 		macsc_enable_manual_bts();
 127:ServerLLDN.c  **** 		appState = APP_STATE_SEND;
 128:ServerLLDN.c  **** 	}
 129:ServerLLDN.c  **** 	
 130:ServerLLDN.c  **** 	static void time_slot_handler(void)
 131:ServerLLDN.c  **** 	{
 132:ServerLLDN.c  **** 		if (timeslot_counter > 0)
 133:ServerLLDN.c  **** 			macsc_use_cmp(MACSC_RELATIVE_CMP, tTS / (SYMBOL_TIME), MACSC_CC1);
 134:ServerLLDN.c  **** 		
 135:ServerLLDN.c  **** 		macsc_enable_manual_bts();
 136:ServerLLDN.c  **** 		appState = APP_STATE_ATT_PAN_STATE;
 137:ServerLLDN.c  **** 		appPanState = APP_PAN_STATE_CHECK_TS;
 138:ServerLLDN.c  **** 	}
 139:ServerLLDN.c  **** 	
 140:ServerLLDN.c  **** 	static void downlink_delay_handler(void)
 141:ServerLLDN.c  **** 	{
 142:ServerLLDN.c  **** 		if(msgReq.options == NWK_OPT_MAC_COMMAND)
 143:ServerLLDN.c  **** 		{
 144:ServerLLDN.c  **** 			counter_delay_msg++;
 145:ServerLLDN.c  **** 			appState = APP_STATE_SEND;
 146:ServerLLDN.c  **** 		}
 147:ServerLLDN.c  **** 	}
 148:ServerLLDN.c  **** 
 149:ServerLLDN.c  **** 	static void end_of_association_delay_handler(void)
 150:ServerLLDN.c  **** 	{
 151:ServerLLDN.c  **** 		appState = APP_STATE_ATT_PAN_STATE;
 152:ServerLLDN.c  **** 		appPanState = APP_PAN_STATE_ONLINE_INITIAL;
 153:ServerLLDN.c  **** 	}
 154:ServerLLDN.c  **** 	
 155:ServerLLDN.c  **** 	#if TIMESLOT_TIMER
 156:ServerLLDN.c  **** 	static void teste_handler(void)
 157:ServerLLDN.c  **** 	{
 158:ServerLLDN.c  **** 		if(msgReq.options)
 159:ServerLLDN.c  **** 			printf("\n***TIMESLOT****");
 160:ServerLLDN.c  **** 		macsc_disable_cmp_int(MACSC_CC3);
 161:ServerLLDN.c  **** 	}
 162:ServerLLDN.c  **** 	#endif
 163:ServerLLDN.c  **** 	
 164:ServerLLDN.c  **** 	static bool addToAckArray(uint8_t addres)
 165:ServerLLDN.c  **** 	{	
 166:ServerLLDN.c  **** 		int pos =(int) addres / 8;
 167:ServerLLDN.c  **** 		int bit_shift = 8 - (addres % 8);
 168:ServerLLDN.c  **** 		
 169:ServerLLDN.c  **** 		if(ACKFrame.ackFlags[pos] & 1 << bit_shift)
 170:ServerLLDN.c  **** 		{
 171:ServerLLDN.c  **** 			printf("\nAddr rep %d", addres);
 172:ServerLLDN.c  **** 			return false;
 173:ServerLLDN.c  **** 		}
 174:ServerLLDN.c  **** 		ACKFrame.ackFlags[pos] |= 1 << bit_shift;
 175:ServerLLDN.c  **** 		if (pos + 1 > ACKFrame_size)
 176:ServerLLDN.c  **** 			ACKFrame_size = pos + 1;
 177:ServerLLDN.c  **** 		
 178:ServerLLDN.c  **** 		return true;
 179:ServerLLDN.c  **** 	}
 180:ServerLLDN.c  **** 
 181:ServerLLDN.c  **** 	static void addConfRequestArray(NWK_ConfigStatus_t *node)
 182:ServerLLDN.c  **** 	{
 183:ServerLLDN.c  **** 
 184:ServerLLDN.c  **** 		uint8_t i;
 185:ServerLLDN.c  **** 		for (i= 0;i < 256 && nodes_info_arr[i].mac_addr != 0; i++);
 186:ServerLLDN.c  **** 		
 187:ServerLLDN.c  **** 		assTimeSlot++;
 188:ServerLLDN.c  **** 	
 189:ServerLLDN.c  **** 		if(node->ts_dir.tsDuration > config_request_frame.conf.tsDuration)
 190:ServerLLDN.c  **** 			config_request_frame.conf.tsDuration =  node->ts_dir.tsDuration;
 191:ServerLLDN.c  **** 		
 192:ServerLLDN.c  **** 		nodes_info_arr[i].req_timeslot_duration = node->ts_dir.tsDuration;
 193:ServerLLDN.c  **** 		nodes_info_arr[i].mac_addr = node->macAddr;
 194:ServerLLDN.c  **** 		nodes_info_arr[i].assigned_time_slot = (uint8_t)i;
 195:ServerLLDN.c  **** 		
 196:ServerLLDN.c  **** 		if(conf_req_list != NULL)
 197:ServerLLDN.c  **** 		{
 198:ServerLLDN.c  **** 			nodes_info_list_t *tmp = (nodes_info_list_t*)malloc(sizeof(nodes_info_list_t));
 199:ServerLLDN.c  **** 			tmp->node = &nodes_info_arr[i];
 200:ServerLLDN.c  **** 			tmp->next = conf_req_list;
 201:ServerLLDN.c  **** 			conf_req_list = tmp;
 202:ServerLLDN.c  **** 		}
 203:ServerLLDN.c  **** 		else
 204:ServerLLDN.c  **** 		{
 205:ServerLLDN.c  **** 			conf_req_list = (nodes_info_list_t*)malloc(sizeof(nodes_info_list_t));
 206:ServerLLDN.c  **** 			conf_req_list->node = &nodes_info_arr[i];
 207:ServerLLDN.c  **** 			conf_req_list->next = NULL;
 208:ServerLLDN.c  **** 		}
 209:ServerLLDN.c  **** 	}
 210:ServerLLDN.c  **** 
 211:ServerLLDN.c  **** 	static void CopyToConfigRequest()
 212:ServerLLDN.c  **** 	{
 213:ServerLLDN.c  **** 		config_request_frame.assTimeSlot = conf_req_list->node->assigned_time_slot;
 214:ServerLLDN.c  **** 		config_request_frame.macAddr = conf_req_list->node->mac_addr;
 215:ServerLLDN.c  **** 		nodes_info_list_t *tmp = conf_req_list;
 216:ServerLLDN.c  **** 		conf_req_list = conf_req_list->next;
 217:ServerLLDN.c  **** 		tmp->node = NULL;
 218:ServerLLDN.c  **** 		tmp->next = NULL;
 219:ServerLLDN.c  **** 		free(tmp);
 220:ServerLLDN.c  **** 	}
 221:ServerLLDN.c  **** 
 222:ServerLLDN.c  **** 
 223:ServerLLDN.c  **** 	static bool appCommandInd(NWK_DataInd_t *ind)
 224:ServerLLDN.c  **** 	{
 225:ServerLLDN.c  **** 		if(ind->data[0] == LL_DISCOVER_RESPONSE)
 226:ServerLLDN.c  **** 		{
 227:ServerLLDN.c  **** 			NWK_DiscoverResponse_t *msg = (NWK_DiscoverResponse_t*)ind->data;
 228:ServerLLDN.c  **** 			addToAckArray(msg->macAddr);	
 229:ServerLLDN.c  **** 					
 230:ServerLLDN.c  **** 			#if PRINT
 231:ServerLLDN.c  **** 			printf("\nDISC %hhx", msg->macAddr);	
 232:ServerLLDN.c  **** 			#endif
 233:ServerLLDN.c  **** 		}
 234:ServerLLDN.c  **** 		else if(ind->data[0] == LL_CONFIGURATION_STATUS)
 235:ServerLLDN.c  **** 		{
 236:ServerLLDN.c  **** 			NWK_ConfigStatus_t *msg = (NWK_ConfigStatus_t*)ind->data;
 237:ServerLLDN.c  **** 			addConfRequestArray(msg);
 238:ServerLLDN.c  **** 			#if PRINT
 239:ServerLLDN.c  **** 			printf("\nCONF %d", msg->macAddr);	
 240:ServerLLDN.c  **** 			#endif
 241:ServerLLDN.c  **** 		}
 242:ServerLLDN.c  **** 		else return false;			
 243:ServerLLDN.c  **** 		return true;
 244:ServerLLDN.c  **** 	}
 245:ServerLLDN.c  **** 	
 246:ServerLLDN.c  **** 	static bool appDataInd(NWK_DataInd_t *ind)
 247:ServerLLDN.c  **** 	{
 248:ServerLLDN.c  **** 		if(!data_received && timeslot_counter > 1)
 249:ServerLLDN.c  **** 		{
 250:ServerLLDN.c  **** 		int curr_ts = timeslot_counter - 2*MacLLDNMgmtTS;
 251:ServerLLDN.c  **** 		data_received = true;
 252:ServerLLDN.c  **** 		
 253:ServerLLDN.c  **** 		nodes_info_arr[curr_ts].rssi = ind->rssi;
 254:ServerLLDN.c  **** 		nodes_info_arr[curr_ts].average_rssi = (nodes_info_arr[curr_ts].rssi + nodes_info_arr[curr_ts].av
 255:ServerLLDN.c  **** 															/(nodes_info_arr[curr_ts].msg_rec + 1);
 256:ServerLLDN.c  **** 		nodes_info_arr[curr_ts].msg_rec++;
 257:ServerLLDN.c  **** 
 258:ServerLLDN.c  **** 		addToAckArray(curr_ts);
 259:ServerLLDN.c  **** 		
 260:ServerLLDN.c  **** 		printf("\n %d payload: ", curr_ts);
 261:ServerLLDN.c  **** 		
 262:ServerLLDN.c  **** 		msg_info_array[curr_ts].size = ind->size;		
 263:ServerLLDN.c  **** 		for (int i = 0; i < ind->size; i++)
 264:ServerLLDN.c  **** 			{
 265:ServerLLDN.c  **** 			msg_info_array[curr_ts].data_payload[i] = ind->data[i];
 266:ServerLLDN.c  **** 			printf("%hhx", msg_info_array[curr_ts].data_payload[i]);
 267:ServerLLDN.c  **** 			}
 268:ServerLLDN.c  **** 		}
 269:ServerLLDN.c  **** 	}
 270:ServerLLDN.c  **** 	
 271:ServerLLDN.c  **** 	static void appPanPrepareACK(void)
 272:ServerLLDN.c  **** 	{
 273:ServerLLDN.c  **** 		msgReq.dstAddr		= 0;
 274:ServerLLDN.c  **** 		msgReq.dstEndpoint	= APP_BEACON_ENDPOINT;
 275:ServerLLDN.c  **** 		msgReq.srcEndpoint	= APP_BEACON_ENDPOINT;
 276:ServerLLDN.c  **** 		msgReq.options		= NWK_OPT_LLDN_ACK;
 277:ServerLLDN.c  **** 		msgReq.data	= (uint8_t *)&ACKFrame;
 278:ServerLLDN.c  **** 		msgReq.size	= sizeof(uint8_t)*(ACKFrame_size + 1);
 279:ServerLLDN.c  **** 
 280:ServerLLDN.c  **** 	}
 281:ServerLLDN.c  **** 
 282:ServerLLDN.c  **** 	static void appPanReset(void)
 283:ServerLLDN.c  **** 	{
 284:ServerLLDN.c  **** 		// prepare beacon reset message
 285:ServerLLDN.c  **** 		msgReq.dstAddr		= 0;
 286:ServerLLDN.c  **** 		msgReq.dstEndpoint	= APP_BEACON_ENDPOINT;
 287:ServerLLDN.c  **** 		msgReq.srcEndpoint	= APP_BEACON_ENDPOINT;
 288:ServerLLDN.c  **** 		msgReq.options		= NWK_OPT_LLDN_BEACON | NWK_OPT_RESET_STATE;
 289:ServerLLDN.c  **** 		msgReq.data			= NULL;
 290:ServerLLDN.c  **** 		msgReq.size			= 0;
 291:ServerLLDN.c  **** 
 292:ServerLLDN.c  **** 		for(int i = 0; i < 32; i++)
 293:ServerLLDN.c  **** 			ACKFrame.ackFlags[i] = 0;
 294:ServerLLDN.c  **** 			
 295:ServerLLDN.c  **** 		for (int i = 0; i < 50; i++)
 296:ServerLLDN.c  **** 		{
 297:ServerLLDN.c  **** 			nodes_info_arr[i].mac_addr = 0;
 298:ServerLLDN.c  **** 			nodes_info_arr[i].msg_rec = 0;
 299:ServerLLDN.c  **** 
 300:ServerLLDN.c  **** 			
 301:ServerLLDN.c  **** 			msg_info_array[i].mac_addr = 0;
 302:ServerLLDN.c  **** 			msg_info_array[i].coop_addr = 0;
 303:ServerLLDN.c  **** 			for (int j = 0; j < 50; j++)
 304:ServerLLDN.c  **** 				nodes_info_arr[i].neighbors[j] = 0;
 305:ServerLLDN.c  **** 		}
 306:ServerLLDN.c  **** 		// assTimeSlot = MacLLDNMgmtTS * 2;	
 307:ServerLLDN.c  **** 		ACKFrame_size = 0;
 308:ServerLLDN.c  **** 		counter_associados = 0;
 309:ServerLLDN.c  **** 		macLLDNnumUplinkTS = 0;
 310:ServerLLDN.c  **** 		n = 0;
 311:ServerLLDN.c  **** 	}
 312:ServerLLDN.c  **** 
 313:ServerLLDN.c  **** 	static void appPanDiscInit(void)
 314:ServerLLDN.c  **** 	{	
 315:ServerLLDN.c  **** 		/* clearray of previous discovery state */
 316:ServerLLDN.c  **** 		for(int i = 0; i < 32; i++)
 317:ServerLLDN.c  **** 			ACKFrame.ackFlags[i] = 0;
 318:ServerLLDN.c  **** 		ACKFrame_size = 0;
 319:ServerLLDN.c  **** 		/* Prepare Beacon Message as first beacon in discovery state */		
 320:ServerLLDN.c  **** 		msgReq.dstAddr				= 0;
 321:ServerLLDN.c  **** 		msgReq.dstEndpoint			= APP_BEACON_ENDPOINT;
 322:ServerLLDN.c  **** 		msgReq.srcEndpoint			= APP_BEACON_ENDPOINT;
 323:ServerLLDN.c  **** 		msgReq.options				= NWK_OPT_LLDN_BEACON | NWK_OPT_DISCOVERY_STATE;
 324:ServerLLDN.c  **** 		msgReq.data					= NULL;
 325:ServerLLDN.c  **** 		msgReq.size					= 0;
 326:ServerLLDN.c  **** 		
 327:ServerLLDN.c  **** 		
 328:ServerLLDN.c  **** 		/* Only start timers if it is the first association process */
 329:ServerLLDN.c  **** 		if(cycles_counter == 0) 
 330:ServerLLDN.c  **** 		{
 331:ServerLLDN.c  **** 			
 332:ServerLLDN.c  **** 		/* Calculates Beacon Intervals according to 802.15.4e - 2012 p. 70 */
 333:ServerLLDN.c  **** 		n = 127; 
 334:ServerLLDN.c  **** 		tTS =  ((p_var*sp + (m+n)*sm + macMinLIFSPeriod)/v_var);
 335:ServerLLDN.c  **** 		#if (MASTER_MACSC == 1)
 336:ServerLLDN.c  **** 		
 337:ServerLLDN.c  **** 			beaconInterval_association = 2 * numBaseTimeSlotperMgmt_association * (tTS) / (SYMBOL_TIME);
 338:ServerLLDN.c  **** 			/*
 339:ServerLLDN.c  **** 			* Configure interrupts callback functions
 340:ServerLLDN.c  **** 			* overflow interrupt, compare 1,2,3 interrupts
 341:ServerLLDN.c  **** 			*/
 342:ServerLLDN.c  **** 			macsc_set_cmp1_int_cb(lldn_server_beacon);
 343:ServerLLDN.c  **** 			/*
 344:ServerLLDN.c  **** 			* Configure MACSC to generate compare interrupts from channels 1,2,3
 345:ServerLLDN.c  **** 			* Set compare mode to absolute, set compare value.
 346:ServerLLDN.c  **** 			*/
 347:ServerLLDN.c  **** 			macsc_enable_manual_bts();
 348:ServerLLDN.c  **** 			macsc_enable_cmp_int(MACSC_CC1);
 349:ServerLLDN.c  **** 
 350:ServerLLDN.c  **** 			macsc_use_cmp(MACSC_RELATIVE_CMP, beaconInterval_association , MACSC_CC1);
 351:ServerLLDN.c  **** 			
 352:ServerLLDN.c  **** 			/* Timer used in testing */
 353:ServerLLDN.c  **** 			#if TIMESLOT_TIMER
 354:ServerLLDN.c  **** 			macsc_set_cmp2_int_cb(teste_handler);	
 355:ServerLLDN.c  **** 			macsc_enable_cmp_int(MACSC_CC2);
 356:ServerLLDN.c  **** 			macsc_use_cmp(MACSC_RELATIVE_CMP, beaconInterval_association / 2, MACSC_CC2);
 357:ServerLLDN.c  **** 			#endif
 358:ServerLLDN.c  **** 			
 359:ServerLLDN.c  **** 		#endif
 360:ServerLLDN.c  **** 		}
 361:ServerLLDN.c  **** 	}
 362:ServerLLDN.c  **** 
 363:ServerLLDN.c  **** 	static void appPanOnlineInit()
 364:ServerLLDN.c  **** 	{
 365:ServerLLDN.c  **** 			timeslot_counter = 0;
 366:ServerLLDN.c  **** 			
 367:ServerLLDN.c  **** 			tTS =  ((p_var*sp + (m+ config_request_frame.conf.tsDuration )*sm + macMinLIFSPeriod)/v_var);
 368:ServerLLDN.c  **** 			
 369:ServerLLDN.c  **** 			n = config_request_frame.conf.tsDuration;
 370:ServerLLDN.c  **** 			
 371:ServerLLDN.c  **** 			msgReq.dstAddr		= 0;
 372:ServerLLDN.c  **** 			msgReq.dstEndpoint	= APP_BEACON_ENDPOINT;
 373:ServerLLDN.c  **** 			msgReq.srcEndpoint	= APP_BEACON_ENDPOINT;
 374:ServerLLDN.c  **** 			msgReq.options		= NWK_OPT_LLDN_BEACON | NWK_OPT_ONLINE_STATE;
 375:ServerLLDN.c  **** 			
 376:ServerLLDN.c  **** 			if(macLLDNRetransmitTS > 0)
 377:ServerLLDN.c  **** 			{
 378:ServerLLDN.c  **** 				msgReq.data		= &ACKFrame.ackFlags[macLLDNRetransmitTS + 1];
 379:ServerLLDN.c  **** 				msgReq.size		= macLLDNRetransmitTS;
 380:ServerLLDN.c  **** 			}
 381:ServerLLDN.c  **** 			else
 382:ServerLLDN.c  **** 			{
 383:ServerLLDN.c  **** 				msgReq.data					= NULL;
 384:ServerLLDN.c  **** 				msgReq.size					= 0;	
 385:ServerLLDN.c  **** 			}
 386:ServerLLDN.c  **** 			
 387:ServerLLDN.c  **** 			// (number of time slots x mgmt time solts) x base timelosts
 388:ServerLLDN.c  **** 			beaconInterval = (assTimeSlot * 2 + 1 + 2*MacLLDNMgmtTS) * tTS / (SYMBOL_TIME);
 389:ServerLLDN.c  **** 			
 390:ServerLLDN.c  **** 			// Configure Timers
 391:ServerLLDN.c  **** 			macsc_set_cmp1_int_cb(time_slot_handler);
 392:ServerLLDN.c  **** 			
 393:ServerLLDN.c  **** 			macsc_enable_manual_bts();
 394:ServerLLDN.c  **** 			
 395:ServerLLDN.c  **** 			macsc_enable_cmp_int(MACSC_CC1);
 396:ServerLLDN.c  **** 			macsc_use_cmp(MACSC_RELATIVE_CMP, numBaseTimeSlotperMgmt_online * tTS / (SYMBOL_TIME), MACSC_CC1
 397:ServerLLDN.c  **** 			
 398:ServerLLDN.c  **** 			NWK_OpenEndpoint(APP_DATA_ENDPOINT, appDataInd);
 399:ServerLLDN.c  **** 	}
 400:ServerLLDN.c  **** 
 401:ServerLLDN.c  **** #else 
 402:ServerLLDN.c  **** 	uint8_t payloadSize = 22;
 403:ServerLLDN.c  **** 	uint8_t assTimeSlot = 0xFF;
 404:ServerLLDN.c  **** 	uint8_t n = 0;
 405:ServerLLDN.c  **** 	
 406:ServerLLDN.c  **** 	NwkFrameBeaconHeaderLLDN_t *rec_beacon;
 407:ServerLLDN.c  **** 	NWK_ACKFormat_t *ackframe;
 408:ServerLLDN.c  **** 	static NWK_DiscoverResponse_t msgDiscResponse = { .id = LL_DISCOVER_RESPONSE,
 409:ServerLLDN.c  **** 													 .macAddr = APP_ADDR,
 410:ServerLLDN.c  **** 													 .ts_dir.tsDuration = 22,
 411:ServerLLDN.c  **** 													 .ts_dir.dirIndicator = 0b1 };
 412:ServerLLDN.c  **** 	static NWK_ConfigStatus_t msgConfigStatus = { .id = LL_CONFIGURATION_STATUS,
 413:ServerLLDN.c  **** 												 .macAddr = APP_ADDR,
 414:ServerLLDN.c  **** 												 .s_macAddr = APP_ADDR,
 415:ServerLLDN.c  **** 												 .ts_dir.tsDuration = 22,
 416:ServerLLDN.c  **** 												 .ts_dir.dirIndicator = 1,
 417:ServerLLDN.c  **** 												 .assTimeSlot = 0xff };
 418:ServerLLDN.c  **** 	uint8_t data_payload = APP_ADDR;
 419:ServerLLDN.c  **** 	static bool ack_received;
 420:ServerLLDN.c  **** 	bool MacLLDNMgmtTS = 0; 
 421:ServerLLDN.c  **** 	bool associated = 0;
 422:ServerLLDN.c  **** 	int ts_time;
 423:ServerLLDN.c  **** 	uint8_t STATE = 10;
 424:ServerLLDN.c  **** 	
 425:ServerLLDN.c  **** 	static void send_message_timeHandler(void)
 426:ServerLLDN.c  **** 	{
 636               		.loc 6 426 0
 637               		.cfi_startproc
 638 021e CF93      		push r28
 639               	.LCFI32:
 640               		.cfi_def_cfa_offset 3
 641               		.cfi_offset 28, -2
 642 0220 DF93      		push r29
 643               	.LCFI33:
 644               		.cfi_def_cfa_offset 4
 645               		.cfi_offset 29, -3
 646 0222 CDB7      		in r28,__SP_L__
 647 0224 DEB7      		in r29,__SP_H__
 648               	.LCFI34:
 649               		.cfi_def_cfa_register 28
 650               	/* prologue: function */
 651               	/* frame size = 0 */
 652               	/* stack size = 2 */
 653               	.L__stack_usage = 2
 427:ServerLLDN.c  **** 		appState = APP_STATE_SEND;	
 654               		.loc 6 427 0
 655 0226 82E0      		ldi r24,lo8(2)
 656 0228 8093 0000 		sts appState,r24
 428:ServerLLDN.c  **** 		#if MASTER_MACSC == 0
 429:ServerLLDN.c  **** 			timer_stop();
 430:ServerLLDN.c  **** 		#endif
 431:ServerLLDN.c  **** 	}
 657               		.loc 6 431 0
 658 022c 0000      		nop
 659               	/* epilogue start */
 660 022e DF91      		pop r29
 661 0230 CF91      		pop r28
 662 0232 0895      		ret
 663               		.cfi_endproc
 664               	.LFE131:
 667               	start_timer:
 668               	.LFB132:
 432:ServerLLDN.c  **** 
 433:ServerLLDN.c  **** 	static void start_timer(int delay)
 434:ServerLLDN.c  **** 	{
 669               		.loc 6 434 0
 670               		.cfi_startproc
 671 0234 CF93      		push r28
 672               	.LCFI35:
 673               		.cfi_def_cfa_offset 3
 674               		.cfi_offset 28, -2
 675 0236 DF93      		push r29
 676               	.LCFI36:
 677               		.cfi_def_cfa_offset 4
 678               		.cfi_offset 29, -3
 679 0238 00D0      		rcall .
 680               	.LCFI37:
 681               		.cfi_def_cfa_offset 6
 682 023a CDB7      		in r28,__SP_L__
 683 023c DEB7      		in r29,__SP_H__
 684               	.LCFI38:
 685               		.cfi_def_cfa_register 28
 686               	/* prologue: function */
 687               	/* frame size = 2 */
 688               	/* stack size = 4 */
 689               	.L__stack_usage = 4
 690 023e 9A83      		std Y+2,r25
 691 0240 8983      		std Y+1,r24
 435:ServerLLDN.c  **** 		#if MASTER_MACSC
 436:ServerLLDN.c  **** 		macsc_enable_manual_bts();
 692               		.loc 6 436 0
 693 0242 0E94 0000 		call macsc_enable_manual_bts
 437:ServerLLDN.c  **** 		macsc_set_cmp1_int_cb(send_message_timeHandler);
 694               		.loc 6 437 0
 695 0246 80E0      		ldi r24,lo8(gs(send_message_timeHandler))
 696 0248 90E0      		ldi r25,hi8(gs(send_message_timeHandler))
 697 024a 0E94 0000 		call macsc_set_cmp1_int_cb
 438:ServerLLDN.c  **** 		macsc_enable_cmp_int(MACSC_CC1);
 698               		.loc 6 438 0
 699 024e 81E0      		ldi r24,lo8(1)
 700 0250 0E94 0000 		call macsc_enable_cmp_int
 439:ServerLLDN.c  **** 		macsc_use_cmp(MACSC_RELATIVE_CMP, delay - 125, MACSC_CC1);
 701               		.loc 6 439 0
 702 0254 8981      		ldd r24,Y+1
 703 0256 9A81      		ldd r25,Y+2
 704 0258 8D57      		subi r24,125
 705 025a 9109      		sbc r25,__zero_reg__
 706 025c 092E      		mov __tmp_reg__,r25
 707 025e 000C      		lsl r0
 708 0260 AA0B      		sbc r26,r26
 709 0262 BB0B      		sbc r27,r27
 710 0264 21E0      		ldi r18,lo8(1)
 711 0266 AC01      		movw r20,r24
 712 0268 BD01      		movw r22,r26
 713 026a 81E0      		ldi r24,lo8(1)
 714 026c 0E94 0000 		call macsc_use_cmp
 440:ServerLLDN.c  **** 		#else
 441:ServerLLDN.c  **** 		timer_init();
 442:ServerLLDN.c  **** 		timer_delay(delay/2);
 443:ServerLLDN.c  **** 		hw_timer_setup_handler(send_message_timeHandler);
 444:ServerLLDN.c  **** 		timer_start();
 445:ServerLLDN.c  **** 		#endif
 446:ServerLLDN.c  **** 	}
 715               		.loc 6 446 0
 716 0270 0000      		nop
 717               	/* epilogue start */
 718 0272 0F90      		pop __tmp_reg__
 719 0274 0F90      		pop __tmp_reg__
 720 0276 DF91      		pop r29
 721 0278 CF91      		pop r28
 722 027a 0895      		ret
 723               		.cfi_endproc
 724               	.LFE132:
 726               	.global	__floatsisf
 727               	.global	__addsf3
 728               	.global	__divsf3
 729               	.global	__fixsfsi
 730               		.section	.rodata
 731               	.LC2:
 732 0011 0A20 5265 		.string	"\n Reset beacon"
 732      7365 7420 
 732      6265 6163 
 732      6F6E 00
 733               		.text
 735               	appBeaconInd:
 736               	.LFB133:
 447:ServerLLDN.c  **** 	
 448:ServerLLDN.c  **** 	static bool appBeaconInd(NWK_DataInd_t *ind)
 449:ServerLLDN.c  **** 	{
 737               		.loc 6 449 0
 738               		.cfi_startproc
 739 027c CF93      		push r28
 740               	.LCFI39:
 741               		.cfi_def_cfa_offset 3
 742               		.cfi_offset 28, -2
 743 027e DF93      		push r29
 744               	.LCFI40:
 745               		.cfi_def_cfa_offset 4
 746               		.cfi_offset 29, -3
 747 0280 00D0      		rcall .
 748 0282 00D0      		rcall .
 749 0284 00D0      		rcall .
 750               	.LCFI41:
 751               		.cfi_def_cfa_offset 10
 752 0286 CDB7      		in r28,__SP_L__
 753 0288 DEB7      		in r29,__SP_H__
 754               	.LCFI42:
 755               		.cfi_def_cfa_register 28
 756               	/* prologue: function */
 757               	/* frame size = 6 */
 758               	/* stack size = 8 */
 759               	.L__stack_usage = 8
 760 028a 9E83      		std Y+6,r25
 761 028c 8D83      		std Y+5,r24
 450:ServerLLDN.c  **** 		rec_beacon = (NwkFrameBeaconHeaderLLDN_t*)ind->data;
 762               		.loc 6 450 0
 763 028e 8D81      		ldd r24,Y+5
 764 0290 9E81      		ldd r25,Y+6
 765 0292 FC01      		movw r30,r24
 766 0294 8085      		ldd r24,Z+8
 767 0296 9185      		ldd r25,Z+9
 768 0298 9093 0000 		sts rec_beacon+1,r25
 769 029c 8093 0000 		sts rec_beacon,r24
 451:ServerLLDN.c  **** 		STATE = rec_beacon->Flags.txState;
 770               		.loc 6 451 0
 771 02a0 8091 0000 		lds r24,rec_beacon
 772 02a4 9091 0000 		lds r25,rec_beacon+1
 773 02a8 FC01      		movw r30,r24
 774 02aa 8381      		ldd r24,Z+3
 775 02ac 8770      		andi r24,lo8(7)
 776 02ae 8093 0000 		sts STATE,r24
 452:ServerLLDN.c  **** 		PanId = rec_beacon->PanId;
 777               		.loc 6 452 0
 778 02b2 8091 0000 		lds r24,rec_beacon
 779 02b6 9091 0000 		lds r25,rec_beacon+1
 780 02ba FC01      		movw r30,r24
 781 02bc 8481      		ldd r24,Z+4
 782 02be 8093 0000 		sts PanId,r24
 453:ServerLLDN.c  **** 		//  bom implementar rotinas pra se o nodo estiver associado a um coordeandor e se no estiver
 454:ServerLLDN.c  **** 		if( ((rec_beacon->Flags.txState == DISC_MODE && !ack_received && rec_beacon->confSeqNumber == 0x0
 783               		.loc 6 454 0
 784 02c2 8091 0000 		lds r24,rec_beacon
 785 02c6 9091 0000 		lds r25,rec_beacon+1
 786 02ca FC01      		movw r30,r24
 787 02cc 8381      		ldd r24,Z+3
 788 02ce 8770      		andi r24,lo8(7)
 789 02d0 8430      		cpi r24,lo8(4)
 790 02d2 01F4      		brne .L21
 791               		.loc 6 454 0 is_stmt 0 discriminator 1
 792 02d4 9091 0000 		lds r25,ack_received
 793 02d8 81E0      		ldi r24,lo8(1)
 794 02da 8927      		eor r24,r25
 795 02dc 8823      		tst r24
 796 02de 01F0      		breq .L21
 797               		.loc 6 454 0 discriminator 3
 798 02e0 8091 0000 		lds r24,rec_beacon
 799 02e4 9091 0000 		lds r25,rec_beacon+1
 800 02e8 FC01      		movw r30,r24
 801 02ea 8581      		ldd r24,Z+5
 802 02ec 8823      		tst r24
 803 02ee 01F0      		breq .L22
 804               	.L21:
 455:ServerLLDN.c  **** 			(rec_beacon->Flags.txState == CONFIG_MODE && ack_received)) && associated == 0)
 805               		.loc 6 455 0 is_stmt 1 discriminator 5
 806 02f0 8091 0000 		lds r24,rec_beacon
 807 02f4 9091 0000 		lds r25,rec_beacon+1
 808 02f8 FC01      		movw r30,r24
 809 02fa 8381      		ldd r24,Z+3
 810 02fc 8770      		andi r24,lo8(7)
 454:ServerLLDN.c  **** 			(rec_beacon->Flags.txState == CONFIG_MODE && ack_received)) && associated == 0)
 811               		.loc 6 454 0 discriminator 5
 812 02fe 8630      		cpi r24,lo8(6)
 813 0300 01F0      		breq .+2
 814 0302 00C0      		rjmp .L23
 815               		.loc 6 455 0
 816 0304 8091 0000 		lds r24,ack_received
 817 0308 8823      		tst r24
 818 030a 01F4      		brne .+2
 819 030c 00C0      		rjmp .L23
 820               	.L22:
 821               		.loc 6 455 0 is_stmt 0 discriminator 1
 822 030e 9091 0000 		lds r25,associated
 823 0312 81E0      		ldi r24,lo8(1)
 824 0314 8927      		eor r24,r25
 825 0316 8823      		tst r24
 826 0318 01F4      		brne .+2
 827 031a 00C0      		rjmp .L23
 828               	.LBB2:
 456:ServerLLDN.c  **** 		{
 457:ServerLLDN.c  **** 	
 458:ServerLLDN.c  **** 			ts_time =  ((p_var*sp + (m+ rec_beacon->TimeSlotSize  )*sm + macMinLIFSPeriod)/v_var)  / (SYMBOL
 829               		.loc 6 458 0 is_stmt 1
 830 031c 8091 0000 		lds r24,rec_beacon
 831 0320 9091 0000 		lds r25,rec_beacon+1
 832 0324 FC01      		movw r30,r24
 833 0326 8681      		ldd r24,Z+6
 834 0328 882F      		mov r24,r24
 835 032a 90E0      		ldi r25,0
 836 032c 0396      		adiw r24,3
 837 032e 880F      		lsl r24
 838 0330 991F      		rol r25
 839 0332 092E      		mov __tmp_reg__,r25
 840 0334 000C      		lsl r0
 841 0336 AA0B      		sbc r26,r26
 842 0338 BB0B      		sbc r27,r27
 843 033a BC01      		movw r22,r24
 844 033c CD01      		movw r24,r26
 845 033e 0E94 0000 		call __floatsisf
 846 0342 DC01      		movw r26,r24
 847 0344 CB01      		movw r24,r22
 848 0346 20E0      		ldi r18,0
 849 0348 30E0      		ldi r19,0
 850 034a 40E4      		ldi r20,lo8(64)
 851 034c 51E4      		ldi r21,lo8(65)
 852 034e BC01      		movw r22,r24
 853 0350 CD01      		movw r24,r26
 854 0352 0E94 0000 		call __addsf3
 855 0356 DC01      		movw r26,r24
 856 0358 CB01      		movw r24,r22
 857 035a 20E0      		ldi r18,0
 858 035c 30E0      		ldi r19,0
 859 035e 40E2      		ldi r20,lo8(32)
 860 0360 52E4      		ldi r21,lo8(66)
 861 0362 BC01      		movw r22,r24
 862 0364 CD01      		movw r24,r26
 863 0366 0E94 0000 		call __addsf3
 864 036a DC01      		movw r26,r24
 865 036c CB01      		movw r24,r22
 866 036e 20E0      		ldi r18,0
 867 0370 34E2      		ldi r19,lo8(36)
 868 0372 44E7      		ldi r20,lo8(116)
 869 0374 57E4      		ldi r21,lo8(71)
 870 0376 BC01      		movw r22,r24
 871 0378 CD01      		movw r24,r26
 872 037a 0E94 0000 		call __divsf3
 873 037e DC01      		movw r26,r24
 874 0380 CB01      		movw r24,r22
 875 0382 2DEB      		ldi r18,lo8(-67)
 876 0384 37E3      		ldi r19,lo8(55)
 877 0386 46E8      		ldi r20,lo8(-122)
 878 0388 57E3      		ldi r21,lo8(55)
 879 038a BC01      		movw r22,r24
 880 038c CD01      		movw r24,r26
 881 038e 0E94 0000 		call __divsf3
 882 0392 DC01      		movw r26,r24
 883 0394 CB01      		movw r24,r22
 884 0396 BC01      		movw r22,r24
 885 0398 CD01      		movw r24,r26
 886 039a 0E94 0000 		call __fixsfsi
 887 039e DC01      		movw r26,r24
 888 03a0 CB01      		movw r24,r22
 889 03a2 9093 0000 		sts ts_time+1,r25
 890 03a6 8093 0000 		sts ts_time,r24
 459:ServerLLDN.c  **** 			int msg_wait_time = rec_beacon->Flags.numBaseMgmtTimeslots * rec_beacon->TimeSlotSize * 2; // sy
 891               		.loc 6 459 0
 892 03aa 8091 0000 		lds r24,rec_beacon
 893 03ae 9091 0000 		lds r25,rec_beacon+1
 894 03b2 FC01      		movw r30,r24
 895 03b4 8381      		ldd r24,Z+3
 896 03b6 8295      		swap r24
 897 03b8 8695      		lsr r24
 898 03ba 8770      		andi r24,lo8(7)
 899 03bc 482F      		mov r20,r24
 900 03be 50E0      		ldi r21,0
 901 03c0 8091 0000 		lds r24,rec_beacon
 902 03c4 9091 0000 		lds r25,rec_beacon+1
 903 03c8 FC01      		movw r30,r24
 904 03ca 8681      		ldd r24,Z+6
 905 03cc 282F      		mov r18,r24
 906 03ce 30E0      		ldi r19,0
 907 03d0 429F      		mul r20,r18
 908 03d2 C001      		movw r24,r0
 909 03d4 439F      		mul r20,r19
 910 03d6 900D      		add r25,r0
 911 03d8 529F      		mul r21,r18
 912 03da 900D      		add r25,r0
 913 03dc 1124      		clr r1
 914 03de 880F      		lsl r24
 915 03e0 991F      		rol r25
 916 03e2 9A83      		std Y+2,r25
 917 03e4 8983      		std Y+1,r24
 460:ServerLLDN.c  **** 			
 461:ServerLLDN.c  **** 			start_timer(msg_wait_time);
 918               		.loc 6 461 0
 919 03e6 8981      		ldd r24,Y+1
 920 03e8 9A81      		ldd r25,Y+2
 921 03ea 0E94 0000 		call start_timer
 462:ServerLLDN.c  **** 			
 463:ServerLLDN.c  **** 			appState = (rec_beacon->Flags.txState == DISC_MODE) ? APP_STATE_PREP_DISC_REPONSE : APP_STATE_PR
 922               		.loc 6 463 0
 923 03ee 8091 0000 		lds r24,rec_beacon
 924 03f2 9091 0000 		lds r25,rec_beacon+1
 925 03f6 FC01      		movw r30,r24
 926 03f8 8381      		ldd r24,Z+3
 927 03fa 8770      		andi r24,lo8(7)
 928 03fc 8430      		cpi r24,lo8(4)
 929 03fe 01F4      		brne .L24
 930               		.loc 6 463 0 is_stmt 0 discriminator 1
 931 0400 84E0      		ldi r24,lo8(4)
 932 0402 00C0      		rjmp .L25
 933               	.L24:
 934               		.loc 6 463 0 discriminator 2
 935 0404 85E0      		ldi r24,lo8(5)
 936               	.L25:
 937               		.loc 6 463 0 discriminator 4
 938 0406 8093 0000 		sts appState,r24
 939               	.LBE2:
 456:ServerLLDN.c  **** 	
 940               		.loc 6 456 0 is_stmt 1 discriminator 4
 941 040a 00C0      		rjmp .L26
 942               	.L23:
 464:ServerLLDN.c  **** 		}
 465:ServerLLDN.c  **** 		else if (rec_beacon->Flags.txState == ONLINE_MODE && assTimeSlot != 0xFF && associated == 1)
 943               		.loc 6 465 0
 944 040c 8091 0000 		lds r24,rec_beacon
 945 0410 9091 0000 		lds r25,rec_beacon+1
 946 0414 FC01      		movw r30,r24
 947 0416 8381      		ldd r24,Z+3
 948 0418 8770      		andi r24,lo8(7)
 949 041a 8823      		tst r24
 950 041c 01F0      		breq .+2
 951 041e 00C0      		rjmp .L27
 952               		.loc 6 465 0 is_stmt 0 discriminator 1
 953 0420 8091 0000 		lds r24,assTimeSlot
 954 0424 8F3F      		cpi r24,lo8(-1)
 955 0426 01F4      		brne .+2
 956 0428 00C0      		rjmp .L27
 957               		.loc 6 465 0 discriminator 2
 958 042a 8091 0000 		lds r24,associated
 959 042e 8823      		tst r24
 960 0430 01F4      		brne .+2
 961 0432 00C0      		rjmp .L27
 962               	.LBB3:
 466:ServerLLDN.c  **** 		{
 467:ServerLLDN.c  **** 			ts_time = ((p_var*sp + (m+ n)*sm + macMinLIFSPeriod)/v_var)  / (SYMBOL_TIME);
 963               		.loc 6 467 0 is_stmt 1
 964 0434 8091 0000 		lds r24,n
 965 0438 882F      		mov r24,r24
 966 043a 90E0      		ldi r25,0
 967 043c 0396      		adiw r24,3
 968 043e 880F      		lsl r24
 969 0440 991F      		rol r25
 970 0442 092E      		mov __tmp_reg__,r25
 971 0444 000C      		lsl r0
 972 0446 AA0B      		sbc r26,r26
 973 0448 BB0B      		sbc r27,r27
 974 044a BC01      		movw r22,r24
 975 044c CD01      		movw r24,r26
 976 044e 0E94 0000 		call __floatsisf
 977 0452 DC01      		movw r26,r24
 978 0454 CB01      		movw r24,r22
 979 0456 20E0      		ldi r18,0
 980 0458 30E0      		ldi r19,0
 981 045a 40E4      		ldi r20,lo8(64)
 982 045c 51E4      		ldi r21,lo8(65)
 983 045e BC01      		movw r22,r24
 984 0460 CD01      		movw r24,r26
 985 0462 0E94 0000 		call __addsf3
 986 0466 DC01      		movw r26,r24
 987 0468 CB01      		movw r24,r22
 988 046a 20E0      		ldi r18,0
 989 046c 30E0      		ldi r19,0
 990 046e 40E2      		ldi r20,lo8(32)
 991 0470 52E4      		ldi r21,lo8(66)
 992 0472 BC01      		movw r22,r24
 993 0474 CD01      		movw r24,r26
 994 0476 0E94 0000 		call __addsf3
 995 047a DC01      		movw r26,r24
 996 047c CB01      		movw r24,r22
 997 047e 20E0      		ldi r18,0
 998 0480 34E2      		ldi r19,lo8(36)
 999 0482 44E7      		ldi r20,lo8(116)
 1000 0484 57E4      		ldi r21,lo8(71)
 1001 0486 BC01      		movw r22,r24
 1002 0488 CD01      		movw r24,r26
 1003 048a 0E94 0000 		call __divsf3
 1004 048e DC01      		movw r26,r24
 1005 0490 CB01      		movw r24,r22
 1006 0492 2DEB      		ldi r18,lo8(-67)
 1007 0494 37E3      		ldi r19,lo8(55)
 1008 0496 46E8      		ldi r20,lo8(-122)
 1009 0498 57E3      		ldi r21,lo8(55)
 1010 049a BC01      		movw r22,r24
 1011 049c CD01      		movw r24,r26
 1012 049e 0E94 0000 		call __divsf3
 1013 04a2 DC01      		movw r26,r24
 1014 04a4 CB01      		movw r24,r22
 1015 04a6 BC01      		movw r22,r24
 1016 04a8 CD01      		movw r24,r26
 1017 04aa 0E94 0000 		call __fixsfsi
 1018 04ae DC01      		movw r26,r24
 1019 04b0 CB01      		movw r24,r22
 1020 04b2 9093 0000 		sts ts_time+1,r25
 1021 04b6 8093 0000 		sts ts_time,r24
 468:ServerLLDN.c  **** 			int msg_wait_time = (2*rec_beacon->Flags.numBaseMgmtTimeslots + assTimeSlot) * ts_time;
 1022               		.loc 6 468 0
 1023 04ba 8091 0000 		lds r24,rec_beacon
 1024 04be 9091 0000 		lds r25,rec_beacon+1
 1025 04c2 FC01      		movw r30,r24
 1026 04c4 8381      		ldd r24,Z+3
 1027 04c6 8295      		swap r24
 1028 04c8 8695      		lsr r24
 1029 04ca 8770      		andi r24,lo8(7)
 1030 04cc 882F      		mov r24,r24
 1031 04ce 90E0      		ldi r25,0
 1032 04d0 9C01      		movw r18,r24
 1033 04d2 220F      		lsl r18
 1034 04d4 331F      		rol r19
 1035 04d6 8091 0000 		lds r24,assTimeSlot
 1036 04da 882F      		mov r24,r24
 1037 04dc 90E0      		ldi r25,0
 1038 04de A901      		movw r20,r18
 1039 04e0 480F      		add r20,r24
 1040 04e2 591F      		adc r21,r25
 1041 04e4 2091 0000 		lds r18,ts_time
 1042 04e8 3091 0000 		lds r19,ts_time+1
 1043 04ec 429F      		mul r20,r18
 1044 04ee C001      		movw r24,r0
 1045 04f0 439F      		mul r20,r19
 1046 04f2 900D      		add r25,r0
 1047 04f4 529F      		mul r21,r18
 1048 04f6 900D      		add r25,r0
 1049 04f8 1124      		clr r1
 1050 04fa 9C83      		std Y+4,r25
 1051 04fc 8B83      		std Y+3,r24
 469:ServerLLDN.c  **** 			start_timer(msg_wait_time+30);
 1052               		.loc 6 469 0
 1053 04fe 8B81      		ldd r24,Y+3
 1054 0500 9C81      		ldd r25,Y+4
 1055 0502 4E96      		adiw r24,30
 1056 0504 0E94 0000 		call start_timer
 470:ServerLLDN.c  **** 			ack_received = false;
 1057               		.loc 6 470 0
 1058 0508 1092 0000 		sts ack_received,__zero_reg__
 471:ServerLLDN.c  **** 			appState = APP_STATE_PREP_DATA_FRAME;
 1059               		.loc 6 471 0
 1060 050c 86E0      		ldi r24,lo8(6)
 1061 050e 8093 0000 		sts appState,r24
 1062               	.LBE3:
 466:ServerLLDN.c  **** 			ts_time = ((p_var*sp + (m+ n)*sm + macMinLIFSPeriod)/v_var)  / (SYMBOL_TIME);
 1063               		.loc 6 466 0
 1064 0512 00C0      		rjmp .L26
 1065               	.L27:
 472:ServerLLDN.c  **** 		}
 473:ServerLLDN.c  **** 		else if (rec_beacon->Flags.txState == RESET_MODE)
 1066               		.loc 6 473 0
 1067 0514 8091 0000 		lds r24,rec_beacon
 1068 0518 9091 0000 		lds r25,rec_beacon+1
 1069 051c FC01      		movw r30,r24
 1070 051e 8381      		ldd r24,Z+3
 1071 0520 8770      		andi r24,lo8(7)
 1072 0522 8730      		cpi r24,lo8(7)
 1073 0524 01F4      		brne .L26
 474:ServerLLDN.c  **** 		{
 475:ServerLLDN.c  **** 			printf("\n Reset beacon");
 1074               		.loc 6 475 0
 1075 0526 80E0      		ldi r24,lo8(.LC2)
 1076 0528 90E0      		ldi r25,hi8(.LC2)
 1077 052a 892F      		mov r24,r25
 1078 052c 8F93      		push r24
 1079 052e 80E0      		ldi r24,lo8(.LC2)
 1080 0530 90E0      		ldi r25,hi8(.LC2)
 1081 0532 8F93      		push r24
 1082 0534 0E94 0000 		call printf
 1083 0538 0F90      		pop __tmp_reg__
 1084 053a 0F90      		pop __tmp_reg__
 476:ServerLLDN.c  **** 			ack_received = 0;
 1085               		.loc 6 476 0
 1086 053c 1092 0000 		sts ack_received,__zero_reg__
 477:ServerLLDN.c  **** 			associated = 0;
 1087               		.loc 6 477 0
 1088 0540 1092 0000 		sts associated,__zero_reg__
 1089               	.L26:
 478:ServerLLDN.c  **** 		}
 479:ServerLLDN.c  **** 		return true;
 1090               		.loc 6 479 0
 1091 0544 81E0      		ldi r24,lo8(1)
 1092               	/* epilogue start */
 480:ServerLLDN.c  **** 	}
 1093               		.loc 6 480 0
 1094 0546 2696      		adiw r28,6
 1095 0548 0FB6      		in __tmp_reg__,__SREG__
 1096 054a F894      		cli
 1097 054c DEBF      		out __SP_H__,r29
 1098 054e 0FBE      		out __SREG__,__tmp_reg__
 1099 0550 CDBF      		out __SP_L__,r28
 1100 0552 DF91      		pop r29
 1101 0554 CF91      		pop r28
 1102 0556 0895      		ret
 1103               		.cfi_endproc
 1104               	.LFE133:
 1106               		.section	.rodata
 1107               	.LC3:
 1108 0020 0A20 2568 		.string	"\n %hhx "
 1108      6878 2000 
 1109               	.LC4:
 1110 0028 4143 4B20 		.string	"ACK TRUE"
 1110      5452 5545 
 1110      00
 1111               		.text
 1112               	.global	check_ack
 1114               	check_ack:
 1115               	.LFB134:
 481:ServerLLDN.c  **** 	
 482:ServerLLDN.c  **** 	bool check_ack(int addr)
 483:ServerLLDN.c  **** 	{
 1116               		.loc 6 483 0
 1117               		.cfi_startproc
 1118 0558 CF93      		push r28
 1119               	.LCFI43:
 1120               		.cfi_def_cfa_offset 3
 1121               		.cfi_offset 28, -2
 1122 055a DF93      		push r29
 1123               	.LCFI44:
 1124               		.cfi_def_cfa_offset 4
 1125               		.cfi_offset 29, -3
 1126 055c 00D0      		rcall .
 1127 055e 00D0      		rcall .
 1128 0560 00D0      		rcall .
 1129               	.LCFI45:
 1130               		.cfi_def_cfa_offset 10
 1131 0562 CDB7      		in r28,__SP_L__
 1132 0564 DEB7      		in r29,__SP_H__
 1133               	.LCFI46:
 1134               		.cfi_def_cfa_register 28
 1135               	/* prologue: function */
 1136               	/* frame size = 6 */
 1137               	/* stack size = 8 */
 1138               	.L__stack_usage = 8
 1139 0566 9E83      		std Y+6,r25
 1140 0568 8D83      		std Y+5,r24
 484:ServerLLDN.c  **** 		int pos =  addr / 8;
 1141               		.loc 6 484 0
 1142 056a 8D81      		ldd r24,Y+5
 1143 056c 9E81      		ldd r25,Y+6
 1144 056e 9923      		tst r25
 1145 0570 04F4      		brge .L30
 1146 0572 0796      		adiw r24,7
 1147               	.L30:
 1148 0574 9595      		asr r25
 1149 0576 8795      		ror r24
 1150 0578 9595      		asr r25
 1151 057a 8795      		ror r24
 1152 057c 9595      		asr r25
 1153 057e 8795      		ror r24
 1154 0580 9A83      		std Y+2,r25
 1155 0582 8983      		std Y+1,r24
 485:ServerLLDN.c  **** 		int bit_shift = 8 - addr % 8;
 1156               		.loc 6 485 0
 1157 0584 8D81      		ldd r24,Y+5
 1158 0586 9E81      		ldd r25,Y+6
 1159 0588 8770      		andi r24,7
 1160 058a 9078      		andi r25,128
 1161 058c 9923      		tst r25
 1162 058e 04F4      		brge .L31
 1163 0590 0197      		sbiw r24,1
 1164 0592 886F      		ori r24,248
 1165 0594 9F6F      		ori r25,255
 1166 0596 0196      		adiw r24,1
 1167               	.L31:
 1168 0598 9C01      		movw r18,r24
 1169 059a 88E0      		ldi r24,lo8(8)
 1170 059c 90E0      		ldi r25,0
 1171 059e 821B      		sub r24,r18
 1172 05a0 930B      		sbc r25,r19
 1173 05a2 9C83      		std Y+4,r25
 1174 05a4 8B83      		std Y+3,r24
 486:ServerLLDN.c  **** 		printf("\n %hhx ", ackframe->ackFlags[pos]);
 1175               		.loc 6 486 0
 1176 05a6 2091 0000 		lds r18,ackframe
 1177 05aa 3091 0000 		lds r19,ackframe+1
 1178 05ae 8981      		ldd r24,Y+1
 1179 05b0 9A81      		ldd r25,Y+2
 1180 05b2 820F      		add r24,r18
 1181 05b4 931F      		adc r25,r19
 1182 05b6 0196      		adiw r24,1
 1183 05b8 FC01      		movw r30,r24
 1184 05ba 8081      		ld r24,Z
 1185 05bc 882F      		mov r24,r24
 1186 05be 90E0      		ldi r25,0
 1187 05c0 292F      		mov r18,r25
 1188 05c2 2F93      		push r18
 1189 05c4 8F93      		push r24
 1190 05c6 80E0      		ldi r24,lo8(.LC3)
 1191 05c8 90E0      		ldi r25,hi8(.LC3)
 1192 05ca 892F      		mov r24,r25
 1193 05cc 8F93      		push r24
 1194 05ce 80E0      		ldi r24,lo8(.LC3)
 1195 05d0 90E0      		ldi r25,hi8(.LC3)
 1196 05d2 8F93      		push r24
 1197 05d4 0E94 0000 		call printf
 1198 05d8 0F90      		pop __tmp_reg__
 1199 05da 0F90      		pop __tmp_reg__
 1200 05dc 0F90      		pop __tmp_reg__
 1201 05de 0F90      		pop __tmp_reg__
 487:ServerLLDN.c  **** 		if( ackframe->ackFlags[pos] & 1 << bit_shift)
 1202               		.loc 6 487 0
 1203 05e0 2091 0000 		lds r18,ackframe
 1204 05e4 3091 0000 		lds r19,ackframe+1
 1205 05e8 8981      		ldd r24,Y+1
 1206 05ea 9A81      		ldd r25,Y+2
 1207 05ec 820F      		add r24,r18
 1208 05ee 931F      		adc r25,r19
 1209 05f0 0196      		adiw r24,1
 1210 05f2 FC01      		movw r30,r24
 1211 05f4 8081      		ld r24,Z
 1212 05f6 882F      		mov r24,r24
 1213 05f8 90E0      		ldi r25,0
 1214 05fa 0B80      		ldd r0,Y+3
 1215 05fc 00C0      		rjmp 2f
 1216               		1:
 1217 05fe 9595      		asr r25
 1218 0600 8795      		ror r24
 1219               		2:
 1220 0602 0A94      		dec r0
 1221 0604 02F4      		brpl 1b
 1222 0606 8170      		andi r24,1
 1223 0608 9927      		clr r25
 1224 060a 892B      		or r24,r25
 1225 060c 01F0      		breq .L32
 488:ServerLLDN.c  **** 		{
 489:ServerLLDN.c  **** 			printf("ACK TRUE");
 1226               		.loc 6 489 0
 1227 060e 80E0      		ldi r24,lo8(.LC4)
 1228 0610 90E0      		ldi r25,hi8(.LC4)
 1229 0612 892F      		mov r24,r25
 1230 0614 8F93      		push r24
 1231 0616 80E0      		ldi r24,lo8(.LC4)
 1232 0618 90E0      		ldi r25,hi8(.LC4)
 1233 061a 8F93      		push r24
 1234 061c 0E94 0000 		call printf
 1235 0620 0F90      		pop __tmp_reg__
 1236 0622 0F90      		pop __tmp_reg__
 490:ServerLLDN.c  **** 			return true;
 1237               		.loc 6 490 0
 1238 0624 81E0      		ldi r24,lo8(1)
 1239 0626 00C0      		rjmp .L33
 1240               	.L32:
 491:ServerLLDN.c  **** 		}
 492:ServerLLDN.c  **** 		else
 493:ServerLLDN.c  **** 			return false;
 1241               		.loc 6 493 0
 1242 0628 80E0      		ldi r24,0
 1243               	.L33:
 1244               	/* epilogue start */
 494:ServerLLDN.c  **** 	}
 1245               		.loc 6 494 0
 1246 062a 2696      		adiw r28,6
 1247 062c 0FB6      		in __tmp_reg__,__SREG__
 1248 062e F894      		cli
 1249 0630 DEBF      		out __SP_H__,r29
 1250 0632 0FBE      		out __SREG__,__tmp_reg__
 1251 0634 CDBF      		out __SP_L__,r28
 1252 0636 DF91      		pop r29
 1253 0638 CF91      		pop r28
 1254 063a 0895      		ret
 1255               		.cfi_endproc
 1256               	.LFE134:
 1259               	appAckInd:
 1260               	.LFB135:
 495:ServerLLDN.c  **** 	
 496:ServerLLDN.c  **** 	static bool appAckInd(NWK_DataInd_t *ind)
 497:ServerLLDN.c  **** 	{
 1261               		.loc 6 497 0
 1262               		.cfi_startproc
 1263 063c CF93      		push r28
 1264               	.LCFI47:
 1265               		.cfi_def_cfa_offset 3
 1266               		.cfi_offset 28, -2
 1267 063e DF93      		push r29
 1268               	.LCFI48:
 1269               		.cfi_def_cfa_offset 4
 1270               		.cfi_offset 29, -3
 1271 0640 00D0      		rcall .
 1272               	.LCFI49:
 1273               		.cfi_def_cfa_offset 6
 1274 0642 CDB7      		in r28,__SP_L__
 1275 0644 DEB7      		in r29,__SP_H__
 1276               	.LCFI50:
 1277               		.cfi_def_cfa_register 28
 1278               	/* prologue: function */
 1279               	/* frame size = 2 */
 1280               	/* stack size = 4 */
 1281               	.L__stack_usage = 4
 1282 0646 9A83      		std Y+2,r25
 1283 0648 8983      		std Y+1,r24
 498:ServerLLDN.c  **** 		#if !MASTER_MACSC
 499:ServerLLDN.c  **** 		ind->data = ind->data - (uint8_t) 1;
 500:ServerLLDN.c  **** 		#endif
 501:ServerLLDN.c  **** 		ackframe = (NWK_ACKFormat_t*)ind->data;
 1284               		.loc 6 501 0
 1285 064a 8981      		ldd r24,Y+1
 1286 064c 9A81      		ldd r25,Y+2
 1287 064e FC01      		movw r30,r24
 1288 0650 8085      		ldd r24,Z+8
 1289 0652 9185      		ldd r25,Z+9
 1290 0654 9093 0000 		sts ackframe+1,r25
 1291 0658 8093 0000 		sts ackframe,r24
 502:ServerLLDN.c  **** 
 503:ServerLLDN.c  **** 		if(PanId == ackframe->sourceId)
 1292               		.loc 6 503 0
 1293 065c 8091 0000 		lds r24,ackframe
 1294 0660 9091 0000 		lds r25,ackframe+1
 1295 0664 FC01      		movw r30,r24
 1296 0666 9081      		ld r25,Z
 1297 0668 8091 0000 		lds r24,PanId
 1298 066c 9817      		cp r25,r24
 1299 066e 01F4      		brne .L35
 504:ServerLLDN.c  **** 		{
 505:ServerLLDN.c  **** 			if(STATE == ONLINE_MODE)
 1300               		.loc 6 505 0
 1301 0670 8091 0000 		lds r24,STATE
 1302 0674 8823      		tst r24
 1303 0676 01F4      		brne .L36
 506:ServerLLDN.c  **** 			{
 507:ServerLLDN.c  **** 				ack_received = check_ack(assTimeSlot + 1);
 1304               		.loc 6 507 0
 1305 0678 8091 0000 		lds r24,assTimeSlot
 1306 067c 882F      		mov r24,r24
 1307 067e 90E0      		ldi r25,0
 1308 0680 0196      		adiw r24,1
 1309 0682 0E94 0000 		call check_ack
 1310 0686 8093 0000 		sts ack_received,r24
 508:ServerLLDN.c  **** 				appState = APP_STATE_RETRANSMIT_DATA;
 1311               		.loc 6 508 0
 1312 068a 87E0      		ldi r24,lo8(7)
 1313 068c 8093 0000 		sts appState,r24
 1314 0690 00C0      		rjmp .L35
 1315               	.L36:
 509:ServerLLDN.c  **** 			}
 510:ServerLLDN.c  **** 			else
 511:ServerLLDN.c  **** 				ack_received = check_ack(APP_ADDR);								
 1316               		.loc 6 511 0
 1317 0692 81E0      		ldi r24,lo8(1)
 1318 0694 90E0      		ldi r25,0
 1319 0696 0E94 0000 		call check_ack
 1320 069a 8093 0000 		sts ack_received,r24
 1321               	.L35:
 512:ServerLLDN.c  **** 		}
 513:ServerLLDN.c  **** 		return true;
 1322               		.loc 6 513 0
 1323 069e 81E0      		ldi r24,lo8(1)
 1324               	/* epilogue start */
 514:ServerLLDN.c  **** 	}
 1325               		.loc 6 514 0
 1326 06a0 0F90      		pop __tmp_reg__
 1327 06a2 0F90      		pop __tmp_reg__
 1328 06a4 DF91      		pop r29
 1329 06a6 CF91      		pop r28
 1330 06a8 0895      		ret
 1331               		.cfi_endproc
 1332               	.LFE135:
 1334               		.section	.rodata
 1335               	.LC5:
 1336 0031 0A41 7373 		.string	"\nAssociado!"
 1336      6F63 6961 
 1336      646F 2100 
 1337               		.text
 1339               	appCommandInd:
 1340               	.LFB136:
 515:ServerLLDN.c  **** 	
 516:ServerLLDN.c  **** 	static bool appCommandInd(NWK_DataInd_t *ind)
 517:ServerLLDN.c  **** 	{
 1341               		.loc 6 517 0
 1342               		.cfi_startproc
 1343 06aa CF93      		push r28
 1344               	.LCFI51:
 1345               		.cfi_def_cfa_offset 3
 1346               		.cfi_offset 28, -2
 1347 06ac DF93      		push r29
 1348               	.LCFI52:
 1349               		.cfi_def_cfa_offset 4
 1350               		.cfi_offset 29, -3
 1351 06ae 00D0      		rcall .
 1352 06b0 00D0      		rcall .
 1353               	.LCFI53:
 1354               		.cfi_def_cfa_offset 8
 1355 06b2 CDB7      		in r28,__SP_L__
 1356 06b4 DEB7      		in r29,__SP_H__
 1357               	.LCFI54:
 1358               		.cfi_def_cfa_register 28
 1359               	/* prologue: function */
 1360               	/* frame size = 4 */
 1361               	/* stack size = 6 */
 1362               	.L__stack_usage = 6
 1363 06b6 9C83      		std Y+4,r25
 1364 06b8 8B83      		std Y+3,r24
 518:ServerLLDN.c  **** 		#if !MASTER_MACSC
 519:ServerLLDN.c  **** 		ind->data = ind->data - (uint8_t) 1;
 520:ServerLLDN.c  **** 		#endif
 521:ServerLLDN.c  **** 		
 522:ServerLLDN.c  **** 		if(ind->data[0] == LL_CONFIGURATION_REQUEST)
 1365               		.loc 6 522 0
 1366 06ba 8B81      		ldd r24,Y+3
 1367 06bc 9C81      		ldd r25,Y+4
 1368 06be FC01      		movw r30,r24
 1369 06c0 8085      		ldd r24,Z+8
 1370 06c2 9185      		ldd r25,Z+9
 1371 06c4 FC01      		movw r30,r24
 1372 06c6 8081      		ld r24,Z
 1373 06c8 8F30      		cpi r24,lo8(15)
 1374 06ca 01F4      		brne .L39
 1375               	.LBB4:
 523:ServerLLDN.c  **** 		{
 524:ServerLLDN.c  **** 			NWK_ConfigRequest_t *msg = (NWK_ConfigRequest_t*)ind->data;
 1376               		.loc 6 524 0
 1377 06cc 8B81      		ldd r24,Y+3
 1378 06ce 9C81      		ldd r25,Y+4
 1379 06d0 FC01      		movw r30,r24
 1380 06d2 8085      		ldd r24,Z+8
 1381 06d4 9185      		ldd r25,Z+9
 1382 06d6 9A83      		std Y+2,r25
 1383 06d8 8983      		std Y+1,r24
 525:ServerLLDN.c  **** 			if(msg->macAddr == APP_ADDR)
 1384               		.loc 6 525 0
 1385 06da 8981      		ldd r24,Y+1
 1386 06dc 9A81      		ldd r25,Y+2
 1387 06de FC01      		movw r30,r24
 1388 06e0 8481      		ldd r24,Z+4
 1389 06e2 8130      		cpi r24,lo8(1)
 1390 06e4 01F4      		brne .L39
 526:ServerLLDN.c  **** 			{
 527:ServerLLDN.c  **** 				PHY_SetChannel(msg->tx_channel);
 1391               		.loc 6 527 0
 1392 06e6 8981      		ldd r24,Y+1
 1393 06e8 9A81      		ldd r25,Y+2
 1394 06ea FC01      		movw r30,r24
 1395 06ec 8281      		ldd r24,Z+2
 1396 06ee 0E94 0000 		call PHY_SetChannel
 528:ServerLLDN.c  **** 				NWK_SetPanId(msg->s_macAddr);
 1397               		.loc 6 528 0
 1398 06f2 8981      		ldd r24,Y+1
 1399 06f4 9A81      		ldd r25,Y+2
 1400 06f6 FC01      		movw r30,r24
 1401 06f8 8181      		ldd r24,Z+1
 1402 06fa 882F      		mov r24,r24
 1403 06fc 90E0      		ldi r25,0
 1404 06fe 0E94 0000 		call NWK_SetPanId
 529:ServerLLDN.c  **** 				PanId = msg->s_macAddr;
 1405               		.loc 6 529 0
 1406 0702 8981      		ldd r24,Y+1
 1407 0704 9A81      		ldd r25,Y+2
 1408 0706 FC01      		movw r30,r24
 1409 0708 8181      		ldd r24,Z+1
 1410 070a 8093 0000 		sts PanId,r24
 530:ServerLLDN.c  **** 				assTimeSlot = msg->assTimeSlot;
 1411               		.loc 6 530 0
 1412 070e 8981      		ldd r24,Y+1
 1413 0710 9A81      		ldd r25,Y+2
 1414 0712 FC01      		movw r30,r24
 1415 0714 8381      		ldd r24,Z+3
 1416 0716 8093 0000 		sts assTimeSlot,r24
 531:ServerLLDN.c  **** 				n = msg->conf.tsDuration;
 1417               		.loc 6 531 0
 1418 071a 8981      		ldd r24,Y+1
 1419 071c 9A81      		ldd r25,Y+2
 1420 071e FC01      		movw r30,r24
 1421 0720 8581      		ldd r24,Z+5
 1422 0722 8F77      		andi r24,lo8(127)
 1423 0724 8093 0000 		sts n,r24
 532:ServerLLDN.c  **** 				associated = 1;
 1424               		.loc 6 532 0
 1425 0728 81E0      		ldi r24,lo8(1)
 1426 072a 8093 0000 		sts associated,r24
 533:ServerLLDN.c  **** 				printf("\nAssociado!");
 1427               		.loc 6 533 0
 1428 072e 80E0      		ldi r24,lo8(.LC5)
 1429 0730 90E0      		ldi r25,hi8(.LC5)
 1430 0732 892F      		mov r24,r25
 1431 0734 8F93      		push r24
 1432 0736 80E0      		ldi r24,lo8(.LC5)
 1433 0738 90E0      		ldi r25,hi8(.LC5)
 1434 073a 8F93      		push r24
 1435 073c 0E94 0000 		call printf
 1436 0740 0F90      		pop __tmp_reg__
 1437 0742 0F90      		pop __tmp_reg__
 1438               	.L39:
 1439               	.LBE4:
 534:ServerLLDN.c  **** 			}
 535:ServerLLDN.c  **** 		}
 536:ServerLLDN.c  **** 		return true;
 1440               		.loc 6 536 0
 1441 0744 81E0      		ldi r24,lo8(1)
 1442               	/* epilogue start */
 537:ServerLLDN.c  **** 	}
 1443               		.loc 6 537 0
 1444 0746 0F90      		pop __tmp_reg__
 1445 0748 0F90      		pop __tmp_reg__
 1446 074a 0F90      		pop __tmp_reg__
 1447 074c 0F90      		pop __tmp_reg__
 1448 074e DF91      		pop r29
 1449 0750 CF91      		pop r28
 1450 0752 0895      		ret
 1451               		.cfi_endproc
 1452               	.LFE136:
 1454               	.global	appPrepareDiscoverResponse
 1456               	appPrepareDiscoverResponse:
 1457               	.LFB137:
 538:ServerLLDN.c  **** 
 539:ServerLLDN.c  **** 	void appPrepareDiscoverResponse()
 540:ServerLLDN.c  **** 	{
 1458               		.loc 6 540 0
 1459               		.cfi_startproc
 1460 0754 CF93      		push r28
 1461               	.LCFI55:
 1462               		.cfi_def_cfa_offset 3
 1463               		.cfi_offset 28, -2
 1464 0756 DF93      		push r29
 1465               	.LCFI56:
 1466               		.cfi_def_cfa_offset 4
 1467               		.cfi_offset 29, -3
 1468 0758 CDB7      		in r28,__SP_L__
 1469 075a DEB7      		in r29,__SP_H__
 1470               	.LCFI57:
 1471               		.cfi_def_cfa_register 28
 1472               	/* prologue: function */
 1473               	/* frame size = 0 */
 1474               	/* stack size = 2 */
 1475               	.L__stack_usage = 2
 541:ServerLLDN.c  **** 		msgReq.dstAddr				= 0;
 1476               		.loc 6 541 0
 1477 075c 1092 0000 		sts msgReq+5+1,__zero_reg__
 1478 0760 1092 0000 		sts msgReq+5,__zero_reg__
 542:ServerLLDN.c  **** 		msgReq.dstEndpoint			= APP_COMMAND_ENDPOINT;
 1479               		.loc 6 542 0
 1480 0764 83E0      		ldi r24,lo8(3)
 1481 0766 8093 0000 		sts msgReq+7,r24
 543:ServerLLDN.c  **** 		msgReq.srcEndpoint			= APP_COMMAND_ENDPOINT;
 1482               		.loc 6 543 0
 1483 076a 83E0      		ldi r24,lo8(3)
 1484 076c 8093 0000 		sts msgReq+8,r24
 544:ServerLLDN.c  **** 		msgReq.options				= NWK_OPT_MAC_COMMAND;
 1485               		.loc 6 544 0
 1486 0770 80E0      		ldi r24,0
 1487 0772 90E8      		ldi r25,lo8(-128)
 1488 0774 9093 0000 		sts msgReq+9+1,r25
 1489 0778 8093 0000 		sts msgReq+9,r24
 545:ServerLLDN.c  **** 		msgReq.data					= (uint8_t*)&msgDiscResponse;
 1490               		.loc 6 545 0
 1491 077c 80E0      		ldi r24,lo8(msgDiscResponse)
 1492 077e 90E0      		ldi r25,hi8(msgDiscResponse)
 1493 0780 9093 0000 		sts msgReq+13+1,r25
 1494 0784 8093 0000 		sts msgReq+13,r24
 546:ServerLLDN.c  **** 		msgReq.size					= sizeof(msgDiscResponse);
 1495               		.loc 6 546 0
 1496 0788 83E0      		ldi r24,lo8(3)
 1497 078a 8093 0000 		sts msgReq+15,r24
 547:ServerLLDN.c  **** 	}
 1498               		.loc 6 547 0
 1499 078e 0000      		nop
 1500               	/* epilogue start */
 1501 0790 DF91      		pop r29
 1502 0792 CF91      		pop r28
 1503 0794 0895      		ret
 1504               		.cfi_endproc
 1505               	.LFE137:
 1507               	.global	appPrepareConfigurationStatus
 1509               	appPrepareConfigurationStatus:
 1510               	.LFB138:
 548:ServerLLDN.c  **** 	
 549:ServerLLDN.c  **** 	void appPrepareConfigurationStatus()
 550:ServerLLDN.c  **** 	{		
 1511               		.loc 6 550 0
 1512               		.cfi_startproc
 1513 0796 CF93      		push r28
 1514               	.LCFI58:
 1515               		.cfi_def_cfa_offset 3
 1516               		.cfi_offset 28, -2
 1517 0798 DF93      		push r29
 1518               	.LCFI59:
 1519               		.cfi_def_cfa_offset 4
 1520               		.cfi_offset 29, -3
 1521 079a CDB7      		in r28,__SP_L__
 1522 079c DEB7      		in r29,__SP_H__
 1523               	.LCFI60:
 1524               		.cfi_def_cfa_register 28
 1525               	/* prologue: function */
 1526               	/* frame size = 0 */
 1527               	/* stack size = 2 */
 1528               	.L__stack_usage = 2
 551:ServerLLDN.c  **** 		msgReq.dstAddr				= 0;
 1529               		.loc 6 551 0
 1530 079e 1092 0000 		sts msgReq+5+1,__zero_reg__
 1531 07a2 1092 0000 		sts msgReq+5,__zero_reg__
 552:ServerLLDN.c  **** 		msgReq.dstEndpoint			= APP_COMMAND_ENDPOINT;
 1532               		.loc 6 552 0
 1533 07a6 83E0      		ldi r24,lo8(3)
 1534 07a8 8093 0000 		sts msgReq+7,r24
 553:ServerLLDN.c  **** 		msgReq.srcEndpoint			= APP_COMMAND_ENDPOINT;
 1535               		.loc 6 553 0
 1536 07ac 83E0      		ldi r24,lo8(3)
 1537 07ae 8093 0000 		sts msgReq+8,r24
 554:ServerLLDN.c  **** 		msgReq.options				= NWK_OPT_MAC_COMMAND;
 1538               		.loc 6 554 0
 1539 07b2 80E0      		ldi r24,0
 1540 07b4 90E8      		ldi r25,lo8(-128)
 1541 07b6 9093 0000 		sts msgReq+9+1,r25
 1542 07ba 8093 0000 		sts msgReq+9,r24
 555:ServerLLDN.c  **** 		msgReq.data					= (uint8_t*)&msgConfigStatus;
 1543               		.loc 6 555 0
 1544 07be 80E0      		ldi r24,lo8(msgConfigStatus)
 1545 07c0 90E0      		ldi r25,hi8(msgConfigStatus)
 1546 07c2 9093 0000 		sts msgReq+13+1,r25
 1547 07c6 8093 0000 		sts msgReq+13,r24
 556:ServerLLDN.c  **** 		msgReq.size					= sizeof(msgConfigStatus);
 1548               		.loc 6 556 0
 1549 07ca 85E0      		ldi r24,lo8(5)
 1550 07cc 8093 0000 		sts msgReq+15,r24
 557:ServerLLDN.c  **** 	}
 1551               		.loc 6 557 0
 1552 07d0 0000      		nop
 1553               	/* epilogue start */
 1554 07d2 DF91      		pop r29
 1555 07d4 CF91      		pop r28
 1556 07d6 0895      		ret
 1557               		.cfi_endproc
 1558               	.LFE138:
 1560               	.global	appPrepareDataFrame
 1562               	appPrepareDataFrame:
 1563               	.LFB139:
 558:ServerLLDN.c  **** 	
 559:ServerLLDN.c  **** 	void appPrepareDataFrame(void)
 560:ServerLLDN.c  **** 	{
 1564               		.loc 6 560 0
 1565               		.cfi_startproc
 1566 07d8 CF93      		push r28
 1567               	.LCFI61:
 1568               		.cfi_def_cfa_offset 3
 1569               		.cfi_offset 28, -2
 1570 07da DF93      		push r29
 1571               	.LCFI62:
 1572               		.cfi_def_cfa_offset 4
 1573               		.cfi_offset 29, -3
 1574 07dc CDB7      		in r28,__SP_L__
 1575 07de DEB7      		in r29,__SP_H__
 1576               	.LCFI63:
 1577               		.cfi_def_cfa_register 28
 1578               	/* prologue: function */
 1579               	/* frame size = 0 */
 1580               	/* stack size = 2 */
 1581               	.L__stack_usage = 2
 561:ServerLLDN.c  **** 		
 562:ServerLLDN.c  **** 		PHY_SetTdmaMode(false);
 1582               		.loc 6 562 0
 1583 07e0 80E0      		ldi r24,0
 1584 07e2 0E94 0000 		call PHY_SetTdmaMode
 563:ServerLLDN.c  **** 
 564:ServerLLDN.c  **** 	
 565:ServerLLDN.c  **** 		msgReq.dstAddr				= 0;
 1585               		.loc 6 565 0
 1586 07e6 1092 0000 		sts msgReq+5+1,__zero_reg__
 1587 07ea 1092 0000 		sts msgReq+5,__zero_reg__
 566:ServerLLDN.c  **** 		msgReq.dstEndpoint			= APP_COMMAND_ENDPOINT;
 1588               		.loc 6 566 0
 1589 07ee 83E0      		ldi r24,lo8(3)
 1590 07f0 8093 0000 		sts msgReq+7,r24
 567:ServerLLDN.c  **** 		msgReq.srcEndpoint			= APP_COMMAND_ENDPOINT;
 1591               		.loc 6 567 0
 1592 07f4 83E0      		ldi r24,lo8(3)
 1593 07f6 8093 0000 		sts msgReq+8,r24
 568:ServerLLDN.c  **** 		msgReq.options				= NWK_OPT_LLDN_DATA;
 1594               		.loc 6 568 0
 1595 07fa 80E0      		ldi r24,0
 1596 07fc 90E2      		ldi r25,lo8(32)
 1597 07fe 9093 0000 		sts msgReq+9+1,r25
 1598 0802 8093 0000 		sts msgReq+9,r24
 569:ServerLLDN.c  **** 		msgReq.data					= (uint8_t *)&data_payload;
 1599               		.loc 6 569 0
 1600 0806 80E0      		ldi r24,lo8(data_payload)
 1601 0808 90E0      		ldi r25,hi8(data_payload)
 1602 080a 9093 0000 		sts msgReq+13+1,r25
 1603 080e 8093 0000 		sts msgReq+13,r24
 570:ServerLLDN.c  **** 		msgReq.size					= sizeof(data_payload);
 1604               		.loc 6 570 0
 1605 0812 81E0      		ldi r24,lo8(1)
 1606 0814 8093 0000 		sts msgReq+15,r24
 571:ServerLLDN.c  **** 	}
 1607               		.loc 6 571 0
 1608 0818 0000      		nop
 1609               	/* epilogue start */
 1610 081a DF91      		pop r29
 1611 081c CF91      		pop r28
 1612 081e 0895      		ret
 1613               		.cfi_endproc
 1614               	.LFE139:
 1617               	appInit:
 1618               	.LFB140:
 572:ServerLLDN.c  **** 	
 573:ServerLLDN.c  **** 	
 574:ServerLLDN.c  **** #endif // APP_COORDINATOR
 575:ServerLLDN.c  **** 
 576:ServerLLDN.c  **** static void appInit(void)
 577:ServerLLDN.c  **** {
 1619               		.loc 6 577 0
 1620               		.cfi_startproc
 1621 0820 CF93      		push r28
 1622               	.LCFI64:
 1623               		.cfi_def_cfa_offset 3
 1624               		.cfi_offset 28, -2
 1625 0822 DF93      		push r29
 1626               	.LCFI65:
 1627               		.cfi_def_cfa_offset 4
 1628               		.cfi_offset 29, -3
 1629 0824 CDB7      		in r28,__SP_L__
 1630 0826 DEB7      		in r29,__SP_H__
 1631               	.LCFI66:
 1632               		.cfi_def_cfa_register 28
 1633               	/* prologue: function */
 1634               	/* frame size = 0 */
 1635               	/* stack size = 2 */
 1636               	.L__stack_usage = 2
 578:ServerLLDN.c  **** 	NWK_SetAddr(APP_ADDR);
 1637               		.loc 6 578 0
 1638 0828 81E0      		ldi r24,lo8(1)
 1639 082a 90E0      		ldi r25,0
 1640 082c 0E94 0000 		call NWK_SetAddr
 579:ServerLLDN.c  **** 	PHY_SetChannel(APP_CHANNEL);
 1641               		.loc 6 579 0
 1642 0830 8FE0      		ldi r24,lo8(15)
 1643 0832 0E94 0000 		call PHY_SetChannel
 580:ServerLLDN.c  **** 	PHY_SetRxState(true);
 1644               		.loc 6 580 0
 1645 0836 81E0      		ldi r24,lo8(1)
 1646 0838 0E94 0000 		call PHY_SetRxState
 581:ServerLLDN.c  **** 		
 582:ServerLLDN.c  **** 	#if APP_COORDINATOR	 
 583:ServerLLDN.c  **** 		/* Timer used for delay between messages */
 584:ServerLLDN.c  **** 		tmrDelay.interval = 1;
 585:ServerLLDN.c  **** 		tmrDelay.mode = SYS_TIMER_INTERVAL_MODE;
 586:ServerLLDN.c  **** 		tmrDelay.handler = tmrDelayHandler;
 587:ServerLLDN.c  **** 	  
 588:ServerLLDN.c  **** 		/* 
 589:ServerLLDN.c  **** 		* Disable CSMA/CA
 590:ServerLLDN.c  **** 		* Disable auto ACK
 591:ServerLLDN.c  **** 		*/
 592:ServerLLDN.c  **** 		NWK_SetPanId(APP_PANID);
 593:ServerLLDN.c  **** 		PanId = APP_PANID;
 594:ServerLLDN.c  **** 		ACKFrame.sourceId = APP_PANID;
 595:ServerLLDN.c  **** 		PHY_SetTdmaMode(true);
 596:ServerLLDN.c  **** 	NWK_OpenEndpoint(APP_COMMAND_ENDPOINT, appCommandInd);
 597:ServerLLDN.c  **** 	#else
 598:ServerLLDN.c  **** 		/*
 599:ServerLLDN.c  **** 		 * Enable CSMA/CA
 600:ServerLLDN.c  **** 		 * Enable Random CSMA seed generator
 601:ServerLLDN.c  **** 		 */
 602:ServerLLDN.c  **** 		PHY_SetTdmaMode(false);
 1647               		.loc 6 602 0
 1648 083c 80E0      		ldi r24,0
 1649 083e 0E94 0000 		call PHY_SetTdmaMode
 603:ServerLLDN.c  **** 		// PHY_SetOptimizedCSMAValues();
 604:ServerLLDN.c  **** 		
 605:ServerLLDN.c  **** 		payloadSize = 127;
 1650               		.loc 6 605 0
 1651 0842 8FE7      		ldi r24,lo8(127)
 1652 0844 8093 0000 		sts payloadSize,r24
 606:ServerLLDN.c  **** 		NWK_OpenEndpoint(APP_BEACON_ENDPOINT, appBeaconInd);
 1653               		.loc 6 606 0
 1654 0848 60E0      		ldi r22,lo8(gs(appBeaconInd))
 1655 084a 70E0      		ldi r23,hi8(gs(appBeaconInd))
 1656 084c 80E0      		ldi r24,0
 1657 084e 0E94 0000 		call NWK_OpenEndpoint
 607:ServerLLDN.c  **** 		NWK_OpenEndpoint(APP_ACK_ENDPOINT, appAckInd);
 1658               		.loc 6 607 0
 1659 0852 60E0      		ldi r22,lo8(gs(appAckInd))
 1660 0854 70E0      		ldi r23,hi8(gs(appAckInd))
 1661 0856 84E0      		ldi r24,lo8(4)
 1662 0858 0E94 0000 		call NWK_OpenEndpoint
 608:ServerLLDN.c  **** 		NWK_OpenEndpoint(APP_COMMAND_ENDPOINT, appCommandInd);
 1663               		.loc 6 608 0
 1664 085c 60E0      		ldi r22,lo8(gs(appCommandInd))
 1665 085e 70E0      		ldi r23,hi8(gs(appCommandInd))
 1666 0860 83E0      		ldi r24,lo8(3)
 1667 0862 0E94 0000 		call NWK_OpenEndpoint
 609:ServerLLDN.c  **** 		/*
 610:ServerLLDN.c  **** 		* Configure interrupts callback functions
 611:ServerLLDN.c  **** 		*/
 612:ServerLLDN.c  **** 		
 613:ServerLLDN.c  **** 	#endif // APP_COORDENATOR
 614:ServerLLDN.c  **** 	PHY_SetPromiscuousMode(true);
 1668               		.loc 6 614 0
 1669 0866 81E0      		ldi r24,lo8(1)
 1670 0868 0E94 0000 		call PHY_SetPromiscuousMode
 615:ServerLLDN.c  **** 
 616:ServerLLDN.c  **** }
 1671               		.loc 6 616 0
 1672 086c 0000      		nop
 1673               	/* epilogue start */
 1674 086e DF91      		pop r29
 1675 0870 CF91      		pop r28
 1676 0872 0895      		ret
 1677               		.cfi_endproc
 1678               	.LFE140:
 1680               		.section	.rodata
 1681               	.LC6:
 1682 003d 0A72 6574 		.string	"\nretransmition_slot %d"
 1682      7261 6E73 
 1682      6D69 7469 
 1682      6F6E 5F73 
 1682      6C6F 7420 
 1683               		.text
 1685               	APP_TaskHandler:
 1686               	.LFB141:
 617:ServerLLDN.c  **** 
 618:ServerLLDN.c  **** static void APP_TaskHandler(void)
 619:ServerLLDN.c  **** {
 1687               		.loc 6 619 0
 1688               		.cfi_startproc
 1689 0874 CF93      		push r28
 1690               	.LCFI67:
 1691               		.cfi_def_cfa_offset 3
 1692               		.cfi_offset 28, -2
 1693 0876 DF93      		push r29
 1694               	.LCFI68:
 1695               		.cfi_def_cfa_offset 4
 1696               		.cfi_offset 29, -3
 1697 0878 00D0      		rcall .
 1698 087a 00D0      		rcall .
 1699               	.LCFI69:
 1700               		.cfi_def_cfa_offset 8
 1701 087c CDB7      		in r28,__SP_L__
 1702 087e DEB7      		in r29,__SP_H__
 1703               	.LCFI70:
 1704               		.cfi_def_cfa_register 28
 1705               	/* prologue: function */
 1706               	/* frame size = 4 */
 1707               	/* stack size = 6 */
 1708               	.L__stack_usage = 6
 620:ServerLLDN.c  **** 	switch (appState){
 1709               		.loc 6 620 0
 1710 0880 8091 0000 		lds r24,appState
 1711 0884 882F      		mov r24,r24
 1712 0886 90E0      		ldi r25,0
 1713 0888 8430      		cpi r24,4
 1714 088a 9105      		cpc r25,__zero_reg__
 1715 088c 01F0      		breq .L47
 1716 088e 8530      		cpi r24,5
 1717 0890 9105      		cpc r25,__zero_reg__
 1718 0892 04F4      		brge .L48
 1719 0894 0097      		sbiw r24,0
 1720 0896 01F0      		breq .L49
 1721 0898 0297      		sbiw r24,2
 1722 089a 01F0      		breq .L50
 621:ServerLLDN.c  **** 		case APP_STATE_INITIAL:
 622:ServerLLDN.c  **** 		{
 623:ServerLLDN.c  **** 			appInit();
 624:ServerLLDN.c  **** 			#if APP_COORDINATOR
 625:ServerLLDN.c  **** 				appState = APP_STATE_ATT_PAN_STATE;
 626:ServerLLDN.c  **** 			#else
 627:ServerLLDN.c  **** 				appState = APP_STATE_IDLE;
 628:ServerLLDN.c  **** 			#endif
 629:ServerLLDN.c  **** 			break;
 630:ServerLLDN.c  **** 		}
 631:ServerLLDN.c  **** 		case APP_STATE_SEND:
 632:ServerLLDN.c  **** 		{
 633:ServerLLDN.c  **** 			appSendData();
 634:ServerLLDN.c  **** 			#if APP_COORDINATOR
 635:ServerLLDN.c  **** 				/* Every time a message is send updates coordinator to prepare next message */
 636:ServerLLDN.c  **** 				appState = APP_STATE_ATT_PAN_STATE;
 637:ServerLLDN.c  **** 			#else
 638:ServerLLDN.c  **** 				appState = APP_STATE_IDLE;
 639:ServerLLDN.c  **** 			#endif
 640:ServerLLDN.c  **** 			break;
 641:ServerLLDN.c  **** 		}
 642:ServerLLDN.c  **** 		#if APP_COORDINATOR // COORDINATOR SPECIFIC STATE MACHINE
 643:ServerLLDN.c  **** 		case APP_STATE_ATT_PAN_STATE:
 644:ServerLLDN.c  **** 		{
 645:ServerLLDN.c  **** 			switch(appPanState)
 646:ServerLLDN.c  **** 			{
 647:ServerLLDN.c  **** 				/* Prepare beacon to desassociate all nodes */
 648:ServerLLDN.c  **** 				case APP_PAN_STATE_RESET:
 649:ServerLLDN.c  **** 				{
 650:ServerLLDN.c  **** 					appPanReset();
 651:ServerLLDN.c  **** 					appPanState = APP_PAN_STATE_DISC_INITIAL;
 652:ServerLLDN.c  **** 					appState	= APP_STATE_SEND;
 653:ServerLLDN.c  **** 					cycles_counter = 0;
 654:ServerLLDN.c  **** 					break;
 655:ServerLLDN.c  **** 				}
 656:ServerLLDN.c  **** 				/* Prepare first Beacon of Discovery */
 657:ServerLLDN.c  **** 				case APP_PAN_STATE_DISC_INITIAL:
 658:ServerLLDN.c  **** 				{
 659:ServerLLDN.c  **** 					/* if nodes associated is equal to expected number of associated nodes stop association proces
 660:ServerLLDN.c  **** 					 * this implementation was done as is to be used in tests, for real network functionality 
 661:ServerLLDN.c  **** 					 * the number of max association processes must be done through macLLDNdiscoveryModeTimeout
 662:ServerLLDN.c  **** 					 */
 663:ServerLLDN.c  **** 					if(counter_associados == NODOS_ASSOCIADOS_ESPERADOS || cycles_counter >= 2)
 664:ServerLLDN.c  **** 					{	
 665:ServerLLDN.c  **** 						printf("\n%d, %d", cycles_counter, counter_associados);
 666:ServerLLDN.c  **** 						counter_associados = 0;
 667:ServerLLDN.c  **** 						/* if all nodes expected where associated stop beacon generation interruptions */
 668:ServerLLDN.c  **** 						// macsc_disable_cmp_int(MACSC_CC1);
 669:ServerLLDN.c  **** 						macsc_disable_cmp_int(MACSC_CC2);
 670:ServerLLDN.c  **** 						msgReq.options = 0;
 671:ServerLLDN.c  **** 						
 672:ServerLLDN.c  **** 						macLLDNnumUplinkTS = (assTimeSlot) * 2 + 1;
 673:ServerLLDN.c  **** 						macLLDNRetransmitTS = assTimeSlot;
 674:ServerLLDN.c  **** 						macLLDNnumTimeSlots = macLLDNnumUplinkTS + 2 *MacLLDNMgmtTS;
 675:ServerLLDN.c  **** 						
 676:ServerLLDN.c  **** 						for(int i = 0; i < 32; i++)
 677:ServerLLDN.c  **** 						ACKFrame.ackFlags[i] = 0;
 678:ServerLLDN.c  **** 						ACKFrame_size = 0;
 679:ServerLLDN.c  **** 						
 680:ServerLLDN.c  **** 						appState = APP_STATE_IDLE;
 681:ServerLLDN.c  **** 						appPanState = APP_PAN_STATE_ONLINE_INITIAL; // APP_PAN_STATE_ONLINE_INIT
 682:ServerLLDN.c  **** 						cycles_counter = NUMERO_CICLOS_ONLINE;
 683:ServerLLDN.c  **** 					}
 684:ServerLLDN.c  **** 					/* if not all nodes expected where associated run through association process again */
 685:ServerLLDN.c  **** 					else 
 686:ServerLLDN.c  **** 					{
 687:ServerLLDN.c  **** 						/* prepare beacon message and start timers for beacon */
 688:ServerLLDN.c  **** 						appPanDiscInit();
 689:ServerLLDN.c  **** 						appState	= APP_STATE_IDLE;
 690:ServerLLDN.c  **** 						appPanState = APP_PAN_STATE_DISC_SECOND_BE;
 691:ServerLLDN.c  **** 					}
 692:ServerLLDN.c  **** 					break;
 693:ServerLLDN.c  **** 				}
 694:ServerLLDN.c  **** 				case APP_PAN_STATE_DISC_SECOND_BE:
 695:ServerLLDN.c  **** 				{
 696:ServerLLDN.c  **** 					/* Prepares message as: Discovery Beacon and Second Beacon */
 697:ServerLLDN.c  **** 					msgReq.options = NWK_OPT_LLDN_BEACON | NWK_OPT_DISCOVERY_STATE | NWK_OPT_SECOND_BEACON ;
 698:ServerLLDN.c  **** 					msgReq.data = NULL;
 699:ServerLLDN.c  **** 					msgReq.size = 0;
 700:ServerLLDN.c  **** 					
 701:ServerLLDN.c  **** 					appState	= APP_PAN_STATE_DISC_PREPARE_ACK;
 702:ServerLLDN.c  **** 					appPanState = APP_PAN_STATE_DISC_PREPARE_ACK;
 703:ServerLLDN.c  **** 					break;
 704:ServerLLDN.c  **** 				}
 705:ServerLLDN.c  **** 				case APP_PAN_STATE_DISC_PREPARE_ACK:
 706:ServerLLDN.c  **** 				{
 707:ServerLLDN.c  **** 					/* This timer implements a delay between messages, 
 708:ServerLLDN.c  **** 					 * if not used the nodes are not able to receive the message
 709:ServerLLDN.c  **** 					 */
 710:ServerLLDN.c  **** 					appPanPrepareACK();
 711:ServerLLDN.c  **** 					SYS_TimerStart(&tmrDelay);
 712:ServerLLDN.c  **** 					
 713:ServerLLDN.c  **** 					appPanState = APP_PAN_STATE_CONFIG_INITIAL;
 714:ServerLLDN.c  **** 					appState = APP_STATE_IDLE;
 715:ServerLLDN.c  **** 					break;
 716:ServerLLDN.c  **** 				}
 717:ServerLLDN.c  **** 				case APP_PAN_STATE_CONFIG_INITIAL:
 718:ServerLLDN.c  **** 				{
 719:ServerLLDN.c  **** 					/* Prepares the message as: Configuration Beacon and First State Beacon */
 720:ServerLLDN.c  **** 					msgReq.options = NWK_OPT_LLDN_BEACON | NWK_OPT_CONFIG_STATE;
 721:ServerLLDN.c  **** 					msgReq.data = NULL;
 722:ServerLLDN.c  **** 					msgReq.size = 0;
 723:ServerLLDN.c  **** 					
 724:ServerLLDN.c  **** 					appState	= APP_STATE_IDLE;
 725:ServerLLDN.c  **** 					appPanState = APP_PAN_STATE_CONFIG_SECOND_BEACON;
 726:ServerLLDN.c  **** 					break;
 727:ServerLLDN.c  **** 
 728:ServerLLDN.c  **** 				}
 729:ServerLLDN.c  **** 				case APP_PAN_STATE_CONFIG_SECOND_BEACON:
 730:ServerLLDN.c  **** 				{
 731:ServerLLDN.c  **** 					/* Prepares the message as: Configuration Beacon and Second State Beacon */
 732:ServerLLDN.c  **** 					msgReq.options = NWK_OPT_LLDN_BEACON | NWK_OPT_CONFIG_STATE | NWK_OPT_SECOND_BEACON;
 733:ServerLLDN.c  **** 					msgReq.data = NULL;
 734:ServerLLDN.c  **** 					msgReq.size = 0;
 735:ServerLLDN.c  **** 					
 736:ServerLLDN.c  **** 					counter_delay_msg = 0;
 737:ServerLLDN.c  **** 					
 738:ServerLLDN.c  **** 					appState	= APP_STATE_IDLE;
 739:ServerLLDN.c  **** 					appPanState = APP_PAN_STATE_SEND_CONF_REQUEST;
 740:ServerLLDN.c  **** 					
 741:ServerLLDN.c  **** 					break;
 742:ServerLLDN.c  **** 				}
 743:ServerLLDN.c  **** 				case APP_PAN_STATE_SEND_CONF_REQUEST:
 744:ServerLLDN.c  **** 				{
 745:ServerLLDN.c  **** 					if(conf_req_list != NULL)
 746:ServerLLDN.c  **** 					{
 747:ServerLLDN.c  **** 						CopyToConfigRequest();
 748:ServerLLDN.c  **** 						msgReq.options		= NWK_OPT_MAC_COMMAND;
 749:ServerLLDN.c  **** 						msgReq.data			= (uint8_t*)&config_request_frame;
 750:ServerLLDN.c  **** 						msgReq.size			= sizeof(NWK_ConfigRequest_t);
 751:ServerLLDN.c  **** 						appState	= APP_STATE_IDLE;
 752:ServerLLDN.c  **** 						appPanState = APP_PAN_STATE_SEND_CONF_REQUEST;
 753:ServerLLDN.c  **** 						
 754:ServerLLDN.c  **** 						// Delay between messages
 755:ServerLLDN.c  **** 						macsc_set_cmp1_int_cb(downlink_delay_handler);
 756:ServerLLDN.c  **** 						macsc_disable_cmp_int(MACSC_CC1);
 757:ServerLLDN.c  **** 						macsc_enable_manual_bts();
 758:ServerLLDN.c  **** 						macsc_enable_cmp_int(MACSC_CC1);
 759:ServerLLDN.c  **** 						macsc_use_cmp(MACSC_RELATIVE_CMP, DELAY, MACSC_CC1);
 760:ServerLLDN.c  **** 						
 761:ServerLLDN.c  **** 						counter_associados++;
 762:ServerLLDN.c  **** 					}
 763:ServerLLDN.c  **** 					else
 764:ServerLLDN.c  **** 					{
 765:ServerLLDN.c  **** 						if(counter_delay_msg > 0)
 766:ServerLLDN.c  **** 						{
 767:ServerLLDN.c  **** 							macsc_set_cmp1_int_cb(lldn_server_beacon);
 768:ServerLLDN.c  **** 							macsc_disable_cmp_int(MACSC_CC1);
 769:ServerLLDN.c  **** 							macsc_enable_manual_bts();
 770:ServerLLDN.c  **** 							macsc_enable_cmp_int(MACSC_CC1);
 771:ServerLLDN.c  **** 							macsc_use_cmp(MACSC_RELATIVE_CMP,beaconInterval_association - counter_delay_msg * DELAY, MAC
 772:ServerLLDN.c  **** 						}
 773:ServerLLDN.c  **** 						
 774:ServerLLDN.c  **** 						appState	= APP_STATE_ATT_PAN_STATE;
 775:ServerLLDN.c  **** 						appPanState = APP_PAN_STATE_CONFIG_THIRD_BEACON;
 776:ServerLLDN.c  **** 					}
 777:ServerLLDN.c  **** 					break;
 778:ServerLLDN.c  **** 				}
 779:ServerLLDN.c  **** 				case APP_PAN_STATE_CONFIG_THIRD_BEACON:
 780:ServerLLDN.c  **** 				{
 781:ServerLLDN.c  **** 					msgReq.options = NWK_OPT_LLDN_BEACON | NWK_OPT_CONFIG_STATE | NWK_OPT_THIRD_BEACON;
 782:ServerLLDN.c  **** 					msgReq.data = NULL;
 783:ServerLLDN.c  **** 					msgReq.size = 0;
 784:ServerLLDN.c  **** 					
 785:ServerLLDN.c  **** 					appState	= APP_STATE_IDLE;
 786:ServerLLDN.c  **** 					appPanState = APP_PAN_STATE_DISC_INITIAL;
 787:ServerLLDN.c  **** 					cycles_counter++;	
 788:ServerLLDN.c  **** 					
 789:ServerLLDN.c  **** 					break;
 790:ServerLLDN.c  **** 				}
 791:ServerLLDN.c  **** 				case APP_PAN_STATE_ONLINE_INITIAL:
 792:ServerLLDN.c  **** 				{
 793:ServerLLDN.c  **** 					if(cycles_counter != 0)
 794:ServerLLDN.c  **** 					{
 795:ServerLLDN.c  **** 					appPanOnlineInit();
 796:ServerLLDN.c  **** 					appState = APP_STATE_SEND;
 797:ServerLLDN.c  **** 					appPanState = APP_PAN_STATE_ONLINE_PREPARE_ACK_GROUP;
 798:ServerLLDN.c  **** 	
 799:ServerLLDN.c  **** 					cycles_counter--;
 800:ServerLLDN.c  **** 					}
 801:ServerLLDN.c  **** 					break;
 802:ServerLLDN.c  **** 				}
 803:ServerLLDN.c  **** 				case APP_PAN_STATE_ONLINE_PREPARE_ACK_GROUP:
 804:ServerLLDN.c  **** 				{
 805:ServerLLDN.c  **** 					for(int i = 0; i < 32; i++)
 806:ServerLLDN.c  **** 						ACKFrame.ackFlags[i] = 0;
 807:ServerLLDN.c  **** 					ACKFrame_size = 0;
 808:ServerLLDN.c  **** 					
 809:ServerLLDN.c  **** 					msgReq.dstAddr		= 0;
 810:ServerLLDN.c  **** 					msgReq.dstEndpoint	= APP_BEACON_ENDPOINT;
 811:ServerLLDN.c  **** 					msgReq.srcEndpoint	= APP_BEACON_ENDPOINT;
 812:ServerLLDN.c  **** 					msgReq.options		= NWK_OPT_LLDN_ACK;
 813:ServerLLDN.c  **** 					msgReq.data	= (uint8_t *)&ACKFrame;
 814:ServerLLDN.c  **** 					msgReq.size	= sizeof(uint8_t)*(macLLDNRetransmitTS + 1);
 815:ServerLLDN.c  **** 					
 816:ServerLLDN.c  **** 					appState = APP_STATE_IDLE;
 817:ServerLLDN.c  **** 					appPanState = APP_PAN_STATE_CHECK_TS;
 818:ServerLLDN.c  **** 					break;
 819:ServerLLDN.c  **** 				}				
 820:ServerLLDN.c  **** 				case APP_PAN_STATE_CHECK_TS:
 821:ServerLLDN.c  **** 				{
 822:ServerLLDN.c  **** 					if(timeslot_counter >= (macLLDNnumUplinkTS + 2*MacLLDNMgmtTS))
 823:ServerLLDN.c  **** 					{
 824:ServerLLDN.c  **** 						if(!association_request)
 825:ServerLLDN.c  **** 						{
 826:ServerLLDN.c  **** 							macsc_set_cmp1_int_cb(end_of_association_delay_handler);
 827:ServerLLDN.c  **** 							macsc_disable_cmp_int(MACSC_CC1);
 828:ServerLLDN.c  **** 							macsc_enable_manual_bts();
 829:ServerLLDN.c  **** 							macsc_enable_cmp_int(MACSC_CC1);
 830:ServerLLDN.c  **** 							macsc_use_cmp(MACSC_RELATIVE_CMP, 5 * beaconInterval_association, MACSC_CC1);
 831:ServerLLDN.c  **** 						}
 832:ServerLLDN.c  **** 						else
 833:ServerLLDN.c  **** 						{
 834:ServerLLDN.c  **** 							printf("\nFim de um Perodo");
 835:ServerLLDN.c  **** 							macsc_disable_cmp_int(MACSC_CC1);
 836:ServerLLDN.c  **** 							macsc_disable_cmp_int(MACSC_CC2);
 837:ServerLLDN.c  **** 							
 838:ServerLLDN.c  **** 						}
 839:ServerLLDN.c  **** 						appState = APP_STATE_IDLE;
 840:ServerLLDN.c  **** 						appPanState = APP_PAN_STATE_IDLE;
 841:ServerLLDN.c  **** 					}
 842:ServerLLDN.c  **** 					else
 843:ServerLLDN.c  **** 					{
 844:ServerLLDN.c  **** 
 845:ServerLLDN.c  **** 						/* check if coordinator received any message in last time slot, used to calculate success rat
 846:ServerLLDN.c  **** 						if(timeslot_counter >= 2*MacLLDNMgmtTS && !data_received)
 847:ServerLLDN.c  **** 							nodes_info_arr[timeslot_counter - 2*MacLLDNMgmtTS].msg_not_rec++;
 848:ServerLLDN.c  **** 						data_received = false;
 849:ServerLLDN.c  **** 						
 850:ServerLLDN.c  **** 						printf("\n------- slot %d --------", timeslot_counter);
 851:ServerLLDN.c  **** 						
 852:ServerLLDN.c  **** 						if(timeslot_counter == 2*MacLLDNMgmtTS + macLLDNRetransmitTS)
 853:ServerLLDN.c  **** 						{
 854:ServerLLDN.c  **** 							data_received = true;
 855:ServerLLDN.c  **** 							printf("\nack_frame %hhx", ACKFrame.ackFlags[0]);
 856:ServerLLDN.c  **** 							appState = APP_STATE_SEND;
 857:ServerLLDN.c  **** 							appPanState = APP_PAN_STATE_IDLE;
 858:ServerLLDN.c  **** 						}
 859:ServerLLDN.c  **** 						else
 860:ServerLLDN.c  **** 							appState = APP_STATE_IDLE;
 861:ServerLLDN.c  **** 						timeslot_counter++;
 862:ServerLLDN.c  **** 					}
 863:ServerLLDN.c  **** 					break;
 864:ServerLLDN.c  **** 				}
 865:ServerLLDN.c  **** 				case APP_PAN_STATE_IDLE:
 866:ServerLLDN.c  **** 				{
 867:ServerLLDN.c  **** 					msgReq.options = 0;
 868:ServerLLDN.c  **** 					appState = APP_STATE_IDLE;
 869:ServerLLDN.c  **** 					break;
 870:ServerLLDN.c  **** 				}
 871:ServerLLDN.c  **** 			}
 872:ServerLLDN.c  **** 			break;	
 873:ServerLLDN.c  **** 		}
 874:ServerLLDN.c  **** 		#else // NODES SPECIFIC STATE MACHINE
 875:ServerLLDN.c  **** 		case APP_STATE_PREP_DISC_REPONSE:
 876:ServerLLDN.c  **** 		{
 877:ServerLLDN.c  **** 			appPrepareDiscoverResponse();
 878:ServerLLDN.c  **** 			appState = APP_STATE_IDLE;	
 879:ServerLLDN.c  **** 			break;
 880:ServerLLDN.c  **** 		}
 881:ServerLLDN.c  **** 		
 882:ServerLLDN.c  **** 		case APP_STATE_PREP_CONFIG_STATUS:
 883:ServerLLDN.c  **** 		{
 884:ServerLLDN.c  **** 			// se o nodo recebeu ack na fase do discovery prepara a mensagem de configuration status
 885:ServerLLDN.c  **** 			if(ack_received && rec_beacon->confSeqNumber == 0 && associated == 0 && STATE != ONLINE_MODE) {
 886:ServerLLDN.c  **** 				appPrepareConfigurationStatus();
 887:ServerLLDN.c  **** 			}
 888:ServerLLDN.c  **** 			// se o nodo no recebeu desativa o timer e fica em idle
 889:ServerLLDN.c  **** 			else {
 890:ServerLLDN.c  **** 				#if MASTER_MACSC
 891:ServerLLDN.c  **** 				macsc_disable_cmp_int(MACSC_CC1);
 892:ServerLLDN.c  **** 				#else
 893:ServerLLDN.c  **** 				timer_stop();
 894:ServerLLDN.c  **** 				#endif
 895:ServerLLDN.c  **** 			}
 896:ServerLLDN.c  **** 			ack_received = 0;
 897:ServerLLDN.c  **** 			appState = APP_STATE_IDLE;
 898:ServerLLDN.c  **** 			break;
 899:ServerLLDN.c  **** 		}
 900:ServerLLDN.c  **** 		case APP_STATE_PREP_DATA_FRAME:
 901:ServerLLDN.c  **** 		{
 902:ServerLLDN.c  **** 			appPrepareDataFrame();
 903:ServerLLDN.c  **** 			appState = APP_STATE_IDLE;
 904:ServerLLDN.c  **** 			break;
 905:ServerLLDN.c  **** 		}
 906:ServerLLDN.c  **** 		case APP_STATE_RETRANSMIT_DATA:
 907:ServerLLDN.c  **** 		{
 908:ServerLLDN.c  **** 			if(!ack_received)
 909:ServerLLDN.c  **** 			{
 910:ServerLLDN.c  **** 				int retransmition_slot = 0;
 911:ServerLLDN.c  **** 				
 912:ServerLLDN.c  **** 				for(int i = 0; i < assTimeSlot && i < (rec_beacon->NumberOfBaseTimeslotsinSuperframe - 3)/2; i+
 913:ServerLLDN.c  **** 					if( check_ack(i) )
 914:ServerLLDN.c  **** 						retransmition_slot++;
 915:ServerLLDN.c  **** 				printf("\nretransmition_slot %d", retransmition_slot);
 916:ServerLLDN.c  **** 				if(retransmition_slot == 0)
 917:ServerLLDN.c  **** 				{
 918:ServerLLDN.c  **** 					appState = APP_STATE_SEND;			
 919:ServerLLDN.c  **** 				}
 920:ServerLLDN.c  **** 				else
 921:ServerLLDN.c  **** 				{
 922:ServerLLDN.c  **** 					#if MASTER_MACSC
 923:ServerLLDN.c  **** 					macsc_enable_manual_bts();
 924:ServerLLDN.c  **** 					macsc_set_cmp1_int_cb(send_message_timeHandler);
 925:ServerLLDN.c  **** 					macsc_enable_cmp_int(MACSC_CC1);
 926:ServerLLDN.c  **** 					macsc_use_cmp(MACSC_RELATIVE_CMP, ts_time * retransmition_slot, MACSC_CC1);
 927:ServerLLDN.c  **** 					#endif
 928:ServerLLDN.c  **** 				}
 929:ServerLLDN.c  **** 			}
 930:ServerLLDN.c  **** 			else
 931:ServerLLDN.c  **** 			{
 932:ServerLLDN.c  **** 				appState = APP_STATE_IDLE;	
 933:ServerLLDN.c  **** 			}
 934:ServerLLDN.c  **** 			
 935:ServerLLDN.c  **** 			break;
 936:ServerLLDN.c  **** 		}
 937:ServerLLDN.c  **** 		#endif
 938:ServerLLDN.c  **** 		default:
 939:ServerLLDN.c  **** 		{
 940:ServerLLDN.c  **** 			break;
 1723               		.loc 6 940 0
 1724 089c 00C0      		rjmp .L54
 1725               	.L48:
 620:ServerLLDN.c  **** 	switch (appState){
 1726               		.loc 6 620 0
 1727 089e 8630      		cpi r24,6
 1728 08a0 9105      		cpc r25,__zero_reg__
 1729 08a2 01F0      		breq .L51
 1730 08a4 8630      		cpi r24,6
 1731 08a6 9105      		cpc r25,__zero_reg__
 1732 08a8 04F0      		brlt .L52
 1733 08aa 0797      		sbiw r24,7
 1734 08ac 01F0      		breq .L53
 1735               		.loc 6 940 0
 1736 08ae 00C0      		rjmp .L54
 1737               	.L49:
 623:ServerLLDN.c  **** 			#if APP_COORDINATOR
 1738               		.loc 6 623 0
 1739 08b0 0E94 0000 		call appInit
 627:ServerLLDN.c  **** 			#endif
 1740               		.loc 6 627 0
 1741 08b4 81E0      		ldi r24,lo8(1)
 1742 08b6 8093 0000 		sts appState,r24
 629:ServerLLDN.c  **** 		}
 1743               		.loc 6 629 0
 1744 08ba 00C0      		rjmp .L54
 1745               	.L50:
 633:ServerLLDN.c  **** 			#if APP_COORDINATOR
 1746               		.loc 6 633 0
 1747 08bc 0E94 0000 		call appSendData
 638:ServerLLDN.c  **** 			#endif
 1748               		.loc 6 638 0
 1749 08c0 81E0      		ldi r24,lo8(1)
 1750 08c2 8093 0000 		sts appState,r24
 640:ServerLLDN.c  **** 		}
 1751               		.loc 6 640 0
 1752 08c6 00C0      		rjmp .L54
 1753               	.L47:
 877:ServerLLDN.c  **** 			appState = APP_STATE_IDLE;	
 1754               		.loc 6 877 0
 1755 08c8 0E94 0000 		call appPrepareDiscoverResponse
 878:ServerLLDN.c  **** 			break;
 1756               		.loc 6 878 0
 1757 08cc 81E0      		ldi r24,lo8(1)
 1758 08ce 8093 0000 		sts appState,r24
 879:ServerLLDN.c  **** 		}
 1759               		.loc 6 879 0
 1760 08d2 00C0      		rjmp .L54
 1761               	.L52:
 885:ServerLLDN.c  **** 				appPrepareConfigurationStatus();
 1762               		.loc 6 885 0
 1763 08d4 8091 0000 		lds r24,ack_received
 1764 08d8 8823      		tst r24
 1765 08da 01F0      		breq .L55
 885:ServerLLDN.c  **** 				appPrepareConfigurationStatus();
 1766               		.loc 6 885 0 is_stmt 0 discriminator 1
 1767 08dc 8091 0000 		lds r24,rec_beacon
 1768 08e0 9091 0000 		lds r25,rec_beacon+1
 1769 08e4 FC01      		movw r30,r24
 1770 08e6 8581      		ldd r24,Z+5
 1771 08e8 8823      		tst r24
 1772 08ea 01F4      		brne .L55
 885:ServerLLDN.c  **** 				appPrepareConfigurationStatus();
 1773               		.loc 6 885 0 discriminator 2
 1774 08ec 9091 0000 		lds r25,associated
 1775 08f0 81E0      		ldi r24,lo8(1)
 1776 08f2 8927      		eor r24,r25
 1777 08f4 8823      		tst r24
 1778 08f6 01F0      		breq .L55
 885:ServerLLDN.c  **** 				appPrepareConfigurationStatus();
 1779               		.loc 6 885 0 discriminator 3
 1780 08f8 8091 0000 		lds r24,STATE
 1781 08fc 8823      		tst r24
 1782 08fe 01F0      		breq .L55
 886:ServerLLDN.c  **** 			}
 1783               		.loc 6 886 0 is_stmt 1
 1784 0900 0E94 0000 		call appPrepareConfigurationStatus
 1785 0904 00C0      		rjmp .L56
 1786               	.L55:
 891:ServerLLDN.c  **** 				#else
 1787               		.loc 6 891 0
 1788 0906 81E0      		ldi r24,lo8(1)
 1789 0908 0E94 0000 		call macsc_disable_cmp_int
 1790               	.L56:
 896:ServerLLDN.c  **** 			appState = APP_STATE_IDLE;
 1791               		.loc 6 896 0
 1792 090c 1092 0000 		sts ack_received,__zero_reg__
 897:ServerLLDN.c  **** 			break;
 1793               		.loc 6 897 0
 1794 0910 81E0      		ldi r24,lo8(1)
 1795 0912 8093 0000 		sts appState,r24
 898:ServerLLDN.c  **** 		}
 1796               		.loc 6 898 0
 1797 0916 00C0      		rjmp .L54
 1798               	.L51:
 902:ServerLLDN.c  **** 			appState = APP_STATE_IDLE;
 1799               		.loc 6 902 0
 1800 0918 0E94 0000 		call appPrepareDataFrame
 903:ServerLLDN.c  **** 			break;
 1801               		.loc 6 903 0
 1802 091c 81E0      		ldi r24,lo8(1)
 1803 091e 8093 0000 		sts appState,r24
 904:ServerLLDN.c  **** 		}
 1804               		.loc 6 904 0
 1805 0922 00C0      		rjmp .L54
 1806               	.L53:
 908:ServerLLDN.c  **** 			{
 1807               		.loc 6 908 0
 1808 0924 9091 0000 		lds r25,ack_received
 1809 0928 81E0      		ldi r24,lo8(1)
 1810 092a 8927      		eor r24,r25
 1811 092c 8823      		tst r24
 1812 092e 01F4      		brne .+2
 1813 0930 00C0      		rjmp .L57
 1814               	.LBB5:
 910:ServerLLDN.c  **** 				
 1815               		.loc 6 910 0
 1816 0932 1A82      		std Y+2,__zero_reg__
 1817 0934 1982      		std Y+1,__zero_reg__
 1818               	.LBB6:
 912:ServerLLDN.c  **** 					if( check_ack(i) )
 1819               		.loc 6 912 0
 1820 0936 1C82      		std Y+4,__zero_reg__
 1821 0938 1B82      		std Y+3,__zero_reg__
 1822 093a 00C0      		rjmp .L58
 1823               	.L62:
 913:ServerLLDN.c  **** 						retransmition_slot++;
 1824               		.loc 6 913 0
 1825 093c 8B81      		ldd r24,Y+3
 1826 093e 9C81      		ldd r25,Y+4
 1827 0940 0E94 0000 		call check_ack
 1828 0944 8823      		tst r24
 1829 0946 01F0      		breq .L59
 914:ServerLLDN.c  **** 				printf("\nretransmition_slot %d", retransmition_slot);
 1830               		.loc 6 914 0
 1831 0948 8981      		ldd r24,Y+1
 1832 094a 9A81      		ldd r25,Y+2
 1833 094c 0196      		adiw r24,1
 1834 094e 9A83      		std Y+2,r25
 1835 0950 8983      		std Y+1,r24
 1836               	.L59:
 912:ServerLLDN.c  **** 					if( check_ack(i) )
 1837               		.loc 6 912 0 discriminator 2
 1838 0952 8B81      		ldd r24,Y+3
 1839 0954 9C81      		ldd r25,Y+4
 1840 0956 0196      		adiw r24,1
 1841 0958 9C83      		std Y+4,r25
 1842 095a 8B83      		std Y+3,r24
 1843               	.L58:
 912:ServerLLDN.c  **** 					if( check_ack(i) )
 1844               		.loc 6 912 0 is_stmt 0 discriminator 1
 1845 095c 8091 0000 		lds r24,assTimeSlot
 1846 0960 282F      		mov r18,r24
 1847 0962 30E0      		ldi r19,0
 1848 0964 8B81      		ldd r24,Y+3
 1849 0966 9C81      		ldd r25,Y+4
 1850 0968 8217      		cp r24,r18
 1851 096a 9307      		cpc r25,r19
 1852 096c 04F4      		brge .L60
 912:ServerLLDN.c  **** 					if( check_ack(i) )
 1853               		.loc 6 912 0 discriminator 3
 1854 096e 8091 0000 		lds r24,rec_beacon
 1855 0972 9091 0000 		lds r25,rec_beacon+1
 1856 0976 FC01      		movw r30,r24
 1857 0978 8781      		ldd r24,Z+7
 1858 097a 882F      		mov r24,r24
 1859 097c 90E0      		ldi r25,0
 1860 097e 0397      		sbiw r24,3
 1861 0980 9923      		tst r25
 1862 0982 04F4      		brge .L61
 1863 0984 0196      		adiw r24,1
 1864               	.L61:
 1865 0986 9595      		asr r25
 1866 0988 8795      		ror r24
 1867 098a 9C01      		movw r18,r24
 1868 098c 8B81      		ldd r24,Y+3
 1869 098e 9C81      		ldd r25,Y+4
 1870 0990 8217      		cp r24,r18
 1871 0992 9307      		cpc r25,r19
 1872 0994 04F0      		brlt .L62
 1873               	.L60:
 1874               	.LBE6:
 915:ServerLLDN.c  **** 				if(retransmition_slot == 0)
 1875               		.loc 6 915 0 is_stmt 1
 1876 0996 8A81      		ldd r24,Y+2
 1877 0998 8F93      		push r24
 1878 099a 8981      		ldd r24,Y+1
 1879 099c 8F93      		push r24
 1880 099e 80E0      		ldi r24,lo8(.LC6)
 1881 09a0 90E0      		ldi r25,hi8(.LC6)
 1882 09a2 892F      		mov r24,r25
 1883 09a4 8F93      		push r24
 1884 09a6 80E0      		ldi r24,lo8(.LC6)
 1885 09a8 90E0      		ldi r25,hi8(.LC6)
 1886 09aa 8F93      		push r24
 1887 09ac 0E94 0000 		call printf
 1888 09b0 0F90      		pop __tmp_reg__
 1889 09b2 0F90      		pop __tmp_reg__
 1890 09b4 0F90      		pop __tmp_reg__
 1891 09b6 0F90      		pop __tmp_reg__
 916:ServerLLDN.c  **** 				{
 1892               		.loc 6 916 0
 1893 09b8 8981      		ldd r24,Y+1
 1894 09ba 9A81      		ldd r25,Y+2
 1895 09bc 892B      		or r24,r25
 1896 09be 01F4      		brne .L63
 918:ServerLLDN.c  **** 				}
 1897               		.loc 6 918 0
 1898 09c0 82E0      		ldi r24,lo8(2)
 1899 09c2 8093 0000 		sts appState,r24
 1900               	.LBE5:
 935:ServerLLDN.c  **** 		}
 1901               		.loc 6 935 0
 1902 09c6 00C0      		rjmp .L66
 1903               	.L63:
 1904               	.LBB7:
 923:ServerLLDN.c  **** 					macsc_set_cmp1_int_cb(send_message_timeHandler);
 1905               		.loc 6 923 0
 1906 09c8 0E94 0000 		call macsc_enable_manual_bts
 924:ServerLLDN.c  **** 					macsc_enable_cmp_int(MACSC_CC1);
 1907               		.loc 6 924 0
 1908 09cc 80E0      		ldi r24,lo8(gs(send_message_timeHandler))
 1909 09ce 90E0      		ldi r25,hi8(gs(send_message_timeHandler))
 1910 09d0 0E94 0000 		call macsc_set_cmp1_int_cb
 925:ServerLLDN.c  **** 					macsc_use_cmp(MACSC_RELATIVE_CMP, ts_time * retransmition_slot, MACSC_CC1);
 1911               		.loc 6 925 0
 1912 09d4 81E0      		ldi r24,lo8(1)
 1913 09d6 0E94 0000 		call macsc_enable_cmp_int
 926:ServerLLDN.c  **** 					#endif
 1914               		.loc 6 926 0
 1915 09da 4091 0000 		lds r20,ts_time
 1916 09de 5091 0000 		lds r21,ts_time+1
 1917 09e2 2981      		ldd r18,Y+1
 1918 09e4 3A81      		ldd r19,Y+2
 1919 09e6 429F      		mul r20,r18
 1920 09e8 C001      		movw r24,r0
 1921 09ea 439F      		mul r20,r19
 1922 09ec 900D      		add r25,r0
 1923 09ee 529F      		mul r21,r18
 1924 09f0 900D      		add r25,r0
 1925 09f2 1124      		clr r1
 1926 09f4 092E      		mov __tmp_reg__,r25
 1927 09f6 000C      		lsl r0
 1928 09f8 AA0B      		sbc r26,r26
 1929 09fa BB0B      		sbc r27,r27
 1930 09fc 21E0      		ldi r18,lo8(1)
 1931 09fe AC01      		movw r20,r24
 1932 0a00 BD01      		movw r22,r26
 1933 0a02 81E0      		ldi r24,lo8(1)
 1934 0a04 0E94 0000 		call macsc_use_cmp
 1935               	.LBE7:
 935:ServerLLDN.c  **** 		}
 1936               		.loc 6 935 0
 1937 0a08 00C0      		rjmp .L66
 1938               	.L57:
 932:ServerLLDN.c  **** 			}
 1939               		.loc 6 932 0
 1940 0a0a 81E0      		ldi r24,lo8(1)
 1941 0a0c 8093 0000 		sts appState,r24
 1942               	.L66:
 935:ServerLLDN.c  **** 		}
 1943               		.loc 6 935 0
 1944 0a10 0000      		nop
 1945               	.L54:
 941:ServerLLDN.c  **** 		}
 942:ServerLLDN.c  **** 	}
 943:ServerLLDN.c  **** }
 1946               		.loc 6 943 0
 1947 0a12 0000      		nop
 1948               	/* epilogue start */
 1949 0a14 0F90      		pop __tmp_reg__
 1950 0a16 0F90      		pop __tmp_reg__
 1951 0a18 0F90      		pop __tmp_reg__
 1952 0a1a 0F90      		pop __tmp_reg__
 1953 0a1c DF91      		pop r29
 1954 0a1e CF91      		pop r28
 1955 0a20 0895      		ret
 1956               		.cfi_endproc
 1957               	.LFE141:
 1959               		.section	.rodata
 1960               	.LC0:
 1961 0054 00        		.byte	0
 1962 0055 C2        		.byte	-62
 1963 0056 01        		.byte	1
 1964 0057 00        		.byte	0
 1965 0058 03        		.byte	3
 1966 0059 00        		.byte	0
 1967 005a 00        		.byte	0
 1968               		.text
 1969               	.global	main
 1971               	main:
 1972               	.LFB142:
 944:ServerLLDN.c  **** 
 945:ServerLLDN.c  **** 	/*****************************************************************************
 946:ServerLLDN.c  **** 	*****************************************************************************/
 947:ServerLLDN.c  **** 	int main(void)
 948:ServerLLDN.c  **** 	{
 1973               		.loc 6 948 0
 1974               		.cfi_startproc
 1975 0a22 0F93      		push r16
 1976               	.LCFI71:
 1977               		.cfi_def_cfa_offset 3
 1978               		.cfi_offset 16, -2
 1979 0a24 1F93      		push r17
 1980               	.LCFI72:
 1981               		.cfi_def_cfa_offset 4
 1982               		.cfi_offset 17, -3
 1983 0a26 CF93      		push r28
 1984               	.LCFI73:
 1985               		.cfi_def_cfa_offset 5
 1986               		.cfi_offset 28, -4
 1987 0a28 DF93      		push r29
 1988               	.LCFI74:
 1989               		.cfi_def_cfa_offset 6
 1990               		.cfi_offset 29, -5
 1991 0a2a CDB7      		in r28,__SP_L__
 1992 0a2c DEB7      		in r29,__SP_H__
 1993               	.LCFI75:
 1994               		.cfi_def_cfa_register 28
 1995 0a2e 2797      		sbiw r28,7
 1996               	.LCFI76:
 1997               		.cfi_def_cfa_offset 13
 1998 0a30 0FB6      		in __tmp_reg__,__SREG__
 1999 0a32 F894      		cli
 2000 0a34 DEBF      		out __SP_H__,r29
 2001 0a36 0FBE      		out __SREG__,__tmp_reg__
 2002 0a38 CDBF      		out __SP_L__,r28
 2003               	/* prologue: function */
 2004               	/* frame size = 7 */
 2005               	/* stack size = 11 */
 2006               	.L__stack_usage = 11
 949:ServerLLDN.c  **** 		sysclk_init();
 2007               		.loc 6 949 0
 2008 0a3a 0E94 0000 		call sysclk_init
 950:ServerLLDN.c  **** 		board_init();
 2009               		.loc 6 950 0
 2010 0a3e 0E94 0000 		call board_init
 951:ServerLLDN.c  **** 
 952:ServerLLDN.c  **** 		SYS_Init();
 2011               		.loc 6 952 0
 2012 0a42 0E94 0000 		call SYS_Init
 953:ServerLLDN.c  **** 		/* Disable CSMA/CA
 954:ServerLLDN.c  **** 		 * Disable auto ACK
 955:ServerLLDN.c  **** 		 * Enable Rx of LLDN Frame Type as described in 802.15.4e - 2012 
 956:ServerLLDN.c  **** 		 */
 957:ServerLLDN.c  **** 
 958:ServerLLDN.c  **** 		sm_init();
 2013               		.loc 6 958 0
 2014 0a46 0E94 0000 		call sm_init
 959:ServerLLDN.c  **** 
 960:ServerLLDN.c  **** 		// Initialize interrupt vector table support.
 961:ServerLLDN.c  **** 	#if (SIO2HOST_CHANNEL == SIO_USB)
 962:ServerLLDN.c  **** 		irq_initialize_vectors();
 963:ServerLLDN.c  **** 	#endif
 964:ServerLLDN.c  **** 		cpu_irq_enable();
 2015               		.loc 6 964 0
 2016               	/* #APP */
 2017               	 ;  964 "ServerLLDN.c" 1
 2018 0a4a 7894      		sei
 2019               	 ;  0 "" 2
 965:ServerLLDN.c  **** 
 966:ServerLLDN.c  **** 	#if 1
 967:ServerLLDN.c  **** 	#if (SIO2HOST_CHANNEL == SIO_USB)
 968:ServerLLDN.c  **** 		stdio_usb_init();
 969:ServerLLDN.c  **** 	#else
 970:ServerLLDN.c  **** 		const usart_serial_options_t usart_serial_options =
 2020               		.loc 6 970 0
 2021               	/* #NOAPP */
 2022 0a4c 27E0      		ldi r18,lo8(7)
 2023 0a4e E0E0      		ldi r30,lo8(.LC0)
 2024 0a50 F0E0      		ldi r31,hi8(.LC0)
 2025 0a52 CE01      		movw r24,r28
 2026 0a54 0196      		adiw r24,1
 2027 0a56 DC01      		movw r26,r24
 2028               		0:
 2029 0a58 0190      		ld r0,Z+
 2030 0a5a 0D92      		st X+,r0
 2031 0a5c 2A95      		dec r18
 2032 0a5e 01F4      		brne 0b
 971:ServerLLDN.c  **** 		{
 972:ServerLLDN.c  **** 			.baudrate     = USART_HOST_BAUDRATE,
 973:ServerLLDN.c  **** 			.charlength   = USART_HOST_CHAR_LENGTH,
 974:ServerLLDN.c  **** 			.paritytype   = USART_HOST_PARITY,
 975:ServerLLDN.c  **** 			.stopbits     = USART_HOST_STOP_BITS
 976:ServerLLDN.c  **** 		};
 977:ServerLLDN.c  **** 
 978:ServerLLDN.c  **** 		stdio_serial_init(USART_HOST, &usart_serial_options);
 2033               		.loc 6 978 0
 2034 0a60 CE01      		movw r24,r28
 2035 0a62 0196      		adiw r24,1
 2036 0a64 BC01      		movw r22,r24
 2037 0a66 80EC      		ldi r24,lo8(-64)
 2038 0a68 90E0      		ldi r25,0
 2039 0a6a 0E94 0000 		call stdio_serial_init
 979:ServerLLDN.c  **** 		usart_double_baud_enable(USART_HOST);
 2040               		.loc 6 979 0
 2041 0a6e 80EC      		ldi r24,lo8(-64)
 2042 0a70 90E0      		ldi r25,0
 2043 0a72 0E94 0000 		call usart_double_baud_enable
 980:ServerLLDN.c  **** 		usart_set_baudrate_precalculated(USART_HOST, USART_HOST_BAUDRATE, sysclk_get_source_clock_hz());
 2044               		.loc 6 980 0
 2045 0a76 0E94 0000 		call sysclk_get_source_clock_hz
 2046 0a7a DC01      		movw r26,r24
 2047 0a7c CB01      		movw r24,r22
 2048 0a7e 8C01      		movw r16,r24
 2049 0a80 9D01      		movw r18,r26
 2050 0a82 40E0      		ldi r20,0
 2051 0a84 52EC      		ldi r21,lo8(-62)
 2052 0a86 61E0      		ldi r22,lo8(1)
 2053 0a88 70E0      		ldi r23,0
 2054 0a8a 80EC      		ldi r24,lo8(-64)
 2055 0a8c 90E0      		ldi r25,0
 2056 0a8e 0E94 0000 		call usart_set_baudrate_precalculated
 2057               	.L68:
 981:ServerLLDN.c  **** 
 982:ServerLLDN.c  **** 	#endif
 983:ServerLLDN.c  **** 	#endif
 984:ServerLLDN.c  **** 		for(;;)
 985:ServerLLDN.c  **** 		{
 986:ServerLLDN.c  **** 			SYS_TaskHandler();
 2058               		.loc 6 986 0 discriminator 1
 2059 0a92 0E94 0000 		call SYS_TaskHandler
 987:ServerLLDN.c  **** 			APP_TaskHandler();
 2060               		.loc 6 987 0 discriminator 1
 2061 0a96 0E94 0000 		call APP_TaskHandler
 988:ServerLLDN.c  **** 		}
 2062               		.loc 6 988 0 discriminator 1
 2063 0a9a 00C0      		rjmp .L68
 2064               		.cfi_endproc
 2065               	.LFE142:
 2067               	.Letext0:
 2068               		.file 7 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\in
 2069               		.file 8 "../../../stack/LwMesh/TDMA/nwk/inc/nwkFrame.h"
 2070               		.file 9 "../../../stack/LwMesh/TDMA/nwk/inc/nwkRx.h"
 2071               		.file 10 "../../../stack/LwMesh/TDMA/nwk/inc/nwkDataReq.h"
 2072               		.file 11 "lldn.h"
 2073               		.file 12 "../../../platform/mega_rf/drivers/sleep/sleep.h"
 2074               		.file 13 "../../../platform/mega_rf/utils/status_codes.h"
 2075               		.file 14 "config/config.h"
 2076               		.file 15 "../../../platform/common/services/sleepmgr/mega_rf/sleepmgr.h"
DEFINED SYMBOLS
                            *ABS*:00000000 ServerLLDN.c
C:\Users\GUILHE~1\AppData\Local\Temp\ccoGDsWF.s:2      *ABS*:0000003e __SP_H__
C:\Users\GUILHE~1\AppData\Local\Temp\ccoGDsWF.s:3      *ABS*:0000003d __SP_L__
C:\Users\GUILHE~1\AppData\Local\Temp\ccoGDsWF.s:4      *ABS*:0000003f __SREG__
C:\Users\GUILHE~1\AppData\Local\Temp\ccoGDsWF.s:5      *ABS*:0000003b __RAMPZ__
C:\Users\GUILHE~1\AppData\Local\Temp\ccoGDsWF.s:6      *ABS*:00000000 __tmp_reg__
C:\Users\GUILHE~1\AppData\Local\Temp\ccoGDsWF.s:7      *ABS*:00000001 __zero_reg__
C:\Users\GUILHE~1\AppData\Local\Temp\ccoGDsWF.s:15     .bss.n:00000000 n
                            *COM*:00000004 tTS
                            *COM*:00000002 macLLDNnumTimeSlots
                            *COM*:00000002 macLLDNnumUplinkTS
                            *COM*:00000002 macLLDNRetransmitTS
C:\Users\GUILHE~1\AppData\Local\Temp\ccoGDsWF.s:23     .text:00000000 sysclk_get_main_hz
C:\Users\GUILHE~1\AppData\Local\Temp\ccoGDsWF.s:60     .text:0000001a sysclk_get_source_clock_hz
C:\Users\GUILHE~1\AppData\Local\Temp\ccoGDsWF.s:97     .progmem.data.baudctrl_1mhz:00000000 baudctrl_1mhz
C:\Users\GUILHE~1\AppData\Local\Temp\ccoGDsWF.s:109    .progmem.data.baudctrl_8mhz:00000000 baudctrl_8mhz
C:\Users\GUILHE~1\AppData\Local\Temp\ccoGDsWF.s:121    .progmem.data.baudctrl_16mhz:00000000 baudctrl_16mhz
C:\Users\GUILHE~1\AppData\Local\Temp\ccoGDsWF.s:132    .text:00000034 usart_double_baud_enable
C:\Users\GUILHE~1\AppData\Local\Temp\ccoGDsWF.s:181    .text:00000062 usart_serial_init
C:\Users\GUILHE~1\AppData\Local\Temp\ccoGDsWF.s:276    .text:000000de usart_serial_putchar
C:\Users\GUILHE~1\AppData\Local\Temp\ccoGDsWF.s:320    .text:00000106 usart_serial_getchar
C:\Users\GUILHE~1\AppData\Local\Temp\ccoGDsWF.s:371    .text:0000013c stdio_serial_init
C:\Users\GUILHE~1\AppData\Local\Temp\ccoGDsWF.s:442    .text:0000019e macsc_enable_manual_bts
C:\Users\GUILHE~1\AppData\Local\Temp\ccoGDsWF.s:496    .bss.appState:00000000 appState
C:\Users\GUILHE~1\AppData\Local\Temp\ccoGDsWF.s:501    .bss.msgReq:00000000 msgReq
C:\Users\GUILHE~1\AppData\Local\Temp\ccoGDsWF.s:506    .bss.PanId:00000000 PanId
C:\Users\GUILHE~1\AppData\Local\Temp\ccoGDsWF.s:514    .text:000001d2 appSendData
C:\Users\GUILHE~1\AppData\Local\Temp\ccoGDsWF.s:576    .data.payloadSize:00000000 payloadSize
C:\Users\GUILHE~1\AppData\Local\Temp\ccoGDsWF.s:582    .data.assTimeSlot:00000000 assTimeSlot
                            *COM*:00000002 rec_beacon
                            *COM*:00000002 ackframe
C:\Users\GUILHE~1\AppData\Local\Temp\ccoGDsWF.s:589    .data.msgDiscResponse:00000000 msgDiscResponse
C:\Users\GUILHE~1\AppData\Local\Temp\ccoGDsWF.s:596    .data.msgConfigStatus:00000000 msgConfigStatus
C:\Users\GUILHE~1\AppData\Local\Temp\ccoGDsWF.s:606    .data.data_payload:00000000 data_payload
C:\Users\GUILHE~1\AppData\Local\Temp\ccoGDsWF.s:611    .bss.ack_received:00000000 ack_received
C:\Users\GUILHE~1\AppData\Local\Temp\ccoGDsWF.s:617    .bss.MacLLDNMgmtTS:00000000 MacLLDNMgmtTS
C:\Users\GUILHE~1\AppData\Local\Temp\ccoGDsWF.s:623    .bss.associated:00000000 associated
                            *COM*:00000002 ts_time
C:\Users\GUILHE~1\AppData\Local\Temp\ccoGDsWF.s:630    .data.STATE:00000000 STATE
C:\Users\GUILHE~1\AppData\Local\Temp\ccoGDsWF.s:634    .text:0000021e send_message_timeHandler
C:\Users\GUILHE~1\AppData\Local\Temp\ccoGDsWF.s:667    .text:00000234 start_timer
C:\Users\GUILHE~1\AppData\Local\Temp\ccoGDsWF.s:735    .text:0000027c appBeaconInd
C:\Users\GUILHE~1\AppData\Local\Temp\ccoGDsWF.s:1114   .text:00000558 check_ack
C:\Users\GUILHE~1\AppData\Local\Temp\ccoGDsWF.s:1259   .text:0000063c appAckInd
C:\Users\GUILHE~1\AppData\Local\Temp\ccoGDsWF.s:1339   .text:000006aa appCommandInd
C:\Users\GUILHE~1\AppData\Local\Temp\ccoGDsWF.s:1456   .text:00000754 appPrepareDiscoverResponse
C:\Users\GUILHE~1\AppData\Local\Temp\ccoGDsWF.s:1509   .text:00000796 appPrepareConfigurationStatus
C:\Users\GUILHE~1\AppData\Local\Temp\ccoGDsWF.s:1562   .text:000007d8 appPrepareDataFrame
C:\Users\GUILHE~1\AppData\Local\Temp\ccoGDsWF.s:1617   .text:00000820 appInit
C:\Users\GUILHE~1\AppData\Local\Temp\ccoGDsWF.s:1685   .text:00000874 APP_TaskHandler
C:\Users\GUILHE~1\AppData\Local\Temp\ccoGDsWF.s:1971   .text:00000a22 main

UNDEFINED SYMBOLS
usart_init_rs232
usart_putchar
usart_getchar
stdio_base
ptr_put
ptr_get
_read
_write
fdevopen
printf
NWK_DataReq
macsc_set_cmp1_int_cb
macsc_enable_cmp_int
macsc_use_cmp
__floatsisf
__addsf3
__divsf3
__fixsfsi
PHY_SetChannel
NWK_SetPanId
PHY_SetTdmaMode
NWK_SetAddr
PHY_SetRxState
NWK_OpenEndpoint
PHY_SetPromiscuousMode
macsc_disable_cmp_int
sysclk_init
board_init
SYS_Init
sm_init
usart_set_baudrate_precalculated
SYS_TaskHandler
__do_copy_data
__do_clear_bss
